"use strict";
var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : new P(function (resolve) {
              resolve(result.value);
            }).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Create Item in table, 'createdAt' and 'updatedAt' timeStamps will be added in each item
 */
function create({ docClient, tableName, item, options = {}, verbose = false, forTrx = false }) {
  return __awaiter(this, void 0, void 0, function* () {
    let params;
    try {
      const timeStamp = Date.now();
      params = Object.assign(
        { TableName: tableName, Item: Object.assign({}, item, { createdAt: timeStamp, updatedAt: timeStamp }) },
        options
      );
      verbose && console.log("params", params);
      /**
       * Return params for this requirement, used for transact method
       */
      if (forTrx) {
        return {
          Put: params,
        };
      }
      yield docClient.put(params).promise();
      verbose && console.log(`Successfully inserted item into table ${tableName}`);
      return params;
    } catch (err) {
      console.error(`Unable to insert item into ${tableName}. Error JSON:`, JSON.stringify(err), err.stack);
      console.log("params", JSON.stringify(params));
      throw err;
    }
  });
}
exports.default = create;

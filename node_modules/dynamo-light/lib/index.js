"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Table = void 0;
const client_dynamodb_1 = require("@aws-sdk/client-dynamodb");
const lib_dynamodb_1 = require("@aws-sdk/lib-dynamodb");
const delete_1 = require("./CRUD/delete");
const get_1 = require("./CRUD/get");
const put_1 = require("./CRUD/put");
const query_1 = require("./CRUD/query");
const scan_1 = require("./CRUD/scan");
const transactWrite_1 = require("./CRUD/transactWrite");
const update_1 = require("./CRUD/update");
const defaultDocOptions = { marshallOptions: { removeUndefinedValues: true } };
// Bare-bones DynamoDB Client are more modular and reduces bundle size and improve loading performance over full client "new DynamoDB({});"
// Avoid using the full client because it may be dropped in the next major version.
let dbClient = new client_dynamodb_1.DynamoDBClient({});
let docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(dbClient, defaultDocOptions);
class Table {
    static transactWrite(transactions, options = { verbose: false }) {
        const { verbose } = options;
        return (0, transactWrite_1.default)({ docClient, transactions, options, verbose });
    }
    static replaceDynamoClient(newDbClient, newDocClient) {
        dbClient = newDbClient;
        docClient = newDocClient;
    }
    constructor(name, config) {
        this.tableName = name;
        this.initialized = false;
        this.partitionKey = undefined;
        this.sortKey = undefined;
        this.indexMap = new Map();
        if (config) {
            this.dbClient = new client_dynamodb_1.DynamoDBClient(config);
            this.docClient = lib_dynamodb_1.DynamoDBDocumentClient.from(this.dbClient, defaultDocOptions);
        }
        else {
            this.dbClient = dbClient;
            this.docClient = docClient;
        }
    }
    initTable() {
        return __awaiter(this, void 0, void 0, function* () {
            const tableInfo = yield this.dbClient.send(new client_dynamodb_1.DescribeTableCommand({
                TableName: this.tableName,
            }));
            this.initialized = true;
            /**
             * Set partitionKey and sortKey
             */
            const { KeySchema = [], GlobalSecondaryIndexes = [] } = tableInfo.Table;
            const { partitionKey, sortKey } = this.retrieveKeys(KeySchema);
            this.partitionKey = partitionKey;
            this.sortKey = sortKey;
            /**
             * Set indexes
             */
            for (const indexRecord of GlobalSecondaryIndexes) {
                const { partitionKey: indexPartitionKey, sortKey: indexSortKey } = this.retrieveKeys(indexRecord.KeySchema);
                const index = {
                    name: indexRecord.IndexName,
                    partitionKey: indexPartitionKey,
                    sortKey: indexSortKey,
                };
                this.indexMap.set(indexRecord.IndexName, index);
            }
        });
    }
    /**
     * Check if the key is valid for this table
     * @param {} key
     */
    isValidKey(key) {
        if (!this.partitionKey) {
            return false;
        }
        /**
         * Check if input key contains non-key fields
         */
        let noExtraField = true;
        for (const objKey of Object.keys(key)) {
            if (this.partitionKey !== objKey && this.sortKey !== objKey) {
                noExtraField = false;
            }
        }
        /**
         * Check if input key contains partitionKey
         */
        const containsPartitionKey = key[this.partitionKey] !== undefined;
        return noExtraField && containsPartitionKey;
    }
    get(key, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.initTable();
            }
            if (typeof key === "string") {
                key = this.parsePartitionKey(key);
            }
            if (!this.isValidKey(key)) {
                throw new Error(`Invalid Key: ${JSON.stringify(key)}`);
            }
            const { verbose, forTrx } = this.retrieveAndDeleteDLOptions(options);
            return (0, get_1.default)({ docClient: this.docClient, tableName: this.tableName, key, options, verbose, forTrx });
        });
    }
    put(item, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.initTable();
            }
            const { verbose, forTrx, autoTimeStamp } = this.retrieveAndDeleteDLOptions(options);
            return (0, put_1.default)({
                docClient: this.docClient,
                tableName: this.tableName,
                item,
                options,
                verbose,
                forTrx,
                autoTimeStamp,
            });
        });
    }
    delete(key, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.initTable();
            }
            if (typeof key === "string") {
                key = this.parsePartitionKey(key);
            }
            if (!this.isValidKey(key)) {
                throw new Error(`Invalid Key: ${JSON.stringify(key)}`);
            }
            const { verbose, forTrx } = this.retrieveAndDeleteDLOptions(options);
            return (0, delete_1.default)({ docClient: this.docClient, tableName: this.tableName, key, options, verbose, forTrx });
        });
    }
    update(key, newFields, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.initTable();
            }
            if (typeof key === "string") {
                key = this.parsePartitionKey(key);
            }
            if (!this.isValidKey(key)) {
                throw new Error(`Invalid Key: ${JSON.stringify(key)}`);
            }
            const { verbose, forTrx, autoTimeStamp } = this.retrieveAndDeleteDLOptions(options);
            return (0, update_1.default)({
                docClient: this.docClient,
                key,
                tableName: this.tableName,
                newFields,
                options,
                verbose,
                forTrx,
                autoTimeStamp,
            });
        });
    }
    query(
    // queryKey: { indexName?: string; partitionKeyValue: string; sortKeyOperator?: string; sortKeyValue?: string },
    queryKey, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.initTable();
            }
            let { partitionKeyValue, sortKeyValue, sortKeyOperator } = queryKey;
            const { indexName } = queryKey;
            let index;
            if (indexName) {
                index = this.indexMap.get(indexName);
                if (indexName && !index) {
                    throw new Error(`Index ${indexName} doesn't belong to table ${this.tableName}`);
                }
            }
            const partitionKey = index ? index.partitionKey : this.partitionKey;
            let sortKey;
            sortKey = index ? index.sortKey : this.sortKey;
            // 如果sortKeyValue不存在，则设置sortKey为undefined
            if (queryKey[sortKey] === undefined && queryKey.sortKeyValue === undefined) {
                sortKey = undefined;
            }
            else {
                if (sortKeyOperator === undefined) {
                    sortKeyOperator = "=";
                }
            }
            // 智能填partitionKeyValue和sortKeyValue
            if (partitionKeyValue === undefined) {
                if (queryKey[partitionKey] !== undefined) {
                    partitionKeyValue = queryKey[partitionKey];
                    delete queryKey[partitionKey];
                }
                else {
                    throw new Error("partitionKeyValue is undefined");
                }
                if (sortKey !== undefined) {
                    sortKeyValue = queryKey[sortKey];
                    delete queryKey[sortKey];
                }
            }
            const { verbose, pagination } = this.retrieveAndDeleteDLOptions(options);
            return (0, query_1.default)({
                docClient: this.docClient,
                tableName: this.tableName,
                indexName,
                partitionKey,
                partitionKeyValue,
                sortKey,
                sortKeyOperator,
                sortKeyValue,
                options,
                pagination,
                verbose,
            });
        });
    }
    scan(param = {}, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.initialized) {
                yield this.initTable();
            }
            const { indexName, filters } = param;
            const { verbose, pagination } = this.retrieveAndDeleteDLOptions(options);
            return (0, scan_1.default)({
                docClient: this.docClient,
                tableName: this.tableName,
                indexName,
                options,
                pagination,
                verbose,
            });
        });
    }
    retrieveKeys(KeySchema) {
        let partitionKey;
        let sortKey;
        for (const { AttributeName, KeyType } of KeySchema) {
            if (KeyType === "HASH") {
                partitionKey = AttributeName;
            }
            if (KeyType === "RANGE") {
                sortKey = AttributeName;
            }
        }
        if (partitionKey === undefined) {
            throw new Error(`Table ${this.tableName} partitionKey is undefined!`);
        }
        return { partitionKey, sortKey };
    }
    parsePartitionKey(partitionKeyValue) {
        return {
            [this.partitionKey]: partitionKeyValue,
        };
    }
    /**
     * Retrieve options specified by DL(dynamo-light), and remove them from the option param
     * @param options
     */
    retrieveAndDeleteDLOptions(options) {
        const { verbose = false, forTrx = false, autoTimeStamp = false, pagination = true } = options;
        delete options.verbose;
        delete options.forTrx;
        delete options.autoTimeStamp;
        delete options.pagination;
        return {
            verbose,
            forTrx,
            autoTimeStamp,
            pagination,
        };
    }
}
exports.Table = Table;

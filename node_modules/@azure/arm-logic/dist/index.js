'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link WorkflowProvisioningState} that the service accepts. */
exports.KnownWorkflowProvisioningState = void 0;
(function (KnownWorkflowProvisioningState) {
    /** NotSpecified */
    KnownWorkflowProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownWorkflowProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownWorkflowProvisioningState["Running"] = "Running";
    /** Ready */
    KnownWorkflowProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownWorkflowProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownWorkflowProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownWorkflowProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownWorkflowProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownWorkflowProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownWorkflowProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownWorkflowProvisioningState["Succeeded"] = "Succeeded";
    /** Moving */
    KnownWorkflowProvisioningState["Moving"] = "Moving";
    /** Updating */
    KnownWorkflowProvisioningState["Updating"] = "Updating";
    /** Registering */
    KnownWorkflowProvisioningState["Registering"] = "Registering";
    /** Registered */
    KnownWorkflowProvisioningState["Registered"] = "Registered";
    /** Unregistering */
    KnownWorkflowProvisioningState["Unregistering"] = "Unregistering";
    /** Unregistered */
    KnownWorkflowProvisioningState["Unregistered"] = "Unregistered";
    /** Completed */
    KnownWorkflowProvisioningState["Completed"] = "Completed";
    /** Renewing */
    KnownWorkflowProvisioningState["Renewing"] = "Renewing";
    /** Pending */
    KnownWorkflowProvisioningState["Pending"] = "Pending";
    /** Waiting */
    KnownWorkflowProvisioningState["Waiting"] = "Waiting";
    /** InProgress */
    KnownWorkflowProvisioningState["InProgress"] = "InProgress";
})(exports.KnownWorkflowProvisioningState || (exports.KnownWorkflowProvisioningState = {}));
/** Known values of {@link WorkflowState} that the service accepts. */
exports.KnownWorkflowState = void 0;
(function (KnownWorkflowState) {
    /** NotSpecified */
    KnownWorkflowState["NotSpecified"] = "NotSpecified";
    /** Completed */
    KnownWorkflowState["Completed"] = "Completed";
    /** Enabled */
    KnownWorkflowState["Enabled"] = "Enabled";
    /** Disabled */
    KnownWorkflowState["Disabled"] = "Disabled";
    /** Deleted */
    KnownWorkflowState["Deleted"] = "Deleted";
    /** Suspended */
    KnownWorkflowState["Suspended"] = "Suspended";
})(exports.KnownWorkflowState || (exports.KnownWorkflowState = {}));
/** Known values of {@link OpenAuthenticationProviderType} that the service accepts. */
exports.KnownOpenAuthenticationProviderType = void 0;
(function (KnownOpenAuthenticationProviderType) {
    /** AAD */
    KnownOpenAuthenticationProviderType["AAD"] = "AAD";
})(exports.KnownOpenAuthenticationProviderType || (exports.KnownOpenAuthenticationProviderType = {}));
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** NotSpecified */
    KnownSkuName["NotSpecified"] = "NotSpecified";
    /** Free */
    KnownSkuName["Free"] = "Free";
    /** Shared */
    KnownSkuName["Shared"] = "Shared";
    /** Basic */
    KnownSkuName["Basic"] = "Basic";
    /** Standard */
    KnownSkuName["Standard"] = "Standard";
    /** Premium */
    KnownSkuName["Premium"] = "Premium";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link ParameterType} that the service accepts. */
exports.KnownParameterType = void 0;
(function (KnownParameterType) {
    /** NotSpecified */
    KnownParameterType["NotSpecified"] = "NotSpecified";
    /** String */
    KnownParameterType["String"] = "String";
    /** SecureString */
    KnownParameterType["SecureString"] = "SecureString";
    /** Int */
    KnownParameterType["Int"] = "Int";
    /** Float */
    KnownParameterType["Float"] = "Float";
    /** Bool */
    KnownParameterType["Bool"] = "Bool";
    /** Array */
    KnownParameterType["Array"] = "Array";
    /** Object */
    KnownParameterType["Object"] = "Object";
    /** SecureObject */
    KnownParameterType["SecureObject"] = "SecureObject";
})(exports.KnownParameterType || (exports.KnownParameterType = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));
/** Known values of {@link KeyType} that the service accepts. */
exports.KnownKeyType = void 0;
(function (KnownKeyType) {
    /** NotSpecified */
    KnownKeyType["NotSpecified"] = "NotSpecified";
    /** Primary */
    KnownKeyType["Primary"] = "Primary";
    /** Secondary */
    KnownKeyType["Secondary"] = "Secondary";
})(exports.KnownKeyType || (exports.KnownKeyType = {}));
/** Known values of {@link WorkflowTriggerProvisioningState} that the service accepts. */
exports.KnownWorkflowTriggerProvisioningState = void 0;
(function (KnownWorkflowTriggerProvisioningState) {
    /** NotSpecified */
    KnownWorkflowTriggerProvisioningState["NotSpecified"] = "NotSpecified";
    /** Accepted */
    KnownWorkflowTriggerProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownWorkflowTriggerProvisioningState["Running"] = "Running";
    /** Ready */
    KnownWorkflowTriggerProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownWorkflowTriggerProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownWorkflowTriggerProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownWorkflowTriggerProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownWorkflowTriggerProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownWorkflowTriggerProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownWorkflowTriggerProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownWorkflowTriggerProvisioningState["Succeeded"] = "Succeeded";
    /** Moving */
    KnownWorkflowTriggerProvisioningState["Moving"] = "Moving";
    /** Updating */
    KnownWorkflowTriggerProvisioningState["Updating"] = "Updating";
    /** Registering */
    KnownWorkflowTriggerProvisioningState["Registering"] = "Registering";
    /** Registered */
    KnownWorkflowTriggerProvisioningState["Registered"] = "Registered";
    /** Unregistering */
    KnownWorkflowTriggerProvisioningState["Unregistering"] = "Unregistering";
    /** Unregistered */
    KnownWorkflowTriggerProvisioningState["Unregistered"] = "Unregistered";
    /** Completed */
    KnownWorkflowTriggerProvisioningState["Completed"] = "Completed";
})(exports.KnownWorkflowTriggerProvisioningState || (exports.KnownWorkflowTriggerProvisioningState = {}));
/** Known values of {@link WorkflowStatus} that the service accepts. */
exports.KnownWorkflowStatus = void 0;
(function (KnownWorkflowStatus) {
    /** NotSpecified */
    KnownWorkflowStatus["NotSpecified"] = "NotSpecified";
    /** Paused */
    KnownWorkflowStatus["Paused"] = "Paused";
    /** Running */
    KnownWorkflowStatus["Running"] = "Running";
    /** Waiting */
    KnownWorkflowStatus["Waiting"] = "Waiting";
    /** Succeeded */
    KnownWorkflowStatus["Succeeded"] = "Succeeded";
    /** Skipped */
    KnownWorkflowStatus["Skipped"] = "Skipped";
    /** Suspended */
    KnownWorkflowStatus["Suspended"] = "Suspended";
    /** Cancelled */
    KnownWorkflowStatus["Cancelled"] = "Cancelled";
    /** Failed */
    KnownWorkflowStatus["Failed"] = "Failed";
    /** Faulted */
    KnownWorkflowStatus["Faulted"] = "Faulted";
    /** TimedOut */
    KnownWorkflowStatus["TimedOut"] = "TimedOut";
    /** Aborted */
    KnownWorkflowStatus["Aborted"] = "Aborted";
    /** Ignored */
    KnownWorkflowStatus["Ignored"] = "Ignored";
})(exports.KnownWorkflowStatus || (exports.KnownWorkflowStatus = {}));
/** Known values of {@link RecurrenceFrequency} that the service accepts. */
exports.KnownRecurrenceFrequency = void 0;
(function (KnownRecurrenceFrequency) {
    /** NotSpecified */
    KnownRecurrenceFrequency["NotSpecified"] = "NotSpecified";
    /** Second */
    KnownRecurrenceFrequency["Second"] = "Second";
    /** Minute */
    KnownRecurrenceFrequency["Minute"] = "Minute";
    /** Hour */
    KnownRecurrenceFrequency["Hour"] = "Hour";
    /** Day */
    KnownRecurrenceFrequency["Day"] = "Day";
    /** Week */
    KnownRecurrenceFrequency["Week"] = "Week";
    /** Month */
    KnownRecurrenceFrequency["Month"] = "Month";
    /** Year */
    KnownRecurrenceFrequency["Year"] = "Year";
})(exports.KnownRecurrenceFrequency || (exports.KnownRecurrenceFrequency = {}));
/** Known values of {@link IntegrationAccountSkuName} that the service accepts. */
exports.KnownIntegrationAccountSkuName = void 0;
(function (KnownIntegrationAccountSkuName) {
    /** NotSpecified */
    KnownIntegrationAccountSkuName["NotSpecified"] = "NotSpecified";
    /** Free */
    KnownIntegrationAccountSkuName["Free"] = "Free";
    /** Basic */
    KnownIntegrationAccountSkuName["Basic"] = "Basic";
    /** Standard */
    KnownIntegrationAccountSkuName["Standard"] = "Standard";
})(exports.KnownIntegrationAccountSkuName || (exports.KnownIntegrationAccountSkuName = {}));
/** Known values of {@link TrackEventsOperationOptions} that the service accepts. */
exports.KnownTrackEventsOperationOptions = void 0;
(function (KnownTrackEventsOperationOptions) {
    /** None */
    KnownTrackEventsOperationOptions["None"] = "None";
    /** DisableSourceInfoEnrich */
    KnownTrackEventsOperationOptions["DisableSourceInfoEnrich"] = "DisableSourceInfoEnrich";
})(exports.KnownTrackEventsOperationOptions || (exports.KnownTrackEventsOperationOptions = {}));
/** Known values of {@link TrackingRecordType} that the service accepts. */
exports.KnownTrackingRecordType = void 0;
(function (KnownTrackingRecordType) {
    /** NotSpecified */
    KnownTrackingRecordType["NotSpecified"] = "NotSpecified";
    /** Custom */
    KnownTrackingRecordType["Custom"] = "Custom";
    /** AS2Message */
    KnownTrackingRecordType["AS2Message"] = "AS2Message";
    /** AS2MDN */
    KnownTrackingRecordType["AS2MDN"] = "AS2MDN";
    /** X12Interchange */
    KnownTrackingRecordType["X12Interchange"] = "X12Interchange";
    /** X12FunctionalGroup */
    KnownTrackingRecordType["X12FunctionalGroup"] = "X12FunctionalGroup";
    /** X12TransactionSet */
    KnownTrackingRecordType["X12TransactionSet"] = "X12TransactionSet";
    /** X12InterchangeAcknowledgment */
    KnownTrackingRecordType["X12InterchangeAcknowledgment"] = "X12InterchangeAcknowledgment";
    /** X12FunctionalGroupAcknowledgment */
    KnownTrackingRecordType["X12FunctionalGroupAcknowledgment"] = "X12FunctionalGroupAcknowledgment";
    /** X12TransactionSetAcknowledgment */
    KnownTrackingRecordType["X12TransactionSetAcknowledgment"] = "X12TransactionSetAcknowledgment";
    /** EdifactInterchange */
    KnownTrackingRecordType["EdifactInterchange"] = "EdifactInterchange";
    /** EdifactFunctionalGroup */
    KnownTrackingRecordType["EdifactFunctionalGroup"] = "EdifactFunctionalGroup";
    /** EdifactTransactionSet */
    KnownTrackingRecordType["EdifactTransactionSet"] = "EdifactTransactionSet";
    /** EdifactInterchangeAcknowledgment */
    KnownTrackingRecordType["EdifactInterchangeAcknowledgment"] = "EdifactInterchangeAcknowledgment";
    /** EdifactFunctionalGroupAcknowledgment */
    KnownTrackingRecordType["EdifactFunctionalGroupAcknowledgment"] = "EdifactFunctionalGroupAcknowledgment";
    /** EdifactTransactionSetAcknowledgment */
    KnownTrackingRecordType["EdifactTransactionSetAcknowledgment"] = "EdifactTransactionSetAcknowledgment";
})(exports.KnownTrackingRecordType || (exports.KnownTrackingRecordType = {}));
/** Known values of {@link SchemaType} that the service accepts. */
exports.KnownSchemaType = void 0;
(function (KnownSchemaType) {
    /** NotSpecified */
    KnownSchemaType["NotSpecified"] = "NotSpecified";
    /** Xml */
    KnownSchemaType["Xml"] = "Xml";
})(exports.KnownSchemaType || (exports.KnownSchemaType = {}));
/** Known values of {@link MapType} that the service accepts. */
exports.KnownMapType = void 0;
(function (KnownMapType) {
    /** NotSpecified */
    KnownMapType["NotSpecified"] = "NotSpecified";
    /** Xslt */
    KnownMapType["Xslt"] = "Xslt";
    /** Xslt20 */
    KnownMapType["Xslt20"] = "Xslt20";
    /** Xslt30 */
    KnownMapType["Xslt30"] = "Xslt30";
    /** Liquid */
    KnownMapType["Liquid"] = "Liquid";
})(exports.KnownMapType || (exports.KnownMapType = {}));
/** Known values of {@link PartnerType} that the service accepts. */
exports.KnownPartnerType = void 0;
(function (KnownPartnerType) {
    /** NotSpecified */
    KnownPartnerType["NotSpecified"] = "NotSpecified";
    /** B2B */
    KnownPartnerType["B2B"] = "B2B";
})(exports.KnownPartnerType || (exports.KnownPartnerType = {}));
/** Known values of {@link HashingAlgorithm} that the service accepts. */
exports.KnownHashingAlgorithm = void 0;
(function (KnownHashingAlgorithm) {
    /** NotSpecified */
    KnownHashingAlgorithm["NotSpecified"] = "NotSpecified";
    /** None */
    KnownHashingAlgorithm["None"] = "None";
    /** MD5 */
    KnownHashingAlgorithm["MD5"] = "MD5";
    /** SHA1 */
    KnownHashingAlgorithm["SHA1"] = "SHA1";
    /** SHA2256 */
    KnownHashingAlgorithm["SHA2256"] = "SHA2256";
    /** SHA2384 */
    KnownHashingAlgorithm["SHA2384"] = "SHA2384";
    /** SHA2512 */
    KnownHashingAlgorithm["SHA2512"] = "SHA2512";
})(exports.KnownHashingAlgorithm || (exports.KnownHashingAlgorithm = {}));
/** Known values of {@link EncryptionAlgorithm} that the service accepts. */
exports.KnownEncryptionAlgorithm = void 0;
(function (KnownEncryptionAlgorithm) {
    /** NotSpecified */
    KnownEncryptionAlgorithm["NotSpecified"] = "NotSpecified";
    /** None */
    KnownEncryptionAlgorithm["None"] = "None";
    /** DES3 */
    KnownEncryptionAlgorithm["DES3"] = "DES3";
    /** RC2 */
    KnownEncryptionAlgorithm["RC2"] = "RC2";
    /** AES128 */
    KnownEncryptionAlgorithm["AES128"] = "AES128";
    /** AES192 */
    KnownEncryptionAlgorithm["AES192"] = "AES192";
    /** AES256 */
    KnownEncryptionAlgorithm["AES256"] = "AES256";
})(exports.KnownEncryptionAlgorithm || (exports.KnownEncryptionAlgorithm = {}));
/** Known values of {@link SigningAlgorithm} that the service accepts. */
exports.KnownSigningAlgorithm = void 0;
(function (KnownSigningAlgorithm) {
    /** NotSpecified */
    KnownSigningAlgorithm["NotSpecified"] = "NotSpecified";
    /** Default */
    KnownSigningAlgorithm["Default"] = "Default";
    /** SHA1 */
    KnownSigningAlgorithm["SHA1"] = "SHA1";
    /** SHA2256 */
    KnownSigningAlgorithm["SHA2256"] = "SHA2256";
    /** SHA2384 */
    KnownSigningAlgorithm["SHA2384"] = "SHA2384";
    /** SHA2512 */
    KnownSigningAlgorithm["SHA2512"] = "SHA2512";
})(exports.KnownSigningAlgorithm || (exports.KnownSigningAlgorithm = {}));
/** Known values of {@link TrailingSeparatorPolicy} that the service accepts. */
exports.KnownTrailingSeparatorPolicy = void 0;
(function (KnownTrailingSeparatorPolicy) {
    /** NotSpecified */
    KnownTrailingSeparatorPolicy["NotSpecified"] = "NotSpecified";
    /** NotAllowed */
    KnownTrailingSeparatorPolicy["NotAllowed"] = "NotAllowed";
    /** Optional */
    KnownTrailingSeparatorPolicy["Optional"] = "Optional";
    /** Mandatory */
    KnownTrailingSeparatorPolicy["Mandatory"] = "Mandatory";
})(exports.KnownTrailingSeparatorPolicy || (exports.KnownTrailingSeparatorPolicy = {}));
/** Known values of {@link X12CharacterSet} that the service accepts. */
exports.KnownX12CharacterSet = void 0;
(function (KnownX12CharacterSet) {
    /** NotSpecified */
    KnownX12CharacterSet["NotSpecified"] = "NotSpecified";
    /** Basic */
    KnownX12CharacterSet["Basic"] = "Basic";
    /** Extended */
    KnownX12CharacterSet["Extended"] = "Extended";
    /** UTF8 */
    KnownX12CharacterSet["UTF8"] = "UTF8";
})(exports.KnownX12CharacterSet || (exports.KnownX12CharacterSet = {}));
/** Known values of {@link X12DateFormat} that the service accepts. */
exports.KnownX12DateFormat = void 0;
(function (KnownX12DateFormat) {
    /** NotSpecified */
    KnownX12DateFormat["NotSpecified"] = "NotSpecified";
    /** Ccyymmdd */
    KnownX12DateFormat["Ccyymmdd"] = "CCYYMMDD";
    /** Yymmdd */
    KnownX12DateFormat["Yymmdd"] = "YYMMDD";
})(exports.KnownX12DateFormat || (exports.KnownX12DateFormat = {}));
/** Known values of {@link X12TimeFormat} that the service accepts. */
exports.KnownX12TimeFormat = void 0;
(function (KnownX12TimeFormat) {
    /** NotSpecified */
    KnownX12TimeFormat["NotSpecified"] = "NotSpecified";
    /** Hhmm */
    KnownX12TimeFormat["Hhmm"] = "HHMM";
    /** Hhmmss */
    KnownX12TimeFormat["Hhmmss"] = "HHMMSS";
    /** HhmmsSdd */
    KnownX12TimeFormat["HhmmsSdd"] = "HHMMSSdd";
    /** HhmmsSd */
    KnownX12TimeFormat["HhmmsSd"] = "HHMMSSd";
})(exports.KnownX12TimeFormat || (exports.KnownX12TimeFormat = {}));
/** Known values of {@link UsageIndicator} that the service accepts. */
exports.KnownUsageIndicator = void 0;
(function (KnownUsageIndicator) {
    /** NotSpecified */
    KnownUsageIndicator["NotSpecified"] = "NotSpecified";
    /** Test */
    KnownUsageIndicator["Test"] = "Test";
    /** Information */
    KnownUsageIndicator["Information"] = "Information";
    /** Production */
    KnownUsageIndicator["Production"] = "Production";
})(exports.KnownUsageIndicator || (exports.KnownUsageIndicator = {}));
/** Known values of {@link MessageFilterType} that the service accepts. */
exports.KnownMessageFilterType = void 0;
(function (KnownMessageFilterType) {
    /** NotSpecified */
    KnownMessageFilterType["NotSpecified"] = "NotSpecified";
    /** Include */
    KnownMessageFilterType["Include"] = "Include";
    /** Exclude */
    KnownMessageFilterType["Exclude"] = "Exclude";
})(exports.KnownMessageFilterType || (exports.KnownMessageFilterType = {}));
/** Known values of {@link EdifactCharacterSet} that the service accepts. */
exports.KnownEdifactCharacterSet = void 0;
(function (KnownEdifactCharacterSet) {
    /** NotSpecified */
    KnownEdifactCharacterSet["NotSpecified"] = "NotSpecified";
    /** Unob */
    KnownEdifactCharacterSet["Unob"] = "UNOB";
    /** Unoa */
    KnownEdifactCharacterSet["Unoa"] = "UNOA";
    /** Unoc */
    KnownEdifactCharacterSet["Unoc"] = "UNOC";
    /** Unod */
    KnownEdifactCharacterSet["Unod"] = "UNOD";
    /** Unoe */
    KnownEdifactCharacterSet["Unoe"] = "UNOE";
    /** Unof */
    KnownEdifactCharacterSet["Unof"] = "UNOF";
    /** Unog */
    KnownEdifactCharacterSet["Unog"] = "UNOG";
    /** Unoh */
    KnownEdifactCharacterSet["Unoh"] = "UNOH";
    /** Unoi */
    KnownEdifactCharacterSet["Unoi"] = "UNOI";
    /** Unoj */
    KnownEdifactCharacterSet["Unoj"] = "UNOJ";
    /** Unok */
    KnownEdifactCharacterSet["Unok"] = "UNOK";
    /** Unox */
    KnownEdifactCharacterSet["Unox"] = "UNOX";
    /** Unoy */
    KnownEdifactCharacterSet["Unoy"] = "UNOY";
    /** Keca */
    KnownEdifactCharacterSet["Keca"] = "KECA";
})(exports.KnownEdifactCharacterSet || (exports.KnownEdifactCharacterSet = {}));
/** Known values of {@link IntegrationServiceEnvironmentAccessEndpointType} that the service accepts. */
exports.KnownIntegrationServiceEnvironmentAccessEndpointType = void 0;
(function (KnownIntegrationServiceEnvironmentAccessEndpointType) {
    /** NotSpecified */
    KnownIntegrationServiceEnvironmentAccessEndpointType["NotSpecified"] = "NotSpecified";
    /** External */
    KnownIntegrationServiceEnvironmentAccessEndpointType["External"] = "External";
    /** Internal */
    KnownIntegrationServiceEnvironmentAccessEndpointType["Internal"] = "Internal";
})(exports.KnownIntegrationServiceEnvironmentAccessEndpointType || (exports.KnownIntegrationServiceEnvironmentAccessEndpointType = {}));
/** Known values of {@link IntegrationServiceEnvironmentSkuName} that the service accepts. */
exports.KnownIntegrationServiceEnvironmentSkuName = void 0;
(function (KnownIntegrationServiceEnvironmentSkuName) {
    /** NotSpecified */
    KnownIntegrationServiceEnvironmentSkuName["NotSpecified"] = "NotSpecified";
    /** Premium */
    KnownIntegrationServiceEnvironmentSkuName["Premium"] = "Premium";
    /** Developer */
    KnownIntegrationServiceEnvironmentSkuName["Developer"] = "Developer";
})(exports.KnownIntegrationServiceEnvironmentSkuName || (exports.KnownIntegrationServiceEnvironmentSkuName = {}));
/** Known values of {@link IntegrationServiceEnvironmentSkuScaleType} that the service accepts. */
exports.KnownIntegrationServiceEnvironmentSkuScaleType = void 0;
(function (KnownIntegrationServiceEnvironmentSkuScaleType) {
    /** Manual */
    KnownIntegrationServiceEnvironmentSkuScaleType["Manual"] = "Manual";
    /** Automatic */
    KnownIntegrationServiceEnvironmentSkuScaleType["Automatic"] = "Automatic";
    /** None */
    KnownIntegrationServiceEnvironmentSkuScaleType["None"] = "None";
})(exports.KnownIntegrationServiceEnvironmentSkuScaleType || (exports.KnownIntegrationServiceEnvironmentSkuScaleType = {}));
/** Known values of {@link IntegrationServiceEnvironmentNetworkDependencyCategoryType} that the service accepts. */
exports.KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType = void 0;
(function (KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType) {
    /** NotSpecified */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["NotSpecified"] = "NotSpecified";
    /** AzureStorage */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["AzureStorage"] = "AzureStorage";
    /** AzureManagement */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["AzureManagement"] = "AzureManagement";
    /** AzureActiveDirectory */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["AzureActiveDirectory"] = "AzureActiveDirectory";
    /** SSLCertificateVerification */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["SSLCertificateVerification"] = "SSLCertificateVerification";
    /** DiagnosticLogsAndMetrics */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["DiagnosticLogsAndMetrics"] = "DiagnosticLogsAndMetrics";
    /** IntegrationServiceEnvironmentConnectors */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["IntegrationServiceEnvironmentConnectors"] = "IntegrationServiceEnvironmentConnectors";
    /** RedisCache */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["RedisCache"] = "RedisCache";
    /** AccessEndpoints */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["AccessEndpoints"] = "AccessEndpoints";
    /** RecoveryService */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["RecoveryService"] = "RecoveryService";
    /** SQL */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["SQL"] = "SQL";
    /** RegionalService */
    KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType["RegionalService"] = "RegionalService";
})(exports.KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType || (exports.KnownIntegrationServiceEnvironmentNetworkDependencyCategoryType = {}));
/** Known values of {@link IntegrationServiceEnvironmentNetworkEndPointAccessibilityState} that the service accepts. */
exports.KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState = void 0;
(function (KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState) {
    /** NotSpecified */
    KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState["NotSpecified"] = "NotSpecified";
    /** Unknown */
    KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState["Unknown"] = "Unknown";
    /** Available */
    KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState["Available"] = "Available";
    /** NotAvailable */
    KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState["NotAvailable"] = "NotAvailable";
})(exports.KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState || (exports.KnownIntegrationServiceEnvironmentNetworkEndPointAccessibilityState = {}));
/** Known values of {@link ErrorResponseCode} that the service accepts. */
exports.KnownErrorResponseCode = void 0;
(function (KnownErrorResponseCode) {
    /** NotSpecified */
    KnownErrorResponseCode["NotSpecified"] = "NotSpecified";
    /** IntegrationServiceEnvironmentNotFound */
    KnownErrorResponseCode["IntegrationServiceEnvironmentNotFound"] = "IntegrationServiceEnvironmentNotFound";
    /** InternalServerError */
    KnownErrorResponseCode["InternalServerError"] = "InternalServerError";
    /** InvalidOperationId */
    KnownErrorResponseCode["InvalidOperationId"] = "InvalidOperationId";
})(exports.KnownErrorResponseCode || (exports.KnownErrorResponseCode = {}));
/** Known values of {@link IntegrationServiceEnvironmentNetworkDependencyHealthState} that the service accepts. */
exports.KnownIntegrationServiceEnvironmentNetworkDependencyHealthState = void 0;
(function (KnownIntegrationServiceEnvironmentNetworkDependencyHealthState) {
    /** NotSpecified */
    KnownIntegrationServiceEnvironmentNetworkDependencyHealthState["NotSpecified"] = "NotSpecified";
    /** Healthy */
    KnownIntegrationServiceEnvironmentNetworkDependencyHealthState["Healthy"] = "Healthy";
    /** Unhealthy */
    KnownIntegrationServiceEnvironmentNetworkDependencyHealthState["Unhealthy"] = "Unhealthy";
    /** Unknown */
    KnownIntegrationServiceEnvironmentNetworkDependencyHealthState["Unknown"] = "Unknown";
})(exports.KnownIntegrationServiceEnvironmentNetworkDependencyHealthState || (exports.KnownIntegrationServiceEnvironmentNetworkDependencyHealthState = {}));
/** Known values of {@link ApiType} that the service accepts. */
exports.KnownApiType = void 0;
(function (KnownApiType) {
    /** NotSpecified */
    KnownApiType["NotSpecified"] = "NotSpecified";
    /** Rest */
    KnownApiType["Rest"] = "Rest";
    /** Soap */
    KnownApiType["Soap"] = "Soap";
})(exports.KnownApiType || (exports.KnownApiType = {}));
/** Known values of {@link WsdlImportMethod} that the service accepts. */
exports.KnownWsdlImportMethod = void 0;
(function (KnownWsdlImportMethod) {
    /** NotSpecified */
    KnownWsdlImportMethod["NotSpecified"] = "NotSpecified";
    /** SoapToRest */
    KnownWsdlImportMethod["SoapToRest"] = "SoapToRest";
    /** SoapPassThrough */
    KnownWsdlImportMethod["SoapPassThrough"] = "SoapPassThrough";
})(exports.KnownWsdlImportMethod || (exports.KnownWsdlImportMethod = {}));
/** Known values of {@link ApiDeploymentParameterVisibility} that the service accepts. */
exports.KnownApiDeploymentParameterVisibility = void 0;
(function (KnownApiDeploymentParameterVisibility) {
    /** NotSpecified */
    KnownApiDeploymentParameterVisibility["NotSpecified"] = "NotSpecified";
    /** Default */
    KnownApiDeploymentParameterVisibility["Default"] = "Default";
    /** Internal */
    KnownApiDeploymentParameterVisibility["Internal"] = "Internal";
})(exports.KnownApiDeploymentParameterVisibility || (exports.KnownApiDeploymentParameterVisibility = {}));
/** Known values of {@link ApiTier} that the service accepts. */
exports.KnownApiTier = void 0;
(function (KnownApiTier) {
    /** NotSpecified */
    KnownApiTier["NotSpecified"] = "NotSpecified";
    /** Enterprise */
    KnownApiTier["Enterprise"] = "Enterprise";
    /** Standard */
    KnownApiTier["Standard"] = "Standard";
    /** Premium */
    KnownApiTier["Premium"] = "Premium";
})(exports.KnownApiTier || (exports.KnownApiTier = {}));
/** Known values of {@link StatusAnnotation} that the service accepts. */
exports.KnownStatusAnnotation = void 0;
(function (KnownStatusAnnotation) {
    /** NotSpecified */
    KnownStatusAnnotation["NotSpecified"] = "NotSpecified";
    /** Preview */
    KnownStatusAnnotation["Preview"] = "Preview";
    /** Production */
    KnownStatusAnnotation["Production"] = "Production";
})(exports.KnownStatusAnnotation || (exports.KnownStatusAnnotation = {}));
/** Known values of {@link SwaggerSchemaType} that the service accepts. */
exports.KnownSwaggerSchemaType = void 0;
(function (KnownSwaggerSchemaType) {
    /** String */
    KnownSwaggerSchemaType["String"] = "String";
    /** Number */
    KnownSwaggerSchemaType["Number"] = "Number";
    /** Integer */
    KnownSwaggerSchemaType["Integer"] = "Integer";
    /** Boolean */
    KnownSwaggerSchemaType["Boolean"] = "Boolean";
    /** Array */
    KnownSwaggerSchemaType["Array"] = "Array";
    /** File */
    KnownSwaggerSchemaType["File"] = "File";
    /** Object */
    KnownSwaggerSchemaType["Object"] = "Object";
    /** Null */
    KnownSwaggerSchemaType["Null"] = "Null";
})(exports.KnownSwaggerSchemaType || (exports.KnownSwaggerSchemaType = {}));
/** Known values of {@link AzureAsyncOperationState} that the service accepts. */
exports.KnownAzureAsyncOperationState = void 0;
(function (KnownAzureAsyncOperationState) {
    /** Failed */
    KnownAzureAsyncOperationState["Failed"] = "Failed";
    /** Succeeded */
    KnownAzureAsyncOperationState["Succeeded"] = "Succeeded";
    /** Pending */
    KnownAzureAsyncOperationState["Pending"] = "Pending";
    /** Canceled */
    KnownAzureAsyncOperationState["Canceled"] = "Canceled";
})(exports.KnownAzureAsyncOperationState || (exports.KnownAzureAsyncOperationState = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const WorkflowListResult = {
    type: {
        name: "Composite",
        className: "WorkflowListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workflow"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FlowEndpointsConfiguration = {
    type: {
        name: "Composite",
        className: "FlowEndpointsConfiguration",
        modelProperties: {
            workflow: {
                serializedName: "workflow",
                type: {
                    name: "Composite",
                    className: "FlowEndpoints"
                }
            },
            connector: {
                serializedName: "connector",
                type: {
                    name: "Composite",
                    className: "FlowEndpoints"
                }
            }
        }
    }
};
const FlowEndpoints = {
    type: {
        name: "Composite",
        className: "FlowEndpoints",
        modelProperties: {
            outgoingIpAddresses: {
                serializedName: "outgoingIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddress"
                        }
                    }
                }
            },
            accessEndpointIpAddresses: {
                serializedName: "accessEndpointIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddress"
                        }
                    }
                }
            }
        }
    }
};
const IpAddress = {
    type: {
        name: "Composite",
        className: "IpAddress",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FlowAccessControlConfiguration = {
    type: {
        name: "Composite",
        className: "FlowAccessControlConfiguration",
        modelProperties: {
            triggers: {
                serializedName: "triggers",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            },
            contents: {
                serializedName: "contents",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            },
            actions: {
                serializedName: "actions",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            },
            workflowManagement: {
                serializedName: "workflowManagement",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfigurationPolicy"
                }
            }
        }
    }
};
const FlowAccessControlConfigurationPolicy = {
    type: {
        name: "Composite",
        className: "FlowAccessControlConfigurationPolicy",
        modelProperties: {
            allowedCallerIpAddresses: {
                serializedName: "allowedCallerIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressRange"
                        }
                    }
                }
            },
            openAuthenticationPolicies: {
                serializedName: "openAuthenticationPolicies",
                type: {
                    name: "Composite",
                    className: "OpenAuthenticationAccessPolicies"
                }
            }
        }
    }
};
const IpAddressRange = {
    type: {
        name: "Composite",
        className: "IpAddressRange",
        modelProperties: {
            addressRange: {
                serializedName: "addressRange",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenAuthenticationAccessPolicies = {
    type: {
        name: "Composite",
        className: "OpenAuthenticationAccessPolicies",
        modelProperties: {
            policies: {
                serializedName: "policies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "OpenAuthenticationAccessPolicy"
                        }
                    }
                }
            }
        }
    }
};
const OpenAuthenticationAccessPolicy = {
    type: {
        name: "Composite",
        className: "OpenAuthenticationAccessPolicy",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            claims: {
                serializedName: "claims",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OpenAuthenticationPolicyClaim"
                        }
                    }
                }
            }
        }
    }
};
const OpenAuthenticationPolicyClaim = {
    type: {
        name: "Composite",
        className: "OpenAuthenticationPolicyClaim",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            plan: {
                serializedName: "plan",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }
        }
    }
};
const ResourceReference = {
    type: {
        name: "Composite",
        className: "ResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowParameter = {
    type: {
        name: "Composite",
        className: "WorkflowParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "any"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "any"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorProperties"
                }
            }
        }
    }
};
const ErrorProperties = {
    type: {
        name: "Composite",
        className: "ErrorProperties",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateUpgradedDefinitionParameters = {
    type: {
        name: "Composite",
        className: "GenerateUpgradedDefinitionParameters",
        modelProperties: {
            targetSchemaVersion: {
                serializedName: "targetSchemaVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetCallbackUrlParameters = {
    type: {
        name: "Composite",
        className: "GetCallbackUrlParameters",
        modelProperties: {
            notAfter: {
                serializedName: "notAfter",
                type: {
                    name: "DateTime"
                }
            },
            keyType: {
                serializedName: "keyType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerCallbackUrl = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerCallbackUrl",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            basePath: {
                serializedName: "basePath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            relativePath: {
                serializedName: "relativePath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            relativePathParameters: {
                serializedName: "relativePathParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            queries: {
                serializedName: "queries",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerListCallbackUrlQueries"
                }
            }
        }
    }
};
const WorkflowTriggerListCallbackUrlQueries = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerListCallbackUrlQueries",
        modelProperties: {
            apiVersion: {
                serializedName: "api-version",
                type: {
                    name: "String"
                }
            },
            sp: {
                serializedName: "sp",
                type: {
                    name: "String"
                }
            },
            sv: {
                serializedName: "sv",
                type: {
                    name: "String"
                }
            },
            sig: {
                serializedName: "sig",
                type: {
                    name: "String"
                }
            },
            se: {
                serializedName: "se",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegenerateActionParameter = {
    type: {
        name: "Composite",
        className: "RegenerateActionParameter",
        modelProperties: {
            keyType: {
                serializedName: "keyType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowVersionListResult = {
    type: {
        name: "Composite",
        className: "WorkflowVersionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerListResult = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowTrigger"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerRecurrence = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerRecurrence",
        modelProperties: {
            frequency: {
                serializedName: "frequency",
                type: {
                    name: "String"
                }
            },
            interval: {
                serializedName: "interval",
                type: {
                    name: "Number"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "String"
                }
            },
            timeZone: {
                serializedName: "timeZone",
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "RecurrenceSchedule"
                }
            }
        }
    }
};
const RecurrenceSchedule = {
    type: {
        name: "Composite",
        className: "RecurrenceSchedule",
        modelProperties: {
            minutes: {
                serializedName: "minutes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            hours: {
                serializedName: "hours",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            weekDays: {
                serializedName: "weekDays",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Sunday",
                                "Monday",
                                "Tuesday",
                                "Wednesday",
                                "Thursday",
                                "Friday",
                                "Saturday"
                            ]
                        }
                    }
                }
            },
            monthDays: {
                serializedName: "monthDays",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            monthlyOccurrences: {
                serializedName: "monthlyOccurrences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecurrenceScheduleOccurrence"
                        }
                    }
                }
            }
        }
    }
};
const RecurrenceScheduleOccurrence = {
    type: {
        name: "Composite",
        className: "RecurrenceScheduleOccurrence",
        modelProperties: {
            day: {
                serializedName: "day",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Sunday",
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday"
                    ]
                }
            },
            occurrence: {
                serializedName: "occurrence",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JsonSchema = {
    type: {
        name: "Composite",
        className: "JsonSchema",
        modelProperties: {
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SetTriggerStateActionDefinition = {
    type: {
        name: "Composite",
        className: "SetTriggerStateActionDefinition",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerReference"
                }
            }
        }
    }
};
const WorkflowTriggerHistoryListResult = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowTriggerHistory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Correlation = {
    type: {
        name: "Composite",
        className: "Correlation",
        modelProperties: {
            clientTrackingId: {
                serializedName: "clientTrackingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContentLink = {
    type: {
        name: "Composite",
        className: "ContentLink",
        modelProperties: {
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            contentVersion: {
                serializedName: "contentVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            contentSize: {
                serializedName: "contentSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            contentHash: {
                serializedName: "contentHash",
                type: {
                    name: "Composite",
                    className: "ContentHash"
                }
            },
            metadata: {
                serializedName: "metadata",
                readOnly: true,
                type: {
                    name: "any"
                }
            }
        }
    }
};
const ContentHash = {
    type: {
        name: "Composite",
        className: "ContentHash",
        modelProperties: {
            algorithm: {
                serializedName: "algorithm",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunListResult = {
    type: {
        name: "Composite",
        className: "WorkflowRunListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRun"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunTrigger = {
    type: {
        name: "Composite",
        className: "WorkflowRunTrigger",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            inputs: {
                serializedName: "inputs",
                readOnly: true,
                type: {
                    name: "any"
                }
            },
            inputsLink: {
                serializedName: "inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            },
            outputs: {
                serializedName: "outputs",
                readOnly: true,
                type: {
                    name: "any"
                }
            },
            outputsLink: {
                serializedName: "outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            },
            scheduledTime: {
                serializedName: "scheduledTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            trackingId: {
                serializedName: "trackingId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            correlation: {
                serializedName: "correlation",
                type: {
                    name: "Composite",
                    className: "Correlation"
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                readOnly: true,
                type: {
                    name: "any"
                }
            },
            trackedProperties: {
                serializedName: "trackedProperties",
                readOnly: true,
                type: {
                    name: "any"
                }
            }
        }
    }
};
const WorkflowRunActionListResult = {
    type: {
        name: "Composite",
        className: "WorkflowRunActionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRunAction"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RunCorrelation = {
    type: {
        name: "Composite",
        className: "RunCorrelation",
        modelProperties: {
            clientTrackingId: {
                serializedName: "clientTrackingId",
                type: {
                    name: "String"
                }
            },
            clientKeywords: {
                serializedName: "clientKeywords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RetryHistory = {
    type: {
        name: "Composite",
        className: "RetryHistory",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "clientRequestId",
                type: {
                    name: "String"
                }
            },
            serviceRequestId: {
                serializedName: "serviceRequestId",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const ExpressionTraces = {
    type: {
        name: "Composite",
        className: "ExpressionTraces",
        modelProperties: {
            inputs: {
                serializedName: "inputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressionRoot"
                        }
                    }
                }
            }
        }
    }
};
const Expression = {
    type: {
        name: "Composite",
        className: "Expression",
        modelProperties: {
            text: {
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "any"
                }
            },
            subexpressions: {
                serializedName: "subexpressions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Expression"
                        }
                    }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "AzureResourceErrorInfo"
                }
            }
        }
    }
};
const ErrorInfo = {
    type: {
        name: "Composite",
        className: "ErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunActionRepetitionDefinitionCollection = {
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionDefinitionCollection",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkflowRunActionRepetitionDefinition"
                        }
                    }
                }
            }
        }
    }
};
const RepetitionIndex = {
    type: {
        name: "Composite",
        className: "RepetitionIndex",
        modelProperties: {
            scopeName: {
                serializedName: "scopeName",
                type: {
                    name: "String"
                }
            },
            itemIndex: {
                serializedName: "itemIndex",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OperationResultProperties = {
    type: {
        name: "Composite",
        className: "OperationResultProperties",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            correlation: {
                serializedName: "correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const RequestHistoryListResult = {
    type: {
        name: "Composite",
        className: "RequestHistoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RequestHistory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RequestHistoryProperties = {
    type: {
        name: "Composite",
        className: "RequestHistoryProperties",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            request: {
                serializedName: "request",
                type: {
                    name: "Composite",
                    className: "Request"
                }
            },
            response: {
                serializedName: "response",
                type: {
                    name: "Composite",
                    className: "Response"
                }
            }
        }
    }
};
const Request = {
    type: {
        name: "Composite",
        className: "Request",
        modelProperties: {
            headers: {
                serializedName: "headers",
                type: {
                    name: "any"
                }
            },
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Response = {
    type: {
        name: "Composite",
        className: "Response",
        modelProperties: {
            headers: {
                serializedName: "headers",
                type: {
                    name: "any"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            },
            bodyLink: {
                serializedName: "bodyLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }
        }
    }
};
const IntegrationAccountListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccount"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountSku = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AssemblyCollection = {
    type: {
        name: "Composite",
        className: "AssemblyCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AssemblyDefinition"
                        }
                    }
                }
            }
        }
    }
};
const ArtifactProperties = {
    type: {
        name: "Composite",
        className: "ArtifactProperties",
        modelProperties: {
            createdTime: {
                serializedName: "createdTime",
                type: {
                    name: "DateTime"
                }
            },
            changedTime: {
                serializedName: "changedTime",
                type: {
                    name: "DateTime"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const BatchConfigurationCollection = {
    type: {
        name: "Composite",
        className: "BatchConfigurationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BatchConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const BatchReleaseCriteria = {
    type: {
        name: "Composite",
        className: "BatchReleaseCriteria",
        modelProperties: {
            messageCount: {
                serializedName: "messageCount",
                type: {
                    name: "Number"
                }
            },
            batchSize: {
                serializedName: "batchSize",
                type: {
                    name: "Number"
                }
            },
            recurrence: {
                serializedName: "recurrence",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerRecurrence"
                }
            }
        }
    }
};
const CallbackUrl = {
    type: {
        name: "Composite",
        className: "CallbackUrl",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListKeyVaultKeysDefinition = {
    type: {
        name: "Composite",
        className: "ListKeyVaultKeysDefinition",
        modelProperties: {
            keyVault: {
                serializedName: "keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultReference"
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultKeyCollection = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyVaultKey"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultKey = {
    type: {
        name: "Composite",
        className: "KeyVaultKey",
        modelProperties: {
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyAttributes"
                }
            }
        }
    }
};
const KeyVaultKeyAttributes = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            created: {
                serializedName: "created",
                type: {
                    name: "Number"
                }
            },
            updated: {
                serializedName: "updated",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TrackingEventsDefinition = {
    type: {
        name: "Composite",
        className: "TrackingEventsDefinition",
        modelProperties: {
            sourceType: {
                serializedName: "sourceType",
                required: true,
                type: {
                    name: "String"
                }
            },
            trackEventsOptions: {
                serializedName: "trackEventsOptions",
                type: {
                    name: "String"
                }
            },
            events: {
                serializedName: "events",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrackingEvent"
                        }
                    }
                }
            }
        }
    }
};
const TrackingEvent = {
    type: {
        name: "Composite",
        className: "TrackingEvent",
        modelProperties: {
            eventLevel: {
                serializedName: "eventLevel",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "LogAlways",
                        "Critical",
                        "Error",
                        "Warning",
                        "Informational",
                        "Verbose"
                    ]
                }
            },
            eventTime: {
                serializedName: "eventTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            recordType: {
                serializedName: "recordType",
                required: true,
                type: {
                    name: "String"
                }
            },
            record: {
                serializedName: "record",
                type: {
                    name: "any"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TrackingEventErrorInfo"
                }
            }
        }
    }
};
const TrackingEventErrorInfo = {
    type: {
        name: "Composite",
        className: "TrackingEventErrorInfo",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountSchemaListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSchemaListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccountSchema"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountMapListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountMapListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccountMap"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountMapPropertiesParametersSchema = {
    type: {
        name: "Composite",
        className: "IntegrationAccountMapPropertiesParametersSchema",
        modelProperties: {
            ref: {
                serializedName: "ref",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountPartnerListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountPartnerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccountPartner"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerContent = {
    type: {
        name: "Composite",
        className: "PartnerContent",
        modelProperties: {
            b2B: {
                serializedName: "b2b",
                type: {
                    name: "Composite",
                    className: "B2BPartnerContent"
                }
            }
        }
    }
};
const B2BPartnerContent = {
    type: {
        name: "Composite",
        className: "B2BPartnerContent",
        modelProperties: {
            businessIdentities: {
                serializedName: "businessIdentities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BusinessIdentity"
                        }
                    }
                }
            }
        }
    }
};
const BusinessIdentity = {
    type: {
        name: "Composite",
        className: "BusinessIdentity",
        modelProperties: {
            qualifier: {
                serializedName: "qualifier",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountAgreementListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountAgreementListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccountAgreement"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AgreementContent = {
    type: {
        name: "Composite",
        className: "AgreementContent",
        modelProperties: {
            aS2: {
                serializedName: "aS2",
                type: {
                    name: "Composite",
                    className: "AS2AgreementContent"
                }
            },
            x12: {
                serializedName: "x12",
                type: {
                    name: "Composite",
                    className: "X12AgreementContent"
                }
            },
            edifact: {
                serializedName: "edifact",
                type: {
                    name: "Composite",
                    className: "EdifactAgreementContent"
                }
            }
        }
    }
};
const AS2AgreementContent = {
    type: {
        name: "Composite",
        className: "AS2AgreementContent",
        modelProperties: {
            receiveAgreement: {
                serializedName: "receiveAgreement",
                type: {
                    name: "Composite",
                    className: "AS2OneWayAgreement"
                }
            },
            sendAgreement: {
                serializedName: "sendAgreement",
                type: {
                    name: "Composite",
                    className: "AS2OneWayAgreement"
                }
            }
        }
    }
};
const AS2OneWayAgreement = {
    type: {
        name: "Composite",
        className: "AS2OneWayAgreement",
        modelProperties: {
            senderBusinessIdentity: {
                serializedName: "senderBusinessIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            },
            receiverBusinessIdentity: {
                serializedName: "receiverBusinessIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            },
            protocolSettings: {
                serializedName: "protocolSettings",
                type: {
                    name: "Composite",
                    className: "AS2ProtocolSettings"
                }
            }
        }
    }
};
const AS2ProtocolSettings = {
    type: {
        name: "Composite",
        className: "AS2ProtocolSettings",
        modelProperties: {
            messageConnectionSettings: {
                serializedName: "messageConnectionSettings",
                type: {
                    name: "Composite",
                    className: "AS2MessageConnectionSettings"
                }
            },
            acknowledgementConnectionSettings: {
                serializedName: "acknowledgementConnectionSettings",
                type: {
                    name: "Composite",
                    className: "AS2AcknowledgementConnectionSettings"
                }
            },
            mdnSettings: {
                serializedName: "mdnSettings",
                type: {
                    name: "Composite",
                    className: "AS2MdnSettings"
                }
            },
            securitySettings: {
                serializedName: "securitySettings",
                type: {
                    name: "Composite",
                    className: "AS2SecuritySettings"
                }
            },
            validationSettings: {
                serializedName: "validationSettings",
                type: {
                    name: "Composite",
                    className: "AS2ValidationSettings"
                }
            },
            envelopeSettings: {
                serializedName: "envelopeSettings",
                type: {
                    name: "Composite",
                    className: "AS2EnvelopeSettings"
                }
            },
            errorSettings: {
                serializedName: "errorSettings",
                type: {
                    name: "Composite",
                    className: "AS2ErrorSettings"
                }
            }
        }
    }
};
const AS2MessageConnectionSettings = {
    type: {
        name: "Composite",
        className: "AS2MessageConnectionSettings",
        modelProperties: {
            ignoreCertificateNameMismatch: {
                serializedName: "ignoreCertificateNameMismatch",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            supportHttpStatusCodeContinue: {
                serializedName: "supportHttpStatusCodeContinue",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            keepHttpConnectionAlive: {
                serializedName: "keepHttpConnectionAlive",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            unfoldHttpHeaders: {
                serializedName: "unfoldHttpHeaders",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AS2AcknowledgementConnectionSettings = {
    type: {
        name: "Composite",
        className: "AS2AcknowledgementConnectionSettings",
        modelProperties: {
            ignoreCertificateNameMismatch: {
                serializedName: "ignoreCertificateNameMismatch",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            supportHttpStatusCodeContinue: {
                serializedName: "supportHttpStatusCodeContinue",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            keepHttpConnectionAlive: {
                serializedName: "keepHttpConnectionAlive",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            unfoldHttpHeaders: {
                serializedName: "unfoldHttpHeaders",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AS2MdnSettings = {
    type: {
        name: "Composite",
        className: "AS2MdnSettings",
        modelProperties: {
            needMDN: {
                serializedName: "needMDN",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            signMDN: {
                serializedName: "signMDN",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            sendMDNAsynchronously: {
                serializedName: "sendMDNAsynchronously",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            receiptDeliveryUrl: {
                serializedName: "receiptDeliveryUrl",
                type: {
                    name: "String"
                }
            },
            dispositionNotificationTo: {
                serializedName: "dispositionNotificationTo",
                type: {
                    name: "String"
                }
            },
            signOutboundMDNIfOptional: {
                serializedName: "signOutboundMDNIfOptional",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            mdnText: {
                serializedName: "mdnText",
                type: {
                    name: "String"
                }
            },
            sendInboundMDNToMessageBox: {
                serializedName: "sendInboundMDNToMessageBox",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            micHashingAlgorithm: {
                serializedName: "micHashingAlgorithm",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AS2SecuritySettings = {
    type: {
        name: "Composite",
        className: "AS2SecuritySettings",
        modelProperties: {
            overrideGroupSigningCertificate: {
                serializedName: "overrideGroupSigningCertificate",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            signingCertificateName: {
                serializedName: "signingCertificateName",
                type: {
                    name: "String"
                }
            },
            encryptionCertificateName: {
                serializedName: "encryptionCertificateName",
                type: {
                    name: "String"
                }
            },
            enableNRRForInboundEncodedMessages: {
                serializedName: "enableNRRForInboundEncodedMessages",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableNRRForInboundDecodedMessages: {
                serializedName: "enableNRRForInboundDecodedMessages",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableNRRForOutboundMDN: {
                serializedName: "enableNRRForOutboundMDN",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableNRRForOutboundEncodedMessages: {
                serializedName: "enableNRRForOutboundEncodedMessages",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableNRRForOutboundDecodedMessages: {
                serializedName: "enableNRRForOutboundDecodedMessages",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableNRRForInboundMDN: {
                serializedName: "enableNRRForInboundMDN",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            sha2AlgorithmFormat: {
                serializedName: "sha2AlgorithmFormat",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AS2ValidationSettings = {
    type: {
        name: "Composite",
        className: "AS2ValidationSettings",
        modelProperties: {
            overrideMessageProperties: {
                serializedName: "overrideMessageProperties",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            encryptMessage: {
                serializedName: "encryptMessage",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            signMessage: {
                serializedName: "signMessage",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            compressMessage: {
                serializedName: "compressMessage",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            checkDuplicateMessage: {
                serializedName: "checkDuplicateMessage",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            interchangeDuplicatesValidityDays: {
                serializedName: "interchangeDuplicatesValidityDays",
                required: true,
                type: {
                    name: "Number"
                }
            },
            checkCertificateRevocationListOnSend: {
                serializedName: "checkCertificateRevocationListOnSend",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            checkCertificateRevocationListOnReceive: {
                serializedName: "checkCertificateRevocationListOnReceive",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            encryptionAlgorithm: {
                serializedName: "encryptionAlgorithm",
                required: true,
                type: {
                    name: "String"
                }
            },
            signingAlgorithm: {
                serializedName: "signingAlgorithm",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AS2EnvelopeSettings = {
    type: {
        name: "Composite",
        className: "AS2EnvelopeSettings",
        modelProperties: {
            messageContentType: {
                serializedName: "messageContentType",
                required: true,
                type: {
                    name: "String"
                }
            },
            transmitFileNameInMimeHeader: {
                serializedName: "transmitFileNameInMimeHeader",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            fileNameTemplate: {
                serializedName: "fileNameTemplate",
                required: true,
                type: {
                    name: "String"
                }
            },
            suspendMessageOnFileNameGenerationError: {
                serializedName: "suspendMessageOnFileNameGenerationError",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            autogenerateFileName: {
                serializedName: "autogenerateFileName",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AS2ErrorSettings = {
    type: {
        name: "Composite",
        className: "AS2ErrorSettings",
        modelProperties: {
            suspendDuplicateMessage: {
                serializedName: "suspendDuplicateMessage",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            resendIfMDNNotReceived: {
                serializedName: "resendIfMDNNotReceived",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const X12AgreementContent = {
    type: {
        name: "Composite",
        className: "X12AgreementContent",
        modelProperties: {
            receiveAgreement: {
                serializedName: "receiveAgreement",
                type: {
                    name: "Composite",
                    className: "X12OneWayAgreement"
                }
            },
            sendAgreement: {
                serializedName: "sendAgreement",
                type: {
                    name: "Composite",
                    className: "X12OneWayAgreement"
                }
            }
        }
    }
};
const X12OneWayAgreement = {
    type: {
        name: "Composite",
        className: "X12OneWayAgreement",
        modelProperties: {
            senderBusinessIdentity: {
                serializedName: "senderBusinessIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            },
            receiverBusinessIdentity: {
                serializedName: "receiverBusinessIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            },
            protocolSettings: {
                serializedName: "protocolSettings",
                type: {
                    name: "Composite",
                    className: "X12ProtocolSettings"
                }
            }
        }
    }
};
const X12ProtocolSettings = {
    type: {
        name: "Composite",
        className: "X12ProtocolSettings",
        modelProperties: {
            validationSettings: {
                serializedName: "validationSettings",
                type: {
                    name: "Composite",
                    className: "X12ValidationSettings"
                }
            },
            framingSettings: {
                serializedName: "framingSettings",
                type: {
                    name: "Composite",
                    className: "X12FramingSettings"
                }
            },
            envelopeSettings: {
                serializedName: "envelopeSettings",
                type: {
                    name: "Composite",
                    className: "X12EnvelopeSettings"
                }
            },
            acknowledgementSettings: {
                serializedName: "acknowledgementSettings",
                type: {
                    name: "Composite",
                    className: "X12AcknowledgementSettings"
                }
            },
            messageFilter: {
                serializedName: "messageFilter",
                type: {
                    name: "Composite",
                    className: "X12MessageFilter"
                }
            },
            securitySettings: {
                serializedName: "securitySettings",
                type: {
                    name: "Composite",
                    className: "X12SecuritySettings"
                }
            },
            processingSettings: {
                serializedName: "processingSettings",
                type: {
                    name: "Composite",
                    className: "X12ProcessingSettings"
                }
            },
            envelopeOverrides: {
                serializedName: "envelopeOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "X12EnvelopeOverride"
                        }
                    }
                }
            },
            validationOverrides: {
                serializedName: "validationOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "X12ValidationOverride"
                        }
                    }
                }
            },
            messageFilterList: {
                serializedName: "messageFilterList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "X12MessageIdentifier"
                        }
                    }
                }
            },
            schemaReferences: {
                serializedName: "schemaReferences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "X12SchemaReference"
                        }
                    }
                }
            },
            x12DelimiterOverrides: {
                serializedName: "x12DelimiterOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "X12DelimiterOverrides"
                        }
                    }
                }
            }
        }
    }
};
const X12ValidationSettings = {
    type: {
        name: "Composite",
        className: "X12ValidationSettings",
        modelProperties: {
            validateCharacterSet: {
                serializedName: "validateCharacterSet",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            checkDuplicateInterchangeControlNumber: {
                serializedName: "checkDuplicateInterchangeControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            interchangeControlNumberValidityDays: {
                serializedName: "interchangeControlNumberValidityDays",
                required: true,
                type: {
                    name: "Number"
                }
            },
            checkDuplicateGroupControlNumber: {
                serializedName: "checkDuplicateGroupControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            checkDuplicateTransactionSetControlNumber: {
                serializedName: "checkDuplicateTransactionSetControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateEDITypes: {
                serializedName: "validateEDITypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateXSDTypes: {
                serializedName: "validateXSDTypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            allowLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "allowLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trimLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "trimLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trailingSeparatorPolicy: {
                serializedName: "trailingSeparatorPolicy",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12FramingSettings = {
    type: {
        name: "Composite",
        className: "X12FramingSettings",
        modelProperties: {
            dataElementSeparator: {
                serializedName: "dataElementSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            componentSeparator: {
                serializedName: "componentSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            replaceSeparatorsInPayload: {
                serializedName: "replaceSeparatorsInPayload",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            replaceCharacter: {
                serializedName: "replaceCharacter",
                required: true,
                type: {
                    name: "Number"
                }
            },
            segmentTerminator: {
                serializedName: "segmentTerminator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            characterSet: {
                serializedName: "characterSet",
                required: true,
                type: {
                    name: "String"
                }
            },
            segmentTerminatorSuffix: {
                serializedName: "segmentTerminatorSuffix",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "None", "CR", "LF", "CRLF"]
                }
            }
        }
    }
};
const X12EnvelopeSettings = {
    type: {
        name: "Composite",
        className: "X12EnvelopeSettings",
        modelProperties: {
            controlStandardsId: {
                serializedName: "controlStandardsId",
                required: true,
                type: {
                    name: "Number"
                }
            },
            useControlStandardsIdAsRepetitionCharacter: {
                serializedName: "useControlStandardsIdAsRepetitionCharacter",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            senderApplicationId: {
                serializedName: "senderApplicationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            receiverApplicationId: {
                serializedName: "receiverApplicationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            controlVersionNumber: {
                serializedName: "controlVersionNumber",
                required: true,
                type: {
                    name: "String"
                }
            },
            interchangeControlNumberLowerBound: {
                serializedName: "interchangeControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            interchangeControlNumberUpperBound: {
                serializedName: "interchangeControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverInterchangeControlNumber: {
                serializedName: "rolloverInterchangeControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableDefaultGroupHeaders: {
                serializedName: "enableDefaultGroupHeaders",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            functionalGroupId: {
                serializedName: "functionalGroupId",
                type: {
                    name: "String"
                }
            },
            groupControlNumberLowerBound: {
                serializedName: "groupControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            groupControlNumberUpperBound: {
                serializedName: "groupControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverGroupControlNumber: {
                serializedName: "rolloverGroupControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            groupHeaderAgencyCode: {
                serializedName: "groupHeaderAgencyCode",
                required: true,
                type: {
                    name: "String"
                }
            },
            groupHeaderVersion: {
                serializedName: "groupHeaderVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            transactionSetControlNumberLowerBound: {
                serializedName: "transactionSetControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionSetControlNumberUpperBound: {
                serializedName: "transactionSetControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverTransactionSetControlNumber: {
                serializedName: "rolloverTransactionSetControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            transactionSetControlNumberPrefix: {
                serializedName: "transactionSetControlNumberPrefix",
                type: {
                    name: "String"
                }
            },
            transactionSetControlNumberSuffix: {
                serializedName: "transactionSetControlNumberSuffix",
                type: {
                    name: "String"
                }
            },
            overwriteExistingTransactionSetControlNumber: {
                serializedName: "overwriteExistingTransactionSetControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            groupHeaderDateFormat: {
                serializedName: "groupHeaderDateFormat",
                required: true,
                type: {
                    name: "String"
                }
            },
            groupHeaderTimeFormat: {
                serializedName: "groupHeaderTimeFormat",
                required: true,
                type: {
                    name: "String"
                }
            },
            usageIndicator: {
                serializedName: "usageIndicator",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12AcknowledgementSettings = {
    type: {
        name: "Composite",
        className: "X12AcknowledgementSettings",
        modelProperties: {
            needTechnicalAcknowledgement: {
                serializedName: "needTechnicalAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            batchTechnicalAcknowledgements: {
                serializedName: "batchTechnicalAcknowledgements",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            needFunctionalAcknowledgement: {
                serializedName: "needFunctionalAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            functionalAcknowledgementVersion: {
                serializedName: "functionalAcknowledgementVersion",
                type: {
                    name: "String"
                }
            },
            batchFunctionalAcknowledgements: {
                serializedName: "batchFunctionalAcknowledgements",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            needImplementationAcknowledgement: {
                serializedName: "needImplementationAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            implementationAcknowledgementVersion: {
                serializedName: "implementationAcknowledgementVersion",
                type: {
                    name: "String"
                }
            },
            batchImplementationAcknowledgements: {
                serializedName: "batchImplementationAcknowledgements",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            needLoopForValidMessages: {
                serializedName: "needLoopForValidMessages",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            sendSynchronousAcknowledgement: {
                serializedName: "sendSynchronousAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            acknowledgementControlNumberPrefix: {
                serializedName: "acknowledgementControlNumberPrefix",
                type: {
                    name: "String"
                }
            },
            acknowledgementControlNumberSuffix: {
                serializedName: "acknowledgementControlNumberSuffix",
                type: {
                    name: "String"
                }
            },
            acknowledgementControlNumberLowerBound: {
                serializedName: "acknowledgementControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            acknowledgementControlNumberUpperBound: {
                serializedName: "acknowledgementControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverAcknowledgementControlNumber: {
                serializedName: "rolloverAcknowledgementControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const X12MessageFilter = {
    type: {
        name: "Composite",
        className: "X12MessageFilter",
        modelProperties: {
            messageFilterType: {
                serializedName: "messageFilterType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12SecuritySettings = {
    type: {
        name: "Composite",
        className: "X12SecuritySettings",
        modelProperties: {
            authorizationQualifier: {
                serializedName: "authorizationQualifier",
                required: true,
                type: {
                    name: "String"
                }
            },
            authorizationValue: {
                serializedName: "authorizationValue",
                type: {
                    name: "String"
                }
            },
            securityQualifier: {
                serializedName: "securityQualifier",
                required: true,
                type: {
                    name: "String"
                }
            },
            passwordValue: {
                serializedName: "passwordValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12ProcessingSettings = {
    type: {
        name: "Composite",
        className: "X12ProcessingSettings",
        modelProperties: {
            maskSecurityInfo: {
                serializedName: "maskSecurityInfo",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            convertImpliedDecimal: {
                serializedName: "convertImpliedDecimal",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            preserveInterchange: {
                serializedName: "preserveInterchange",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            suspendInterchangeOnError: {
                serializedName: "suspendInterchangeOnError",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            createEmptyXmlTagsForTrailingSeparators: {
                serializedName: "createEmptyXmlTagsForTrailingSeparators",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            useDotAsDecimalSeparator: {
                serializedName: "useDotAsDecimalSeparator",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const X12EnvelopeOverride = {
    type: {
        name: "Composite",
        className: "X12EnvelopeOverride",
        modelProperties: {
            targetNamespace: {
                serializedName: "targetNamespace",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocolVersion: {
                serializedName: "protocolVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            responsibleAgencyCode: {
                serializedName: "responsibleAgencyCode",
                required: true,
                type: {
                    name: "String"
                }
            },
            headerVersion: {
                serializedName: "headerVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            senderApplicationId: {
                serializedName: "senderApplicationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            receiverApplicationId: {
                serializedName: "receiverApplicationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            functionalIdentifierCode: {
                serializedName: "functionalIdentifierCode",
                type: {
                    name: "String"
                }
            },
            dateFormat: {
                serializedName: "dateFormat",
                required: true,
                type: {
                    name: "String"
                }
            },
            timeFormat: {
                serializedName: "timeFormat",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12ValidationOverride = {
    type: {
        name: "Composite",
        className: "X12ValidationOverride",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            validateEDITypes: {
                serializedName: "validateEDITypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateXSDTypes: {
                serializedName: "validateXSDTypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            allowLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "allowLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateCharacterSet: {
                serializedName: "validateCharacterSet",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trimLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "trimLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trailingSeparatorPolicy: {
                serializedName: "trailingSeparatorPolicy",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12MessageIdentifier = {
    type: {
        name: "Composite",
        className: "X12MessageIdentifier",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12SchemaReference = {
    type: {
        name: "Composite",
        className: "X12SchemaReference",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            senderApplicationId: {
                serializedName: "senderApplicationId",
                type: {
                    name: "String"
                }
            },
            schemaVersion: {
                serializedName: "schemaVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            schemaName: {
                serializedName: "schemaName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const X12DelimiterOverrides = {
    type: {
        name: "Composite",
        className: "X12DelimiterOverrides",
        modelProperties: {
            protocolVersion: {
                serializedName: "protocolVersion",
                type: {
                    name: "String"
                }
            },
            messageId: {
                serializedName: "messageId",
                type: {
                    name: "String"
                }
            },
            dataElementSeparator: {
                serializedName: "dataElementSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            componentSeparator: {
                serializedName: "componentSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            segmentTerminator: {
                serializedName: "segmentTerminator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            segmentTerminatorSuffix: {
                serializedName: "segmentTerminatorSuffix",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "None", "CR", "LF", "CRLF"]
                }
            },
            replaceCharacter: {
                serializedName: "replaceCharacter",
                required: true,
                type: {
                    name: "Number"
                }
            },
            replaceSeparatorsInPayload: {
                serializedName: "replaceSeparatorsInPayload",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            targetNamespace: {
                serializedName: "targetNamespace",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactAgreementContent = {
    type: {
        name: "Composite",
        className: "EdifactAgreementContent",
        modelProperties: {
            receiveAgreement: {
                serializedName: "receiveAgreement",
                type: {
                    name: "Composite",
                    className: "EdifactOneWayAgreement"
                }
            },
            sendAgreement: {
                serializedName: "sendAgreement",
                type: {
                    name: "Composite",
                    className: "EdifactOneWayAgreement"
                }
            }
        }
    }
};
const EdifactOneWayAgreement = {
    type: {
        name: "Composite",
        className: "EdifactOneWayAgreement",
        modelProperties: {
            senderBusinessIdentity: {
                serializedName: "senderBusinessIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            },
            receiverBusinessIdentity: {
                serializedName: "receiverBusinessIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            },
            protocolSettings: {
                serializedName: "protocolSettings",
                type: {
                    name: "Composite",
                    className: "EdifactProtocolSettings"
                }
            }
        }
    }
};
const EdifactProtocolSettings = {
    type: {
        name: "Composite",
        className: "EdifactProtocolSettings",
        modelProperties: {
            validationSettings: {
                serializedName: "validationSettings",
                type: {
                    name: "Composite",
                    className: "EdifactValidationSettings"
                }
            },
            framingSettings: {
                serializedName: "framingSettings",
                type: {
                    name: "Composite",
                    className: "EdifactFramingSettings"
                }
            },
            envelopeSettings: {
                serializedName: "envelopeSettings",
                type: {
                    name: "Composite",
                    className: "EdifactEnvelopeSettings"
                }
            },
            acknowledgementSettings: {
                serializedName: "acknowledgementSettings",
                type: {
                    name: "Composite",
                    className: "EdifactAcknowledgementSettings"
                }
            },
            messageFilter: {
                serializedName: "messageFilter",
                type: {
                    name: "Composite",
                    className: "EdifactMessageFilter"
                }
            },
            processingSettings: {
                serializedName: "processingSettings",
                type: {
                    name: "Composite",
                    className: "EdifactProcessingSettings"
                }
            },
            envelopeOverrides: {
                serializedName: "envelopeOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdifactEnvelopeOverride"
                        }
                    }
                }
            },
            messageFilterList: {
                serializedName: "messageFilterList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdifactMessageIdentifier"
                        }
                    }
                }
            },
            schemaReferences: {
                serializedName: "schemaReferences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdifactSchemaReference"
                        }
                    }
                }
            },
            validationOverrides: {
                serializedName: "validationOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdifactValidationOverride"
                        }
                    }
                }
            },
            edifactDelimiterOverrides: {
                serializedName: "edifactDelimiterOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdifactDelimiterOverride"
                        }
                    }
                }
            }
        }
    }
};
const EdifactValidationSettings = {
    type: {
        name: "Composite",
        className: "EdifactValidationSettings",
        modelProperties: {
            validateCharacterSet: {
                serializedName: "validateCharacterSet",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            checkDuplicateInterchangeControlNumber: {
                serializedName: "checkDuplicateInterchangeControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            interchangeControlNumberValidityDays: {
                serializedName: "interchangeControlNumberValidityDays",
                required: true,
                type: {
                    name: "Number"
                }
            },
            checkDuplicateGroupControlNumber: {
                serializedName: "checkDuplicateGroupControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            checkDuplicateTransactionSetControlNumber: {
                serializedName: "checkDuplicateTransactionSetControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateEDITypes: {
                serializedName: "validateEDITypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateXSDTypes: {
                serializedName: "validateXSDTypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            allowLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "allowLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trimLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "trimLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trailingSeparatorPolicy: {
                serializedName: "trailingSeparatorPolicy",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactFramingSettings = {
    type: {
        name: "Composite",
        className: "EdifactFramingSettings",
        modelProperties: {
            serviceCodeListDirectoryVersion: {
                serializedName: "serviceCodeListDirectoryVersion",
                type: {
                    name: "String"
                }
            },
            characterEncoding: {
                serializedName: "characterEncoding",
                type: {
                    name: "String"
                }
            },
            protocolVersion: {
                serializedName: "protocolVersion",
                required: true,
                type: {
                    name: "Number"
                }
            },
            dataElementSeparator: {
                serializedName: "dataElementSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            componentSeparator: {
                serializedName: "componentSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            segmentTerminator: {
                serializedName: "segmentTerminator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            releaseIndicator: {
                serializedName: "releaseIndicator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            repetitionSeparator: {
                serializedName: "repetitionSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            characterSet: {
                serializedName: "characterSet",
                required: true,
                type: {
                    name: "String"
                }
            },
            decimalPointIndicator: {
                serializedName: "decimalPointIndicator",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "Comma", "Decimal"]
                }
            },
            segmentTerminatorSuffix: {
                serializedName: "segmentTerminatorSuffix",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "None", "CR", "LF", "CRLF"]
                }
            }
        }
    }
};
const EdifactEnvelopeSettings = {
    type: {
        name: "Composite",
        className: "EdifactEnvelopeSettings",
        modelProperties: {
            groupAssociationAssignedCode: {
                serializedName: "groupAssociationAssignedCode",
                type: {
                    name: "String"
                }
            },
            communicationAgreementId: {
                serializedName: "communicationAgreementId",
                type: {
                    name: "String"
                }
            },
            applyDelimiterStringAdvice: {
                serializedName: "applyDelimiterStringAdvice",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            createGroupingSegments: {
                serializedName: "createGroupingSegments",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enableDefaultGroupHeaders: {
                serializedName: "enableDefaultGroupHeaders",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            recipientReferencePasswordValue: {
                serializedName: "recipientReferencePasswordValue",
                type: {
                    name: "String"
                }
            },
            recipientReferencePasswordQualifier: {
                serializedName: "recipientReferencePasswordQualifier",
                type: {
                    name: "String"
                }
            },
            applicationReferenceId: {
                serializedName: "applicationReferenceId",
                type: {
                    name: "String"
                }
            },
            processingPriorityCode: {
                serializedName: "processingPriorityCode",
                type: {
                    name: "String"
                }
            },
            interchangeControlNumberLowerBound: {
                serializedName: "interchangeControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            interchangeControlNumberUpperBound: {
                serializedName: "interchangeControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverInterchangeControlNumber: {
                serializedName: "rolloverInterchangeControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            interchangeControlNumberPrefix: {
                serializedName: "interchangeControlNumberPrefix",
                type: {
                    name: "String"
                }
            },
            interchangeControlNumberSuffix: {
                serializedName: "interchangeControlNumberSuffix",
                type: {
                    name: "String"
                }
            },
            senderReverseRoutingAddress: {
                serializedName: "senderReverseRoutingAddress",
                type: {
                    name: "String"
                }
            },
            receiverReverseRoutingAddress: {
                serializedName: "receiverReverseRoutingAddress",
                type: {
                    name: "String"
                }
            },
            functionalGroupId: {
                serializedName: "functionalGroupId",
                type: {
                    name: "String"
                }
            },
            groupControllingAgencyCode: {
                serializedName: "groupControllingAgencyCode",
                type: {
                    name: "String"
                }
            },
            groupMessageVersion: {
                serializedName: "groupMessageVersion",
                type: {
                    name: "String"
                }
            },
            groupMessageRelease: {
                serializedName: "groupMessageRelease",
                type: {
                    name: "String"
                }
            },
            groupControlNumberLowerBound: {
                serializedName: "groupControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            groupControlNumberUpperBound: {
                serializedName: "groupControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverGroupControlNumber: {
                serializedName: "rolloverGroupControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            groupControlNumberPrefix: {
                serializedName: "groupControlNumberPrefix",
                type: {
                    name: "String"
                }
            },
            groupControlNumberSuffix: {
                serializedName: "groupControlNumberSuffix",
                type: {
                    name: "String"
                }
            },
            groupApplicationReceiverQualifier: {
                serializedName: "groupApplicationReceiverQualifier",
                type: {
                    name: "String"
                }
            },
            groupApplicationReceiverId: {
                serializedName: "groupApplicationReceiverId",
                type: {
                    name: "String"
                }
            },
            groupApplicationSenderQualifier: {
                serializedName: "groupApplicationSenderQualifier",
                type: {
                    name: "String"
                }
            },
            groupApplicationSenderId: {
                serializedName: "groupApplicationSenderId",
                type: {
                    name: "String"
                }
            },
            groupApplicationPassword: {
                serializedName: "groupApplicationPassword",
                type: {
                    name: "String"
                }
            },
            overwriteExistingTransactionSetControlNumber: {
                serializedName: "overwriteExistingTransactionSetControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            transactionSetControlNumberPrefix: {
                serializedName: "transactionSetControlNumberPrefix",
                type: {
                    name: "String"
                }
            },
            transactionSetControlNumberSuffix: {
                serializedName: "transactionSetControlNumberSuffix",
                type: {
                    name: "String"
                }
            },
            transactionSetControlNumberLowerBound: {
                serializedName: "transactionSetControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionSetControlNumberUpperBound: {
                serializedName: "transactionSetControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverTransactionSetControlNumber: {
                serializedName: "rolloverTransactionSetControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            isTestInterchange: {
                serializedName: "isTestInterchange",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            senderInternalIdentification: {
                serializedName: "senderInternalIdentification",
                type: {
                    name: "String"
                }
            },
            senderInternalSubIdentification: {
                serializedName: "senderInternalSubIdentification",
                type: {
                    name: "String"
                }
            },
            receiverInternalIdentification: {
                serializedName: "receiverInternalIdentification",
                type: {
                    name: "String"
                }
            },
            receiverInternalSubIdentification: {
                serializedName: "receiverInternalSubIdentification",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactAcknowledgementSettings = {
    type: {
        name: "Composite",
        className: "EdifactAcknowledgementSettings",
        modelProperties: {
            needTechnicalAcknowledgement: {
                serializedName: "needTechnicalAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            batchTechnicalAcknowledgements: {
                serializedName: "batchTechnicalAcknowledgements",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            needFunctionalAcknowledgement: {
                serializedName: "needFunctionalAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            batchFunctionalAcknowledgements: {
                serializedName: "batchFunctionalAcknowledgements",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            needLoopForValidMessages: {
                serializedName: "needLoopForValidMessages",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            sendSynchronousAcknowledgement: {
                serializedName: "sendSynchronousAcknowledgement",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            acknowledgementControlNumberPrefix: {
                serializedName: "acknowledgementControlNumberPrefix",
                type: {
                    name: "String"
                }
            },
            acknowledgementControlNumberSuffix: {
                serializedName: "acknowledgementControlNumberSuffix",
                type: {
                    name: "String"
                }
            },
            acknowledgementControlNumberLowerBound: {
                serializedName: "acknowledgementControlNumberLowerBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            acknowledgementControlNumberUpperBound: {
                serializedName: "acknowledgementControlNumberUpperBound",
                required: true,
                type: {
                    name: "Number"
                }
            },
            rolloverAcknowledgementControlNumber: {
                serializedName: "rolloverAcknowledgementControlNumber",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EdifactMessageFilter = {
    type: {
        name: "Composite",
        className: "EdifactMessageFilter",
        modelProperties: {
            messageFilterType: {
                serializedName: "messageFilterType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactProcessingSettings = {
    type: {
        name: "Composite",
        className: "EdifactProcessingSettings",
        modelProperties: {
            maskSecurityInfo: {
                serializedName: "maskSecurityInfo",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            preserveInterchange: {
                serializedName: "preserveInterchange",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            suspendInterchangeOnError: {
                serializedName: "suspendInterchangeOnError",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            createEmptyXmlTagsForTrailingSeparators: {
                serializedName: "createEmptyXmlTagsForTrailingSeparators",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            useDotAsDecimalSeparator: {
                serializedName: "useDotAsDecimalSeparator",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EdifactEnvelopeOverride = {
    type: {
        name: "Composite",
        className: "EdifactEnvelopeOverride",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                type: {
                    name: "String"
                }
            },
            messageVersion: {
                serializedName: "messageVersion",
                type: {
                    name: "String"
                }
            },
            messageRelease: {
                serializedName: "messageRelease",
                type: {
                    name: "String"
                }
            },
            messageAssociationAssignedCode: {
                serializedName: "messageAssociationAssignedCode",
                type: {
                    name: "String"
                }
            },
            targetNamespace: {
                serializedName: "targetNamespace",
                type: {
                    name: "String"
                }
            },
            functionalGroupId: {
                serializedName: "functionalGroupId",
                type: {
                    name: "String"
                }
            },
            senderApplicationQualifier: {
                serializedName: "senderApplicationQualifier",
                type: {
                    name: "String"
                }
            },
            senderApplicationId: {
                serializedName: "senderApplicationId",
                type: {
                    name: "String"
                }
            },
            receiverApplicationQualifier: {
                serializedName: "receiverApplicationQualifier",
                type: {
                    name: "String"
                }
            },
            receiverApplicationId: {
                serializedName: "receiverApplicationId",
                type: {
                    name: "String"
                }
            },
            controllingAgencyCode: {
                serializedName: "controllingAgencyCode",
                type: {
                    name: "String"
                }
            },
            groupHeaderMessageVersion: {
                serializedName: "groupHeaderMessageVersion",
                type: {
                    name: "String"
                }
            },
            groupHeaderMessageRelease: {
                serializedName: "groupHeaderMessageRelease",
                type: {
                    name: "String"
                }
            },
            associationAssignedCode: {
                serializedName: "associationAssignedCode",
                type: {
                    name: "String"
                }
            },
            applicationPassword: {
                serializedName: "applicationPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactMessageIdentifier = {
    type: {
        name: "Composite",
        className: "EdifactMessageIdentifier",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactSchemaReference = {
    type: {
        name: "Composite",
        className: "EdifactSchemaReference",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            messageVersion: {
                serializedName: "messageVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            messageRelease: {
                serializedName: "messageRelease",
                required: true,
                type: {
                    name: "String"
                }
            },
            senderApplicationId: {
                serializedName: "senderApplicationId",
                type: {
                    name: "String"
                }
            },
            senderApplicationQualifier: {
                serializedName: "senderApplicationQualifier",
                type: {
                    name: "String"
                }
            },
            associationAssignedCode: {
                serializedName: "associationAssignedCode",
                type: {
                    name: "String"
                }
            },
            schemaName: {
                serializedName: "schemaName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EdifactValidationOverride = {
    type: {
        name: "Composite",
        className: "EdifactValidationOverride",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            enforceCharacterSet: {
                serializedName: "enforceCharacterSet",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateEDITypes: {
                serializedName: "validateEDITypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            validateXSDTypes: {
                serializedName: "validateXSDTypes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            allowLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "allowLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            trailingSeparatorPolicy: {
                serializedName: "trailingSeparatorPolicy",
                required: true,
                type: {
                    name: "String"
                }
            },
            trimLeadingAndTrailingSpacesAndZeroes: {
                serializedName: "trimLeadingAndTrailingSpacesAndZeroes",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EdifactDelimiterOverride = {
    type: {
        name: "Composite",
        className: "EdifactDelimiterOverride",
        modelProperties: {
            messageId: {
                serializedName: "messageId",
                type: {
                    name: "String"
                }
            },
            messageVersion: {
                serializedName: "messageVersion",
                type: {
                    name: "String"
                }
            },
            messageRelease: {
                serializedName: "messageRelease",
                type: {
                    name: "String"
                }
            },
            dataElementSeparator: {
                serializedName: "dataElementSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            componentSeparator: {
                serializedName: "componentSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            segmentTerminator: {
                serializedName: "segmentTerminator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            repetitionSeparator: {
                serializedName: "repetitionSeparator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            segmentTerminatorSuffix: {
                serializedName: "segmentTerminatorSuffix",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "None", "CR", "LF", "CRLF"]
                }
            },
            decimalPointIndicator: {
                serializedName: "decimalPointIndicator",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "Comma", "Decimal"]
                }
            },
            releaseIndicator: {
                serializedName: "releaseIndicator",
                required: true,
                type: {
                    name: "Number"
                }
            },
            messageAssociationAssignedCode: {
                serializedName: "messageAssociationAssignedCode",
                type: {
                    name: "String"
                }
            },
            targetNamespace: {
                serializedName: "targetNamespace",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountCertificateListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountCertificateListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccountCertificate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultKeyReference = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyReference",
        modelProperties: {
            keyVault: {
                serializedName: "keyVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyReferenceKeyVault"
                }
            },
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultKeyReferenceKeyVault = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyReferenceKeyVault",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountSessionListResult = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSessionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationAccountSession"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentListResult = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationServiceEnvironment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentProperties = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            integrationServiceEnvironmentId: {
                serializedName: "integrationServiceEnvironmentId",
                type: {
                    name: "String"
                }
            },
            endpointsConfiguration: {
                serializedName: "endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration"
                }
            },
            networkConfiguration: {
                serializedName: "networkConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkConfiguration"
                }
            },
            encryptionConfiguration: {
                serializedName: "encryptionConfiguration",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmenEncryptionConfiguration"
                }
            }
        }
    }
};
const NetworkConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkConfiguration",
        modelProperties: {
            virtualNetworkAddressSpace: {
                serializedName: "virtualNetworkAddressSpace",
                type: {
                    name: "String"
                }
            },
            accessEndpoint: {
                serializedName: "accessEndpoint",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentAccessEndpoint"
                }
            },
            subnets: {
                serializedName: "subnets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentAccessEndpoint = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentAccessEndpoint",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmenEncryptionConfiguration = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmenEncryptionConfiguration",
        modelProperties: {
            encryptionKeyReference: {
                serializedName: "encryptionKeyReference",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmenEncryptionKeyReference"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmenEncryptionKeyReference = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmenEncryptionKeyReference",
        modelProperties: {
            keyVault: {
                serializedName: "keyVault",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            keyName: {
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentSku = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentSkuList = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentSkuList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationServiceEnvironmentSkuDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentSkuDefinition = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentSkuDefinition",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentSkuDefinitionSku"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentSkuCapacity"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentSkuDefinitionSku = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentSkuDefinitionSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentSkuCapacity = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentSkuCapacity",
        modelProperties: {
            minimum: {
                serializedName: "minimum",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                type: {
                    name: "Number"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentSubnetNetworkHealth = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentSubnetNetworkHealth",
        modelProperties: {
            outboundNetworkDependencies: {
                serializedName: "outboundNetworkDependencies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationServiceEnvironmentNetworkDependency"
                        }
                    }
                }
            },
            outboundNetworkHealth: {
                serializedName: "outboundNetworkHealth",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentNetworkDependencyHealth"
                }
            },
            networkDependencyHealthState: {
                serializedName: "networkDependencyHealthState",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentNetworkDependency = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentNetworkDependency",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationServiceEnvironmentNetworkEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentNetworkEndpoint = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentNetworkEndpoint",
        modelProperties: {
            accessibility: {
                serializedName: "accessibility",
                type: {
                    name: "String"
                }
            },
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String"
                }
            },
            ports: {
                serializedName: "ports",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentNetworkDependencyHealth = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentNetworkDependencyHealth",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ExtendedErrorInfo"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedErrorInfo = {
    type: {
        name: "Composite",
        className: "ExtendedErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExtendedErrorInfo"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innerError",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentManagedApiListResult = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentManagedApiListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IntegrationServiceEnvironmentManagedApi"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationServiceEnvironmentManagedApiDeploymentParameters = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentManagedApiDeploymentParameters",
        modelProperties: {
            contentLinkDefinition: {
                serializedName: "contentLinkDefinition",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }
        }
    }
};
const ApiResourceProperties = {
    type: {
        name: "Composite",
        className: "ApiResourceProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectionParameters: {
                serializedName: "connectionParameters",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Composite",
                    className: "ApiResourceMetadata"
                }
            },
            runtimeUrls: {
                serializedName: "runtimeUrls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            generalInformation: {
                serializedName: "generalInformation",
                type: {
                    name: "Composite",
                    className: "ApiResourceGeneralInformation"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            backendService: {
                serializedName: "backendService",
                type: {
                    name: "Composite",
                    className: "ApiResourceBackendService"
                }
            },
            policies: {
                serializedName: "policies",
                type: {
                    name: "Composite",
                    className: "ApiResourcePolicies"
                }
            },
            apiDefinitionUrl: {
                serializedName: "apiDefinitionUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            apiDefinitions: {
                serializedName: "apiDefinitions",
                type: {
                    name: "Composite",
                    className: "ApiResourceDefinitions"
                }
            },
            integrationServiceEnvironment: {
                serializedName: "integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiResourceMetadata = {
    type: {
        name: "Composite",
        className: "ApiResourceMetadata",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            brandColor: {
                serializedName: "brandColor",
                type: {
                    name: "String"
                }
            },
            hideKey: {
                serializedName: "hideKey",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            apiType: {
                serializedName: "ApiType",
                type: {
                    name: "String"
                }
            },
            wsdlService: {
                serializedName: "wsdlService",
                type: {
                    name: "Composite",
                    className: "WsdlService"
                }
            },
            wsdlImportMethod: {
                serializedName: "wsdlImportMethod",
                type: {
                    name: "String"
                }
            },
            connectionType: {
                serializedName: "connectionType",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            deploymentParameters: {
                serializedName: "deploymentParameters",
                type: {
                    name: "Composite",
                    className: "ApiDeploymentParameterMetadataSet"
                }
            }
        }
    }
};
const WsdlService = {
    type: {
        name: "Composite",
        className: "WsdlService",
        modelProperties: {
            qualifiedName: {
                serializedName: "qualifiedName",
                type: {
                    name: "String"
                }
            },
            endpointQualifiedNames: {
                serializedName: "EndpointQualifiedNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ApiDeploymentParameterMetadataSet = {
    type: {
        name: "Composite",
        className: "ApiDeploymentParameterMetadataSet",
        modelProperties: {
            packageContentLink: {
                serializedName: "packageContentLink",
                type: {
                    name: "Composite",
                    className: "ApiDeploymentParameterMetadata"
                }
            },
            redisCacheConnectionString: {
                serializedName: "redisCacheConnectionString",
                type: {
                    name: "Composite",
                    className: "ApiDeploymentParameterMetadata"
                }
            }
        }
    }
};
const ApiDeploymentParameterMetadata = {
    type: {
        name: "Composite",
        className: "ApiDeploymentParameterMetadata",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            isRequired: {
                serializedName: "isRequired",
                type: {
                    name: "Boolean"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            visibility: {
                serializedName: "visibility",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiResourceGeneralInformation = {
    type: {
        name: "Composite",
        className: "ApiResourceGeneralInformation",
        modelProperties: {
            iconUrl: {
                serializedName: "iconUrl",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            termsOfUseUrl: {
                serializedName: "termsOfUseUrl",
                type: {
                    name: "String"
                }
            },
            releaseTag: {
                serializedName: "releaseTag",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiResourceBackendService = {
    type: {
        name: "Composite",
        className: "ApiResourceBackendService",
        modelProperties: {
            serviceUrl: {
                serializedName: "serviceUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiResourcePolicies = {
    type: {
        name: "Composite",
        className: "ApiResourcePolicies",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            },
            contentLink: {
                serializedName: "contentLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiResourceDefinitions = {
    type: {
        name: "Composite",
        className: "ApiResourceDefinitions",
        modelProperties: {
            originalSwaggerUrl: {
                serializedName: "originalSwaggerUrl",
                type: {
                    name: "String"
                }
            },
            modifiedSwaggerUrl: {
                serializedName: "modifiedSwaggerUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationListResult = {
    type: {
        name: "Composite",
        className: "ApiOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationPropertiesDefinition = {
    type: {
        name: "Composite",
        className: "ApiOperationPropertiesDefinition",
        modelProperties: {
            summary: {
                serializedName: "summary",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            visibility: {
                serializedName: "visibility",
                type: {
                    name: "String"
                }
            },
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "String"
                }
            },
            triggerHint: {
                serializedName: "triggerHint",
                type: {
                    name: "String"
                }
            },
            pageable: {
                serializedName: "pageable",
                type: {
                    name: "Boolean"
                }
            },
            annotation: {
                serializedName: "annotation",
                type: {
                    name: "Composite",
                    className: "ApiOperationAnnotation"
                }
            },
            api: {
                serializedName: "api",
                type: {
                    name: "Composite",
                    className: "ApiReference"
                }
            },
            inputsDefinition: {
                serializedName: "inputsDefinition",
                type: {
                    name: "Composite",
                    className: "SwaggerSchema"
                }
            },
            responsesDefinition: {
                serializedName: "responsesDefinition",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "SwaggerSchema" } }
                }
            },
            isWebhook: {
                serializedName: "isWebhook",
                type: {
                    name: "Boolean"
                }
            },
            isNotification: {
                serializedName: "isNotification",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApiOperationAnnotation = {
    type: {
        name: "Composite",
        className: "ApiOperationAnnotation",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            revision: {
                serializedName: "revision",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SwaggerSchema = {
    type: {
        name: "Composite",
        className: "SwaggerSchema",
        modelProperties: {
            ref: {
                serializedName: "ref",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            items: {
                serializedName: "items",
                type: {
                    name: "Composite",
                    className: "SwaggerSchema"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "SwaggerSchema" } }
                }
            },
            additionalProperties: {
                serializedName: "additionalProperties",
                type: {
                    name: "any"
                }
            },
            required: {
                serializedName: "required",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxProperties: {
                serializedName: "maxProperties",
                type: {
                    name: "Number"
                }
            },
            minProperties: {
                serializedName: "minProperties",
                type: {
                    name: "Number"
                }
            },
            allOf: {
                serializedName: "allOf",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SwaggerSchema"
                        }
                    }
                }
            },
            discriminator: {
                serializedName: "discriminator",
                type: {
                    name: "String"
                }
            },
            readOnly: {
                serializedName: "readOnly",
                type: {
                    name: "Boolean"
                }
            },
            xml: {
                serializedName: "xml",
                type: {
                    name: "Composite",
                    className: "SwaggerXml"
                }
            },
            externalDocs: {
                serializedName: "externalDocs",
                type: {
                    name: "Composite",
                    className: "SwaggerExternalDocumentation"
                }
            },
            example: {
                serializedName: "example",
                type: {
                    name: "any"
                }
            },
            notificationUrlExtension: {
                serializedName: "notificationUrlExtension",
                type: {
                    name: "Boolean"
                }
            },
            dynamicSchemaOld: {
                serializedName: "dynamicSchemaOld",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicSchema"
                }
            },
            dynamicSchemaNew: {
                serializedName: "dynamicSchemaNew",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicProperties"
                }
            },
            dynamicListNew: {
                serializedName: "dynamicListNew",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicList"
                }
            },
            dynamicTree: {
                serializedName: "dynamicTree",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicTree"
                }
            }
        }
    }
};
const SwaggerXml = {
    type: {
        name: "Composite",
        className: "SwaggerXml",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            namespace: {
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "prefix",
                type: {
                    name: "String"
                }
            },
            attribute: {
                serializedName: "attribute",
                type: {
                    name: "Boolean"
                }
            },
            wrapped: {
                serializedName: "wrapped",
                type: {
                    name: "Boolean"
                }
            },
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const SwaggerExternalDocumentation = {
    type: {
        name: "Composite",
        className: "SwaggerExternalDocumentation",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const SwaggerCustomDynamicSchema = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicSchema",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                type: {
                    name: "String"
                }
            },
            valuePath: {
                serializedName: "valuePath",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const SwaggerCustomDynamicProperties = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicProperties",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                type: {
                    name: "String"
                }
            },
            valuePath: {
                serializedName: "valuePath",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "SwaggerCustomDynamicProperties"
                        }
                    }
                }
            }
        }
    }
};
const SwaggerCustomDynamicList = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicList",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                type: {
                    name: "String"
                }
            },
            builtInOperation: {
                serializedName: "builtInOperation",
                type: {
                    name: "String"
                }
            },
            itemsPath: {
                serializedName: "itemsPath",
                type: {
                    name: "String"
                }
            },
            itemValuePath: {
                serializedName: "itemValuePath",
                type: {
                    name: "String"
                }
            },
            itemTitlePath: {
                serializedName: "itemTitlePath",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "SwaggerCustomDynamicProperties"
                        }
                    }
                }
            }
        }
    }
};
const SwaggerCustomDynamicTree = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicTree",
        modelProperties: {
            settings: {
                serializedName: "settings",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicTreeSettings"
                }
            },
            open: {
                serializedName: "open",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicTreeCommand"
                }
            },
            browse: {
                serializedName: "browse",
                type: {
                    name: "Composite",
                    className: "SwaggerCustomDynamicTreeCommand"
                }
            }
        }
    }
};
const SwaggerCustomDynamicTreeSettings = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicTreeSettings",
        modelProperties: {
            canSelectParentNodes: {
                serializedName: "CanSelectParentNodes",
                type: {
                    name: "Boolean"
                }
            },
            canSelectLeafNodes: {
                serializedName: "CanSelectLeafNodes",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SwaggerCustomDynamicTreeCommand = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicTreeCommand",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                type: {
                    name: "String"
                }
            },
            itemsPath: {
                serializedName: "itemsPath",
                type: {
                    name: "String"
                }
            },
            itemValuePath: {
                serializedName: "itemValuePath",
                type: {
                    name: "String"
                }
            },
            itemTitlePath: {
                serializedName: "itemTitlePath",
                type: {
                    name: "String"
                }
            },
            itemFullTitlePath: {
                serializedName: "itemFullTitlePath",
                type: {
                    name: "String"
                }
            },
            itemIsParent: {
                serializedName: "itemIsParent",
                type: {
                    name: "String"
                }
            },
            selectableFilter: {
                serializedName: "selectableFilter",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "SwaggerCustomDynamicTreeParameter"
                        }
                    }
                }
            }
        }
    }
};
const SwaggerCustomDynamicTreeParameter = {
    type: {
        name: "Composite",
        className: "SwaggerCustomDynamicTreeParameter",
        modelProperties: {
            selectedItemValuePath: {
                serializedName: "selectedItemValuePath",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "any"
                }
            },
            parameterReference: {
                serializedName: "parameterReference",
                type: {
                    name: "String"
                }
            },
            required: {
                serializedName: "required",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "any"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowFilter = {
    type: {
        name: "Composite",
        className: "WorkflowFilter",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerFilter = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerFilter",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowTriggerHistoryFilter = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistoryFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunFilter = {
    type: {
        name: "Composite",
        className: "WorkflowRunFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkflowRunActionFilter = {
    type: {
        name: "Composite",
        className: "WorkflowRunActionFilter",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedApiListResult = {
    type: {
        name: "Composite",
        className: "ManagedApiListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedApi"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountSchemaFilter = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSchemaFilter",
        modelProperties: {
            schemaType: {
                serializedName: "schemaType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountMapFilter = {
    type: {
        name: "Composite",
        className: "IntegrationAccountMapFilter",
        modelProperties: {
            mapType: {
                serializedName: "mapType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountPartnerFilter = {
    type: {
        name: "Composite",
        className: "IntegrationAccountPartnerFilter",
        modelProperties: {
            partnerType: {
                serializedName: "partnerType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IntegrationAccountAgreementFilter = {
    type: {
        name: "Composite",
        className: "IntegrationAccountAgreementFilter",
        modelProperties: {
            agreementType: {
                serializedName: "agreementType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "AS2", "X12", "Edifact"]
                }
            }
        }
    }
};
const IntegrationAccountSessionFilter = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSessionFilter",
        modelProperties: {
            changedTime: {
                serializedName: "changedTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const WorkflowReference = {
    type: {
        name: "Composite",
        className: "WorkflowReference",
        modelProperties: Object.assign({}, ResourceReference.type.modelProperties)
    }
};
const WorkflowTriggerReference = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerReference",
        modelProperties: Object.assign(Object.assign({}, ResourceReference.type.modelProperties), { flowName: {
                serializedName: "flowName",
                type: {
                    name: "String"
                }
            }, triggerName: {
                serializedName: "triggerName",
                type: {
                    name: "String"
                }
            } })
    }
};
const KeyVaultReference = {
    type: {
        name: "Composite",
        className: "KeyVaultReference",
        modelProperties: Object.assign({}, ResourceReference.type.modelProperties)
    }
};
const ApiReference = {
    type: {
        name: "Composite",
        className: "ApiReference",
        modelProperties: Object.assign(Object.assign({}, ResourceReference.type.modelProperties), { displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }, iconUri: {
                serializedName: "iconUri",
                type: {
                    name: "String"
                }
            }, swagger: {
                serializedName: "swagger",
                type: {
                    name: "any"
                }
            }, brandColor: {
                serializedName: "brandColor",
                type: {
                    name: "String"
                }
            }, category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            }, integrationServiceEnvironment: {
                serializedName: "integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            } })
    }
};
const WorkflowOutputParameter = {
    type: {
        name: "Composite",
        className: "WorkflowOutputParameter",
        modelProperties: Object.assign(Object.assign({}, WorkflowParameter.type.modelProperties), { error: {
                serializedName: "error",
                readOnly: true,
                type: {
                    name: "any"
                }
            } })
    }
};
const Workflow = {
    type: {
        name: "Composite",
        className: "Workflow",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, accessEndpoint: {
                serializedName: "properties.accessEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endpointsConfiguration: {
                serializedName: "properties.endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration"
                }
            }, accessControl: {
                serializedName: "properties.accessControl",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfiguration"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, integrationAccount: {
                serializedName: "properties.integrationAccount",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, integrationServiceEnvironment: {
                serializedName: "properties.integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, definition: {
                serializedName: "properties.definition",
                type: {
                    name: "any"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "WorkflowParameter" } }
                }
            } })
    }
};
const WorkflowVersion = {
    type: {
        name: "Composite",
        className: "WorkflowVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, accessEndpoint: {
                serializedName: "properties.accessEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endpointsConfiguration: {
                serializedName: "properties.endpointsConfiguration",
                type: {
                    name: "Composite",
                    className: "FlowEndpointsConfiguration"
                }
            }, accessControl: {
                serializedName: "properties.accessControl",
                type: {
                    name: "Composite",
                    className: "FlowAccessControlConfiguration"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, integrationAccount: {
                serializedName: "properties.integrationAccount",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, definition: {
                serializedName: "properties.definition",
                type: {
                    name: "any"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "WorkflowParameter" } }
                }
            } })
    }
};
const WorkflowRunActionRepetitionDefinition = {
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionDefinition",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { startTime: {
                serializedName: "properties.startTime",
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                type: {
                    name: "DateTime"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                type: {
                    name: "any"
                }
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inputs: {
                serializedName: "properties.inputs",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputs: {
                serializedName: "properties.outputs",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, trackedProperties: {
                serializedName: "properties.trackedProperties",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, retryHistory: {
                serializedName: "properties.retryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory"
                        }
                    }
                }
            }, iterationCount: {
                serializedName: "properties.iterationCount",
                type: {
                    name: "Number"
                }
            }, repetitionIndexes: {
                serializedName: "properties.repetitionIndexes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepetitionIndex"
                        }
                    }
                }
            } })
    }
};
const RequestHistory = {
    type: {
        name: "Composite",
        className: "RequestHistory",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "RequestHistoryProperties"
                }
            } })
    }
};
const IntegrationAccount = {
    type: {
        name: "Composite",
        className: "IntegrationAccount",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "IntegrationAccountSku"
                }
            }, integrationServiceEnvironment: {
                serializedName: "properties.integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            } })
    }
};
const AssemblyDefinition = {
    type: {
        name: "Composite",
        className: "AssemblyDefinition",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AssemblyProperties"
                }
            } })
    }
};
const BatchConfiguration = {
    type: {
        name: "Composite",
        className: "BatchConfiguration",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BatchConfigurationProperties"
                }
            } })
    }
};
const IntegrationAccountSchema = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSchema",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { schemaType: {
                serializedName: "properties.schemaType",
                required: true,
                type: {
                    name: "String"
                }
            }, targetNamespace: {
                serializedName: "properties.targetNamespace",
                type: {
                    name: "String"
                }
            }, documentName: {
                serializedName: "properties.documentName",
                type: {
                    name: "String"
                }
            }, fileName: {
                serializedName: "properties.fileName",
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            }, content: {
                serializedName: "properties.content",
                type: {
                    name: "String"
                }
            }, contentType: {
                serializedName: "properties.contentType",
                type: {
                    name: "String"
                }
            }, contentLink: {
                serializedName: "properties.contentLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            } })
    }
};
const IntegrationAccountMap = {
    type: {
        name: "Composite",
        className: "IntegrationAccountMap",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { mapType: {
                serializedName: "properties.mapType",
                required: true,
                type: {
                    name: "String"
                }
            }, parametersSchema: {
                serializedName: "properties.parametersSchema",
                type: {
                    name: "Composite",
                    className: "IntegrationAccountMapPropertiesParametersSchema"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, content: {
                serializedName: "properties.content",
                type: {
                    name: "String"
                }
            }, contentType: {
                serializedName: "properties.contentType",
                type: {
                    name: "String"
                }
            }, contentLink: {
                serializedName: "properties.contentLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            } })
    }
};
const IntegrationAccountPartner = {
    type: {
        name: "Composite",
        className: "IntegrationAccountPartner",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { partnerType: {
                serializedName: "properties.partnerType",
                required: true,
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            }, content: {
                serializedName: "properties.content",
                type: {
                    name: "Composite",
                    className: "PartnerContent"
                }
            } })
    }
};
const IntegrationAccountAgreement = {
    type: {
        name: "Composite",
        className: "IntegrationAccountAgreement",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            }, agreementType: {
                serializedName: "properties.agreementType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSpecified", "AS2", "X12", "Edifact"]
                }
            }, hostPartner: {
                serializedName: "properties.hostPartner",
                required: true,
                type: {
                    name: "String"
                }
            }, guestPartner: {
                serializedName: "properties.guestPartner",
                required: true,
                type: {
                    name: "String"
                }
            }, hostIdentity: {
                serializedName: "properties.hostIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            }, guestIdentity: {
                serializedName: "properties.guestIdentity",
                type: {
                    name: "Composite",
                    className: "BusinessIdentity"
                }
            }, content: {
                serializedName: "properties.content",
                type: {
                    name: "Composite",
                    className: "AgreementContent"
                }
            } })
    }
};
const IntegrationAccountCertificate = {
    type: {
        name: "Composite",
        className: "IntegrationAccountCertificate",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "any"
                }
            }, key: {
                serializedName: "properties.key",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyReference"
                }
            }, publicCertificate: {
                serializedName: "properties.publicCertificate",
                type: {
                    name: "String"
                }
            } })
    }
};
const IntegrationAccountSession = {
    type: {
        name: "Composite",
        className: "IntegrationAccountSession",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, content: {
                serializedName: "properties.content",
                type: {
                    name: "any"
                }
            } })
    }
};
const IntegrationServiceEnvironment = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentProperties"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentSku"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            } })
    }
};
const IntegrationServiceEnvironmentManagedApi = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentManagedApi",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { namePropertiesName: {
                serializedName: "properties.name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionParameters: {
                serializedName: "properties.connectionParameters",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Composite",
                    className: "ApiResourceMetadata"
                }
            }, runtimeUrls: {
                serializedName: "properties.runtimeUrls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, generalInformation: {
                serializedName: "properties.generalInformation",
                type: {
                    name: "Composite",
                    className: "ApiResourceGeneralInformation"
                }
            }, capabilities: {
                serializedName: "properties.capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, backendService: {
                serializedName: "properties.backendService",
                type: {
                    name: "Composite",
                    className: "ApiResourceBackendService"
                }
            }, policies: {
                serializedName: "properties.policies",
                type: {
                    name: "Composite",
                    className: "ApiResourcePolicies"
                }
            }, apiDefinitionUrl: {
                serializedName: "properties.apiDefinitionUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, apiDefinitions: {
                serializedName: "properties.apiDefinitions",
                type: {
                    name: "Composite",
                    className: "ApiResourceDefinitions"
                }
            }, integrationServiceEnvironment: {
                serializedName: "properties.integrationServiceEnvironment",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, category: {
                serializedName: "properties.category",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentParameters: {
                serializedName: "properties.deploymentParameters",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentManagedApiDeploymentParameters"
                }
            } })
    }
};
const ApiOperation = {
    type: {
        name: "Composite",
        className: "ApiOperation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ApiOperationPropertiesDefinition"
                }
            } })
    }
};
const ManagedApi = {
    type: {
        name: "Composite",
        className: "ManagedApi",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ApiResourceProperties"
                }
            } })
    }
};
const WorkflowTrigger = {
    type: {
        name: "Composite",
        className: "WorkflowTrigger",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, changedTime: {
                serializedName: "properties.changedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastExecutionTime: {
                serializedName: "properties.lastExecutionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, nextExecutionTime: {
                serializedName: "properties.nextExecutionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, recurrence: {
                serializedName: "properties.recurrence",
                type: {
                    name: "Composite",
                    className: "WorkflowTriggerRecurrence"
                }
            }, workflow: {
                serializedName: "properties.workflow",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            } })
    }
};
const WorkflowTriggerHistory = {
    type: {
        name: "Composite",
        className: "WorkflowTriggerHistory",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, scheduledTime: {
                serializedName: "properties.scheduledTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "Correlation"
                }
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, fired: {
                serializedName: "properties.fired",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, run: {
                serializedName: "properties.run",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            } })
    }
};
const WorkflowRun = {
    type: {
        name: "Composite",
        className: "WorkflowRun",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, waitEndTime: {
                serializedName: "properties.waitEndTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, correlationId: {
                serializedName: "properties.correlationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "Correlation"
                }
            }, workflow: {
                serializedName: "properties.workflow",
                type: {
                    name: "Composite",
                    className: "ResourceReference"
                }
            }, trigger: {
                serializedName: "properties.trigger",
                type: {
                    name: "Composite",
                    className: "WorkflowRunTrigger"
                }
            }, outputs: {
                serializedName: "properties.outputs",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "WorkflowOutputParameter" }
                    }
                }
            }, response: {
                serializedName: "properties.response",
                type: {
                    name: "Composite",
                    className: "WorkflowRunTrigger"
                }
            } })
    }
};
const WorkflowRunAction = {
    type: {
        name: "Composite",
        className: "WorkflowRunAction",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTime: {
                serializedName: "properties.endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, code: {
                serializedName: "properties.code",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, error: {
                serializedName: "properties.error",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, trackingId: {
                serializedName: "properties.trackingId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, correlation: {
                serializedName: "properties.correlation",
                type: {
                    name: "Composite",
                    className: "RunActionCorrelation"
                }
            }, inputsLink: {
                serializedName: "properties.inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputsLink: {
                serializedName: "properties.outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, trackedProperties: {
                serializedName: "properties.trackedProperties",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, retryHistory: {
                serializedName: "properties.retryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory"
                        }
                    }
                }
            } })
    }
};
const RunActionCorrelation = {
    type: {
        name: "Composite",
        className: "RunActionCorrelation",
        modelProperties: Object.assign(Object.assign({}, RunCorrelation.type.modelProperties), { actionTrackingId: {
                serializedName: "actionTrackingId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressionRoot = {
    type: {
        name: "Composite",
        className: "ExpressionRoot",
        modelProperties: Object.assign(Object.assign({}, Expression.type.modelProperties), { path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureResourceErrorInfo = {
    type: {
        name: "Composite",
        className: "AzureResourceErrorInfo",
        modelProperties: Object.assign(Object.assign({}, ErrorInfo.type.modelProperties), { message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }, details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureResourceErrorInfo"
                        }
                    }
                }
            } })
    }
};
const OperationResult = {
    type: {
        name: "Composite",
        className: "OperationResult",
        modelProperties: Object.assign(Object.assign({}, OperationResultProperties.type.modelProperties), { trackingId: {
                serializedName: "trackingId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inputs: {
                serializedName: "inputs",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, inputsLink: {
                serializedName: "inputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, outputs: {
                serializedName: "outputs",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, outputsLink: {
                serializedName: "outputsLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            }, trackedProperties: {
                serializedName: "trackedProperties",
                readOnly: true,
                type: {
                    name: "any"
                }
            }, retryHistory: {
                serializedName: "retryHistory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RetryHistory"
                        }
                    }
                }
            }, iterationCount: {
                serializedName: "iterationCount",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ArtifactContentPropertiesDefinition = {
    type: {
        name: "Composite",
        className: "ArtifactContentPropertiesDefinition",
        modelProperties: Object.assign(Object.assign({}, ArtifactProperties.type.modelProperties), { content: {
                serializedName: "content",
                type: {
                    name: "any"
                }
            }, contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            }, contentLink: {
                serializedName: "contentLink",
                type: {
                    name: "Composite",
                    className: "ContentLink"
                }
            } })
    }
};
const BatchConfigurationProperties = {
    type: {
        name: "Composite",
        className: "BatchConfigurationProperties",
        modelProperties: Object.assign(Object.assign({}, ArtifactProperties.type.modelProperties), { batchGroupName: {
                serializedName: "batchGroupName",
                required: true,
                type: {
                    name: "String"
                }
            }, releaseCriteria: {
                serializedName: "releaseCriteria",
                type: {
                    name: "Composite",
                    className: "BatchReleaseCriteria"
                }
            } })
    }
};
const IntegrationServiceEnvironmentManagedApiProperties = {
    type: {
        name: "Composite",
        className: "IntegrationServiceEnvironmentManagedApiProperties",
        modelProperties: Object.assign(Object.assign({}, ApiResourceProperties.type.modelProperties), { deploymentParameters: {
                serializedName: "deploymentParameters",
                type: {
                    name: "Composite",
                    className: "IntegrationServiceEnvironmentManagedApiDeploymentParameters"
                }
            } })
    }
};
const WorkflowRunActionRepetitionProperties = {
    type: {
        name: "Composite",
        className: "WorkflowRunActionRepetitionProperties",
        modelProperties: Object.assign(Object.assign({}, OperationResult.type.modelProperties), { repetitionIndexes: {
                serializedName: "repetitionIndexes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RepetitionIndex"
                        }
                    }
                }
            } })
    }
};
const AssemblyProperties = {
    type: {
        name: "Composite",
        className: "AssemblyProperties",
        modelProperties: Object.assign(Object.assign({}, ArtifactContentPropertiesDefinition.type.modelProperties), { assemblyName: {
                serializedName: "assemblyName",
                required: true,
                type: {
                    name: "String"
                }
            }, assemblyVersion: {
                serializedName: "assemblyVersion",
                type: {
                    name: "String"
                }
            }, assemblyCulture: {
                serializedName: "assemblyCulture",
                type: {
                    name: "String"
                }
            }, assemblyPublicKeyToken: {
                serializedName: "assemblyPublicKeyToken",
                type: {
                    name: "String"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    WorkflowListResult: WorkflowListResult,
    FlowEndpointsConfiguration: FlowEndpointsConfiguration,
    FlowEndpoints: FlowEndpoints,
    IpAddress: IpAddress,
    FlowAccessControlConfiguration: FlowAccessControlConfiguration,
    FlowAccessControlConfigurationPolicy: FlowAccessControlConfigurationPolicy,
    IpAddressRange: IpAddressRange,
    OpenAuthenticationAccessPolicies: OpenAuthenticationAccessPolicies,
    OpenAuthenticationAccessPolicy: OpenAuthenticationAccessPolicy,
    OpenAuthenticationPolicyClaim: OpenAuthenticationPolicyClaim,
    Sku: Sku,
    ResourceReference: ResourceReference,
    WorkflowParameter: WorkflowParameter,
    ManagedServiceIdentity: ManagedServiceIdentity,
    UserAssignedIdentity: UserAssignedIdentity,
    Resource: Resource,
    ErrorResponse: ErrorResponse,
    ErrorProperties: ErrorProperties,
    GenerateUpgradedDefinitionParameters: GenerateUpgradedDefinitionParameters,
    GetCallbackUrlParameters: GetCallbackUrlParameters,
    WorkflowTriggerCallbackUrl: WorkflowTriggerCallbackUrl,
    WorkflowTriggerListCallbackUrlQueries: WorkflowTriggerListCallbackUrlQueries,
    RegenerateActionParameter: RegenerateActionParameter,
    WorkflowVersionListResult: WorkflowVersionListResult,
    WorkflowTriggerListResult: WorkflowTriggerListResult,
    WorkflowTriggerRecurrence: WorkflowTriggerRecurrence,
    RecurrenceSchedule: RecurrenceSchedule,
    RecurrenceScheduleOccurrence: RecurrenceScheduleOccurrence,
    SubResource: SubResource,
    JsonSchema: JsonSchema,
    SetTriggerStateActionDefinition: SetTriggerStateActionDefinition,
    WorkflowTriggerHistoryListResult: WorkflowTriggerHistoryListResult,
    Correlation: Correlation,
    ContentLink: ContentLink,
    ContentHash: ContentHash,
    WorkflowRunListResult: WorkflowRunListResult,
    WorkflowRunTrigger: WorkflowRunTrigger,
    WorkflowRunActionListResult: WorkflowRunActionListResult,
    RunCorrelation: RunCorrelation,
    RetryHistory: RetryHistory,
    ExpressionTraces: ExpressionTraces,
    Expression: Expression,
    ErrorInfo: ErrorInfo,
    WorkflowRunActionRepetitionDefinitionCollection: WorkflowRunActionRepetitionDefinitionCollection,
    RepetitionIndex: RepetitionIndex,
    OperationResultProperties: OperationResultProperties,
    RequestHistoryListResult: RequestHistoryListResult,
    RequestHistoryProperties: RequestHistoryProperties,
    Request: Request,
    Response: Response,
    IntegrationAccountListResult: IntegrationAccountListResult,
    IntegrationAccountSku: IntegrationAccountSku,
    AssemblyCollection: AssemblyCollection,
    ArtifactProperties: ArtifactProperties,
    BatchConfigurationCollection: BatchConfigurationCollection,
    BatchReleaseCriteria: BatchReleaseCriteria,
    CallbackUrl: CallbackUrl,
    ListKeyVaultKeysDefinition: ListKeyVaultKeysDefinition,
    KeyVaultKeyCollection: KeyVaultKeyCollection,
    KeyVaultKey: KeyVaultKey,
    KeyVaultKeyAttributes: KeyVaultKeyAttributes,
    TrackingEventsDefinition: TrackingEventsDefinition,
    TrackingEvent: TrackingEvent,
    TrackingEventErrorInfo: TrackingEventErrorInfo,
    IntegrationAccountSchemaListResult: IntegrationAccountSchemaListResult,
    IntegrationAccountMapListResult: IntegrationAccountMapListResult,
    IntegrationAccountMapPropertiesParametersSchema: IntegrationAccountMapPropertiesParametersSchema,
    IntegrationAccountPartnerListResult: IntegrationAccountPartnerListResult,
    PartnerContent: PartnerContent,
    B2BPartnerContent: B2BPartnerContent,
    BusinessIdentity: BusinessIdentity,
    IntegrationAccountAgreementListResult: IntegrationAccountAgreementListResult,
    AgreementContent: AgreementContent,
    AS2AgreementContent: AS2AgreementContent,
    AS2OneWayAgreement: AS2OneWayAgreement,
    AS2ProtocolSettings: AS2ProtocolSettings,
    AS2MessageConnectionSettings: AS2MessageConnectionSettings,
    AS2AcknowledgementConnectionSettings: AS2AcknowledgementConnectionSettings,
    AS2MdnSettings: AS2MdnSettings,
    AS2SecuritySettings: AS2SecuritySettings,
    AS2ValidationSettings: AS2ValidationSettings,
    AS2EnvelopeSettings: AS2EnvelopeSettings,
    AS2ErrorSettings: AS2ErrorSettings,
    X12AgreementContent: X12AgreementContent,
    X12OneWayAgreement: X12OneWayAgreement,
    X12ProtocolSettings: X12ProtocolSettings,
    X12ValidationSettings: X12ValidationSettings,
    X12FramingSettings: X12FramingSettings,
    X12EnvelopeSettings: X12EnvelopeSettings,
    X12AcknowledgementSettings: X12AcknowledgementSettings,
    X12MessageFilter: X12MessageFilter,
    X12SecuritySettings: X12SecuritySettings,
    X12ProcessingSettings: X12ProcessingSettings,
    X12EnvelopeOverride: X12EnvelopeOverride,
    X12ValidationOverride: X12ValidationOverride,
    X12MessageIdentifier: X12MessageIdentifier,
    X12SchemaReference: X12SchemaReference,
    X12DelimiterOverrides: X12DelimiterOverrides,
    EdifactAgreementContent: EdifactAgreementContent,
    EdifactOneWayAgreement: EdifactOneWayAgreement,
    EdifactProtocolSettings: EdifactProtocolSettings,
    EdifactValidationSettings: EdifactValidationSettings,
    EdifactFramingSettings: EdifactFramingSettings,
    EdifactEnvelopeSettings: EdifactEnvelopeSettings,
    EdifactAcknowledgementSettings: EdifactAcknowledgementSettings,
    EdifactMessageFilter: EdifactMessageFilter,
    EdifactProcessingSettings: EdifactProcessingSettings,
    EdifactEnvelopeOverride: EdifactEnvelopeOverride,
    EdifactMessageIdentifier: EdifactMessageIdentifier,
    EdifactSchemaReference: EdifactSchemaReference,
    EdifactValidationOverride: EdifactValidationOverride,
    EdifactDelimiterOverride: EdifactDelimiterOverride,
    IntegrationAccountCertificateListResult: IntegrationAccountCertificateListResult,
    KeyVaultKeyReference: KeyVaultKeyReference,
    KeyVaultKeyReferenceKeyVault: KeyVaultKeyReferenceKeyVault,
    IntegrationAccountSessionListResult: IntegrationAccountSessionListResult,
    IntegrationServiceEnvironmentListResult: IntegrationServiceEnvironmentListResult,
    IntegrationServiceEnvironmentProperties: IntegrationServiceEnvironmentProperties,
    NetworkConfiguration: NetworkConfiguration,
    IntegrationServiceEnvironmentAccessEndpoint: IntegrationServiceEnvironmentAccessEndpoint,
    IntegrationServiceEnvironmenEncryptionConfiguration: IntegrationServiceEnvironmenEncryptionConfiguration,
    IntegrationServiceEnvironmenEncryptionKeyReference: IntegrationServiceEnvironmenEncryptionKeyReference,
    IntegrationServiceEnvironmentSku: IntegrationServiceEnvironmentSku,
    IntegrationServiceEnvironmentSkuList: IntegrationServiceEnvironmentSkuList,
    IntegrationServiceEnvironmentSkuDefinition: IntegrationServiceEnvironmentSkuDefinition,
    IntegrationServiceEnvironmentSkuDefinitionSku: IntegrationServiceEnvironmentSkuDefinitionSku,
    IntegrationServiceEnvironmentSkuCapacity: IntegrationServiceEnvironmentSkuCapacity,
    IntegrationServiceEnvironmentSubnetNetworkHealth: IntegrationServiceEnvironmentSubnetNetworkHealth,
    IntegrationServiceEnvironmentNetworkDependency: IntegrationServiceEnvironmentNetworkDependency,
    IntegrationServiceEnvironmentNetworkEndpoint: IntegrationServiceEnvironmentNetworkEndpoint,
    IntegrationServiceEnvironmentNetworkDependencyHealth: IntegrationServiceEnvironmentNetworkDependencyHealth,
    ExtendedErrorInfo: ExtendedErrorInfo,
    IntegrationServiceEnvironmentManagedApiListResult: IntegrationServiceEnvironmentManagedApiListResult,
    IntegrationServiceEnvironmentManagedApiDeploymentParameters: IntegrationServiceEnvironmentManagedApiDeploymentParameters,
    ApiResourceProperties: ApiResourceProperties,
    ApiResourceMetadata: ApiResourceMetadata,
    WsdlService: WsdlService,
    ApiDeploymentParameterMetadataSet: ApiDeploymentParameterMetadataSet,
    ApiDeploymentParameterMetadata: ApiDeploymentParameterMetadata,
    ApiResourceGeneralInformation: ApiResourceGeneralInformation,
    ApiResourceBackendService: ApiResourceBackendService,
    ApiResourcePolicies: ApiResourcePolicies,
    ApiResourceDefinitions: ApiResourceDefinitions,
    ApiOperationListResult: ApiOperationListResult,
    ApiOperationPropertiesDefinition: ApiOperationPropertiesDefinition,
    ApiOperationAnnotation: ApiOperationAnnotation,
    SwaggerSchema: SwaggerSchema,
    SwaggerXml: SwaggerXml,
    SwaggerExternalDocumentation: SwaggerExternalDocumentation,
    SwaggerCustomDynamicSchema: SwaggerCustomDynamicSchema,
    SwaggerCustomDynamicProperties: SwaggerCustomDynamicProperties,
    SwaggerCustomDynamicList: SwaggerCustomDynamicList,
    SwaggerCustomDynamicTree: SwaggerCustomDynamicTree,
    SwaggerCustomDynamicTreeSettings: SwaggerCustomDynamicTreeSettings,
    SwaggerCustomDynamicTreeCommand: SwaggerCustomDynamicTreeCommand,
    SwaggerCustomDynamicTreeParameter: SwaggerCustomDynamicTreeParameter,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    WorkflowFilter: WorkflowFilter,
    WorkflowTriggerFilter: WorkflowTriggerFilter,
    WorkflowTriggerHistoryFilter: WorkflowTriggerHistoryFilter,
    WorkflowRunFilter: WorkflowRunFilter,
    WorkflowRunActionFilter: WorkflowRunActionFilter,
    ManagedApiListResult: ManagedApiListResult,
    IntegrationAccountSchemaFilter: IntegrationAccountSchemaFilter,
    IntegrationAccountMapFilter: IntegrationAccountMapFilter,
    IntegrationAccountPartnerFilter: IntegrationAccountPartnerFilter,
    IntegrationAccountAgreementFilter: IntegrationAccountAgreementFilter,
    IntegrationAccountSessionFilter: IntegrationAccountSessionFilter,
    WorkflowReference: WorkflowReference,
    WorkflowTriggerReference: WorkflowTriggerReference,
    KeyVaultReference: KeyVaultReference,
    ApiReference: ApiReference,
    WorkflowOutputParameter: WorkflowOutputParameter,
    Workflow: Workflow,
    WorkflowVersion: WorkflowVersion,
    WorkflowRunActionRepetitionDefinition: WorkflowRunActionRepetitionDefinition,
    RequestHistory: RequestHistory,
    IntegrationAccount: IntegrationAccount,
    AssemblyDefinition: AssemblyDefinition,
    BatchConfiguration: BatchConfiguration,
    IntegrationAccountSchema: IntegrationAccountSchema,
    IntegrationAccountMap: IntegrationAccountMap,
    IntegrationAccountPartner: IntegrationAccountPartner,
    IntegrationAccountAgreement: IntegrationAccountAgreement,
    IntegrationAccountCertificate: IntegrationAccountCertificate,
    IntegrationAccountSession: IntegrationAccountSession,
    IntegrationServiceEnvironment: IntegrationServiceEnvironment,
    IntegrationServiceEnvironmentManagedApi: IntegrationServiceEnvironmentManagedApi,
    ApiOperation: ApiOperation,
    ManagedApi: ManagedApi,
    WorkflowTrigger: WorkflowTrigger,
    WorkflowTriggerHistory: WorkflowTriggerHistory,
    WorkflowRun: WorkflowRun,
    WorkflowRunAction: WorkflowRunAction,
    RunActionCorrelation: RunActionCorrelation,
    ExpressionRoot: ExpressionRoot,
    AzureResourceErrorInfo: AzureResourceErrorInfo,
    OperationResult: OperationResult,
    ArtifactContentPropertiesDefinition: ArtifactContentPropertiesDefinition,
    BatchConfigurationProperties: BatchConfigurationProperties,
    IntegrationServiceEnvironmentManagedApiProperties: IntegrationServiceEnvironmentManagedApiProperties,
    WorkflowRunActionRepetitionProperties: WorkflowRunActionRepetitionProperties,
    AssemblyProperties: AssemblyProperties
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workflowName = {
    parameterPath: "workflowName",
    mapper: {
        serializedName: "workflowName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const workflow = {
    parameterPath: "workflow",
    mapper: Workflow
};
const parameters = {
    parameterPath: "parameters",
    mapper: GenerateUpgradedDefinitionParameters
};
const listCallbackUrl = {
    parameterPath: "listCallbackUrl",
    mapper: GetCallbackUrlParameters
};
const move = {
    parameterPath: "move",
    mapper: WorkflowReference
};
const keyType = {
    parameterPath: "keyType",
    mapper: RegenerateActionParameter
};
const validate = {
    parameterPath: "validate",
    mapper: Workflow
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const versionId = {
    parameterPath: "versionId",
    mapper: {
        serializedName: "versionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const triggerName = {
    parameterPath: "triggerName",
    mapper: {
        serializedName: "triggerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const setState = {
    parameterPath: "setState",
    mapper: SetTriggerStateActionDefinition
};
const parameters1 = {
    parameterPath: ["options", "parameters"],
    mapper: GetCallbackUrlParameters
};
const historyName = {
    parameterPath: "historyName",
    mapper: {
        serializedName: "historyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const runName = {
    parameterPath: "runName",
    mapper: {
        serializedName: "runName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const actionName = {
    parameterPath: "actionName",
    mapper: {
        serializedName: "actionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const repetitionName = {
    parameterPath: "repetitionName",
    mapper: {
        serializedName: "repetitionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const requestHistoryName = {
    parameterPath: "requestHistoryName",
    mapper: {
        serializedName: "requestHistoryName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const integrationAccountName = {
    parameterPath: "integrationAccountName",
    mapper: {
        serializedName: "integrationAccountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const integrationAccount = {
    parameterPath: "integrationAccount",
    mapper: IntegrationAccount
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: GetCallbackUrlParameters
};
const listKeyVaultKeys = {
    parameterPath: "listKeyVaultKeys",
    mapper: ListKeyVaultKeysDefinition
};
const logTrackingEvents = {
    parameterPath: "logTrackingEvents",
    mapper: TrackingEventsDefinition
};
const regenerateAccessKey = {
    parameterPath: "regenerateAccessKey",
    mapper: RegenerateActionParameter
};
const assemblyArtifactName = {
    parameterPath: "assemblyArtifactName",
    mapper: {
        serializedName: "assemblyArtifactName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const assemblyArtifact = {
    parameterPath: "assemblyArtifact",
    mapper: AssemblyDefinition
};
const batchConfigurationName = {
    parameterPath: "batchConfigurationName",
    mapper: {
        serializedName: "batchConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const batchConfiguration = {
    parameterPath: "batchConfiguration",
    mapper: BatchConfiguration
};
const schemaName = {
    parameterPath: "schemaName",
    mapper: {
        serializedName: "schemaName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const schema = {
    parameterPath: "schema",
    mapper: IntegrationAccountSchema
};
const listContentCallbackUrl = {
    parameterPath: "listContentCallbackUrl",
    mapper: GetCallbackUrlParameters
};
const mapName = {
    parameterPath: "mapName",
    mapper: {
        serializedName: "mapName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const map = {
    parameterPath: "map",
    mapper: IntegrationAccountMap
};
const partnerName = {
    parameterPath: "partnerName",
    mapper: {
        serializedName: "partnerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const partner = {
    parameterPath: "partner",
    mapper: IntegrationAccountPartner
};
const agreementName = {
    parameterPath: "agreementName",
    mapper: {
        serializedName: "agreementName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const agreement = {
    parameterPath: "agreement",
    mapper: IntegrationAccountAgreement
};
const certificateName = {
    parameterPath: "certificateName",
    mapper: {
        serializedName: "certificateName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const certificate = {
    parameterPath: "certificate",
    mapper: IntegrationAccountCertificate
};
const sessionName = {
    parameterPath: "sessionName",
    mapper: {
        serializedName: "sessionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const session = {
    parameterPath: "session",
    mapper: IntegrationAccountSession
};
const resourceGroup = {
    parameterPath: "resourceGroup",
    mapper: {
        serializedName: "resourceGroup",
        required: true,
        type: {
            name: "String"
        }
    }
};
const integrationServiceEnvironmentName = {
    parameterPath: "integrationServiceEnvironmentName",
    mapper: {
        serializedName: "integrationServiceEnvironmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const integrationServiceEnvironment = {
    parameterPath: "integrationServiceEnvironment",
    mapper: IntegrationServiceEnvironment
};
const apiName = {
    parameterPath: "apiName",
    mapper: {
        serializedName: "apiName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const integrationServiceEnvironmentManagedApi = {
    parameterPath: "integrationServiceEnvironmentManagedApi",
    mapper: IntegrationServiceEnvironmentManagedApi
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Workflows operations. */
class WorkflowsImpl {
    /**
     * Initialize a new instance of the class Workflows class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflows by subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflows by resource group.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of workflows by subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * Gets a list of workflows by resource group.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Gets a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, getOperationSpec$m);
    }
    /**
     * Creates or updates a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param workflow The workflow.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workflowName, workflow, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, workflow, options }, createOrUpdateOperationSpec$a);
    }
    /**
     * Updates a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    update(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, updateOperationSpec$2);
    }
    /**
     * Deletes a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, deleteOperationSpec$b);
    }
    /**
     * Disables a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    disable(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, disableOperationSpec);
    }
    /**
     * Enables a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    enable(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, enableOperationSpec);
    }
    /**
     * Generates the upgraded definition for a workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param parameters Parameters for generating an upgraded definition.
     * @param options The options parameters.
     */
    generateUpgradedDefinition(resourceGroupName, workflowName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, parameters, options }, generateUpgradedDefinitionOperationSpec);
    }
    /**
     * Get the workflow callback Url.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param listCallbackUrl Which callback url to list.
     * @param options The options parameters.
     */
    listCallbackUrl(resourceGroupName, workflowName, listCallbackUrl, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, listCallbackUrl, options }, listCallbackUrlOperationSpec$3);
    }
    /**
     * Gets an OpenAPI definition for the workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    listSwagger(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, listSwaggerOperationSpec);
    }
    /**
     * Moves an existing workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param move The workflow to move.
     * @param options The options parameters.
     */
    beginMove(resourceGroupName, workflowName, move, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workflowName, move, options }, moveOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Moves an existing workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param move The workflow to move.
     * @param options The options parameters.
     */
    beginMoveAndWait(resourceGroupName, workflowName, move, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMove(resourceGroupName, workflowName, move, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Regenerates the callback URL access key for request triggers.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param keyType The access key type.
     * @param options The options parameters.
     */
    regenerateAccessKey(resourceGroupName, workflowName, keyType, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, keyType, options }, regenerateAccessKeyOperationSpec$1);
    }
    /**
     * Validates the workflow.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param validate The workflow.
     * @param options The options parameters.
     */
    validateByResourceGroup(resourceGroupName, workflowName, validate, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, validate, options }, validateByResourceGroupOperationSpec);
    }
    /**
     * Validates the workflow definition.
     * @param resourceGroupName The resource group name.
     * @param location The workflow location.
     * @param workflowName The workflow name.
     * @param validate The workflow.
     * @param options The options parameters.
     */
    validateByLocation(resourceGroupName, location, workflowName, validate, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, workflowName, validate, options }, validateByLocationOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Logic/workflows",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Workflow
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Workflow
        },
        201: {
            bodyMapper: Workflow
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workflow,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Workflow
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const disableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/disable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const enableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/enable",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const generateUpgradedDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/generateUpgradedDefinition",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listCallbackUrlOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/listCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: listCallbackUrl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listSwaggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/listSwagger",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "any" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const moveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/move",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: move,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const regenerateAccessKeyOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/regenerateAccessKey",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: keyType,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const validateByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: validate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const validateByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/locations/{location}/workflows/{workflowName}/validate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: validate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowVersions operations. */
class WorkflowVersionsImpl {
    /**
     * Initialize a new instance of the class WorkflowVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow versions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow versions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, listOperationSpec$k);
    }
    /**
     * Gets a workflow version.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param versionId The workflow versionId.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, versionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, versionId, options }, getOperationSpec$l);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, nextLink, options }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/versions/{versionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        versionId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowTriggers operations. */
class WorkflowTriggersImpl {
    /**
     * Initialize a new instance of the class WorkflowTriggers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow triggers.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow triggers.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, listOperationSpec$j);
    }
    /**
     * Gets a workflow trigger.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, options }, getOperationSpec$k);
    }
    /**
     * Resets a workflow trigger.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    reset(resourceGroupName, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, options }, resetOperationSpec);
    }
    /**
     * Runs a workflow trigger.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    run(resourceGroupName, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, options }, runOperationSpec);
    }
    /**
     * Get the trigger schema as JSON.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    getSchemaJson(resourceGroupName, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, options }, getSchemaJsonOperationSpec);
    }
    /**
     * Sets the state of a workflow trigger.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param setState The workflow trigger state.
     * @param options The options parameters.
     */
    setState(resourceGroupName, workflowName, triggerName, setState, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, setState, options }, setStateOperationSpec);
    }
    /**
     * Get the callback URL for a workflow trigger.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    listCallbackUrl(resourceGroupName, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, options }, listCallbackUrlOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, nextLink, options }, listNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTrigger
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const resetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/reset",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const runOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/run",
    httpMethod: "POST",
    responses: {
        200: {},
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const getSchemaJsonOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/schemas/json",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JsonSchema
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const setStateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/setState",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: setState,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const listCallbackUrlOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/listCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WorkflowVersionTriggers operations. */
class WorkflowVersionTriggersImpl {
    /**
     * Initialize a new instance of the class WorkflowVersionTriggers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the callback url for a trigger of a workflow version.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param versionId The workflow versionId.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    listCallbackUrl(resourceGroupName, workflowName, versionId, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, versionId, triggerName, options }, listCallbackUrlOperationSpec$1);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listCallbackUrlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/versions/{versionId}/triggers/{triggerName}/listCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        versionId,
        triggerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowTriggerHistories operations. */
class WorkflowTriggerHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowTriggerHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow trigger histories.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, triggerName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, triggerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, triggerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, triggerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, triggerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, triggerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, triggerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, triggerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow trigger histories.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, triggerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, options }, listOperationSpec$i);
    }
    /**
     * Gets a workflow trigger history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, triggerName, historyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, historyName, options }, getOperationSpec$j);
    }
    /**
     * Resubmits a workflow run based on the trigger history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param historyName The workflow trigger history name. Corresponds to the run name for triggers that
     *                    resulted in a run.
     * @param options The options parameters.
     */
    resubmit(resourceGroupName, workflowName, triggerName, historyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, historyName, options }, resubmitOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param triggerName The workflow trigger name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, triggerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, triggerName, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/histories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/histories/{historyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistory
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName,
        historyName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const resubmitOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/triggers/{triggerName}/histories/{historyName}/resubmit",
    httpMethod: "POST",
    responses: {
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        triggerName,
        historyName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRuns operations. */
class WorkflowRunsImpl {
    /**
     * Initialize a new instance of the class WorkflowRuns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow runs.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of workflow runs.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, options }, listOperationSpec$h);
    }
    /**
     * Gets a workflow run.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, options }, getOperationSpec$i);
    }
    /**
     * Cancels a workflow run.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    cancel(resourceGroupName, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, options }, cancelOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, nextLink, options }, listNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActions operations. */
class WorkflowRunActionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of workflow run actions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, runName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, runName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, runName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, runName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, runName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, runName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, runName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, runName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    listExpressionTraces(resourceGroupName, workflowName, runName, actionName, options) {
        const iter = this.listExpressionTracesPagingAll(resourceGroupName, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listExpressionTracesPagingPage(resourceGroupName, workflowName, runName, actionName, options, settings);
            }
        };
    }
    listExpressionTracesPagingPage(resourceGroupName, workflowName, runName, actionName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listExpressionTraces(resourceGroupName, workflowName, runName, actionName, options));
            yield yield tslib.__await(result.inputs || []);
        });
    }
    listExpressionTracesPagingAll(resourceGroupName, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listExpressionTracesPagingPage(resourceGroupName, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of workflow run actions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, runName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, options }, listOperationSpec$g);
    }
    /**
     * Gets a workflow run action.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, actionName, options }, getOperationSpec$h);
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _listExpressionTraces(resourceGroupName, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, actionName, options }, listExpressionTracesOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, runName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, nextLink, options }, listNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunAction
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listExpressionTracesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/listExpressionTraces",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressionTraces
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink,
        runName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRepetitions operations. */
class WorkflowRunActionRepetitionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRepetitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all of a workflow run action repetitions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, runName, actionName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, runName, actionName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, workflowName, runName, actionName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    listExpressionTraces(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        const iter = this.listExpressionTracesPagingAll(resourceGroupName, workflowName, runName, actionName, repetitionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listExpressionTracesPagingPage(resourceGroupName, workflowName, runName, actionName, repetitionName, options, settings);
            }
        };
    }
    listExpressionTracesPagingPage(resourceGroupName, workflowName, runName, actionName, repetitionName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listExpressionTraces(resourceGroupName, workflowName, runName, actionName, repetitionName, options));
            yield yield tslib.__await(result.inputs || []);
        });
    }
    listExpressionTracesPagingAll(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listExpressionTracesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listExpressionTracesPagingPage(resourceGroupName, workflowName, runName, actionName, repetitionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all of a workflow run action repetitions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, actionName, options }, listOperationSpec$f);
    }
    /**
     * Get a workflow run action repetition.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, getOperationSpec$g);
    }
    /**
     * Lists a workflow run expression trace.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    _listExpressionTraces(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, listExpressionTracesOperationSpec);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listExpressionTracesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/listExpressionTraces",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressionTraces
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRepetitionsRequestHistories operations. */
class WorkflowRunActionRepetitionsRequestHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRepetitionsRequestHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List a workflow run repetition request history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, runName, actionName, repetitionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, runName, actionName, repetitionName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, runName, actionName, repetitionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, runName, actionName, repetitionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, runName, actionName, repetitionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, runName, actionName, repetitionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List a workflow run repetition request history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, listOperationSpec$e);
    }
    /**
     * Gets a workflow run repetition request history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param requestHistoryName The request history name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, actionName, repetitionName, requestHistoryName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            repetitionName,
            requestHistoryName,
            options
        }, getOperationSpec$f);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, runName, actionName, repetitionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            repetitionName,
            nextLink,
            options
        }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/requestHistories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/repetitions/{repetitionName}/requestHistories/{requestHistoryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistory
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName,
        repetitionName,
        requestHistoryName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionRequestHistories operations. */
class WorkflowRunActionRequestHistoriesImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionRequestHistories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List a workflow run request history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, runName, actionName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, runName, actionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workflowName, runName, actionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workflowName, runName, actionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List a workflow run request history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, actionName, options }, listOperationSpec$d);
    }
    /**
     * Gets a workflow run request history.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param requestHistoryName The request history name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, actionName, requestHistoryName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            requestHistoryName,
            options
        }, getOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workflowName, runName, actionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            nextLink,
            options
        }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/requestHistories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/requestHistories/{requestHistoryName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistory
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName,
        requestHistoryName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RequestHistoryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        nextLink,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkflowRunActionScopeRepetitions operations. */
class WorkflowRunActionScopeRepetitionsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunActionScopeRepetitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the workflow run action scoped repetitions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workflowName, runName, actionName, options) {
        const iter = this.listPagingAll(resourceGroupName, workflowName, runName, actionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workflowName, runName, actionName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workflowName, runName, actionName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, workflowName, runName, actionName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, workflowName, runName, actionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workflowName, runName, actionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the workflow run action scoped repetitions.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workflowName, runName, actionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, actionName, options }, listOperationSpec$c);
    }
    /**
     * Get a workflow run action scoped repetition.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param actionName The workflow action name.
     * @param repetitionName The workflow repetition.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, actionName, repetitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workflowName,
            runName,
            actionName,
            repetitionName,
            options
        }, getOperationSpec$d);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/scopeRepetitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinitionCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/actions/{actionName}/scopeRepetitions/{repetitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRunActionRepetitionDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        actionName,
        repetitionName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing WorkflowRunOperations operations. */
class WorkflowRunOperationsImpl {
    /**
     * Initialize a new instance of the class WorkflowRunOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets an operation for a run.
     * @param resourceGroupName The resource group name.
     * @param workflowName The workflow name.
     * @param runName The workflow run name.
     * @param operationId The workflow operation id.
     * @param options The options parameters.
     */
    get(resourceGroupName, workflowName, runName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workflowName, runName, operationId, options }, getOperationSpec$c);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/workflows/{workflowName}/runs/{runName}/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkflowRun
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workflowName,
        runName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccounts operations. */
class IntegrationAccountsImpl {
    /**
     * Initialize a new instance of the class IntegrationAccounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration accounts by subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration accounts by resource group.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the integration account's Key Vault keys.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param listKeyVaultKeys The key vault parameters.
     * @param options The options parameters.
     */
    listKeyVaultKeys(resourceGroupName, integrationAccountName, listKeyVaultKeys, options) {
        const iter = this.listKeyVaultKeysPagingAll(resourceGroupName, integrationAccountName, listKeyVaultKeys, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listKeyVaultKeysPagingPage(resourceGroupName, integrationAccountName, listKeyVaultKeys, options, settings);
            }
        };
    }
    listKeyVaultKeysPagingPage(resourceGroupName, integrationAccountName, listKeyVaultKeys, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listKeyVaultKeysPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listKeyVaultKeys(resourceGroupName, integrationAccountName, listKeyVaultKeys, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listKeyVaultKeysPagingAll(resourceGroupName, integrationAccountName, listKeyVaultKeys, options) {
        return tslib.__asyncGenerator(this, arguments, function* listKeyVaultKeysPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listKeyVaultKeysPagingPage(resourceGroupName, integrationAccountName, listKeyVaultKeys, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets a list of integration accounts by subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Gets a list of integration accounts by resource group.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Gets an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, getOperationSpec$b);
    }
    /**
     * Creates or updates an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param integrationAccount The integration account.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, integrationAccount, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            integrationAccount,
            options
        }, createOrUpdateOperationSpec$9);
    }
    /**
     * Updates an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param integrationAccount The integration account.
     * @param options The options parameters.
     */
    update(resourceGroupName, integrationAccountName, integrationAccount, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            integrationAccount,
            options
        }, updateOperationSpec$1);
    }
    /**
     * Deletes an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, deleteOperationSpec$a);
    }
    /**
     * Gets the integration account callback URL.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param parameters The callback URL parameters.
     * @param options The options parameters.
     */
    listCallbackUrl(resourceGroupName, integrationAccountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, parameters, options }, listCallbackUrlOperationSpec);
    }
    /**
     * Gets the integration account's Key Vault keys.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param listKeyVaultKeys The key vault parameters.
     * @param options The options parameters.
     */
    _listKeyVaultKeys(resourceGroupName, integrationAccountName, listKeyVaultKeys, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, listKeyVaultKeys, options }, listKeyVaultKeysOperationSpec);
    }
    /**
     * Logs the integration account's tracking events.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param logTrackingEvents The callback URL parameters.
     * @param options The options parameters.
     */
    logTrackingEvents(resourceGroupName, integrationAccountName, logTrackingEvents, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, logTrackingEvents, options }, logTrackingEventsOperationSpec);
    }
    /**
     * Regenerates the integration account access key.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param regenerateAccessKey The access key type.
     * @param options The options parameters.
     */
    regenerateAccessKey(resourceGroupName, integrationAccountName, regenerateAccessKey, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            regenerateAccessKey,
            options
        }, regenerateAccessKeyOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Logic/integrationAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccount
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccount
        },
        201: {
            bodyMapper: IntegrationAccount
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: integrationAccount,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IntegrationAccount
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: integrationAccount,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listCallbackUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/listCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const listKeyVaultKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/listKeyVaultKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: KeyVaultKeyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: listKeyVaultKeys,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const logTrackingEventsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/logTrackingEvents",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: logTrackingEvents,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const regenerateAccessKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/regenerateAccessKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IntegrationAccount
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: regenerateAccessKey,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountAssemblies operations. */
class IntegrationAccountAssembliesImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountAssemblies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the assemblies for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the assemblies for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$b);
    }
    /**
     * Get an assembly for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param assemblyArtifactName The assembly artifact name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, assemblyArtifactName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            assemblyArtifactName,
            options
        }, getOperationSpec$a);
    }
    /**
     * Create or update an assembly for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param assemblyArtifactName The assembly artifact name.
     * @param assemblyArtifact The assembly artifact.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, assemblyArtifactName, assemblyArtifact, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            assemblyArtifactName,
            assemblyArtifact,
            options
        }, createOrUpdateOperationSpec$8);
    }
    /**
     * Delete an assembly for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param assemblyArtifactName The assembly artifact name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, assemblyArtifactName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            assemblyArtifactName,
            options
        }, deleteOperationSpec$9);
    }
    /**
     * Get the content callback url for an integration account assembly.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param assemblyArtifactName The assembly artifact name.
     * @param options The options parameters.
     */
    listContentCallbackUrl(resourceGroupName, integrationAccountName, assemblyArtifactName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            assemblyArtifactName,
            options
        }, listContentCallbackUrlOperationSpec$4);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/assemblies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AssemblyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/assemblies/{assemblyArtifactName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AssemblyDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        assemblyArtifactName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/assemblies/{assemblyArtifactName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AssemblyDefinition
        },
        201: {
            bodyMapper: AssemblyDefinition
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: assemblyArtifact,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        assemblyArtifactName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/assemblies/{assemblyArtifactName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        assemblyArtifactName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listContentCallbackUrlOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/assemblies/{assemblyArtifactName}/listContentCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        assemblyArtifactName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountBatchConfigurations operations. */
class IntegrationAccountBatchConfigurationsImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountBatchConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the batch configurations for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the batch configurations for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$a);
    }
    /**
     * Get a batch configuration for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param batchConfigurationName The batch configuration name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, batchConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            batchConfigurationName,
            options
        }, getOperationSpec$9);
    }
    /**
     * Create or update a batch configuration for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param batchConfigurationName The batch configuration name.
     * @param batchConfiguration The batch configuration.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, batchConfigurationName, batchConfiguration, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            batchConfigurationName,
            batchConfiguration,
            options
        }, createOrUpdateOperationSpec$7);
    }
    /**
     * Delete a batch configuration for an integration account.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param batchConfigurationName The batch configuration name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, batchConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            batchConfigurationName,
            options
        }, deleteOperationSpec$8);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/batchConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchConfigurationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/batchConfigurations/{batchConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchConfiguration
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        batchConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/batchConfigurations/{batchConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BatchConfiguration
        },
        201: {
            bodyMapper: BatchConfiguration
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: batchConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        batchConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/batchConfigurations/{batchConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        batchConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountSchemas operations. */
class IntegrationAccountSchemasImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountSchemas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration account schemas.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, integrationAccountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration account schemas.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$9);
    }
    /**
     * Gets an integration account schema.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param schemaName The integration account schema name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, schemaName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, schemaName, options }, getOperationSpec$8);
    }
    /**
     * Creates or updates an integration account schema.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param schemaName The integration account schema name.
     * @param schema The integration account schema.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, schemaName, schema, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            schemaName,
            schema,
            options
        }, createOrUpdateOperationSpec$6);
    }
    /**
     * Deletes an integration account schema.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param schemaName The integration account schema name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, schemaName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, schemaName, options }, deleteOperationSpec$7);
    }
    /**
     * Get the content callback url.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param schemaName The integration account schema name.
     * @param listContentCallbackUrl The callback url parameters.
     * @param options The options parameters.
     */
    listContentCallbackUrl(resourceGroupName, integrationAccountName, schemaName, listContentCallbackUrl, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            schemaName,
            listContentCallbackUrl,
            options
        }, listContentCallbackUrlOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, integrationAccountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, nextLink, options }, listNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/schemas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSchemaListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/schemas/{schemaName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSchema
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/schemas/{schemaName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSchema
        },
        201: {
            bodyMapper: IntegrationAccountSchema
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: schema,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        schemaName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/schemas/{schemaName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        schemaName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listContentCallbackUrlOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/schemas/{schemaName}/listContentCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: listContentCallbackUrl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        schemaName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSchemaListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountMaps operations. */
class IntegrationAccountMapsImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountMaps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration account maps.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, integrationAccountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration account maps.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$8);
    }
    /**
     * Gets an integration account map.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param mapName The integration account map name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, mapName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, mapName, options }, getOperationSpec$7);
    }
    /**
     * Creates or updates an integration account map. If the map is larger than 4 MB, you need to store the
     * map in an Azure blob and use the blob's Shared Access Signature (SAS) URL as the 'contentLink'
     * property value.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param mapName The integration account map name.
     * @param map The integration account map.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, mapName, map, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, mapName, map, options }, createOrUpdateOperationSpec$5);
    }
    /**
     * Deletes an integration account map.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param mapName The integration account map name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, mapName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, mapName, options }, deleteOperationSpec$6);
    }
    /**
     * Get the content callback url.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param mapName The integration account map name.
     * @param listContentCallbackUrl The callback url parameters.
     * @param options The options parameters.
     */
    listContentCallbackUrl(resourceGroupName, integrationAccountName, mapName, listContentCallbackUrl, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            mapName,
            listContentCallbackUrl,
            options
        }, listContentCallbackUrlOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, integrationAccountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/maps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountMapListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/maps/{mapName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountMap
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        mapName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/maps/{mapName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccountMap
        },
        201: {
            bodyMapper: IntegrationAccountMap
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: map,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        mapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/maps/{mapName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        mapName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listContentCallbackUrlOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/maps/{mapName}/listContentCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: listContentCallbackUrl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        mapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountMapListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountPartners operations. */
class IntegrationAccountPartnersImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountPartners class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration account partners.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, integrationAccountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration account partners.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$7);
    }
    /**
     * Gets an integration account partner.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param partnerName The integration account partner name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, partnerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, partnerName, options }, getOperationSpec$6);
    }
    /**
     * Creates or updates an integration account partner.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param partnerName The integration account partner name.
     * @param partner The integration account partner.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, partnerName, partner, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            partnerName,
            partner,
            options
        }, createOrUpdateOperationSpec$4);
    }
    /**
     * Deletes an integration account partner.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param partnerName The integration account partner name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, partnerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, partnerName, options }, deleteOperationSpec$5);
    }
    /**
     * Get the content callback url.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param partnerName The integration account partner name.
     * @param listContentCallbackUrl The callback url parameters.
     * @param options The options parameters.
     */
    listContentCallbackUrl(resourceGroupName, integrationAccountName, partnerName, listContentCallbackUrl, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            partnerName,
            listContentCallbackUrl,
            options
        }, listContentCallbackUrlOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, integrationAccountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/partners",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountPartnerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/partners/{partnerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountPartner
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        partnerName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/partners/{partnerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccountPartner
        },
        201: {
            bodyMapper: IntegrationAccountPartner
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: partner,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        partnerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/partners/{partnerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        partnerName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listContentCallbackUrlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/partners/{partnerName}/listContentCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: listContentCallbackUrl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        partnerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountPartnerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountAgreements operations. */
class IntegrationAccountAgreementsImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountAgreements class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration account agreements.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, integrationAccountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration account agreements.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$6);
    }
    /**
     * Gets an integration account agreement.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param agreementName The integration account agreement name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, agreementName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, agreementName, options }, getOperationSpec$5);
    }
    /**
     * Creates or updates an integration account agreement.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param agreementName The integration account agreement name.
     * @param agreement The integration account agreement.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, agreementName, agreement, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            agreementName,
            agreement,
            options
        }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes an integration account agreement.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param agreementName The integration account agreement name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, agreementName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, agreementName, options }, deleteOperationSpec$4);
    }
    /**
     * Get the content callback url.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param agreementName The integration account agreement name.
     * @param listContentCallbackUrl The callback url parameters.
     * @param options The options parameters.
     */
    listContentCallbackUrl(resourceGroupName, integrationAccountName, agreementName, listContentCallbackUrl, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            agreementName,
            listContentCallbackUrl,
            options
        }, listContentCallbackUrlOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, integrationAccountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountAgreementListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountAgreement
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        agreementName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccountAgreement
        },
        201: {
            bodyMapper: IntegrationAccountAgreement
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: agreement,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        agreementName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        agreementName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listContentCallbackUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/agreements/{agreementName}/listContentCallbackUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: WorkflowTriggerCallbackUrl
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: listContentCallbackUrl,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        agreementName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountAgreementListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountCertificates operations. */
class IntegrationAccountCertificatesImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountCertificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration account certificates.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, integrationAccountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration account certificates.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$5);
    }
    /**
     * Gets an integration account certificate.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param certificateName The integration account certificate name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, certificateName, options }, getOperationSpec$4);
    }
    /**
     * Creates or updates an integration account certificate.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param certificateName The integration account certificate name.
     * @param certificate The integration account certificate.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, certificateName, certificate, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            certificateName,
            certificate,
            options
        }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes an integration account certificate.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param certificateName The integration account certificate name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, certificateName, options }, deleteOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, integrationAccountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountCertificateListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/certificates/{certificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountCertificate
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/certificates/{certificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccountCertificate
        },
        201: {
            bodyMapper: IntegrationAccountCertificate
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: certificate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        certificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/certificates/{certificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountCertificateListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationAccountSessions operations. */
class IntegrationAccountSessionsImpl {
    /**
     * Initialize a new instance of the class IntegrationAccountSessions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration account sessions.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, integrationAccountName, options) {
        const iter = this.listPagingAll(resourceGroupName, integrationAccountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, integrationAccountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, integrationAccountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, integrationAccountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, integrationAccountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, integrationAccountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, integrationAccountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration account sessions.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, integrationAccountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, options }, listOperationSpec$4);
    }
    /**
     * Gets an integration account session.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param sessionName The integration account session name.
     * @param options The options parameters.
     */
    get(resourceGroupName, integrationAccountName, sessionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, sessionName, options }, getOperationSpec$3);
    }
    /**
     * Creates or updates an integration account session.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param sessionName The integration account session name.
     * @param session The integration account session.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, integrationAccountName, sessionName, session, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            integrationAccountName,
            sessionName,
            session,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes an integration account session.
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param sessionName The integration account session name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, integrationAccountName, sessionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, sessionName, options }, deleteOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name.
     * @param integrationAccountName The integration account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, integrationAccountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, integrationAccountName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/sessions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSessionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/sessions/{sessionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSession
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        sessionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/sessions/{sessionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSession
        },
        201: {
            bodyMapper: IntegrationAccountSession
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: session,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        sessionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Logic/integrationAccounts/{integrationAccountName}/sessions/{sessionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        integrationAccountName,
        sessionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationAccountSessionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        integrationAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationServiceEnvironments operations. */
class IntegrationServiceEnvironmentsImpl {
    /**
     * Initialize a new instance of the class IntegrationServiceEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration service environments by subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration service environments by resource group.
     * @param resourceGroup The resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroup, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroup, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroup, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroup, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroup, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroup, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroup, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroup, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of integration service environments by subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Gets a list of integration service environments by resource group.
     * @param resourceGroup The resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroup, options) {
        return this.client.sendOperationRequest({ resourceGroup, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    get(resourceGroup, integrationServiceEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, options }, getOperationSpec$2);
    }
    /**
     * Creates or updates an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param integrationServiceEnvironment The integration service environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroup, integrationServiceEnvironmentName, integrationServiceEnvironment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroup,
                integrationServiceEnvironmentName,
                integrationServiceEnvironment,
                options
            }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param integrationServiceEnvironment The integration service environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroup, integrationServiceEnvironmentName, integrationServiceEnvironment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroup, integrationServiceEnvironmentName, integrationServiceEnvironment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param integrationServiceEnvironment The integration service environment.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroup, integrationServiceEnvironmentName, integrationServiceEnvironment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroup,
                integrationServiceEnvironmentName,
                integrationServiceEnvironment,
                options
            }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param integrationServiceEnvironment The integration service environment.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroup, integrationServiceEnvironmentName, integrationServiceEnvironment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroup, integrationServiceEnvironmentName, integrationServiceEnvironment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    delete(resourceGroup, integrationServiceEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, options }, deleteOperationSpec$1);
    }
    /**
     * Restarts an integration service environment.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    restart(resourceGroup, integrationServiceEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, options }, restartOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroup The resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroup, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroup, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Logic/integrationServiceEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironment
        },
        201: {
            bodyMapper: IntegrationServiceEnvironment
        },
        202: {
            bodyMapper: IntegrationServiceEnvironment
        },
        204: {
            bodyMapper: IntegrationServiceEnvironment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: integrationServiceEnvironment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironment
        },
        201: {
            bodyMapper: IntegrationServiceEnvironment
        },
        202: {
            bodyMapper: IntegrationServiceEnvironment
        },
        204: {
            bodyMapper: IntegrationServiceEnvironment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: integrationServiceEnvironment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroup
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationServiceEnvironmentSkus operations. */
class IntegrationServiceEnvironmentSkusImpl {
    /**
     * Initialize a new instance of the class IntegrationServiceEnvironmentSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of integration service environment Skus.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    list(resourceGroup, integrationServiceEnvironmentName, options) {
        const iter = this.listPagingAll(resourceGroup, integrationServiceEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroup, integrationServiceEnvironmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroup, integrationServiceEnvironmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroup, integrationServiceEnvironmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroup, integrationServiceEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroup, integrationServiceEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroup, integrationServiceEnvironmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of integration service environment Skus.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    _list(resourceGroup, integrationServiceEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroup, integrationServiceEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentSkuList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentSkuList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IntegrationServiceEnvironmentNetworkHealth operations. */
class IntegrationServiceEnvironmentNetworkHealthImpl {
    /**
     * Initialize a new instance of the class IntegrationServiceEnvironmentNetworkHealth class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the integration service environment network health.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    get(resourceGroup, integrationServiceEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, options }, getOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/health/network",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "IntegrationServiceEnvironmentSubnetNetworkHealth"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationServiceEnvironmentManagedApis operations. */
class IntegrationServiceEnvironmentManagedApisImpl {
    /**
     * Initialize a new instance of the class IntegrationServiceEnvironmentManagedApis class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the integration service environment managed Apis.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    list(resourceGroup, integrationServiceEnvironmentName, options) {
        const iter = this.listPagingAll(resourceGroup, integrationServiceEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroup, integrationServiceEnvironmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroup, integrationServiceEnvironmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroup, integrationServiceEnvironmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroup, integrationServiceEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroup, integrationServiceEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroup, integrationServiceEnvironmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the integration service environment managed Apis.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param options The options parameters.
     */
    _list(resourceGroup, integrationServiceEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, options }, listOperationSpec$2);
    }
    /**
     * Gets the integration service environment managed Api.
     * @param resourceGroup The resource group name.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param options The options parameters.
     */
    get(resourceGroup, integrationServiceEnvironmentName, apiName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, apiName, options }, getOperationSpec);
    }
    /**
     * Puts the integration service environment managed Api.
     * @param resourceGroup The resource group name.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param integrationServiceEnvironmentManagedApi The integration service environment managed api.
     * @param options The options parameters.
     */
    beginPut(resourceGroup, integrationServiceEnvironmentName, apiName, integrationServiceEnvironmentManagedApi, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroup,
                integrationServiceEnvironmentName,
                apiName,
                integrationServiceEnvironmentManagedApi,
                options
            }, putOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Puts the integration service environment managed Api.
     * @param resourceGroup The resource group name.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param integrationServiceEnvironmentManagedApi The integration service environment managed api.
     * @param options The options parameters.
     */
    beginPutAndWait(resourceGroup, integrationServiceEnvironmentName, apiName, integrationServiceEnvironmentManagedApi, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPut(resourceGroup, integrationServiceEnvironmentName, apiName, integrationServiceEnvironmentManagedApi, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the integration service environment managed Api.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroup, integrationServiceEnvironmentName, apiName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroup, integrationServiceEnvironmentName, apiName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the integration service environment managed Api.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroup, integrationServiceEnvironmentName, apiName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroup, integrationServiceEnvironmentName, apiName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroup, integrationServiceEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/managedApis",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentManagedApiListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/managedApis/{apiName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentManagedApi
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName,
        apiName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/managedApis/{apiName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentManagedApi
        },
        201: {
            bodyMapper: IntegrationServiceEnvironmentManagedApi
        },
        202: {
            bodyMapper: IntegrationServiceEnvironmentManagedApi
        },
        204: {
            bodyMapper: IntegrationServiceEnvironmentManagedApi
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: integrationServiceEnvironmentManagedApi,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName,
        apiName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/managedApis/{apiName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName,
        apiName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IntegrationServiceEnvironmentManagedApiListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroup,
        integrationServiceEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IntegrationServiceEnvironmentManagedApiOperations operations. */
class IntegrationServiceEnvironmentManagedApiOperationsImpl {
    /**
     * Initialize a new instance of the class IntegrationServiceEnvironmentManagedApiOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the managed Api operations.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param options The options parameters.
     */
    list(resourceGroup, integrationServiceEnvironmentName, apiName, options) {
        const iter = this.listPagingAll(resourceGroup, integrationServiceEnvironmentName, apiName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroup, integrationServiceEnvironmentName, apiName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroup, integrationServiceEnvironmentName, apiName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroup, integrationServiceEnvironmentName, apiName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroup, integrationServiceEnvironmentName, apiName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroup, integrationServiceEnvironmentName, apiName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroup, integrationServiceEnvironmentName, apiName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the managed Api operations.
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param options The options parameters.
     */
    _list(resourceGroup, integrationServiceEnvironmentName, apiName, options) {
        return this.client.sendOperationRequest({ resourceGroup, integrationServiceEnvironmentName, apiName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroup The resource group.
     * @param integrationServiceEnvironmentName The integration service environment name.
     * @param apiName The api name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroup, integrationServiceEnvironmentName, apiName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroup,
            integrationServiceEnvironmentName,
            apiName,
            nextLink,
            options
        }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Logic/integrationServiceEnvironments/{integrationServiceEnvironmentName}/managedApis/{apiName}/apiOperations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiOperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroup,
        integrationServiceEnvironmentName,
        apiName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiOperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroup,
        integrationServiceEnvironmentName,
        apiName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Logic REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Logic REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/providers/Microsoft.Logic/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LogicManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the LogicManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription id.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-logic/8.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2019-05-01";
        this.workflows = new WorkflowsImpl(this);
        this.workflowVersions = new WorkflowVersionsImpl(this);
        this.workflowTriggers = new WorkflowTriggersImpl(this);
        this.workflowVersionTriggers = new WorkflowVersionTriggersImpl(this);
        this.workflowTriggerHistories = new WorkflowTriggerHistoriesImpl(this);
        this.workflowRuns = new WorkflowRunsImpl(this);
        this.workflowRunActions = new WorkflowRunActionsImpl(this);
        this.workflowRunActionRepetitions = new WorkflowRunActionRepetitionsImpl(this);
        this.workflowRunActionRepetitionsRequestHistories = new WorkflowRunActionRepetitionsRequestHistoriesImpl(this);
        this.workflowRunActionRequestHistories = new WorkflowRunActionRequestHistoriesImpl(this);
        this.workflowRunActionScopeRepetitions = new WorkflowRunActionScopeRepetitionsImpl(this);
        this.workflowRunOperations = new WorkflowRunOperationsImpl(this);
        this.integrationAccounts = new IntegrationAccountsImpl(this);
        this.integrationAccountAssemblies = new IntegrationAccountAssembliesImpl(this);
        this.integrationAccountBatchConfigurations = new IntegrationAccountBatchConfigurationsImpl(this);
        this.integrationAccountSchemas = new IntegrationAccountSchemasImpl(this);
        this.integrationAccountMaps = new IntegrationAccountMapsImpl(this);
        this.integrationAccountPartners = new IntegrationAccountPartnersImpl(this);
        this.integrationAccountAgreements = new IntegrationAccountAgreementsImpl(this);
        this.integrationAccountCertificates = new IntegrationAccountCertificatesImpl(this);
        this.integrationAccountSessions = new IntegrationAccountSessionsImpl(this);
        this.integrationServiceEnvironments = new IntegrationServiceEnvironmentsImpl(this);
        this.integrationServiceEnvironmentSkus = new IntegrationServiceEnvironmentSkusImpl(this);
        this.integrationServiceEnvironmentNetworkHealth = new IntegrationServiceEnvironmentNetworkHealthImpl(this);
        this.integrationServiceEnvironmentManagedApis = new IntegrationServiceEnvironmentManagedApisImpl(this);
        this.integrationServiceEnvironmentManagedApiOperations = new IntegrationServiceEnvironmentManagedApiOperationsImpl(this);
        this.operations = new OperationsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.LogicManagementClient = LogicManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map

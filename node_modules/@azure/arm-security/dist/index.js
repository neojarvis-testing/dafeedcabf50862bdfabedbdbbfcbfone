'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link SupportedCloudEnum} that the service accepts. */
exports.KnownSupportedCloudEnum = void 0;
(function (KnownSupportedCloudEnum) {
    KnownSupportedCloudEnum["AWS"] = "AWS";
    KnownSupportedCloudEnum["GCP"] = "GCP";
})(exports.KnownSupportedCloudEnum || (exports.KnownSupportedCloudEnum = {}));
/** Known values of {@link SeverityEnum} that the service accepts. */
exports.KnownSeverityEnum = void 0;
(function (KnownSeverityEnum) {
    KnownSeverityEnum["High"] = "High";
    KnownSeverityEnum["Medium"] = "Medium";
    KnownSeverityEnum["Low"] = "Low";
})(exports.KnownSeverityEnum || (exports.KnownSeverityEnum = {}));
/** Known values of {@link ResourceStatus} that the service accepts. */
exports.KnownResourceStatus = void 0;
(function (KnownResourceStatus) {
    /** This assessment on the resource is healthy */
    KnownResourceStatus["Healthy"] = "Healthy";
    /** This assessment is not applicable to this resource */
    KnownResourceStatus["NotApplicable"] = "NotApplicable";
    /** This assessment is turned off by policy on this subscription */
    KnownResourceStatus["OffByPolicy"] = "OffByPolicy";
    /** This assessment on the resource is not healthy */
    KnownResourceStatus["NotHealthy"] = "NotHealthy";
})(exports.KnownResourceStatus || (exports.KnownResourceStatus = {}));
/** Known values of {@link PricingTier} that the service accepts. */
exports.KnownPricingTier = void 0;
(function (KnownPricingTier) {
    /** Get free Azure security center experience with basic security features */
    KnownPricingTier["Free"] = "Free";
    /** Get the standard Azure security center experience with advanced security features */
    KnownPricingTier["Standard"] = "Standard";
})(exports.KnownPricingTier || (exports.KnownPricingTier = {}));
/** Known values of {@link ValueType} that the service accepts. */
exports.KnownValueType = void 0;
(function (KnownValueType) {
    /** An IP range in CIDR format (e.g. '192.168.0.1/8'). */
    KnownValueType["IpCidr"] = "IpCidr";
    /** Any string value. */
    KnownValueType["String"] = "String";
})(exports.KnownValueType || (exports.KnownValueType = {}));
/** Known values of {@link SecuritySolutionStatus} that the service accepts. */
exports.KnownSecuritySolutionStatus = void 0;
(function (KnownSecuritySolutionStatus) {
    KnownSecuritySolutionStatus["Enabled"] = "Enabled";
    KnownSecuritySolutionStatus["Disabled"] = "Disabled";
})(exports.KnownSecuritySolutionStatus || (exports.KnownSecuritySolutionStatus = {}));
/** Known values of {@link ExportData} that the service accepts. */
exports.KnownExportData = void 0;
(function (KnownExportData) {
    /** Agent raw events */
    KnownExportData["RawEvents"] = "RawEvents";
})(exports.KnownExportData || (exports.KnownExportData = {}));
/** Known values of {@link DataSource} that the service accepts. */
exports.KnownDataSource = void 0;
(function (KnownDataSource) {
    /** Devices twin data */
    KnownDataSource["TwinData"] = "TwinData";
})(exports.KnownDataSource || (exports.KnownDataSource = {}));
/** Known values of {@link RecommendationType} that the service accepts. */
exports.KnownRecommendationType = void 0;
(function (KnownRecommendationType) {
    /** Authentication schema used for pull an edge module from an ACR repository does not use Service Principal Authentication. */
    KnownRecommendationType["IoTAcrauthentication"] = "IoT_ACRAuthentication";
    /** IoT agent message size capacity is currently underutilized, causing an increase in the number of sent messages. Adjust message intervals for better utilization. */
    KnownRecommendationType["IoTAgentSendsUnutilizedMessages"] = "IoT_AgentSendsUnutilizedMessages";
    /** Identified security related system configuration issues. */
    KnownRecommendationType["IoTBaseline"] = "IoT_Baseline";
    /** You can optimize Edge Hub memory usage by turning off protocol heads for any protocols not used by Edge modules in your solution. */
    KnownRecommendationType["IoTEdgeHubMemOptimize"] = "IoT_EdgeHubMemOptimize";
    /** Logging is disabled for this edge module. */
    KnownRecommendationType["IoTEdgeLoggingOptions"] = "IoT_EdgeLoggingOptions";
    /** A minority within a device security group has inconsistent Edge Module settings with the rest of their group. */
    KnownRecommendationType["IoTInconsistentModuleSettings"] = "IoT_InconsistentModuleSettings";
    /** Install the Azure Security of Things Agent. */
    KnownRecommendationType["IoTInstallAgent"] = "IoT_InstallAgent";
    /** IP Filter Configuration should have rules defined for allowed traffic and should deny all other traffic by default. */
    KnownRecommendationType["IoTIpfilterDenyAll"] = "IoT_IPFilter_DenyAll";
    /** An Allow IP Filter rules source IP range is too large. Overly permissive rules might expose your IoT hub to malicious intenders. */
    KnownRecommendationType["IoTIpfilterPermissiveRule"] = "IoT_IPFilter_PermissiveRule";
    /** A listening endpoint was found on the device. */
    KnownRecommendationType["IoTOpenPorts"] = "IoT_OpenPorts";
    /** An Allowed firewall policy was found (INPUT/OUTPUT). The policy should Deny all traffic by default and define rules to allow necessary communication to/from the device. */
    KnownRecommendationType["IoTPermissiveFirewallPolicy"] = "IoT_PermissiveFirewallPolicy";
    /** A rule in the firewall has been found that contains a permissive pattern for a wide range of IP addresses or Ports. */
    KnownRecommendationType["IoTPermissiveInputFirewallRules"] = "IoT_PermissiveInputFirewallRules";
    /** A rule in the firewall has been found that contains a permissive pattern for a wide range of IP addresses or Ports. */
    KnownRecommendationType["IoTPermissiveOutputFirewallRules"] = "IoT_PermissiveOutputFirewallRules";
    /** Edge module is configured to run in privileged mode, with extensive Linux capabilities or with host-level network access (send/receive data to host machine). */
    KnownRecommendationType["IoTPrivilegedDockerOptions"] = "IoT_PrivilegedDockerOptions";
    /** Same authentication credentials to the IoT Hub used by multiple devices. This could indicate an illegitimate device impersonating a legitimate device. It also exposes the risk of device impersonation by an attacker. */
    KnownRecommendationType["IoTSharedCredentials"] = "IoT_SharedCredentials";
    /** Insecure TLS configurations detected. Immediate upgrade recommended. */
    KnownRecommendationType["IoTVulnerableTLSCipherSuite"] = "IoT_VulnerableTLSCipherSuite";
})(exports.KnownRecommendationType || (exports.KnownRecommendationType = {}));
/** Known values of {@link RecommendationConfigStatus} that the service accepts. */
exports.KnownRecommendationConfigStatus = void 0;
(function (KnownRecommendationConfigStatus) {
    KnownRecommendationConfigStatus["Disabled"] = "Disabled";
    KnownRecommendationConfigStatus["Enabled"] = "Enabled";
})(exports.KnownRecommendationConfigStatus || (exports.KnownRecommendationConfigStatus = {}));
/** Known values of {@link UnmaskedIpLoggingStatus} that the service accepts. */
exports.KnownUnmaskedIpLoggingStatus = void 0;
(function (KnownUnmaskedIpLoggingStatus) {
    /** Unmasked IP logging is disabled */
    KnownUnmaskedIpLoggingStatus["Disabled"] = "Disabled";
    /** Unmasked IP logging is enabled */
    KnownUnmaskedIpLoggingStatus["Enabled"] = "Enabled";
})(exports.KnownUnmaskedIpLoggingStatus || (exports.KnownUnmaskedIpLoggingStatus = {}));
/** Known values of {@link AdditionalWorkspaceType} that the service accepts. */
exports.KnownAdditionalWorkspaceType = void 0;
(function (KnownAdditionalWorkspaceType) {
    KnownAdditionalWorkspaceType["Sentinel"] = "Sentinel";
})(exports.KnownAdditionalWorkspaceType || (exports.KnownAdditionalWorkspaceType = {}));
/** Known values of {@link AdditionalWorkspaceDataType} that the service accepts. */
exports.KnownAdditionalWorkspaceDataType = void 0;
(function (KnownAdditionalWorkspaceDataType) {
    KnownAdditionalWorkspaceDataType["Alerts"] = "Alerts";
    KnownAdditionalWorkspaceDataType["RawEvents"] = "RawEvents";
})(exports.KnownAdditionalWorkspaceDataType || (exports.KnownAdditionalWorkspaceDataType = {}));
/** Known values of {@link ReportedSeverity} that the service accepts. */
exports.KnownReportedSeverity = void 0;
(function (KnownReportedSeverity) {
    KnownReportedSeverity["Informational"] = "Informational";
    KnownReportedSeverity["Low"] = "Low";
    KnownReportedSeverity["Medium"] = "Medium";
    KnownReportedSeverity["High"] = "High";
})(exports.KnownReportedSeverity || (exports.KnownReportedSeverity = {}));
/** Known values of {@link TaskUpdateActionType} that the service accepts. */
exports.KnownTaskUpdateActionType = void 0;
(function (KnownTaskUpdateActionType) {
    KnownTaskUpdateActionType["Activate"] = "Activate";
    KnownTaskUpdateActionType["Dismiss"] = "Dismiss";
    KnownTaskUpdateActionType["Start"] = "Start";
    KnownTaskUpdateActionType["Resolve"] = "Resolve";
    KnownTaskUpdateActionType["Close"] = "Close";
})(exports.KnownTaskUpdateActionType || (exports.KnownTaskUpdateActionType = {}));
/** Known values of {@link AutoProvision} that the service accepts. */
exports.KnownAutoProvision = void 0;
(function (KnownAutoProvision) {
    /** Install missing security agent on VMs automatically */
    KnownAutoProvision["On"] = "On";
    /** Do not install security agent on the VMs automatically */
    KnownAutoProvision["Off"] = "Off";
})(exports.KnownAutoProvision || (exports.KnownAutoProvision = {}));
/** Known values of {@link InformationProtectionPolicyName} that the service accepts. */
exports.KnownInformationProtectionPolicyName = void 0;
(function (KnownInformationProtectionPolicyName) {
    KnownInformationProtectionPolicyName["Effective"] = "effective";
    KnownInformationProtectionPolicyName["Custom"] = "custom";
})(exports.KnownInformationProtectionPolicyName || (exports.KnownInformationProtectionPolicyName = {}));
/** Known values of {@link AlertNotifications} that the service accepts. */
exports.KnownAlertNotifications = void 0;
(function (KnownAlertNotifications) {
    /** Get notifications on new alerts */
    KnownAlertNotifications["On"] = "On";
    /** Don't get notifications on new alerts */
    KnownAlertNotifications["Off"] = "Off";
})(exports.KnownAlertNotifications || (exports.KnownAlertNotifications = {}));
/** Known values of {@link AlertsToAdmins} that the service accepts. */
exports.KnownAlertsToAdmins = void 0;
(function (KnownAlertsToAdmins) {
    /** Send notification on new alerts to the subscription's admins */
    KnownAlertsToAdmins["On"] = "On";
    /** Don't send notification on new alerts to the subscription's admins */
    KnownAlertsToAdmins["Off"] = "Off";
})(exports.KnownAlertsToAdmins || (exports.KnownAlertsToAdmins = {}));
/** Known values of {@link State} that the service accepts. */
exports.KnownState = void 0;
(function (KnownState) {
    /** All supported regulatory compliance controls in the given standard have a passed state */
    KnownState["Passed"] = "Passed";
    /** At least one supported regulatory compliance control in the given standard has a state of failed */
    KnownState["Failed"] = "Failed";
    /** All supported regulatory compliance controls in the given standard have a state of skipped */
    KnownState["Skipped"] = "Skipped";
    /** No supported regulatory compliance data for the given standard */
    KnownState["Unsupported"] = "Unsupported";
})(exports.KnownState || (exports.KnownState = {}));
/** Known values of {@link SubAssessmentStatusCode} that the service accepts. */
exports.KnownSubAssessmentStatusCode = void 0;
(function (KnownSubAssessmentStatusCode) {
    /** The resource is healthy */
    KnownSubAssessmentStatusCode["Healthy"] = "Healthy";
    /** The resource has a security issue that needs to be addressed */
    KnownSubAssessmentStatusCode["Unhealthy"] = "Unhealthy";
    /** Assessment for this resource did not happen */
    KnownSubAssessmentStatusCode["NotApplicable"] = "NotApplicable";
})(exports.KnownSubAssessmentStatusCode || (exports.KnownSubAssessmentStatusCode = {}));
/** Known values of {@link Severity} that the service accepts. */
exports.KnownSeverity = void 0;
(function (KnownSeverity) {
    KnownSeverity["Low"] = "Low";
    KnownSeverity["Medium"] = "Medium";
    KnownSeverity["High"] = "High";
})(exports.KnownSeverity || (exports.KnownSeverity = {}));
/** Known values of {@link Source} that the service accepts. */
exports.KnownSource = void 0;
(function (KnownSource) {
    /** Resource is in Azure */
    KnownSource["Azure"] = "Azure";
    /** Resource in an on premise machine connected to Azure cloud */
    KnownSource["OnPremise"] = "OnPremise";
    /** SQL Resource in an on premise machine connected to Azure cloud */
    KnownSource["OnPremiseSql"] = "OnPremiseSql";
})(exports.KnownSource || (exports.KnownSource = {}));
/** Known values of {@link AssessedResourceType} that the service accepts. */
exports.KnownAssessedResourceType = void 0;
(function (KnownAssessedResourceType) {
    KnownAssessedResourceType["SqlServerVulnerability"] = "SqlServerVulnerability";
    KnownAssessedResourceType["ContainerRegistryVulnerability"] = "ContainerRegistryVulnerability";
    KnownAssessedResourceType["ServerVulnerability"] = "ServerVulnerability";
})(exports.KnownAssessedResourceType || (exports.KnownAssessedResourceType = {}));
/** Known values of {@link EventSource} that the service accepts. */
exports.KnownEventSource = void 0;
(function (KnownEventSource) {
    KnownEventSource["Assessments"] = "Assessments";
    KnownEventSource["AssessmentsSnapshot"] = "AssessmentsSnapshot";
    KnownEventSource["SubAssessments"] = "SubAssessments";
    KnownEventSource["SubAssessmentsSnapshot"] = "SubAssessmentsSnapshot";
    KnownEventSource["Alerts"] = "Alerts";
    KnownEventSource["SecureScores"] = "SecureScores";
    KnownEventSource["SecureScoresSnapshot"] = "SecureScoresSnapshot";
    KnownEventSource["SecureScoreControls"] = "SecureScoreControls";
    KnownEventSource["SecureScoreControlsSnapshot"] = "SecureScoreControlsSnapshot";
    KnownEventSource["RegulatoryComplianceAssessment"] = "RegulatoryComplianceAssessment";
    KnownEventSource["RegulatoryComplianceAssessmentSnapshot"] = "RegulatoryComplianceAssessmentSnapshot";
})(exports.KnownEventSource || (exports.KnownEventSource = {}));
/** Known values of {@link PropertyType} that the service accepts. */
exports.KnownPropertyType = void 0;
(function (KnownPropertyType) {
    KnownPropertyType["String"] = "String";
    KnownPropertyType["Integer"] = "Integer";
    KnownPropertyType["Number"] = "Number";
    KnownPropertyType["Boolean"] = "Boolean";
})(exports.KnownPropertyType || (exports.KnownPropertyType = {}));
/** Known values of {@link Operator} that the service accepts. */
exports.KnownOperator = void 0;
(function (KnownOperator) {
    /** Applies for decimal and non-decimal operands */
    KnownOperator["Equals"] = "Equals";
    /** Applies only for decimal operands */
    KnownOperator["GreaterThan"] = "GreaterThan";
    /** Applies only for decimal operands */
    KnownOperator["GreaterThanOrEqualTo"] = "GreaterThanOrEqualTo";
    /** Applies only for decimal operands */
    KnownOperator["LesserThan"] = "LesserThan";
    /** Applies only for decimal operands */
    KnownOperator["LesserThanOrEqualTo"] = "LesserThanOrEqualTo";
    /** Applies  for decimal and non-decimal operands */
    KnownOperator["NotEquals"] = "NotEquals";
    /** Applies only for non-decimal operands */
    KnownOperator["Contains"] = "Contains";
    /** Applies only for non-decimal operands */
    KnownOperator["StartsWith"] = "StartsWith";
    /** Applies only for non-decimal operands */
    KnownOperator["EndsWith"] = "EndsWith";
})(exports.KnownOperator || (exports.KnownOperator = {}));
/** Known values of {@link ActionType} that the service accepts. */
exports.KnownActionType = void 0;
(function (KnownActionType) {
    KnownActionType["LogicApp"] = "LogicApp";
    KnownActionType["EventHub"] = "EventHub";
    KnownActionType["Workspace"] = "Workspace";
})(exports.KnownActionType || (exports.KnownActionType = {}));
/** Known values of {@link ServerVulnerabilityAssessmentPropertiesProvisioningState} that the service accepts. */
exports.KnownServerVulnerabilityAssessmentPropertiesProvisioningState = void 0;
(function (KnownServerVulnerabilityAssessmentPropertiesProvisioningState) {
    KnownServerVulnerabilityAssessmentPropertiesProvisioningState["Succeeded"] = "Succeeded";
    KnownServerVulnerabilityAssessmentPropertiesProvisioningState["Failed"] = "Failed";
    KnownServerVulnerabilityAssessmentPropertiesProvisioningState["Canceled"] = "Canceled";
    KnownServerVulnerabilityAssessmentPropertiesProvisioningState["Provisioning"] = "Provisioning";
    KnownServerVulnerabilityAssessmentPropertiesProvisioningState["Deprovisioning"] = "Deprovisioning";
})(exports.KnownServerVulnerabilityAssessmentPropertiesProvisioningState || (exports.KnownServerVulnerabilityAssessmentPropertiesProvisioningState = {}));
/** Known values of {@link Tactics} that the service accepts. */
exports.KnownTactics = void 0;
(function (KnownTactics) {
    KnownTactics["Reconnaissance"] = "Reconnaissance";
    KnownTactics["ResourceDevelopment"] = "Resource Development";
    KnownTactics["InitialAccess"] = "Initial Access";
    KnownTactics["Execution"] = "Execution";
    KnownTactics["Persistence"] = "Persistence";
    KnownTactics["PrivilegeEscalation"] = "Privilege Escalation";
    KnownTactics["DefenseEvasion"] = "Defense Evasion";
    KnownTactics["CredentialAccess"] = "Credential Access";
    KnownTactics["Discovery"] = "Discovery";
    KnownTactics["LateralMovement"] = "Lateral Movement";
    KnownTactics["Collection"] = "Collection";
    KnownTactics["CommandAndControl"] = "Command and Control";
    KnownTactics["Exfiltration"] = "Exfiltration";
    KnownTactics["Impact"] = "Impact";
})(exports.KnownTactics || (exports.KnownTactics = {}));
/** Known values of {@link Techniques} that the service accepts. */
exports.KnownTechniques = void 0;
(function (KnownTechniques) {
    KnownTechniques["AbuseElevationControlMechanism"] = "Abuse Elevation Control Mechanism";
    KnownTechniques["AccessTokenManipulation"] = "Access Token Manipulation";
    KnownTechniques["AccountDiscovery"] = "Account Discovery";
    KnownTechniques["AccountManipulation"] = "Account Manipulation";
    KnownTechniques["ActiveScanning"] = "Active Scanning";
    KnownTechniques["ApplicationLayerProtocol"] = "Application Layer Protocol";
    KnownTechniques["AudioCapture"] = "Audio Capture";
    KnownTechniques["BootOrLogonAutostartExecution"] = "Boot or Logon Autostart Execution";
    KnownTechniques["BootOrLogonInitializationScripts"] = "Boot or Logon Initialization Scripts";
    KnownTechniques["BruteForce"] = "Brute Force";
    KnownTechniques["CloudInfrastructureDiscovery"] = "Cloud Infrastructure Discovery";
    KnownTechniques["CloudServiceDashboard"] = "Cloud Service Dashboard";
    KnownTechniques["CloudServiceDiscovery"] = "Cloud Service Discovery";
    KnownTechniques["CommandAndScriptingInterpreter"] = "Command and Scripting Interpreter";
    KnownTechniques["CompromiseClientSoftwareBinary"] = "Compromise Client Software Binary";
    KnownTechniques["CompromiseInfrastructure"] = "Compromise Infrastructure";
    KnownTechniques["ContainerAndResourceDiscovery"] = "Container and Resource Discovery";
    KnownTechniques["CreateAccount"] = "Create Account";
    KnownTechniques["CreateOrModifySystemProcess"] = "Create or Modify System Process";
    KnownTechniques["CredentialsFromPasswordStores"] = "Credentials from Password Stores";
    KnownTechniques["DataDestruction"] = "Data Destruction";
    KnownTechniques["DataEncryptedForImpact"] = "Data Encrypted for Impact";
    KnownTechniques["DataFromCloudStorageObject"] = "Data from Cloud Storage Object";
    KnownTechniques["DataFromConfigurationRepository"] = "Data from Configuration Repository";
    KnownTechniques["DataFromInformationRepositories"] = "Data from Information Repositories";
    KnownTechniques["DataFromLocalSystem"] = "Data from Local System";
    KnownTechniques["DataManipulation"] = "Data Manipulation";
    KnownTechniques["DataStaged"] = "Data Staged";
    KnownTechniques["Defacement"] = "Defacement";
    KnownTechniques["DeobfuscateDecodeFilesOrInformation"] = "Deobfuscate/Decode Files or Information";
    KnownTechniques["DiskWipe"] = "Disk Wipe";
    KnownTechniques["DomainTrustDiscovery"] = "Domain Trust Discovery";
    KnownTechniques["DriveByCompromise"] = "Drive-by Compromise";
    KnownTechniques["DynamicResolution"] = "Dynamic Resolution";
    KnownTechniques["EndpointDenialOfService"] = "Endpoint Denial of Service";
    KnownTechniques["EventTriggeredExecution"] = "Event Triggered Execution";
    KnownTechniques["ExfiltrationOverAlternativeProtocol"] = "Exfiltration Over Alternative Protocol";
    KnownTechniques["ExploitPublicFacingApplication"] = "Exploit Public-Facing Application";
    KnownTechniques["ExploitationForClientExecution"] = "Exploitation for Client Execution";
    KnownTechniques["ExploitationForCredentialAccess"] = "Exploitation for Credential Access";
    KnownTechniques["ExploitationForDefenseEvasion"] = "Exploitation for Defense Evasion";
    KnownTechniques["ExploitationForPrivilegeEscalation"] = "Exploitation for Privilege Escalation";
    KnownTechniques["ExploitationOfRemoteServices"] = "Exploitation of Remote Services";
    KnownTechniques["ExternalRemoteServices"] = "External Remote Services";
    KnownTechniques["FallbackChannels"] = "Fallback Channels";
    KnownTechniques["FileAndDirectoryDiscovery"] = "File and Directory Discovery";
    KnownTechniques["GatherVictimNetworkInformation"] = "Gather Victim Network Information";
    KnownTechniques["HideArtifacts"] = "Hide Artifacts";
    KnownTechniques["HijackExecutionFlow"] = "Hijack Execution Flow";
    KnownTechniques["ImpairDefenses"] = "Impair Defenses";
    KnownTechniques["ImplantContainerImage"] = "Implant Container Image";
    KnownTechniques["IndicatorRemovalOnHost"] = "Indicator Removal on Host";
    KnownTechniques["IndirectCommandExecution"] = "Indirect Command Execution";
    KnownTechniques["IngressToolTransfer"] = "Ingress Tool Transfer";
    KnownTechniques["InputCapture"] = "Input Capture";
    KnownTechniques["InterProcessCommunication"] = "Inter-Process Communication";
    KnownTechniques["LateralToolTransfer"] = "Lateral Tool Transfer";
    KnownTechniques["ManInTheMiddle"] = "Man-in-the-Middle";
    KnownTechniques["Masquerading"] = "Masquerading";
    KnownTechniques["ModifyAuthenticationProcess"] = "Modify Authentication Process";
    KnownTechniques["ModifyRegistry"] = "Modify Registry";
    KnownTechniques["NetworkDenialOfService"] = "Network Denial of Service";
    KnownTechniques["NetworkServiceScanning"] = "Network Service Scanning";
    KnownTechniques["NetworkSniffing"] = "Network Sniffing";
    KnownTechniques["NonApplicationLayerProtocol"] = "Non-Application Layer Protocol";
    KnownTechniques["NonStandardPort"] = "Non-Standard Port";
    KnownTechniques["ObtainCapabilities"] = "Obtain Capabilities";
    KnownTechniques["ObfuscatedFilesOrInformation"] = "Obfuscated Files or Information";
    KnownTechniques["OfficeApplicationStartup"] = "Office Application Startup";
    KnownTechniques["OSCredentialDumping"] = "OS Credential Dumping";
    KnownTechniques["PermissionGroupsDiscovery"] = "Permission Groups Discovery";
    KnownTechniques["Phishing"] = "Phishing";
    KnownTechniques["PreOSBoot"] = "Pre-OS Boot";
    KnownTechniques["ProcessDiscovery"] = "Process Discovery";
    KnownTechniques["ProcessInjection"] = "Process Injection";
    KnownTechniques["ProtocolTunneling"] = "Protocol Tunneling";
    KnownTechniques["Proxy"] = "Proxy";
    KnownTechniques["QueryRegistry"] = "Query Registry";
    KnownTechniques["RemoteAccessSoftware"] = "Remote Access Software";
    KnownTechniques["RemoteServiceSessionHijacking"] = "Remote Service Session Hijacking";
    KnownTechniques["RemoteServices"] = "Remote Services";
    KnownTechniques["RemoteSystemDiscovery"] = "Remote System Discovery";
    KnownTechniques["ResourceHijacking"] = "Resource Hijacking";
    KnownTechniques["ScheduledTaskJob"] = "Scheduled Task/Job";
    KnownTechniques["ScreenCapture"] = "Screen Capture";
    KnownTechniques["SearchVictimOwnedWebsites"] = "Search Victim-Owned Websites";
    KnownTechniques["ServerSoftwareComponent"] = "Server Software Component";
    KnownTechniques["ServiceStop"] = "Service Stop";
    KnownTechniques["SignedBinaryProxyExecution"] = "Signed Binary Proxy Execution";
    KnownTechniques["SoftwareDeploymentTools"] = "Software Deployment Tools";
    KnownTechniques["SQLStoredProcedures"] = "SQL Stored Procedures";
    KnownTechniques["StealOrForgeKerberosTickets"] = "Steal or Forge Kerberos Tickets";
    KnownTechniques["SubvertTrustControls"] = "Subvert Trust Controls";
    KnownTechniques["SupplyChainCompromise"] = "Supply Chain Compromise";
    KnownTechniques["SystemInformationDiscovery"] = "System Information Discovery";
    KnownTechniques["TaintSharedContent"] = "Taint Shared Content";
    KnownTechniques["TrafficSignaling"] = "Traffic Signaling";
    KnownTechniques["TransferDataToCloudAccount"] = "Transfer Data to Cloud Account";
    KnownTechniques["TrustedRelationship"] = "Trusted Relationship";
    KnownTechniques["UnsecuredCredentials"] = "Unsecured Credentials";
    KnownTechniques["UserExecution"] = "User Execution";
    KnownTechniques["ValidAccounts"] = "Valid Accounts";
    KnownTechniques["WindowsManagementInstrumentation"] = "Windows Management Instrumentation";
    KnownTechniques["FileAndDirectoryPermissionsModification"] = "File and Directory Permissions Modification";
})(exports.KnownTechniques || (exports.KnownTechniques = {}));
/** Known values of {@link Categories} that the service accepts. */
exports.KnownCategories = void 0;
(function (KnownCategories) {
    KnownCategories["Compute"] = "Compute";
    KnownCategories["Networking"] = "Networking";
    KnownCategories["Data"] = "Data";
    KnownCategories["IdentityAndAccess"] = "IdentityAndAccess";
    KnownCategories["IoT"] = "IoT";
})(exports.KnownCategories || (exports.KnownCategories = {}));
/** Known values of {@link UserImpact} that the service accepts. */
exports.KnownUserImpact = void 0;
(function (KnownUserImpact) {
    KnownUserImpact["Low"] = "Low";
    KnownUserImpact["Moderate"] = "Moderate";
    KnownUserImpact["High"] = "High";
})(exports.KnownUserImpact || (exports.KnownUserImpact = {}));
/** Known values of {@link ImplementationEffort} that the service accepts. */
exports.KnownImplementationEffort = void 0;
(function (KnownImplementationEffort) {
    KnownImplementationEffort["Low"] = "Low";
    KnownImplementationEffort["Moderate"] = "Moderate";
    KnownImplementationEffort["High"] = "High";
})(exports.KnownImplementationEffort || (exports.KnownImplementationEffort = {}));
/** Known values of {@link Threats} that the service accepts. */
exports.KnownThreats = void 0;
(function (KnownThreats) {
    KnownThreats["AccountBreach"] = "accountBreach";
    KnownThreats["DataExfiltration"] = "dataExfiltration";
    KnownThreats["DataSpillage"] = "dataSpillage";
    KnownThreats["MaliciousInsider"] = "maliciousInsider";
    KnownThreats["ElevationOfPrivilege"] = "elevationOfPrivilege";
    KnownThreats["ThreatResistance"] = "threatResistance";
    KnownThreats["MissingCoverage"] = "missingCoverage";
    KnownThreats["DenialOfService"] = "denialOfService";
})(exports.KnownThreats || (exports.KnownThreats = {}));
/** Known values of {@link AssessmentType} that the service accepts. */
exports.KnownAssessmentType = void 0;
(function (KnownAssessmentType) {
    /** Azure Security Center managed assessments */
    KnownAssessmentType["BuiltIn"] = "BuiltIn";
    /** User defined policies that are automatically ingested from Azure Policy to Azure Security Center */
    KnownAssessmentType["CustomPolicy"] = "CustomPolicy";
    /** User assessments pushed directly by the user or other third party to Azure Security Center */
    KnownAssessmentType["CustomerManaged"] = "CustomerManaged";
    /** An assessment that was created by a verified 3rd party if the user connected it to ASC */
    KnownAssessmentType["VerifiedPartner"] = "VerifiedPartner";
})(exports.KnownAssessmentType || (exports.KnownAssessmentType = {}));
/** Known values of {@link AssessmentStatusCode} that the service accepts. */
exports.KnownAssessmentStatusCode = void 0;
(function (KnownAssessmentStatusCode) {
    /** The resource is healthy */
    KnownAssessmentStatusCode["Healthy"] = "Healthy";
    /** The resource has a security issue that needs to be addressed */
    KnownAssessmentStatusCode["Unhealthy"] = "Unhealthy";
    /** Assessment for this resource did not happen */
    KnownAssessmentStatusCode["NotApplicable"] = "NotApplicable";
})(exports.KnownAssessmentStatusCode || (exports.KnownAssessmentStatusCode = {}));
/** Known values of {@link ExpandEnum} that the service accepts. */
exports.KnownExpandEnum = void 0;
(function (KnownExpandEnum) {
    /** All links associated with an assessment */
    KnownExpandEnum["Links"] = "links";
    /** Assessment metadata */
    KnownExpandEnum["Metadata"] = "metadata";
})(exports.KnownExpandEnum || (exports.KnownExpandEnum = {}));
/** Known values of {@link EnforcementMode} that the service accepts. */
exports.KnownEnforcementMode = void 0;
(function (KnownEnforcementMode) {
    KnownEnforcementMode["Audit"] = "Audit";
    KnownEnforcementMode["Enforce"] = "Enforce";
    KnownEnforcementMode["None"] = "None";
})(exports.KnownEnforcementMode || (exports.KnownEnforcementMode = {}));
/** Known values of {@link ConfigurationStatus} that the service accepts. */
exports.KnownConfigurationStatus = void 0;
(function (KnownConfigurationStatus) {
    KnownConfigurationStatus["Configured"] = "Configured";
    KnownConfigurationStatus["NotConfigured"] = "NotConfigured";
    KnownConfigurationStatus["InProgress"] = "InProgress";
    KnownConfigurationStatus["Failed"] = "Failed";
    KnownConfigurationStatus["NoStatus"] = "NoStatus";
})(exports.KnownConfigurationStatus || (exports.KnownConfigurationStatus = {}));
/** Known values of {@link RecommendationStatus} that the service accepts. */
exports.KnownRecommendationStatus = void 0;
(function (KnownRecommendationStatus) {
    KnownRecommendationStatus["Recommended"] = "Recommended";
    KnownRecommendationStatus["NotRecommended"] = "NotRecommended";
    KnownRecommendationStatus["NotAvailable"] = "NotAvailable";
    KnownRecommendationStatus["NoStatus"] = "NoStatus";
})(exports.KnownRecommendationStatus || (exports.KnownRecommendationStatus = {}));
/** Known values of {@link AdaptiveApplicationControlIssue} that the service accepts. */
exports.KnownAdaptiveApplicationControlIssue = void 0;
(function (KnownAdaptiveApplicationControlIssue) {
    KnownAdaptiveApplicationControlIssue["ViolationsAudited"] = "ViolationsAudited";
    KnownAdaptiveApplicationControlIssue["ViolationsBlocked"] = "ViolationsBlocked";
    KnownAdaptiveApplicationControlIssue["MsiAndScriptViolationsAudited"] = "MsiAndScriptViolationsAudited";
    KnownAdaptiveApplicationControlIssue["MsiAndScriptViolationsBlocked"] = "MsiAndScriptViolationsBlocked";
    KnownAdaptiveApplicationControlIssue["ExecutableViolationsAudited"] = "ExecutableViolationsAudited";
    KnownAdaptiveApplicationControlIssue["RulesViolatedManually"] = "RulesViolatedManually";
})(exports.KnownAdaptiveApplicationControlIssue || (exports.KnownAdaptiveApplicationControlIssue = {}));
/** Known values of {@link SourceSystem} that the service accepts. */
exports.KnownSourceSystem = void 0;
(function (KnownSourceSystem) {
    KnownSourceSystem["AzureAppLocker"] = "Azure_AppLocker";
    KnownSourceSystem["AzureAuditD"] = "Azure_AuditD";
    KnownSourceSystem["NonAzureAppLocker"] = "NonAzure_AppLocker";
    KnownSourceSystem["NonAzureAuditD"] = "NonAzure_AuditD";
    KnownSourceSystem["None"] = "None";
})(exports.KnownSourceSystem || (exports.KnownSourceSystem = {}));
/** Known values of {@link RecommendationAction} that the service accepts. */
exports.KnownRecommendationAction = void 0;
(function (KnownRecommendationAction) {
    KnownRecommendationAction["Recommended"] = "Recommended";
    KnownRecommendationAction["Add"] = "Add";
    KnownRecommendationAction["Remove"] = "Remove";
})(exports.KnownRecommendationAction || (exports.KnownRecommendationAction = {}));
/** Known values of {@link EnforcementSupport} that the service accepts. */
exports.KnownEnforcementSupport = void 0;
(function (KnownEnforcementSupport) {
    KnownEnforcementSupport["Supported"] = "Supported";
    KnownEnforcementSupport["NotSupported"] = "NotSupported";
    KnownEnforcementSupport["Unknown"] = "Unknown";
})(exports.KnownEnforcementSupport || (exports.KnownEnforcementSupport = {}));
/** Known values of {@link FileType} that the service accepts. */
exports.KnownFileType = void 0;
(function (KnownFileType) {
    KnownFileType["Exe"] = "Exe";
    KnownFileType["Dll"] = "Dll";
    KnownFileType["Msi"] = "Msi";
    KnownFileType["Script"] = "Script";
    KnownFileType["Executable"] = "Executable";
    KnownFileType["Unknown"] = "Unknown";
})(exports.KnownFileType || (exports.KnownFileType = {}));
/** Known values of {@link Direction} that the service accepts. */
exports.KnownDirection = void 0;
(function (KnownDirection) {
    KnownDirection["Inbound"] = "Inbound";
    KnownDirection["Outbound"] = "Outbound";
})(exports.KnownDirection || (exports.KnownDirection = {}));
/** Known values of {@link TransportProtocol} that the service accepts. */
exports.KnownTransportProtocol = void 0;
(function (KnownTransportProtocol) {
    KnownTransportProtocol["TCP"] = "TCP";
    KnownTransportProtocol["UDP"] = "UDP";
})(exports.KnownTransportProtocol || (exports.KnownTransportProtocol = {}));
/** Known values of {@link ConnectionType} that the service accepts. */
exports.KnownConnectionType = void 0;
(function (KnownConnectionType) {
    KnownConnectionType["Internal"] = "Internal";
    KnownConnectionType["External"] = "External";
})(exports.KnownConnectionType || (exports.KnownConnectionType = {}));
/** Known values of {@link Protocol} that the service accepts. */
exports.KnownProtocol = void 0;
(function (KnownProtocol) {
    KnownProtocol["TCP"] = "TCP";
    KnownProtocol["UDP"] = "UDP";
    KnownProtocol["All"] = "*";
})(exports.KnownProtocol || (exports.KnownProtocol = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    KnownStatus["Revoked"] = "Revoked";
    KnownStatus["Initiated"] = "Initiated";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link StatusReason} that the service accepts. */
exports.KnownStatusReason = void 0;
(function (KnownStatusReason) {
    KnownStatusReason["Expired"] = "Expired";
    KnownStatusReason["UserRequested"] = "UserRequested";
    KnownStatusReason["NewerRequestInitiated"] = "NewerRequestInitiated";
})(exports.KnownStatusReason || (exports.KnownStatusReason = {}));
/** Known values of {@link SecurityFamily} that the service accepts. */
exports.KnownSecurityFamily = void 0;
(function (KnownSecurityFamily) {
    KnownSecurityFamily["Waf"] = "Waf";
    KnownSecurityFamily["Ngfw"] = "Ngfw";
    KnownSecurityFamily["SaasWaf"] = "SaasWaf";
    KnownSecurityFamily["Va"] = "Va";
})(exports.KnownSecurityFamily || (exports.KnownSecurityFamily = {}));
/** Known values of {@link ExternalSecuritySolutionKind} that the service accepts. */
exports.KnownExternalSecuritySolutionKind = void 0;
(function (KnownExternalSecuritySolutionKind) {
    KnownExternalSecuritySolutionKind["CEF"] = "CEF";
    KnownExternalSecuritySolutionKind["ATA"] = "ATA";
    KnownExternalSecuritySolutionKind["AAD"] = "AAD";
})(exports.KnownExternalSecuritySolutionKind || (exports.KnownExternalSecuritySolutionKind = {}));
/** Known values of {@link ExpandControlsEnum} that the service accepts. */
exports.KnownExpandControlsEnum = void 0;
(function (KnownExpandControlsEnum) {
    /** Add definition object for each control */
    KnownExpandControlsEnum["Definition"] = "definition";
})(exports.KnownExpandControlsEnum || (exports.KnownExpandControlsEnum = {}));
/** Known values of {@link ControlType} that the service accepts. */
exports.KnownControlType = void 0;
(function (KnownControlType) {
    /** Azure Security Center managed assessments */
    KnownControlType["BuiltIn"] = "BuiltIn";
    /** Non Azure Security Center managed assessments */
    KnownControlType["Custom"] = "Custom";
})(exports.KnownControlType || (exports.KnownControlType = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Failed"] = "Failed";
    KnownProvisioningState["Updating"] = "Updating";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link HybridComputeProvisioningState} that the service accepts. */
exports.KnownHybridComputeProvisioningState = void 0;
(function (KnownHybridComputeProvisioningState) {
    /** Valid service principal details. */
    KnownHybridComputeProvisioningState["Valid"] = "Valid";
    /** Invalid service principal details. */
    KnownHybridComputeProvisioningState["Invalid"] = "Invalid";
    /** the service principal details are expired */
    KnownHybridComputeProvisioningState["Expired"] = "Expired";
})(exports.KnownHybridComputeProvisioningState || (exports.KnownHybridComputeProvisioningState = {}));
/** Known values of {@link AuthenticationProvisioningState} that the service accepts. */
exports.KnownAuthenticationProvisioningState = void 0;
(function (KnownAuthenticationProvisioningState) {
    /** Valid connector */
    KnownAuthenticationProvisioningState["Valid"] = "Valid";
    /** Invalid connector */
    KnownAuthenticationProvisioningState["Invalid"] = "Invalid";
    /** the connection has expired */
    KnownAuthenticationProvisioningState["Expired"] = "Expired";
    /** Incorrect policy of the connector */
    KnownAuthenticationProvisioningState["IncorrectPolicy"] = "IncorrectPolicy";
})(exports.KnownAuthenticationProvisioningState || (exports.KnownAuthenticationProvisioningState = {}));
/** Known values of {@link PermissionProperty} that the service accepts. */
exports.KnownPermissionProperty = void 0;
(function (KnownPermissionProperty) {
    /** This permission provides read only access to AWS Security Hub resources. */
    KnownPermissionProperty["AWSAWSSecurityHubReadOnlyAccess"] = "AWS::AWSSecurityHubReadOnlyAccess";
    /** This permission grants access to read security configuration metadata. */
    KnownPermissionProperty["AWSSecurityAudit"] = "AWS::SecurityAudit";
    /** The permission provides for EC2 Automation service to execute activities defined within Automation documents. */
    KnownPermissionProperty["AWSAmazonSSMAutomationRole"] = "AWS::AmazonSSMAutomationRole";
    /** This permission provides read only access to GCP Security Command Center. */
    KnownPermissionProperty["GCPSecurityCenterAdminViewer"] = "GCP::Security Center Admin Viewer";
})(exports.KnownPermissionProperty || (exports.KnownPermissionProperty = {}));
/** Known values of {@link AuthenticationType} that the service accepts. */
exports.KnownAuthenticationType = void 0;
(function (KnownAuthenticationType) {
    /** AWS cloud account connector user credentials authentication */
    KnownAuthenticationType["AwsCreds"] = "awsCreds";
    /** AWS account connector assume role authentication */
    KnownAuthenticationType["AwsAssumeRole"] = "awsAssumeRole";
    /** GCP account connector service to service authentication */
    KnownAuthenticationType["GcpCredentials"] = "gcpCredentials";
})(exports.KnownAuthenticationType || (exports.KnownAuthenticationType = {}));
/** Known values of {@link ScanTriggerType} that the service accepts. */
exports.KnownScanTriggerType = void 0;
(function (KnownScanTriggerType) {
    /** OnDemand */
    KnownScanTriggerType["OnDemand"] = "OnDemand";
    /** Recurring */
    KnownScanTriggerType["Recurring"] = "Recurring";
})(exports.KnownScanTriggerType || (exports.KnownScanTriggerType = {}));
/** Known values of {@link ScanState} that the service accepts. */
exports.KnownScanState = void 0;
(function (KnownScanState) {
    /** Failed */
    KnownScanState["Failed"] = "Failed";
    /** FailedToRun */
    KnownScanState["FailedToRun"] = "FailedToRun";
    /** InProgress */
    KnownScanState["InProgress"] = "InProgress";
    /** Passed */
    KnownScanState["Passed"] = "Passed";
})(exports.KnownScanState || (exports.KnownScanState = {}));
/** Known values of {@link RuleStatus} that the service accepts. */
exports.KnownRuleStatus = void 0;
(function (KnownRuleStatus) {
    /** NonFinding */
    KnownRuleStatus["NonFinding"] = "NonFinding";
    /** Finding */
    KnownRuleStatus["Finding"] = "Finding";
    /** InternalError */
    KnownRuleStatus["InternalError"] = "InternalError";
})(exports.KnownRuleStatus || (exports.KnownRuleStatus = {}));
/** Known values of {@link RuleSeverity} that the service accepts. */
exports.KnownRuleSeverity = void 0;
(function (KnownRuleSeverity) {
    /** High */
    KnownRuleSeverity["High"] = "High";
    /** Medium */
    KnownRuleSeverity["Medium"] = "Medium";
    /** Low */
    KnownRuleSeverity["Low"] = "Low";
    /** Informational */
    KnownRuleSeverity["Informational"] = "Informational";
    /** Obsolete */
    KnownRuleSeverity["Obsolete"] = "Obsolete";
})(exports.KnownRuleSeverity || (exports.KnownRuleSeverity = {}));
/** Known values of {@link RuleType} that the service accepts. */
exports.KnownRuleType = void 0;
(function (KnownRuleType) {
    /** Binary */
    KnownRuleType["Binary"] = "Binary";
    /** BaselineExpected */
    KnownRuleType["BaselineExpected"] = "BaselineExpected";
    /** PositiveList */
    KnownRuleType["PositiveList"] = "PositiveList";
    /** NegativeList */
    KnownRuleType["NegativeList"] = "NegativeList";
})(exports.KnownRuleType || (exports.KnownRuleType = {}));
/** Known values of {@link AlertSeverity} that the service accepts. */
exports.KnownAlertSeverity = void 0;
(function (KnownAlertSeverity) {
    /** Informational */
    KnownAlertSeverity["Informational"] = "Informational";
    /** Low */
    KnownAlertSeverity["Low"] = "Low";
    /** Medium */
    KnownAlertSeverity["Medium"] = "Medium";
    /** High */
    KnownAlertSeverity["High"] = "High";
})(exports.KnownAlertSeverity || (exports.KnownAlertSeverity = {}));
/** Known values of {@link Intent} that the service accepts. */
exports.KnownIntent = void 0;
(function (KnownIntent) {
    /** Unknown */
    KnownIntent["Unknown"] = "Unknown";
    /** PreAttack could be either an attempt to access a certain resource regardless of a malicious intent, or a failed attempt to gain access to a target system to gather information prior to exploitation. This step is usually detected as an attempt, originating from outside the network, to scan the target system and find a way in.  Further details on the PreAttack stage can be read in [MITRE Pre-Att&ck matrix](https://attack.mitre.org/matrices/pre/). */
    KnownIntent["PreAttack"] = "PreAttack";
    /** InitialAccess is the stage where an attacker manages to get foothold on the attacked resource. */
    KnownIntent["InitialAccess"] = "InitialAccess";
    /** Persistence is any access, action, or configuration change to a system that gives a threat actor a persistent presence on that system. */
    KnownIntent["Persistence"] = "Persistence";
    /** Privilege escalation is the result of actions that allow an adversary to obtain a higher level of permissions on a system or network. */
    KnownIntent["PrivilegeEscalation"] = "PrivilegeEscalation";
    /** Defense evasion consists of techniques an adversary may use to evade detection or avoid other defenses. */
    KnownIntent["DefenseEvasion"] = "DefenseEvasion";
    /** Credential access represents techniques resulting in access to or control over system, domain, or service credentials that are used within an enterprise environment. */
    KnownIntent["CredentialAccess"] = "CredentialAccess";
    /** Discovery consists of techniques that allow the adversary to gain knowledge about the system and internal network. */
    KnownIntent["Discovery"] = "Discovery";
    /** Lateral movement consists of techniques that enable an adversary to access and control remote systems on a network and could, but does not necessarily, include execution of tools on remote systems. */
    KnownIntent["LateralMovement"] = "LateralMovement";
    /** The execution tactic represents techniques that result in execution of adversary-controlled code on a local or remote system. */
    KnownIntent["Execution"] = "Execution";
    /** Collection consists of techniques used to identify and gather information, such as sensitive files, from a target network prior to exfiltration. */
    KnownIntent["Collection"] = "Collection";
    /** Exfiltration refers to techniques and attributes that result or aid in the adversary removing files and information from a target network. */
    KnownIntent["Exfiltration"] = "Exfiltration";
    /** The command and control tactic represents how adversaries communicate with systems under their control within a target network. */
    KnownIntent["CommandAndControl"] = "CommandAndControl";
    /** Impact events primarily try to directly reduce the availability or integrity of a system, service, or network; including manipulation of data to impact a business or operational process. */
    KnownIntent["Impact"] = "Impact";
    /** Probing could be either an attempt to access a certain resource regardless of a malicious intent, or a failed attempt to gain access to a target system to gather information prior to exploitation. */
    KnownIntent["Probing"] = "Probing";
    /** Exploitation is the stage where an attacker manages to get a foothold on the attacked resource. This stage is relevant for compute hosts and resources such as user accounts, certificates etc. */
    KnownIntent["Exploitation"] = "Exploitation";
})(exports.KnownIntent || (exports.KnownIntent = {}));
/** Known values of {@link ResourceIdentifierType} that the service accepts. */
exports.KnownResourceIdentifierType = void 0;
(function (KnownResourceIdentifierType) {
    KnownResourceIdentifierType["AzureResource"] = "AzureResource";
    KnownResourceIdentifierType["LogAnalytics"] = "LogAnalytics";
})(exports.KnownResourceIdentifierType || (exports.KnownResourceIdentifierType = {}));
/** Known values of {@link AlertStatus} that the service accepts. */
exports.KnownAlertStatus = void 0;
(function (KnownAlertStatus) {
    /** An alert which doesn't specify a value is assigned the status 'Active' */
    KnownAlertStatus["Active"] = "Active";
    /** Alert closed after handling */
    KnownAlertStatus["Resolved"] = "Resolved";
    /** Alert dismissed as false positive */
    KnownAlertStatus["Dismissed"] = "Dismissed";
})(exports.KnownAlertStatus || (exports.KnownAlertStatus = {}));
/** Known values of {@link Kind} that the service accepts. */
exports.KnownKind = void 0;
(function (KnownKind) {
    /** Simulate alerts according to bundles */
    KnownKind["Bundles"] = "Bundles";
})(exports.KnownKind || (exports.KnownKind = {}));
/** Known values of {@link SettingKind} that the service accepts. */
exports.KnownSettingKind = void 0;
(function (KnownSettingKind) {
    KnownSettingKind["DataExportSettings"] = "DataExportSettings";
    KnownSettingKind["AlertSuppressionSetting"] = "AlertSuppressionSetting";
    KnownSettingKind["AlertSyncSettings"] = "AlertSyncSettings";
})(exports.KnownSettingKind || (exports.KnownSettingKind = {}));
/** Known values of {@link SettingName} that the service accepts. */
exports.KnownSettingName = void 0;
(function (KnownSettingName) {
    KnownSettingName["Mcas"] = "MCAS";
    KnownSettingName["Wdatp"] = "WDATP";
    KnownSettingName["WdatpExcludeLinuxPublicPreview"] = "WDATP_EXCLUDE_LINUX_PUBLIC_PREVIEW";
    KnownSettingName["Sentinel"] = "Sentinel";
})(exports.KnownSettingName || (exports.KnownSettingName = {}));
/** Known values of {@link EndOfSupportStatus} that the service accepts. */
exports.KnownEndOfSupportStatus = void 0;
(function (KnownEndOfSupportStatus) {
    KnownEndOfSupportStatus["None"] = "None";
    KnownEndOfSupportStatus["NoLongerSupported"] = "noLongerSupported";
    KnownEndOfSupportStatus["VersionNoLongerSupported"] = "versionNoLongerSupported";
    KnownEndOfSupportStatus["UpcomingNoLongerSupported"] = "upcomingNoLongerSupported";
    KnownEndOfSupportStatus["UpcomingVersionNoLongerSupported"] = "upcomingVersionNoLongerSupported";
})(exports.KnownEndOfSupportStatus || (exports.KnownEndOfSupportStatus = {}));
/** Known values of {@link CloudName} that the service accepts. */
exports.KnownCloudName = void 0;
(function (KnownCloudName) {
    KnownCloudName["Azure"] = "Azure";
    KnownCloudName["AWS"] = "AWS";
    KnownCloudName["GCP"] = "GCP";
})(exports.KnownCloudName || (exports.KnownCloudName = {}));
/** Known values of {@link OfferingType} that the service accepts. */
exports.KnownOfferingType = void 0;
(function (KnownOfferingType) {
    KnownOfferingType["CspmMonitorAws"] = "CspmMonitorAws";
    KnownOfferingType["DefenderForContainersAws"] = "DefenderForContainersAws";
    KnownOfferingType["DefenderForServersAws"] = "DefenderForServersAws";
    KnownOfferingType["InformationProtectionAws"] = "InformationProtectionAws";
})(exports.KnownOfferingType || (exports.KnownOfferingType = {}));
/** Known values of {@link OrganizationMembershipType} that the service accepts. */
exports.KnownOrganizationMembershipType = void 0;
(function (KnownOrganizationMembershipType) {
    KnownOrganizationMembershipType["Member"] = "Member";
    KnownOrganizationMembershipType["Organization"] = "Organization";
})(exports.KnownOrganizationMembershipType || (exports.KnownOrganizationMembershipType = {}));
/** Known values of {@link AadConnectivityState} that the service accepts. */
exports.KnownAadConnectivityState = void 0;
(function (KnownAadConnectivityState) {
    KnownAadConnectivityState["Discovered"] = "Discovered";
    KnownAadConnectivityState["NotLicensed"] = "NotLicensed";
    KnownAadConnectivityState["Connected"] = "Connected";
})(exports.KnownAadConnectivityState || (exports.KnownAadConnectivityState = {}));
/** Known values of {@link BundleType} that the service accepts. */
exports.KnownBundleType = void 0;
(function (KnownBundleType) {
    KnownBundleType["AppServices"] = "AppServices";
    KnownBundleType["DNS"] = "DNS";
    KnownBundleType["KeyVaults"] = "KeyVaults";
    KnownBundleType["KubernetesService"] = "KubernetesService";
    KnownBundleType["ResourceManager"] = "ResourceManager";
    KnownBundleType["SqlServers"] = "SqlServers";
    KnownBundleType["StorageAccounts"] = "StorageAccounts";
    KnownBundleType["VirtualMachines"] = "VirtualMachines";
})(exports.KnownBundleType || (exports.KnownBundleType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const MdeOnboardingDataList = {
    type: {
        name: "Composite",
        className: "MdeOnboardingDataList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MdeOnboardingData"
                        }
                    }
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            code: {
                serializedName: "error.code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "error.message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "error.target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "error.details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "error.additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CustomAssessmentAutomationsListResult = {
    type: {
        name: "Composite",
        className: "CustomAssessmentAutomationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomAssessmentAutomation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomEntityStoreAssignmentRequest = {
    type: {
        name: "Composite",
        className: "CustomEntityStoreAssignmentRequest",
        modelProperties: {
            principal: {
                serializedName: "properties.principal",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomEntityStoreAssignmentsListResult = {
    type: {
        name: "Composite",
        className: "CustomEntityStoreAssignmentsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomEntityStoreAssignment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComplianceResultList = {
    type: {
        name: "Composite",
        className: "ComplianceResultList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComplianceResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PricingList = {
    type: {
        name: "Composite",
        className: "PricingList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Pricing"
                        }
                    }
                }
            }
        }
    }
};
const DeviceSecurityGroupList = {
    type: {
        name: "Composite",
        className: "DeviceSecurityGroupList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeviceSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomAlertRule = {
    type: {
        name: "Composite",
        className: "CustomAlertRule",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isEnabled: {
                serializedName: "isEnabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSecuritySolutionsList = {
    type: {
        name: "Composite",
        className: "IoTSecuritySolutionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecuritySolutionModel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserDefinedResourcesProperties = {
    type: {
        name: "Composite",
        className: "UserDefinedResourcesProperties",
        modelProperties: {
            query: {
                serializedName: "query",
                required: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            querySubscriptions: {
                serializedName: "querySubscriptions",
                required: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^[0-9A-Fa-f]{8}-([0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RecommendationConfigurationProperties = {
    type: {
        name: "Composite",
        className: "RecommendationConfigurationProperties",
        modelProperties: {
            recommendationType: {
                serializedName: "recommendationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                defaultValue: "Enabled",
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdditionalWorkspacesProperties = {
    type: {
        name: "Composite",
        className: "AdditionalWorkspacesProperties",
        modelProperties: {
            workspace: {
                serializedName: "workspace",
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Sentinel",
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            dataTypes: {
                serializedName: "dataTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const TagsResource = {
    type: {
        name: "Composite",
        className: "TagsResource",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const IoTSecuritySolutionAnalyticsModelList = {
    type: {
        name: "Composite",
        className: "IoTSecuritySolutionAnalyticsModelList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecuritySolutionAnalyticsModel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSeverityMetrics = {
    type: {
        name: "Composite",
        className: "IoTSeverityMetrics",
        modelProperties: {
            high: {
                serializedName: "high",
                type: {
                    name: "Number"
                }
            },
            medium: {
                serializedName: "medium",
                type: {
                    name: "Number"
                }
            },
            low: {
                serializedName: "low",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem = {
    type: {
        name: "Composite",
        className: "IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTime"
                }
            },
            devicesMetrics: {
                serializedName: "devicesMetrics",
                type: {
                    name: "Composite",
                    className: "IoTSeverityMetrics"
                }
            }
        }
    }
};
const IoTSecurityAlertedDevice = {
    type: {
        name: "Composite",
        className: "IoTSecurityAlertedDevice",
        modelProperties: {
            deviceId: {
                serializedName: "deviceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            alertsCount: {
                serializedName: "alertsCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IoTSecurityDeviceAlert = {
    type: {
        name: "Composite",
        className: "IoTSecurityDeviceAlert",
        modelProperties: {
            alertDisplayName: {
                serializedName: "alertDisplayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            reportedSeverity: {
                serializedName: "reportedSeverity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            alertsCount: {
                serializedName: "alertsCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IoTSecurityDeviceRecommendation = {
    type: {
        name: "Composite",
        className: "IoTSecurityDeviceRecommendation",
        modelProperties: {
            recommendationDisplayName: {
                serializedName: "recommendationDisplayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            reportedSeverity: {
                serializedName: "reportedSeverity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            devicesCount: {
                serializedName: "devicesCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const IoTSecurityAggregatedAlertList = {
    type: {
        name: "Composite",
        className: "IoTSecurityAggregatedAlertList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecurityAggregatedAlert"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSecurityAggregatedAlertPropertiesTopDevicesListItem = {
    type: {
        name: "Composite",
        className: "IoTSecurityAggregatedAlertPropertiesTopDevicesListItem",
        modelProperties: {
            deviceId: {
                serializedName: "deviceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            alertsCount: {
                serializedName: "alertsCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            lastOccurrence: {
                serializedName: "lastOccurrence",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSecurityAggregatedRecommendationList = {
    type: {
        name: "Composite",
        className: "IoTSecurityAggregatedRecommendationList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecurityAggregatedRecommendation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AscLocationList = {
    type: {
        name: "Composite",
        className: "AscLocationList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AscLocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationList = {
    type: {
        name: "Composite",
        className: "OperationList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityTaskList = {
    type: {
        name: "Composite",
        className: "SecurityTaskList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityTask"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityTaskParameters = {
    type: {
        name: "Composite",
        className: "SecurityTaskParameters",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoProvisioningSettingList = {
    type: {
        name: "Composite",
        className: "AutoProvisioningSettingList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutoProvisioningSetting"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComplianceList = {
    type: {
        name: "Composite",
        className: "ComplianceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Compliance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComplianceSegment = {
    type: {
        name: "Composite",
        className: "ComplianceSegment",
        modelProperties: {
            segmentType: {
                serializedName: "segmentType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            percentage: {
                serializedName: "percentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SensitivityLabel = {
    type: {
        name: "Composite",
        className: "SensitivityLabel",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            rank: {
                serializedName: "rank",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Low", "Medium", "High", "Critical"]
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const InformationType = {
    type: {
        name: "Composite",
        className: "InformationType",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "Number"
                }
            },
            recommendedLabelId: {
                serializedName: "recommendedLabelId",
                type: {
                    name: "Uuid"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            custom: {
                serializedName: "custom",
                type: {
                    name: "Boolean"
                }
            },
            keywords: {
                serializedName: "keywords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InformationProtectionKeyword"
                        }
                    }
                }
            }
        }
    }
};
const InformationProtectionKeyword = {
    type: {
        name: "Composite",
        className: "InformationProtectionKeyword",
        modelProperties: {
            pattern: {
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            },
            custom: {
                serializedName: "custom",
                type: {
                    name: "Boolean"
                }
            },
            canBeNumeric: {
                serializedName: "canBeNumeric",
                type: {
                    name: "Boolean"
                }
            },
            excluded: {
                serializedName: "excluded",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const InformationProtectionPolicyList = {
    type: {
        name: "Composite",
        className: "InformationProtectionPolicyList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InformationProtectionPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityContactList = {
    type: {
        name: "Composite",
        className: "SecurityContactList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityContact"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceSettingList = {
    type: {
        name: "Composite",
        className: "WorkspaceSettingList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkspaceSetting"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegulatoryComplianceStandardList = {
    type: {
        name: "Composite",
        className: "RegulatoryComplianceStandardList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegulatoryComplianceStandard"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegulatoryComplianceControlList = {
    type: {
        name: "Composite",
        className: "RegulatoryComplianceControlList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegulatoryComplianceControl"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegulatoryComplianceAssessmentList = {
    type: {
        name: "Composite",
        className: "RegulatoryComplianceAssessmentList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegulatoryComplianceAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecuritySubAssessmentList = {
    type: {
        name: "Composite",
        className: "SecuritySubAssessmentList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecuritySubAssessment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubAssessmentStatus = {
    type: {
        name: "Composite",
        className: "SubAssessmentStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            cause: {
                serializedName: "cause",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            severity: {
                serializedName: "severity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceDetails = {
    type: {
        name: "Composite",
        className: "ResourceDetails",
        uberParent: "ResourceDetails",
        polymorphicDiscriminator: {
            serializedName: "source",
            clientName: "source"
        },
        modelProperties: {
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdditionalData = {
    type: {
        name: "Composite",
        className: "AdditionalData",
        uberParent: "AdditionalData",
        polymorphicDiscriminator: {
            serializedName: "assessedResourceType",
            clientName: "assessedResourceType"
        },
        modelProperties: {
            assessedResourceType: {
                serializedName: "assessedResourceType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutomationList = {
    type: {
        name: "Composite",
        className: "AutomationList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Automation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutomationScope = {
    type: {
        name: "Composite",
        className: "AutomationScope",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            scopePath: {
                serializedName: "scopePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutomationSource = {
    type: {
        name: "Composite",
        className: "AutomationSource",
        modelProperties: {
            eventSource: {
                serializedName: "eventSource",
                type: {
                    name: "String"
                }
            },
            ruleSets: {
                serializedName: "ruleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutomationRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const AutomationRuleSet = {
    type: {
        name: "Composite",
        className: "AutomationRuleSet",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutomationTriggeringRule"
                        }
                    }
                }
            }
        }
    }
};
const AutomationTriggeringRule = {
    type: {
        name: "Composite",
        className: "AutomationTriggeringRule",
        modelProperties: {
            propertyJPath: {
                serializedName: "propertyJPath",
                type: {
                    name: "String"
                }
            },
            propertyType: {
                serializedName: "propertyType",
                type: {
                    name: "String"
                }
            },
            expectedValue: {
                serializedName: "expectedValue",
                type: {
                    name: "String"
                }
            },
            operator: {
                serializedName: "operator",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutomationAction = {
    type: {
        name: "Composite",
        className: "AutomationAction",
        uberParent: "AutomationAction",
        polymorphicDiscriminator: {
            serializedName: "actionType",
            clientName: "actionType"
        },
        modelProperties: {
            actionType: {
                serializedName: "actionType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureTrackedResourceLocation = {
    type: {
        name: "Composite",
        className: "AzureTrackedResourceLocation",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KindAutoGenerated = {
    type: {
        name: "Composite",
        className: "KindAutoGenerated",
        modelProperties: {
            kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ETag = {
    type: {
        name: "Composite",
        className: "ETag",
        modelProperties: {
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Tags = {
    type: {
        name: "Composite",
        className: "Tags",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AutomationValidationStatus = {
    type: {
        name: "Composite",
        className: "AutomationValidationStatus",
        modelProperties: {
            isValid: {
                serializedName: "isValid",
                type: {
                    name: "Boolean"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertsSuppressionRulesList = {
    type: {
        name: "Composite",
        className: "AlertsSuppressionRulesList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AlertsSuppressionRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuppressionAlertsScope = {
    type: {
        name: "Composite",
        className: "SuppressionAlertsScope",
        modelProperties: {
            allOf: {
                serializedName: "allOf",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScopeElement"
                        }
                    }
                }
            }
        }
    }
};
const ScopeElement = {
    type: {
        name: "Composite",
        className: "ScopeElement",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            field: {
                serializedName: "field",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerVulnerabilityAssessmentsList = {
    type: {
        name: "Composite",
        className: "ServerVulnerabilityAssessmentsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerVulnerabilityAssessment"
                        }
                    }
                }
            }
        }
    }
};
const SecurityAssessmentMetadataResponseList = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadataResponseList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityAssessmentMetadataResponse"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAssessmentMetadataPropertiesResponsePublishDates = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadataPropertiesResponsePublishDates",
        modelProperties: {
            ga: {
                constraints: {
                    Pattern: new RegExp("^([0-9]{2}\\/){2}[0-9]{4}$")
                },
                serializedName: "GA",
                type: {
                    name: "String"
                }
            },
            public: {
                constraints: {
                    Pattern: new RegExp("^([0-9]{2}\\/){2}[0-9]{4}$")
                },
                serializedName: "public",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAssessmentMetadataProperties = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadataProperties",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                required: true,
                type: {
                    name: "String"
                }
            },
            policyDefinitionId: {
                serializedName: "policyDefinitionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            remediationDescription: {
                serializedName: "remediationDescription",
                type: {
                    name: "String"
                }
            },
            categories: {
                serializedName: "categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            severity: {
                serializedName: "severity",
                required: true,
                type: {
                    name: "String"
                }
            },
            userImpact: {
                serializedName: "userImpact",
                type: {
                    name: "String"
                }
            },
            implementationEffort: {
                serializedName: "implementationEffort",
                type: {
                    name: "String"
                }
            },
            threats: {
                serializedName: "threats",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            preview: {
                serializedName: "preview",
                type: {
                    name: "Boolean"
                }
            },
            assessmentType: {
                serializedName: "assessmentType",
                required: true,
                type: {
                    name: "String"
                }
            },
            partnerData: {
                serializedName: "partnerData",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataPartnerData"
                }
            }
        }
    }
};
const SecurityAssessmentMetadataPartnerData = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadataPartnerData",
        modelProperties: {
            partnerName: {
                serializedName: "partnerName",
                required: true,
                type: {
                    name: "String"
                }
            },
            productName: {
                serializedName: "productName",
                type: {
                    name: "String"
                }
            },
            secret: {
                serializedName: "secret",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAssessmentList = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityAssessmentResponse"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AssessmentStatus = {
    type: {
        name: "Composite",
        className: "AssessmentStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            cause: {
                serializedName: "cause",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAssessmentPropertiesBase = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentPropertiesBase",
        modelProperties: {
            resourceDetails: {
                serializedName: "resourceDetails",
                type: {
                    name: "Composite",
                    className: "ResourceDetails"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            additionalData: {
                serializedName: "additionalData",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            links: {
                serializedName: "links",
                type: {
                    name: "Composite",
                    className: "AssessmentLinks"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataProperties"
                }
            },
            partnersData: {
                serializedName: "partnersData",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentPartnerData"
                }
            }
        }
    }
};
const AssessmentLinks = {
    type: {
        name: "Composite",
        className: "AssessmentLinks",
        modelProperties: {
            azurePortalUri: {
                serializedName: "azurePortalUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAssessmentPartnerData = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentPartnerData",
        modelProperties: {
            partnerName: {
                serializedName: "partnerName",
                required: true,
                type: {
                    name: "String"
                }
            },
            secret: {
                serializedName: "secret",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdaptiveApplicationControlGroups = {
    type: {
        name: "Composite",
        className: "AdaptiveApplicationControlGroups",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdaptiveApplicationControlGroup"
                        }
                    }
                }
            }
        }
    }
};
const ProtectionMode = {
    type: {
        name: "Composite",
        className: "ProtectionMode",
        modelProperties: {
            exe: {
                serializedName: "exe",
                type: {
                    name: "String"
                }
            },
            msi: {
                serializedName: "msi",
                type: {
                    name: "String"
                }
            },
            script: {
                serializedName: "script",
                type: {
                    name: "String"
                }
            },
            executable: {
                serializedName: "executable",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdaptiveApplicationControlIssueSummary = {
    type: {
        name: "Composite",
        className: "AdaptiveApplicationControlIssueSummary",
        modelProperties: {
            issue: {
                serializedName: "issue",
                type: {
                    name: "String"
                }
            },
            numberOfVms: {
                serializedName: "numberOfVms",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VmRecommendation = {
    type: {
        name: "Composite",
        className: "VmRecommendation",
        modelProperties: {
            configurationStatus: {
                serializedName: "configurationStatus",
                type: {
                    name: "String"
                }
            },
            recommendationAction: {
                serializedName: "recommendationAction",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            enforcementSupport: {
                serializedName: "enforcementSupport",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PathRecommendation = {
    type: {
        name: "Composite",
        className: "PathRecommendation",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            publisherInfo: {
                serializedName: "publisherInfo",
                type: {
                    name: "Composite",
                    className: "PublisherInfo"
                }
            },
            common: {
                serializedName: "common",
                type: {
                    name: "Boolean"
                }
            },
            userSids: {
                serializedName: "userSids",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            usernames: {
                serializedName: "usernames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserRecommendation"
                        }
                    }
                }
            },
            fileType: {
                serializedName: "fileType",
                type: {
                    name: "String"
                }
            },
            configurationStatus: {
                serializedName: "configurationStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublisherInfo = {
    type: {
        name: "Composite",
        className: "PublisherInfo",
        modelProperties: {
            publisherName: {
                serializedName: "publisherName",
                type: {
                    name: "String"
                }
            },
            productName: {
                serializedName: "productName",
                type: {
                    name: "String"
                }
            },
            binaryName: {
                serializedName: "binaryName",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserRecommendation = {
    type: {
        name: "Composite",
        className: "UserRecommendation",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            recommendationAction: {
                serializedName: "recommendationAction",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Location = {
    type: {
        name: "Composite",
        className: "Location",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdaptiveNetworkHardeningsList = {
    type: {
        name: "Composite",
        className: "AdaptiveNetworkHardeningsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdaptiveNetworkHardening"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Rule = {
    type: {
        name: "Composite",
        className: "Rule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            direction: {
                serializedName: "direction",
                type: {
                    name: "String"
                }
            },
            destinationPort: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "destinationPort",
                type: {
                    name: "Number"
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroups = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroups",
        modelProperties: {
            networkInterface: {
                serializedName: "networkInterface",
                type: {
                    name: "String"
                }
            },
            networkSecurityGroups: {
                serializedName: "networkSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AdaptiveNetworkHardeningEnforceRequest = {
    type: {
        name: "Composite",
        className: "AdaptiveNetworkHardeningEnforceRequest",
        modelProperties: {
            rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Rule"
                        }
                    }
                }
            },
            networkSecurityGroups: {
                serializedName: "networkSecurityGroups",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AllowedConnectionsList = {
    type: {
        name: "Composite",
        className: "AllowedConnectionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AllowedConnectionsResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectableResource = {
    type: {
        name: "Composite",
        className: "ConnectableResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            inboundConnectedResources: {
                serializedName: "inboundConnectedResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectedResource"
                        }
                    }
                }
            },
            outboundConnectedResources: {
                serializedName: "outboundConnectedResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectedResource"
                        }
                    }
                }
            }
        }
    }
};
const ConnectedResource = {
    type: {
        name: "Composite",
        className: "ConnectedResource",
        modelProperties: {
            connectedResourceId: {
                serializedName: "connectedResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tcpPorts: {
                serializedName: "tcpPorts",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            udpPorts: {
                serializedName: "udpPorts",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopologyList = {
    type: {
        name: "Composite",
        className: "TopologyList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologyResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopologySingleResource = {
    type: {
        name: "Composite",
        className: "TopologySingleResource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            severity: {
                serializedName: "severity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            recommendationsExist: {
                serializedName: "recommendationsExist",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            networkZones: {
                serializedName: "networkZones",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            topologyScore: {
                serializedName: "topologyScore",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            parents: {
                serializedName: "parents",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologySingleResourceParent"
                        }
                    }
                }
            },
            children: {
                serializedName: "children",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologySingleResourceChild"
                        }
                    }
                }
            }
        }
    }
};
const TopologySingleResourceParent = {
    type: {
        name: "Composite",
        className: "TopologySingleResourceParent",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopologySingleResourceChild = {
    type: {
        name: "Composite",
        className: "TopologySingleResourceChild",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JitNetworkAccessPoliciesList = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPoliciesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JitNetworkAccessPolicyVirtualMachine = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPolicyVirtualMachine",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            ports: {
                serializedName: "ports",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessPortRule"
                        }
                    }
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JitNetworkAccessPortRule = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPortRule",
        modelProperties: {
            number: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "number",
                required: true,
                type: {
                    name: "Number"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            allowedSourceAddressPrefix: {
                serializedName: "allowedSourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            allowedSourceAddressPrefixes: {
                serializedName: "allowedSourceAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxRequestAccessDuration: {
                serializedName: "maxRequestAccessDuration",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JitNetworkAccessRequest = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessRequest",
        modelProperties: {
            virtualMachines: {
                serializedName: "virtualMachines",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessRequestVirtualMachine"
                        }
                    }
                }
            },
            startTimeUtc: {
                serializedName: "startTimeUtc",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            requestor: {
                serializedName: "requestor",
                required: true,
                type: {
                    name: "String"
                }
            },
            justification: {
                serializedName: "justification",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JitNetworkAccessRequestVirtualMachine = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessRequestVirtualMachine",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            ports: {
                serializedName: "ports",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessRequestPort"
                        }
                    }
                }
            }
        }
    }
};
const JitNetworkAccessRequestPort = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessRequestPort",
        modelProperties: {
            number: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "number",
                required: true,
                type: {
                    name: "Number"
                }
            },
            allowedSourceAddressPrefix: {
                serializedName: "allowedSourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            allowedSourceAddressPrefixes: {
                serializedName: "allowedSourceAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            endTimeUtc: {
                serializedName: "endTimeUtc",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            statusReason: {
                serializedName: "statusReason",
                required: true,
                type: {
                    name: "String"
                }
            },
            mappedPort: {
                serializedName: "mappedPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JitNetworkAccessPolicyInitiateRequest = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPolicyInitiateRequest",
        modelProperties: {
            virtualMachines: {
                serializedName: "virtualMachines",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessPolicyInitiateVirtualMachine"
                        }
                    }
                }
            },
            justification: {
                serializedName: "justification",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JitNetworkAccessPolicyInitiateVirtualMachine = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPolicyInitiateVirtualMachine",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            ports: {
                serializedName: "ports",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessPolicyInitiatePort"
                        }
                    }
                }
            }
        }
    }
};
const JitNetworkAccessPolicyInitiatePort = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPolicyInitiatePort",
        modelProperties: {
            number: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "number",
                required: true,
                type: {
                    name: "Number"
                }
            },
            allowedSourceAddressPrefix: {
                serializedName: "allowedSourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            endTimeUtc: {
                serializedName: "endTimeUtc",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DiscoveredSecuritySolutionList = {
    type: {
        name: "Composite",
        className: "DiscoveredSecuritySolutionList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiscoveredSecuritySolution"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecuritySolutionsReferenceDataList = {
    type: {
        name: "Composite",
        className: "SecuritySolutionsReferenceDataList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecuritySolutionsReferenceData"
                        }
                    }
                }
            }
        }
    }
};
const ExternalSecuritySolutionList = {
    type: {
        name: "Composite",
        className: "ExternalSecuritySolutionList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExternalSecuritySolution"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExternalSecuritySolutionKindAutoGenerated = {
    type: {
        name: "Composite",
        className: "ExternalSecuritySolutionKindAutoGenerated",
        modelProperties: {
            kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecureScoresList = {
    type: {
        name: "Composite",
        className: "SecureScoresList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecureScoreItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecureScoreControlList = {
    type: {
        name: "Composite",
        className: "SecureScoreControlList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecureScoreControlDetails"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecureScoreControlDefinitionSource = {
    type: {
        name: "Composite",
        className: "SecureScoreControlDefinitionSource",
        modelProperties: {
            sourceType: {
                serializedName: "sourceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureResourceLink = {
    type: {
        name: "Composite",
        className: "AzureResourceLink",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecureScoreControlDefinitionList = {
    type: {
        name: "Composite",
        className: "SecureScoreControlDefinitionList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecureScoreControlDefinitionItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecuritySolutionList = {
    type: {
        name: "Composite",
        className: "SecuritySolutionList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecuritySolution"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectorSettingList = {
    type: {
        name: "Composite",
        className: "ConnectorSettingList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectorSetting"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HybridComputeSettingsProperties = {
    type: {
        name: "Composite",
        className: "HybridComputeSettingsProperties",
        modelProperties: {
            hybridComputeProvisioningState: {
                serializedName: "hybridComputeProvisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            autoProvision: {
                serializedName: "autoProvision",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceGroupName: {
                serializedName: "resourceGroupName",
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            proxyServer: {
                serializedName: "proxyServer",
                type: {
                    name: "Composite",
                    className: "ProxyServerProperties"
                }
            },
            servicePrincipal: {
                serializedName: "servicePrincipal",
                type: {
                    name: "Composite",
                    className: "ServicePrincipalProperties"
                }
            }
        }
    }
};
const ProxyServerProperties = {
    type: {
        name: "Composite",
        className: "ProxyServerProperties",
        modelProperties: {
            ip: {
                serializedName: "ip",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServicePrincipalProperties = {
    type: {
        name: "Composite",
        className: "ServicePrincipalProperties",
        modelProperties: {
            applicationId: {
                serializedName: "applicationId",
                type: {
                    name: "String"
                }
            },
            secret: {
                serializedName: "secret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthenticationDetailsProperties = {
    type: {
        name: "Composite",
        className: "AuthenticationDetailsProperties",
        uberParent: "AuthenticationDetailsProperties",
        polymorphicDiscriminator: {
            serializedName: "authenticationType",
            clientName: "authenticationType"
        },
        modelProperties: {
            authenticationProvisioningState: {
                serializedName: "authenticationProvisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            grantedPermissions: {
                serializedName: "grantedPermissions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            authenticationType: {
                serializedName: "authenticationType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScanProperties = {
    type: {
        name: "Composite",
        className: "ScanProperties",
        modelProperties: {
            triggerType: {
                serializedName: "triggerType",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            server: {
                serializedName: "server",
                type: {
                    name: "String"
                }
            },
            database: {
                serializedName: "database",
                type: {
                    name: "String"
                }
            },
            sqlVersion: {
                serializedName: "sqlVersion",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            highSeverityFailedRulesCount: {
                serializedName: "highSeverityFailedRulesCount",
                type: {
                    name: "Number"
                }
            },
            mediumSeverityFailedRulesCount: {
                serializedName: "mediumSeverityFailedRulesCount",
                type: {
                    name: "Number"
                }
            },
            lowSeverityFailedRulesCount: {
                serializedName: "lowSeverityFailedRulesCount",
                type: {
                    name: "Number"
                }
            },
            totalPassedRulesCount: {
                serializedName: "totalPassedRulesCount",
                type: {
                    name: "Number"
                }
            },
            totalFailedRulesCount: {
                serializedName: "totalFailedRulesCount",
                type: {
                    name: "Number"
                }
            },
            totalRulesCount: {
                serializedName: "totalRulesCount",
                type: {
                    name: "Number"
                }
            },
            isBaselineApplied: {
                serializedName: "isBaselineApplied",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Scans = {
    type: {
        name: "Composite",
        className: "Scans",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Scan"
                        }
                    }
                }
            }
        }
    }
};
const ScanResultProperties = {
    type: {
        name: "Composite",
        className: "ScanResultProperties",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            isTrimmed: {
                serializedName: "isTrimmed",
                type: {
                    name: "Boolean"
                }
            },
            queryResults: {
                serializedName: "queryResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            },
            remediation: {
                serializedName: "remediation",
                type: {
                    name: "Composite",
                    className: "Remediation"
                }
            },
            baselineAdjustedResult: {
                serializedName: "baselineAdjustedResult",
                type: {
                    name: "Composite",
                    className: "BaselineAdjustedResult"
                }
            },
            ruleMetadata: {
                serializedName: "ruleMetadata",
                type: {
                    name: "Composite",
                    className: "VaRule"
                }
            }
        }
    }
};
const Remediation = {
    type: {
        name: "Composite",
        className: "Remediation",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            scripts: {
                serializedName: "scripts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            automated: {
                serializedName: "automated",
                type: {
                    name: "Boolean"
                }
            },
            portalLink: {
                serializedName: "portalLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BaselineAdjustedResult = {
    type: {
        name: "Composite",
        className: "BaselineAdjustedResult",
        modelProperties: {
            baseline: {
                serializedName: "baseline",
                type: {
                    name: "Composite",
                    className: "Baseline"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            resultsNotInBaseline: {
                serializedName: "resultsNotInBaseline",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            },
            resultsOnlyInBaseline: {
                serializedName: "resultsOnlyInBaseline",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const Baseline = {
    type: {
        name: "Composite",
        className: "Baseline",
        modelProperties: {
            expectedResults: {
                serializedName: "expectedResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            },
            updatedTime: {
                serializedName: "updatedTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const VaRule = {
    type: {
        name: "Composite",
        className: "VaRule",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                type: {
                    name: "String"
                }
            },
            severity: {
                serializedName: "severity",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            rationale: {
                serializedName: "rationale",
                type: {
                    name: "String"
                }
            },
            queryCheck: {
                serializedName: "queryCheck",
                type: {
                    name: "Composite",
                    className: "QueryCheck"
                }
            },
            benchmarkReferences: {
                serializedName: "benchmarkReferences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BenchmarkReference"
                        }
                    }
                }
            }
        }
    }
};
const QueryCheck = {
    type: {
        name: "Composite",
        className: "QueryCheck",
        modelProperties: {
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            },
            expectedResult: {
                serializedName: "expectedResult",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            },
            columnNames: {
                serializedName: "columnNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BenchmarkReference = {
    type: {
        name: "Composite",
        className: "BenchmarkReference",
        modelProperties: {
            benchmark: {
                serializedName: "benchmark",
                type: {
                    name: "String"
                }
            },
            reference: {
                serializedName: "reference",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScanResults = {
    type: {
        name: "Composite",
        className: "ScanResults",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScanResult"
                        }
                    }
                }
            }
        }
    }
};
const RuleResultsInput = {
    type: {
        name: "Composite",
        className: "RuleResultsInput",
        modelProperties: {
            latestScan: {
                serializedName: "latestScan",
                type: {
                    name: "Boolean"
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const RuleResultsProperties = {
    type: {
        name: "Composite",
        className: "RuleResultsProperties",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "String"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const RulesResults = {
    type: {
        name: "Composite",
        className: "RulesResults",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuleResults"
                        }
                    }
                }
            }
        }
    }
};
const RulesResultsInput = {
    type: {
        name: "Composite",
        className: "RulesResultsInput",
        modelProperties: {
            latestScan: {
                serializedName: "latestScan",
                type: {
                    name: "Boolean"
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Sequence",
                                    element: { type: { name: "String" } }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
const AlertList = {
    type: {
        name: "Composite",
        className: "AlertList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Alert"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceIdentifier = {
    type: {
        name: "Composite",
        className: "ResourceIdentifier",
        uberParent: "ResourceIdentifier",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertEntity = {
    type: {
        name: "Composite",
        className: "AlertEntity",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertSimulatorRequestBody = {
    type: {
        name: "Composite",
        className: "AlertSimulatorRequestBody",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AlertSimulatorRequestProperties"
                }
            }
        }
    }
};
const AlertSimulatorRequestProperties = {
    serializedName: "AlertSimulatorRequestProperties",
    type: {
        name: "Composite",
        className: "AlertSimulatorRequestProperties",
        uberParent: "AlertSimulatorRequestProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SettingsList = {
    type: {
        name: "Composite",
        className: "SettingsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Setting"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IngestionSettingList = {
    type: {
        name: "Composite",
        className: "IngestionSettingList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IngestionSetting"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IngestionSettingToken = {
    type: {
        name: "Composite",
        className: "IngestionSettingToken",
        modelProperties: {
            token: {
                serializedName: "token",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionStrings = {
    type: {
        name: "Composite",
        className: "ConnectionStrings",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IngestionConnectionString"
                        }
                    }
                }
            }
        }
    }
};
const IngestionConnectionString = {
    type: {
        name: "Composite",
        className: "IngestionConnectionString",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SoftwaresList = {
    type: {
        name: "Composite",
        className: "SoftwaresList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Software"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityConnectorsList = {
    type: {
        name: "Composite",
        className: "SecurityConnectorsList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityConnector"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudOffering = {
    type: {
        name: "Composite",
        className: "CloudOffering",
        uberParent: "CloudOffering",
        polymorphicDiscriminator: {
            serializedName: "offeringType",
            clientName: "offeringType"
        },
        modelProperties: {
            offeringType: {
                serializedName: "offeringType",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityConnectorPropertiesOrganizationalData = {
    type: {
        name: "Composite",
        className: "SecurityConnectorPropertiesOrganizationalData",
        modelProperties: {
            organizationMembershipType: {
                serializedName: "organizationMembershipType",
                type: {
                    name: "String"
                }
            },
            parentHierarchyId: {
                serializedName: "parentHierarchyId",
                type: {
                    name: "String"
                }
            },
            stacksetName: {
                serializedName: "stacksetName",
                type: {
                    name: "String"
                }
            },
            excludedAccountIds: {
                serializedName: "excludedAccountIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Cvss = {
    type: {
        name: "Composite",
        className: "Cvss",
        modelProperties: {
            base: {
                serializedName: "base",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Cve = {
    type: {
        name: "Composite",
        className: "Cve",
        modelProperties: {
            title: {
                serializedName: "title",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            link: {
                serializedName: "link",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VendorReference = {
    type: {
        name: "Composite",
        className: "VendorReference",
        modelProperties: {
            title: {
                serializedName: "title",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            link: {
                serializedName: "link",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExternalSecuritySolutionProperties = {
    type: {
        name: "Composite",
        className: "ExternalSecuritySolutionProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            deviceVendor: {
                serializedName: "deviceVendor",
                type: {
                    name: "String"
                }
            },
            deviceType: {
                serializedName: "deviceType",
                type: {
                    name: "String"
                }
            },
            workspace: {
                serializedName: "workspace",
                type: {
                    name: "Composite",
                    className: "ConnectedWorkspace"
                }
            }
        }
    }
};
const ConnectedWorkspace = {
    type: {
        name: "Composite",
        className: "ConnectedWorkspace",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AadConnectivityStateAutoGenerated = {
    type: {
        name: "Composite",
        className: "AadConnectivityStateAutoGenerated",
        modelProperties: {
            connectivityState: {
                serializedName: "connectivityState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecureScoreControlScore = {
    type: {
        name: "Composite",
        className: "SecureScoreControlScore",
        modelProperties: {
            max: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0
                },
                serializedName: "max",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            current: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0
                },
                serializedName: "current",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            percentage: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "percentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CspmMonitorAwsOfferingNativeCloudConnection = {
    type: {
        name: "Composite",
        className: "CspmMonitorAwsOfferingNativeCloudConnection",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefenderForContainersAwsOfferingKubernetesService = {
    type: {
        name: "Composite",
        className: "DefenderForContainersAwsOfferingKubernetesService",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefenderForContainersAwsOfferingKubernetesScubaReader = {
    type: {
        name: "Composite",
        className: "DefenderForContainersAwsOfferingKubernetesScubaReader",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefenderForContainersAwsOfferingCloudWatchToKinesis = {
    type: {
        name: "Composite",
        className: "DefenderForContainersAwsOfferingCloudWatchToKinesis",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefenderForContainersAwsOfferingKinesisToS3 = {
    type: {
        name: "Composite",
        className: "DefenderForContainersAwsOfferingKinesisToS3",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefenderForServersAwsOfferingDefenderForServers = {
    type: {
        name: "Composite",
        className: "DefenderForServersAwsOfferingDefenderForServers",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefenderForServersAwsOfferingArcAutoProvisioning = {
    type: {
        name: "Composite",
        className: "DefenderForServersAwsOfferingArcAutoProvisioning",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            servicePrincipalSecretMetadata: {
                serializedName: "servicePrincipalSecretMetadata",
                type: {
                    name: "Composite",
                    className: "DefenderForServersAwsOfferingArcAutoProvisioningServicePrincipalSecretMetadata"
                }
            }
        }
    }
};
const DefenderForServersAwsOfferingArcAutoProvisioningServicePrincipalSecretMetadata = {
    type: {
        name: "Composite",
        className: "DefenderForServersAwsOfferingArcAutoProvisioningServicePrincipalSecretMetadata",
        modelProperties: {
            expiryDate: {
                serializedName: "expiryDate",
                type: {
                    name: "String"
                }
            },
            parameterStoreRegion: {
                serializedName: "parameterStoreRegion",
                type: {
                    name: "String"
                }
            },
            parameterNameInStore: {
                serializedName: "parameterNameInStore",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InformationProtectionAwsOfferingInformationProtection = {
    type: {
        name: "Composite",
        className: "InformationProtectionAwsOfferingInformationProtection",
        modelProperties: {
            cloudRoleArn: {
                serializedName: "cloudRoleArn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MdeOnboardingData = {
    type: {
        name: "Composite",
        className: "MdeOnboardingData",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { onboardingPackageWindows: {
                serializedName: "properties.onboardingPackageWindows",
                type: {
                    name: "ByteArray"
                }
            }, onboardingPackageLinux: {
                serializedName: "properties.onboardingPackageLinux",
                type: {
                    name: "ByteArray"
                }
            } })
    }
};
const CustomAssessmentAutomation = {
    type: {
        name: "Composite",
        className: "CustomAssessmentAutomation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, compressedQuery: {
                serializedName: "properties.compressedQuery",
                type: {
                    name: "String"
                }
            }, supportedCloud: {
                serializedName: "properties.supportedCloud",
                type: {
                    name: "String"
                }
            }, severity: {
                serializedName: "properties.severity",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, remediationDescription: {
                serializedName: "properties.remediationDescription",
                type: {
                    name: "String"
                }
            }, assessmentKey: {
                serializedName: "properties.assessmentKey",
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomAssessmentAutomationRequest = {
    type: {
        name: "Composite",
        className: "CustomAssessmentAutomationRequest",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { compressedQuery: {
                serializedName: "properties.compressedQuery",
                type: {
                    name: "String"
                }
            }, supportedCloud: {
                serializedName: "properties.supportedCloud",
                type: {
                    name: "String"
                }
            }, severity: {
                serializedName: "properties.severity",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, remediationDescription: {
                serializedName: "properties.remediationDescription",
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomEntityStoreAssignment = {
    type: {
        name: "Composite",
        className: "CustomEntityStoreAssignment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, principal: {
                serializedName: "properties.principal",
                type: {
                    name: "String"
                }
            }, entityStoreDatabaseLink: {
                serializedName: "properties.entityStoreDatabaseLink",
                type: {
                    name: "String"
                }
            } })
    }
};
const ComplianceResult = {
    type: {
        name: "Composite",
        className: "ComplianceResult",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { resourceStatus: {
                serializedName: "properties.resourceStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Pricing = {
    type: {
        name: "Composite",
        className: "Pricing",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { pricingTier: {
                serializedName: "properties.pricingTier",
                type: {
                    name: "String"
                }
            }, subPlan: {
                serializedName: "properties.subPlan",
                type: {
                    name: "String"
                }
            }, freeTrialRemainingTime: {
                serializedName: "properties.freeTrialRemainingTime",
                readOnly: true,
                type: {
                    name: "TimeSpan"
                }
            } })
    }
};
const AdvancedThreatProtectionSetting = {
    type: {
        name: "Composite",
        className: "AdvancedThreatProtectionSetting",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { isEnabled: {
                serializedName: "properties.isEnabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DeviceSecurityGroup = {
    type: {
        name: "Composite",
        className: "DeviceSecurityGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { thresholdRules: {
                serializedName: "properties.thresholdRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ThresholdCustomAlertRule"
                        }
                    }
                }
            }, timeWindowRules: {
                serializedName: "properties.timeWindowRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeWindowCustomAlertRule"
                        }
                    }
                }
            }, allowlistRules: {
                serializedName: "properties.allowlistRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AllowlistCustomAlertRule"
                        }
                    }
                }
            }, denylistRules: {
                serializedName: "properties.denylistRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DenylistCustomAlertRule"
                        }
                    }
                }
            } })
    }
};
const IoTSecuritySolutionModel = {
    type: {
        name: "Composite",
        className: "IoTSecuritySolutionModel",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), TagsResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, workspace: {
                serializedName: "properties.workspace",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, status: {
                defaultValue: "Enabled",
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, export: {
                serializedName: "properties.export",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, disabledDataSources: {
                serializedName: "properties.disabledDataSources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, iotHubs: {
                serializedName: "properties.iotHubs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, userDefinedResources: {
                serializedName: "properties.userDefinedResources",
                type: {
                    name: "Composite",
                    className: "UserDefinedResourcesProperties"
                }
            }, autoDiscoveredResources: {
                serializedName: "properties.autoDiscoveredResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, recommendationsConfiguration: {
                serializedName: "properties.recommendationsConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendationConfigurationProperties"
                        }
                    }
                }
            }, unmaskedIpLoggingStatus: {
                defaultValue: "Disabled",
                serializedName: "properties.unmaskedIpLoggingStatus",
                type: {
                    name: "String"
                }
            }, additionalWorkspaces: {
                serializedName: "properties.additionalWorkspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdditionalWorkspacesProperties"
                        }
                    }
                }
            } })
    }
};
const IoTSecuritySolutionAnalyticsModel = {
    type: {
        name: "Composite",
        className: "IoTSecuritySolutionAnalyticsModel",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { metrics: {
                serializedName: "properties.metrics",
                type: {
                    name: "Composite",
                    className: "IoTSeverityMetrics"
                }
            }, unhealthyDeviceCount: {
                serializedName: "properties.unhealthyDeviceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, devicesMetrics: {
                serializedName: "properties.devicesMetrics",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem"
                        }
                    }
                }
            }, topAlertedDevices: {
                serializedName: "properties.topAlertedDevices",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecurityAlertedDevice"
                        }
                    }
                }
            }, mostPrevalentDeviceAlerts: {
                serializedName: "properties.mostPrevalentDeviceAlerts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecurityDeviceAlert"
                        }
                    }
                }
            }, mostPrevalentDeviceRecommendations: {
                serializedName: "properties.mostPrevalentDeviceRecommendations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecurityDeviceRecommendation"
                        }
                    }
                }
            } })
    }
};
const IoTSecurityAggregatedAlert = {
    type: {
        name: "Composite",
        className: "IoTSecurityAggregatedAlert",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), TagsResource.type.modelProperties), { alertType: {
                serializedName: "properties.alertType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, alertDisplayName: {
                serializedName: "properties.alertDisplayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, aggregatedDateUtc: {
                serializedName: "properties.aggregatedDateUtc",
                readOnly: true,
                type: {
                    name: "Date"
                }
            }, vendorName: {
                serializedName: "properties.vendorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, reportedSeverity: {
                serializedName: "properties.reportedSeverity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, remediationSteps: {
                serializedName: "properties.remediationSteps",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, count: {
                serializedName: "properties.count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, effectedResourceType: {
                serializedName: "properties.effectedResourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, systemSource: {
                serializedName: "properties.systemSource",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, actionTaken: {
                serializedName: "properties.actionTaken",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, logAnalyticsQuery: {
                serializedName: "properties.logAnalyticsQuery",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, topDevicesList: {
                serializedName: "properties.topDevicesList",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSecurityAggregatedAlertPropertiesTopDevicesListItem"
                        }
                    }
                }
            } })
    }
};
const IoTSecurityAggregatedRecommendation = {
    type: {
        name: "Composite",
        className: "IoTSecurityAggregatedRecommendation",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), TagsResource.type.modelProperties), { recommendationName: {
                serializedName: "properties.recommendationName",
                type: {
                    name: "String"
                }
            }, recommendationDisplayName: {
                serializedName: "properties.recommendationDisplayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, recommendationTypeId: {
                serializedName: "properties.recommendationTypeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, detectedBy: {
                serializedName: "properties.detectedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, remediationSteps: {
                serializedName: "properties.remediationSteps",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, reportedSeverity: {
                serializedName: "properties.reportedSeverity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, healthyDevices: {
                serializedName: "properties.healthyDevices",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unhealthyDeviceCount: {
                serializedName: "properties.unhealthyDeviceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, logAnalyticsQuery: {
                serializedName: "properties.logAnalyticsQuery",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AscLocation = {
    type: {
        name: "Composite",
        className: "AscLocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const SecurityTask = {
    type: {
        name: "Composite",
        className: "SecurityTask",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationTimeUtc: {
                serializedName: "properties.creationTimeUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, securityTaskParameters: {
                serializedName: "properties.securityTaskParameters",
                type: {
                    name: "Composite",
                    className: "SecurityTaskParameters"
                }
            }, lastStateChangeTimeUtc: {
                serializedName: "properties.lastStateChangeTimeUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, subState: {
                serializedName: "properties.subState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AutoProvisioningSetting = {
    type: {
        name: "Composite",
        className: "AutoProvisioningSetting",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { autoProvision: {
                serializedName: "properties.autoProvision",
                type: {
                    name: "String"
                }
            } })
    }
};
const Compliance = {
    type: {
        name: "Composite",
        className: "Compliance",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { assessmentTimestampUtcDate: {
                serializedName: "properties.assessmentTimestampUtcDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, resourceCount: {
                serializedName: "properties.resourceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, assessmentResult: {
                serializedName: "properties.assessmentResult",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComplianceSegment"
                        }
                    }
                }
            } })
    }
};
const InformationProtectionPolicy = {
    type: {
        name: "Composite",
        className: "InformationProtectionPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { lastModifiedUtc: {
                serializedName: "properties.lastModifiedUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, labels: {
                serializedName: "properties.labels",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "SensitivityLabel" } }
                }
            }, informationTypes: {
                serializedName: "properties.informationTypes",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "InformationType" } }
                }
            } })
    }
};
const SecurityContact = {
    type: {
        name: "Composite",
        className: "SecurityContact",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { email: {
                serializedName: "properties.email",
                type: {
                    name: "String"
                }
            }, phone: {
                serializedName: "properties.phone",
                type: {
                    name: "String"
                }
            }, alertNotifications: {
                serializedName: "properties.alertNotifications",
                type: {
                    name: "String"
                }
            }, alertsToAdmins: {
                serializedName: "properties.alertsToAdmins",
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkspaceSetting = {
    type: {
        name: "Composite",
        className: "WorkspaceSetting",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { workspaceId: {
                serializedName: "properties.workspaceId",
                type: {
                    name: "String"
                }
            }, scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            } })
    }
};
const RegulatoryComplianceStandard = {
    type: {
        name: "Composite",
        className: "RegulatoryComplianceStandard",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, passedControls: {
                serializedName: "properties.passedControls",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, failedControls: {
                serializedName: "properties.failedControls",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, skippedControls: {
                serializedName: "properties.skippedControls",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unsupportedControls: {
                serializedName: "properties.unsupportedControls",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const RegulatoryComplianceControl = {
    type: {
        name: "Composite",
        className: "RegulatoryComplianceControl",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, passedAssessments: {
                serializedName: "properties.passedAssessments",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, failedAssessments: {
                serializedName: "properties.failedAssessments",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, skippedAssessments: {
                serializedName: "properties.skippedAssessments",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const RegulatoryComplianceAssessment = {
    type: {
        name: "Composite",
        className: "RegulatoryComplianceAssessment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, assessmentType: {
                serializedName: "properties.assessmentType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, assessmentDetailsLink: {
                serializedName: "properties.assessmentDetailsLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, passedResources: {
                serializedName: "properties.passedResources",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, failedResources: {
                serializedName: "properties.failedResources",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, skippedResources: {
                serializedName: "properties.skippedResources",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unsupportedResources: {
                serializedName: "properties.unsupportedResources",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SecuritySubAssessment = {
    type: {
        name: "Composite",
        className: "SecuritySubAssessment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { idPropertiesId: {
                serializedName: "properties.id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "Composite",
                    className: "SubAssessmentStatus"
                }
            }, remediation: {
                serializedName: "properties.remediation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, impact: {
                serializedName: "properties.impact",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, category: {
                serializedName: "properties.category",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timeGenerated: {
                serializedName: "properties.timeGenerated",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, resourceDetails: {
                serializedName: "properties.resourceDetails",
                type: {
                    name: "Composite",
                    className: "ResourceDetails"
                }
            }, additionalData: {
                serializedName: "properties.additionalData",
                type: {
                    name: "Composite",
                    className: "AdditionalData"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), AzureTrackedResourceLocation.type.modelProperties), KindAutoGenerated.type.modelProperties), ETag.type.modelProperties), Tags.type.modelProperties)
    }
};
const AlertsSuppressionRule = {
    type: {
        name: "Composite",
        className: "AlertsSuppressionRule",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { alertType: {
                serializedName: "properties.alertType",
                type: {
                    name: "String"
                }
            }, lastModifiedUtc: {
                serializedName: "properties.lastModifiedUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, expirationDateUtc: {
                serializedName: "properties.expirationDateUtc",
                type: {
                    name: "DateTime"
                }
            }, reason: {
                serializedName: "properties.reason",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled", "Expired"]
                }
            }, comment: {
                serializedName: "properties.comment",
                type: {
                    name: "String"
                }
            }, suppressionAlertsScope: {
                serializedName: "properties.suppressionAlertsScope",
                type: {
                    name: "Composite",
                    className: "SuppressionAlertsScope"
                }
            } })
    }
};
const ServerVulnerabilityAssessment = {
    type: {
        name: "Composite",
        className: "ServerVulnerabilityAssessment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityAssessmentMetadataResponse = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadataResponse",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, policyDefinitionId: {
                serializedName: "properties.policyDefinitionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, remediationDescription: {
                serializedName: "properties.remediationDescription",
                type: {
                    name: "String"
                }
            }, categories: {
                serializedName: "properties.categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, severity: {
                serializedName: "properties.severity",
                type: {
                    name: "String"
                }
            }, userImpact: {
                serializedName: "properties.userImpact",
                type: {
                    name: "String"
                }
            }, implementationEffort: {
                serializedName: "properties.implementationEffort",
                type: {
                    name: "String"
                }
            }, threats: {
                serializedName: "properties.threats",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, preview: {
                serializedName: "properties.preview",
                type: {
                    name: "Boolean"
                }
            }, assessmentType: {
                serializedName: "properties.assessmentType",
                type: {
                    name: "String"
                }
            }, partnerData: {
                serializedName: "properties.partnerData",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataPartnerData"
                }
            }, publishDates: {
                serializedName: "properties.publishDates",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataPropertiesResponsePublishDates"
                }
            }, plannedDeprecationDate: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{2}\\/[0-9]{4}$")
                },
                serializedName: "properties.plannedDeprecationDate",
                type: {
                    name: "String"
                }
            }, tactics: {
                serializedName: "properties.tactics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, techniques: {
                serializedName: "properties.techniques",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SecurityAssessmentResponse = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentResponse",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { resourceDetails: {
                serializedName: "properties.resourceDetails",
                type: {
                    name: "Composite",
                    className: "ResourceDetails"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, additionalData: {
                serializedName: "properties.additionalData",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, links: {
                serializedName: "properties.links",
                type: {
                    name: "Composite",
                    className: "AssessmentLinks"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataProperties"
                }
            }, partnersData: {
                serializedName: "properties.partnersData",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentPartnerData"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "Composite",
                    className: "AssessmentStatusResponse"
                }
            } })
    }
};
const SecurityAssessment = {
    type: {
        name: "Composite",
        className: "SecurityAssessment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { resourceDetails: {
                serializedName: "properties.resourceDetails",
                type: {
                    name: "Composite",
                    className: "ResourceDetails"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, additionalData: {
                serializedName: "properties.additionalData",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, links: {
                serializedName: "properties.links",
                type: {
                    name: "Composite",
                    className: "AssessmentLinks"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataProperties"
                }
            }, partnersData: {
                serializedName: "properties.partnersData",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentPartnerData"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "Composite",
                    className: "AssessmentStatus"
                }
            } })
    }
};
const AdaptiveApplicationControlGroup = {
    type: {
        name: "Composite",
        className: "AdaptiveApplicationControlGroup",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Location.type.modelProperties), { enforcementMode: {
                serializedName: "properties.enforcementMode",
                type: {
                    name: "String"
                }
            }, protectionMode: {
                serializedName: "properties.protectionMode",
                type: {
                    name: "Composite",
                    className: "ProtectionMode"
                }
            }, configurationStatus: {
                serializedName: "properties.configurationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, recommendationStatus: {
                serializedName: "properties.recommendationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, issues: {
                serializedName: "properties.issues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdaptiveApplicationControlIssueSummary"
                        }
                    }
                }
            }, sourceSystem: {
                serializedName: "properties.sourceSystem",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vmRecommendations: {
                serializedName: "properties.vmRecommendations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VmRecommendation"
                        }
                    }
                }
            }, pathRecommendations: {
                serializedName: "properties.pathRecommendations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PathRecommendation"
                        }
                    }
                }
            } })
    }
};
const AdaptiveNetworkHardening = {
    type: {
        name: "Composite",
        className: "AdaptiveNetworkHardening",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Rule"
                        }
                    }
                }
            }, rulesCalculationTime: {
                serializedName: "properties.rulesCalculationTime",
                type: {
                    name: "DateTime"
                }
            }, effectiveNetworkSecurityGroups: {
                serializedName: "properties.effectiveNetworkSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityGroups"
                        }
                    }
                }
            } })
    }
};
const AllowedConnectionsResource = {
    type: {
        name: "Composite",
        className: "AllowedConnectionsResource",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Location.type.modelProperties), { calculatedDateTime: {
                serializedName: "properties.calculatedDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, connectableResources: {
                serializedName: "properties.connectableResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectableResource"
                        }
                    }
                }
            } })
    }
};
const TopologyResource = {
    type: {
        name: "Composite",
        className: "TopologyResource",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Location.type.modelProperties), { calculatedDateTime: {
                serializedName: "properties.calculatedDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, topologyResources: {
                serializedName: "properties.topologyResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologySingleResource"
                        }
                    }
                }
            } })
    }
};
const JitNetworkAccessPolicy = {
    type: {
        name: "Composite",
        className: "JitNetworkAccessPolicy",
        modelProperties: Object.assign(Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), KindAutoGenerated.type.modelProperties), Location.type.modelProperties), { virtualMachines: {
                serializedName: "properties.virtualMachines",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessPolicyVirtualMachine"
                        }
                    }
                }
            }, requests: {
                serializedName: "properties.requests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JitNetworkAccessRequest"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DiscoveredSecuritySolution = {
    type: {
        name: "Composite",
        className: "DiscoveredSecuritySolution",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Location.type.modelProperties), { securityFamily: {
                serializedName: "properties.securityFamily",
                required: true,
                type: {
                    name: "String"
                }
            }, offer: {
                serializedName: "properties.offer",
                required: true,
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                required: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "properties.sku",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecuritySolutionsReferenceData = {
    type: {
        name: "Composite",
        className: "SecuritySolutionsReferenceData",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Location.type.modelProperties), { securityFamily: {
                serializedName: "properties.securityFamily",
                required: true,
                type: {
                    name: "String"
                }
            }, alertVendorName: {
                serializedName: "properties.alertVendorName",
                required: true,
                type: {
                    name: "String"
                }
            }, packageInfoUrl: {
                serializedName: "properties.packageInfoUrl",
                required: true,
                type: {
                    name: "String"
                }
            }, productName: {
                serializedName: "properties.productName",
                required: true,
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                required: true,
                type: {
                    name: "String"
                }
            }, publisherDisplayName: {
                serializedName: "properties.publisherDisplayName",
                required: true,
                type: {
                    name: "String"
                }
            }, template: {
                serializedName: "properties.template",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExternalSecuritySolution = {
    serializedName: "ExternalSecuritySolution",
    type: {
        name: "Composite",
        className: "ExternalSecuritySolution",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), ExternalSecuritySolutionKindAutoGenerated.type.modelProperties), Location.type.modelProperties)
    }
};
const SecureScoreItem = {
    type: {
        name: "Composite",
        className: "SecureScoreItem",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, weight: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.weight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, max: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.score.max",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, current: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.score.current",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, percentage: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.score.percentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SecureScoreControlDefinitionItem = {
    type: {
        name: "Composite",
        className: "SecureScoreControlDefinitionItem",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, maxScore: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.maxScore",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "SecureScoreControlDefinitionSource"
                }
            }, assessmentDefinitions: {
                serializedName: "properties.assessmentDefinitions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureResourceLink"
                        }
                    }
                }
            } })
    }
};
const SecureScoreControlDetails = {
    type: {
        name: "Composite",
        className: "SecureScoreControlDetails",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, healthyResourceCount: {
                serializedName: "properties.healthyResourceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, unhealthyResourceCount: {
                serializedName: "properties.unhealthyResourceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, notApplicableResourceCount: {
                serializedName: "properties.notApplicableResourceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, weight: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.weight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, definition: {
                serializedName: "properties.definition",
                type: {
                    name: "Composite",
                    className: "SecureScoreControlDefinitionItem"
                }
            }, max: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.score.max",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, current: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.score.current",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, percentage: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.score.percentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const SecuritySolution = {
    type: {
        name: "Composite",
        className: "SecuritySolution",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Location.type.modelProperties), { securityFamily: {
                serializedName: "properties.securityFamily",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, template: {
                serializedName: "properties.template",
                type: {
                    name: "String"
                }
            }, protectionStatus: {
                serializedName: "properties.protectionStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectorSetting = {
    type: {
        name: "Composite",
        className: "ConnectorSetting",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { hybridComputeSettings: {
                serializedName: "properties.hybridComputeSettings",
                type: {
                    name: "Composite",
                    className: "HybridComputeSettingsProperties"
                }
            }, authenticationDetails: {
                serializedName: "properties.authenticationDetails",
                type: {
                    name: "Composite",
                    className: "AuthenticationDetailsProperties"
                }
            } })
    }
};
const Scan = {
    type: {
        name: "Composite",
        className: "Scan",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ScanProperties"
                }
            } })
    }
};
const ScanResult = {
    type: {
        name: "Composite",
        className: "ScanResult",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ScanResultProperties"
                }
            } })
    }
};
const RuleResults = {
    type: {
        name: "Composite",
        className: "RuleResults",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "RuleResultsProperties"
                }
            } })
    }
};
const Alert = {
    type: {
        name: "Composite",
        className: "Alert",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { alertType: {
                serializedName: "properties.alertType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, systemAlertId: {
                serializedName: "properties.systemAlertId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, productComponentName: {
                serializedName: "properties.productComponentName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, alertDisplayName: {
                serializedName: "properties.alertDisplayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, severity: {
                serializedName: "properties.severity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, intent: {
                serializedName: "properties.intent",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTimeUtc: {
                serializedName: "properties.startTimeUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, endTimeUtc: {
                serializedName: "properties.endTimeUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, resourceIdentifiers: {
                serializedName: "properties.resourceIdentifiers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceIdentifier"
                        }
                    }
                }
            }, remediationSteps: {
                serializedName: "properties.remediationSteps",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, vendorName: {
                serializedName: "properties.vendorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, extendedLinks: {
                serializedName: "properties.extendedLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "String" } }
                        }
                    }
                }
            }, alertUri: {
                serializedName: "properties.alertUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timeGeneratedUtc: {
                serializedName: "properties.timeGeneratedUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, productName: {
                serializedName: "properties.productName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, processingEndTimeUtc: {
                serializedName: "properties.processingEndTimeUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, entities: {
                serializedName: "properties.entities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AlertEntity"
                        }
                    }
                }
            }, isIncident: {
                serializedName: "properties.isIncident",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, correlationKey: {
                serializedName: "properties.correlationKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, extendedProperties: {
                serializedName: "properties.extendedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, compromisedEntity: {
                serializedName: "properties.compromisedEntity",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Setting = {
    serializedName: "Setting",
    type: {
        name: "Composite",
        className: "Setting",
        uberParent: "Resource",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IngestionSetting = {
    type: {
        name: "Composite",
        className: "IngestionSetting",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const Software = {
    type: {
        name: "Composite",
        className: "Software",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { deviceId: {
                serializedName: "properties.deviceId",
                type: {
                    name: "String"
                }
            }, osPlatform: {
                serializedName: "properties.osPlatform",
                type: {
                    name: "String"
                }
            }, vendor: {
                serializedName: "properties.vendor",
                type: {
                    name: "String"
                }
            }, softwareName: {
                serializedName: "properties.softwareName",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                type: {
                    name: "String"
                }
            }, endOfSupportStatus: {
                serializedName: "properties.endOfSupportStatus",
                type: {
                    name: "String"
                }
            }, endOfSupportDate: {
                serializedName: "properties.endOfSupportDate",
                type: {
                    name: "String"
                }
            }, numberOfKnownVulnerabilities: {
                serializedName: "properties.numberOfKnownVulnerabilities",
                type: {
                    name: "Number"
                }
            }, firstSeenAt: {
                serializedName: "properties.firstSeenAt",
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityAssessmentMetadata = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadata",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, policyDefinitionId: {
                serializedName: "properties.policyDefinitionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, remediationDescription: {
                serializedName: "properties.remediationDescription",
                type: {
                    name: "String"
                }
            }, categories: {
                serializedName: "properties.categories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, severity: {
                serializedName: "properties.severity",
                type: {
                    name: "String"
                }
            }, userImpact: {
                serializedName: "properties.userImpact",
                type: {
                    name: "String"
                }
            }, implementationEffort: {
                serializedName: "properties.implementationEffort",
                type: {
                    name: "String"
                }
            }, threats: {
                serializedName: "properties.threats",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, preview: {
                serializedName: "properties.preview",
                type: {
                    name: "Boolean"
                }
            }, assessmentType: {
                serializedName: "properties.assessmentType",
                type: {
                    name: "String"
                }
            }, partnerData: {
                serializedName: "properties.partnerData",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataPartnerData"
                }
            } })
    }
};
const ThresholdCustomAlertRule = {
    serializedName: "ThresholdCustomAlertRule",
    type: {
        name: "Composite",
        className: "ThresholdCustomAlertRule",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: Object.assign(Object.assign({}, CustomAlertRule.type.modelProperties), { minThreshold: {
                serializedName: "minThreshold",
                required: true,
                type: {
                    name: "Number"
                }
            }, maxThreshold: {
                serializedName: "maxThreshold",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ListCustomAlertRule = {
    serializedName: "ListCustomAlertRule",
    type: {
        name: "Composite",
        className: "ListCustomAlertRule",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: Object.assign(Object.assign({}, CustomAlertRule.type.modelProperties), { valueType: {
                serializedName: "valueType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const UpdateIotSecuritySolutionData = {
    type: {
        name: "Composite",
        className: "UpdateIotSecuritySolutionData",
        modelProperties: Object.assign(Object.assign({}, TagsResource.type.modelProperties), { userDefinedResources: {
                serializedName: "properties.userDefinedResources",
                type: {
                    name: "Composite",
                    className: "UserDefinedResourcesProperties"
                }
            }, recommendationsConfiguration: {
                serializedName: "properties.recommendationsConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecommendationConfigurationProperties"
                        }
                    }
                }
            } })
    }
};
const AzureResourceDetails = {
    serializedName: "Azure",
    type: {
        name: "Composite",
        className: "AzureResourceDetails",
        uberParent: "ResourceDetails",
        polymorphicDiscriminator: ResourceDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ResourceDetails.type.modelProperties), { id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OnPremiseResourceDetails = {
    serializedName: "OnPremise",
    type: {
        name: "Composite",
        className: "OnPremiseResourceDetails",
        uberParent: "ResourceDetails",
        polymorphicDiscriminator: {
            serializedName: "source",
            clientName: "source"
        },
        modelProperties: Object.assign(Object.assign({}, ResourceDetails.type.modelProperties), { workspaceId: {
                serializedName: "workspaceId",
                required: true,
                type: {
                    name: "String"
                }
            }, vmuuid: {
                serializedName: "vmuuid",
                required: true,
                type: {
                    name: "String"
                }
            }, sourceComputerId: {
                serializedName: "sourceComputerId",
                required: true,
                type: {
                    name: "String"
                }
            }, machineName: {
                serializedName: "machineName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlServerVulnerabilityProperties = {
    serializedName: "SqlServerVulnerability",
    type: {
        name: "Composite",
        className: "SqlServerVulnerabilityProperties",
        uberParent: "AdditionalData",
        polymorphicDiscriminator: AdditionalData.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdditionalData.type.modelProperties), { type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, query: {
                serializedName: "query",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ContainerRegistryVulnerabilityProperties = {
    serializedName: "ContainerRegistryVulnerability",
    type: {
        name: "Composite",
        className: "ContainerRegistryVulnerabilityProperties",
        uberParent: "AdditionalData",
        polymorphicDiscriminator: AdditionalData.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdditionalData.type.modelProperties), { type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, cvss: {
                serializedName: "cvss",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "Cvss" } }
                }
            }, patchable: {
                serializedName: "patchable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, cve: {
                serializedName: "cve",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cve"
                        }
                    }
                }
            }, publishedTime: {
                serializedName: "publishedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, vendorReferences: {
                serializedName: "vendorReferences",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VendorReference"
                        }
                    }
                }
            }, repositoryName: {
                serializedName: "repositoryName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, imageDigest: {
                serializedName: "imageDigest",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServerVulnerabilityProperties = {
    serializedName: "ServerVulnerabilityAssessment",
    type: {
        name: "Composite",
        className: "ServerVulnerabilityProperties",
        uberParent: "AdditionalData",
        polymorphicDiscriminator: AdditionalData.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdditionalData.type.modelProperties), { type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, cvss: {
                serializedName: "cvss",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "Cvss" } }
                }
            }, patchable: {
                serializedName: "patchable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, cve: {
                serializedName: "cve",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cve"
                        }
                    }
                }
            }, threat: {
                serializedName: "threat",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publishedTime: {
                serializedName: "publishedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, vendorReferences: {
                serializedName: "vendorReferences",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VendorReference"
                        }
                    }
                }
            } })
    }
};
const AutomationActionLogicApp = {
    serializedName: "LogicApp",
    type: {
        name: "Composite",
        className: "AutomationActionLogicApp",
        uberParent: "AutomationAction",
        polymorphicDiscriminator: AutomationAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AutomationAction.type.modelProperties), { logicAppResourceId: {
                serializedName: "logicAppResourceId",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            } })
    }
};
const AutomationActionEventHub = {
    serializedName: "EventHub",
    type: {
        name: "Composite",
        className: "AutomationActionEventHub",
        uberParent: "AutomationAction",
        polymorphicDiscriminator: AutomationAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AutomationAction.type.modelProperties), { eventHubResourceId: {
                serializedName: "eventHubResourceId",
                type: {
                    name: "String"
                }
            }, sasPolicyName: {
                serializedName: "sasPolicyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "String"
                }
            } })
    }
};
const AutomationActionWorkspace = {
    serializedName: "Workspace",
    type: {
        name: "Composite",
        className: "AutomationActionWorkspace",
        uberParent: "AutomationAction",
        polymorphicDiscriminator: AutomationAction.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AutomationAction.type.modelProperties), { workspaceResourceId: {
                serializedName: "workspaceResourceId",
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityAssessmentMetadataPropertiesResponse = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentMetadataPropertiesResponse",
        modelProperties: Object.assign(Object.assign({}, SecurityAssessmentMetadataProperties.type.modelProperties), { publishDates: {
                serializedName: "publishDates",
                type: {
                    name: "Composite",
                    className: "SecurityAssessmentMetadataPropertiesResponsePublishDates"
                }
            }, plannedDeprecationDate: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{2}\\/[0-9]{4}$")
                },
                serializedName: "plannedDeprecationDate",
                type: {
                    name: "String"
                }
            }, tactics: {
                serializedName: "tactics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, techniques: {
                serializedName: "techniques",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const AssessmentStatusResponse = {
    type: {
        name: "Composite",
        className: "AssessmentStatusResponse",
        modelProperties: Object.assign(Object.assign({}, AssessmentStatus.type.modelProperties), { firstEvaluationDate: {
                serializedName: "firstEvaluationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, statusChangeDate: {
                serializedName: "statusChangeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const SecurityAssessmentPropertiesResponse = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentPropertiesResponse",
        modelProperties: Object.assign(Object.assign({}, SecurityAssessmentPropertiesBase.type.modelProperties), { status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "AssessmentStatusResponse"
                }
            } })
    }
};
const SecurityAssessmentProperties = {
    type: {
        name: "Composite",
        className: "SecurityAssessmentProperties",
        modelProperties: Object.assign(Object.assign({}, SecurityAssessmentPropertiesBase.type.modelProperties), { status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "AssessmentStatus"
                }
            } })
    }
};
const AwsCredsAuthenticationDetailsProperties = {
    serializedName: "awsCreds",
    type: {
        name: "Composite",
        className: "AwsCredsAuthenticationDetailsProperties",
        uberParent: "AuthenticationDetailsProperties",
        polymorphicDiscriminator: AuthenticationDetailsProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AuthenticationDetailsProperties.type.modelProperties), { accountId: {
                serializedName: "accountId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, awsAccessKeyId: {
                serializedName: "awsAccessKeyId",
                required: true,
                type: {
                    name: "String"
                }
            }, awsSecretAccessKey: {
                serializedName: "awsSecretAccessKey",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AwAssumeRoleAuthenticationDetailsProperties = {
    serializedName: "awsAssumeRole",
    type: {
        name: "Composite",
        className: "AwAssumeRoleAuthenticationDetailsProperties",
        uberParent: "AuthenticationDetailsProperties",
        polymorphicDiscriminator: AuthenticationDetailsProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AuthenticationDetailsProperties.type.modelProperties), { accountId: {
                serializedName: "accountId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, awsAssumeRoleArn: {
                serializedName: "awsAssumeRoleArn",
                required: true,
                type: {
                    name: "String"
                }
            }, awsExternalId: {
                serializedName: "awsExternalId",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const GcpCredentialsDetailsProperties = {
    serializedName: "gcpCredentials",
    type: {
        name: "Composite",
        className: "GcpCredentialsDetailsProperties",
        uberParent: "AuthenticationDetailsProperties",
        polymorphicDiscriminator: AuthenticationDetailsProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AuthenticationDetailsProperties.type.modelProperties), { organizationId: {
                serializedName: "organizationId",
                required: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }, projectId: {
                serializedName: "projectId",
                required: true,
                type: {
                    name: "String"
                }
            }, privateKeyId: {
                serializedName: "privateKeyId",
                required: true,
                type: {
                    name: "String"
                }
            }, privateKey: {
                serializedName: "privateKey",
                required: true,
                type: {
                    name: "String"
                }
            }, clientEmail: {
                serializedName: "clientEmail",
                required: true,
                type: {
                    name: "String"
                }
            }, clientId: {
                serializedName: "clientId",
                required: true,
                type: {
                    name: "String"
                }
            }, authUri: {
                serializedName: "authUri",
                required: true,
                type: {
                    name: "String"
                }
            }, tokenUri: {
                serializedName: "tokenUri",
                required: true,
                type: {
                    name: "String"
                }
            }, authProviderX509CertUrl: {
                serializedName: "authProviderX509CertUrl",
                required: true,
                type: {
                    name: "String"
                }
            }, clientX509CertUrl: {
                serializedName: "clientX509CertUrl",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureResourceIdentifier = {
    serializedName: "AzureResource",
    type: {
        name: "Composite",
        className: "AzureResourceIdentifier",
        uberParent: "ResourceIdentifier",
        polymorphicDiscriminator: ResourceIdentifier.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ResourceIdentifier.type.modelProperties), { azureResourceId: {
                serializedName: "azureResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LogAnalyticsIdentifier = {
    serializedName: "LogAnalytics",
    type: {
        name: "Composite",
        className: "LogAnalyticsIdentifier",
        uberParent: "ResourceIdentifier",
        polymorphicDiscriminator: ResourceIdentifier.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ResourceIdentifier.type.modelProperties), { workspaceId: {
                serializedName: "workspaceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, workspaceSubscriptionId: {
                constraints: {
                    Pattern: new RegExp("^[0-9A-Fa-f]{8}-([0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}$")
                },
                serializedName: "workspaceSubscriptionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, workspaceResourceGroup: {
                serializedName: "workspaceResourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, agentId: {
                serializedName: "agentId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AlertSimulatorBundlesRequestProperties = {
    serializedName: "Bundles",
    type: {
        name: "Composite",
        className: "AlertSimulatorBundlesRequestProperties",
        uberParent: "AlertSimulatorRequestProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: AlertSimulatorRequestProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AlertSimulatorRequestProperties.type.modelProperties), { bundles: {
                serializedName: "bundles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const CspmMonitorAwsOffering = {
    serializedName: "CspmMonitorAws",
    type: {
        name: "Composite",
        className: "CspmMonitorAwsOffering",
        uberParent: "CloudOffering",
        polymorphicDiscriminator: CloudOffering.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CloudOffering.type.modelProperties), { nativeCloudConnection: {
                serializedName: "nativeCloudConnection",
                type: {
                    name: "Composite",
                    className: "CspmMonitorAwsOfferingNativeCloudConnection"
                }
            } })
    }
};
const DefenderForContainersAwsOffering = {
    serializedName: "DefenderForContainersAws",
    type: {
        name: "Composite",
        className: "DefenderForContainersAwsOffering",
        uberParent: "CloudOffering",
        polymorphicDiscriminator: CloudOffering.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CloudOffering.type.modelProperties), { kubernetesService: {
                serializedName: "kubernetesService",
                type: {
                    name: "Composite",
                    className: "DefenderForContainersAwsOfferingKubernetesService"
                }
            }, kubernetesScubaReader: {
                serializedName: "kubernetesScubaReader",
                type: {
                    name: "Composite",
                    className: "DefenderForContainersAwsOfferingKubernetesScubaReader"
                }
            }, cloudWatchToKinesis: {
                serializedName: "cloudWatchToKinesis",
                type: {
                    name: "Composite",
                    className: "DefenderForContainersAwsOfferingCloudWatchToKinesis"
                }
            }, kinesisToS3: {
                serializedName: "kinesisToS3",
                type: {
                    name: "Composite",
                    className: "DefenderForContainersAwsOfferingKinesisToS3"
                }
            } })
    }
};
const DefenderForServersAwsOffering = {
    serializedName: "DefenderForServersAws",
    type: {
        name: "Composite",
        className: "DefenderForServersAwsOffering",
        uberParent: "CloudOffering",
        polymorphicDiscriminator: CloudOffering.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CloudOffering.type.modelProperties), { defenderForServers: {
                serializedName: "defenderForServers",
                type: {
                    name: "Composite",
                    className: "DefenderForServersAwsOfferingDefenderForServers"
                }
            }, arcAutoProvisioning: {
                serializedName: "arcAutoProvisioning",
                type: {
                    name: "Composite",
                    className: "DefenderForServersAwsOfferingArcAutoProvisioning"
                }
            } })
    }
};
const InformationProtectionAwsOffering = {
    serializedName: "InformationProtectionAws",
    type: {
        name: "Composite",
        className: "InformationProtectionAwsOffering",
        uberParent: "CloudOffering",
        polymorphicDiscriminator: CloudOffering.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CloudOffering.type.modelProperties), { informationProtection: {
                serializedName: "informationProtection",
                type: {
                    name: "Composite",
                    className: "InformationProtectionAwsOfferingInformationProtection"
                }
            } })
    }
};
const CefSolutionProperties = {
    type: {
        name: "Composite",
        className: "CefSolutionProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, ExternalSecuritySolutionProperties.type.modelProperties), { hostname: {
                serializedName: "hostname",
                type: {
                    name: "String"
                }
            }, agent: {
                serializedName: "agent",
                type: {
                    name: "String"
                }
            }, lastEventReceived: {
                serializedName: "lastEventReceived",
                type: {
                    name: "String"
                }
            } })
    }
};
const AtaSolutionProperties = {
    type: {
        name: "Composite",
        className: "AtaSolutionProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, ExternalSecuritySolutionProperties.type.modelProperties), { lastEventReceived: {
                serializedName: "lastEventReceived",
                type: {
                    name: "String"
                }
            } })
    }
};
const AadSolutionProperties = {
    type: {
        name: "Composite",
        className: "AadSolutionProperties",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, ExternalSecuritySolutionProperties.type.modelProperties), AadConnectivityStateAutoGenerated.type.modelProperties)
    }
};
const Automation = {
    type: {
        name: "Composite",
        className: "Automation",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, isEnabled: {
                serializedName: "properties.isEnabled",
                type: {
                    name: "Boolean"
                }
            }, scopes: {
                serializedName: "properties.scopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutomationScope"
                        }
                    }
                }
            }, sources: {
                serializedName: "properties.sources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutomationSource"
                        }
                    }
                }
            }, actions: {
                serializedName: "properties.actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutomationAction"
                        }
                    }
                }
            } })
    }
};
const SecurityConnector = {
    type: {
        name: "Composite",
        className: "SecurityConnector",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, hierarchyIdentifier: {
                serializedName: "properties.hierarchyIdentifier",
                type: {
                    name: "String"
                }
            }, cloudName: {
                serializedName: "properties.cloudName",
                type: {
                    name: "String"
                }
            }, offerings: {
                serializedName: "properties.offerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudOffering"
                        }
                    }
                }
            }, organizationalData: {
                serializedName: "properties.organizationalData",
                type: {
                    name: "Composite",
                    className: "SecurityConnectorPropertiesOrganizationalData"
                }
            } })
    }
};
const CefExternalSecuritySolution = {
    serializedName: "CEF",
    type: {
        name: "Composite",
        className: "CefExternalSecuritySolution",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ExternalSecuritySolution.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CefSolutionProperties"
                }
            } })
    }
};
const AtaExternalSecuritySolution = {
    serializedName: "ATA",
    type: {
        name: "Composite",
        className: "AtaExternalSecuritySolution",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ExternalSecuritySolution.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AtaSolutionProperties"
                }
            } })
    }
};
const AadExternalSecuritySolution = {
    serializedName: "AAD",
    type: {
        name: "Composite",
        className: "AadExternalSecuritySolution",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ExternalSecuritySolution.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AadSolutionProperties"
                }
            } })
    }
};
const DataExportSettings = {
    serializedName: "DataExportSettings",
    type: {
        name: "Composite",
        className: "DataExportSettings",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Setting.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const AlertSyncSettings = {
    serializedName: "AlertSyncSettings",
    type: {
        name: "Composite",
        className: "AlertSyncSettings",
        uberParent: "Resource",
        polymorphicDiscriminator: Resource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Setting.type.modelProperties), { enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const TimeWindowCustomAlertRule = {
    serializedName: "TimeWindowCustomAlertRule",
    type: {
        name: "Composite",
        className: "TimeWindowCustomAlertRule",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: Object.assign(Object.assign({}, ThresholdCustomAlertRule.type.modelProperties), { timeWindowSize: {
                serializedName: "timeWindowSize",
                required: true,
                type: {
                    name: "TimeSpan"
                }
            } })
    }
};
const AllowlistCustomAlertRule = {
    serializedName: "AllowlistCustomAlertRule",
    type: {
        name: "Composite",
        className: "AllowlistCustomAlertRule",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: Object.assign(Object.assign({}, ListCustomAlertRule.type.modelProperties), { allowlistValues: {
                serializedName: "allowlistValues",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const DenylistCustomAlertRule = {
    serializedName: "DenylistCustomAlertRule",
    type: {
        name: "Composite",
        className: "DenylistCustomAlertRule",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ListCustomAlertRule.type.modelProperties), { denylistValues: {
                serializedName: "denylistValues",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const OnPremiseSqlResourceDetails = {
    serializedName: "OnPremiseSql",
    type: {
        name: "Composite",
        className: "OnPremiseSqlResourceDetails",
        uberParent: "ResourceDetails",
        polymorphicDiscriminator: ResourceDetails.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OnPremiseResourceDetails.type.modelProperties), { serverName: {
                serializedName: "serverName",
                required: true,
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "databaseName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ActiveConnectionsNotInAllowedRange = {
    serializedName: "ActiveConnectionsNotInAllowedRange",
    type: {
        name: "Composite",
        className: "ActiveConnectionsNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const AmqpC2DMessagesNotInAllowedRange = {
    serializedName: "AmqpC2DMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "AmqpC2DMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const MqttC2DMessagesNotInAllowedRange = {
    serializedName: "MqttC2DMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "MqttC2DMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const HttpC2DMessagesNotInAllowedRange = {
    serializedName: "HttpC2DMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "HttpC2DMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const AmqpC2DRejectedMessagesNotInAllowedRange = {
    serializedName: "AmqpC2DRejectedMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "AmqpC2DRejectedMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const MqttC2DRejectedMessagesNotInAllowedRange = {
    serializedName: "MqttC2DRejectedMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "MqttC2DRejectedMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const HttpC2DRejectedMessagesNotInAllowedRange = {
    serializedName: "HttpC2DRejectedMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "HttpC2DRejectedMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const AmqpD2CMessagesNotInAllowedRange = {
    serializedName: "AmqpD2CMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "AmqpD2CMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const MqttD2CMessagesNotInAllowedRange = {
    serializedName: "MqttD2CMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "MqttD2CMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const HttpD2CMessagesNotInAllowedRange = {
    serializedName: "HttpD2CMessagesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "HttpD2CMessagesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const DirectMethodInvokesNotInAllowedRange = {
    serializedName: "DirectMethodInvokesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "DirectMethodInvokesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const FailedLocalLoginsNotInAllowedRange = {
    serializedName: "FailedLocalLoginsNotInAllowedRange",
    type: {
        name: "Composite",
        className: "FailedLocalLoginsNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const FileUploadsNotInAllowedRange = {
    serializedName: "FileUploadsNotInAllowedRange",
    type: {
        name: "Composite",
        className: "FileUploadsNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const QueuePurgesNotInAllowedRange = {
    serializedName: "QueuePurgesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "QueuePurgesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const TwinUpdatesNotInAllowedRange = {
    serializedName: "TwinUpdatesNotInAllowedRange",
    type: {
        name: "Composite",
        className: "TwinUpdatesNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const UnauthorizedOperationsNotInAllowedRange = {
    serializedName: "UnauthorizedOperationsNotInAllowedRange",
    type: {
        name: "Composite",
        className: "UnauthorizedOperationsNotInAllowedRange",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TimeWindowCustomAlertRule.type.modelProperties)
    }
};
const ConnectionToIpNotAllowed = {
    serializedName: "ConnectionToIpNotAllowed",
    type: {
        name: "Composite",
        className: "ConnectionToIpNotAllowed",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AllowlistCustomAlertRule.type.modelProperties)
    }
};
const ConnectionFromIpNotAllowed = {
    serializedName: "ConnectionFromIpNotAllowed",
    type: {
        name: "Composite",
        className: "ConnectionFromIpNotAllowed",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AllowlistCustomAlertRule.type.modelProperties)
    }
};
const LocalUserNotAllowed = {
    serializedName: "LocalUserNotAllowed",
    type: {
        name: "Composite",
        className: "LocalUserNotAllowed",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AllowlistCustomAlertRule.type.modelProperties)
    }
};
const ProcessNotAllowed = {
    serializedName: "ProcessNotAllowed",
    type: {
        name: "Composite",
        className: "ProcessNotAllowed",
        uberParent: "CustomAlertRule",
        polymorphicDiscriminator: CustomAlertRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AllowlistCustomAlertRule.type.modelProperties)
    }
};
let discriminators = {
    CustomAlertRule: CustomAlertRule,
    ResourceDetails: ResourceDetails,
    AdditionalData: AdditionalData,
    AutomationAction: AutomationAction,
    AuthenticationDetailsProperties: AuthenticationDetailsProperties,
    ResourceIdentifier: ResourceIdentifier,
    AlertSimulatorRequestProperties: AlertSimulatorRequestProperties,
    CloudOffering: CloudOffering,
    "Resource.ExternalSecuritySolution": ExternalSecuritySolution,
    "Resource.Setting": Setting,
    "CustomAlertRule.ThresholdCustomAlertRule": ThresholdCustomAlertRule,
    "CustomAlertRule.ListCustomAlertRule": ListCustomAlertRule,
    "ResourceDetails.Azure": AzureResourceDetails,
    "ResourceDetails.OnPremise": OnPremiseResourceDetails,
    "AdditionalData.SqlServerVulnerability": SqlServerVulnerabilityProperties,
    "AdditionalData.ContainerRegistryVulnerability": ContainerRegistryVulnerabilityProperties,
    "AdditionalData.ServerVulnerabilityAssessment": ServerVulnerabilityProperties,
    "AutomationAction.LogicApp": AutomationActionLogicApp,
    "AutomationAction.EventHub": AutomationActionEventHub,
    "AutomationAction.Workspace": AutomationActionWorkspace,
    "AuthenticationDetailsProperties.awsCreds": AwsCredsAuthenticationDetailsProperties,
    "AuthenticationDetailsProperties.awsAssumeRole": AwAssumeRoleAuthenticationDetailsProperties,
    "AuthenticationDetailsProperties.gcpCredentials": GcpCredentialsDetailsProperties,
    "ResourceIdentifier.AzureResource": AzureResourceIdentifier,
    "ResourceIdentifier.LogAnalytics": LogAnalyticsIdentifier,
    "AlertSimulatorRequestProperties.Bundles": AlertSimulatorBundlesRequestProperties,
    "CloudOffering.CspmMonitorAws": CspmMonitorAwsOffering,
    "CloudOffering.DefenderForContainersAws": DefenderForContainersAwsOffering,
    "CloudOffering.DefenderForServersAws": DefenderForServersAwsOffering,
    "CloudOffering.InformationProtectionAws": InformationProtectionAwsOffering,
    "Resource.CEF": CefExternalSecuritySolution,
    "Resource.ATA": AtaExternalSecuritySolution,
    "Resource.AAD": AadExternalSecuritySolution,
    "Resource.DataExportSettings": DataExportSettings,
    "Resource.AlertSyncSettings": AlertSyncSettings,
    "CustomAlertRule.TimeWindowCustomAlertRule": TimeWindowCustomAlertRule,
    "CustomAlertRule.AllowlistCustomAlertRule": AllowlistCustomAlertRule,
    "CustomAlertRule.DenylistCustomAlertRule": DenylistCustomAlertRule,
    "ResourceDetails.OnPremiseSql": OnPremiseSqlResourceDetails,
    "CustomAlertRule.ActiveConnectionsNotInAllowedRange": ActiveConnectionsNotInAllowedRange,
    "CustomAlertRule.AmqpC2DMessagesNotInAllowedRange": AmqpC2DMessagesNotInAllowedRange,
    "CustomAlertRule.MqttC2DMessagesNotInAllowedRange": MqttC2DMessagesNotInAllowedRange,
    "CustomAlertRule.HttpC2DMessagesNotInAllowedRange": HttpC2DMessagesNotInAllowedRange,
    "CustomAlertRule.AmqpC2DRejectedMessagesNotInAllowedRange": AmqpC2DRejectedMessagesNotInAllowedRange,
    "CustomAlertRule.MqttC2DRejectedMessagesNotInAllowedRange": MqttC2DRejectedMessagesNotInAllowedRange,
    "CustomAlertRule.HttpC2DRejectedMessagesNotInAllowedRange": HttpC2DRejectedMessagesNotInAllowedRange,
    "CustomAlertRule.AmqpD2CMessagesNotInAllowedRange": AmqpD2CMessagesNotInAllowedRange,
    "CustomAlertRule.MqttD2CMessagesNotInAllowedRange": MqttD2CMessagesNotInAllowedRange,
    "CustomAlertRule.HttpD2CMessagesNotInAllowedRange": HttpD2CMessagesNotInAllowedRange,
    "CustomAlertRule.DirectMethodInvokesNotInAllowedRange": DirectMethodInvokesNotInAllowedRange,
    "CustomAlertRule.FailedLocalLoginsNotInAllowedRange": FailedLocalLoginsNotInAllowedRange,
    "CustomAlertRule.FileUploadsNotInAllowedRange": FileUploadsNotInAllowedRange,
    "CustomAlertRule.QueuePurgesNotInAllowedRange": QueuePurgesNotInAllowedRange,
    "CustomAlertRule.TwinUpdatesNotInAllowedRange": TwinUpdatesNotInAllowedRange,
    "CustomAlertRule.UnauthorizedOperationsNotInAllowedRange": UnauthorizedOperationsNotInAllowedRange,
    "CustomAlertRule.ConnectionToIpNotAllowed": ConnectionToIpNotAllowed,
    "CustomAlertRule.ConnectionFromIpNotAllowed": ConnectionFromIpNotAllowed,
    "CustomAlertRule.LocalUserNotAllowed": LocalUserNotAllowed,
    "CustomAlertRule.ProcessNotAllowed": ProcessNotAllowed
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MdeOnboardingDataList: MdeOnboardingDataList,
    Resource: Resource,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    SystemData: SystemData,
    CustomAssessmentAutomationsListResult: CustomAssessmentAutomationsListResult,
    CustomEntityStoreAssignmentRequest: CustomEntityStoreAssignmentRequest,
    CustomEntityStoreAssignmentsListResult: CustomEntityStoreAssignmentsListResult,
    ComplianceResultList: ComplianceResultList,
    PricingList: PricingList,
    DeviceSecurityGroupList: DeviceSecurityGroupList,
    CustomAlertRule: CustomAlertRule,
    IoTSecuritySolutionsList: IoTSecuritySolutionsList,
    UserDefinedResourcesProperties: UserDefinedResourcesProperties,
    RecommendationConfigurationProperties: RecommendationConfigurationProperties,
    AdditionalWorkspacesProperties: AdditionalWorkspacesProperties,
    TagsResource: TagsResource,
    IoTSecuritySolutionAnalyticsModelList: IoTSecuritySolutionAnalyticsModelList,
    IoTSeverityMetrics: IoTSeverityMetrics,
    IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem: IoTSecuritySolutionAnalyticsModelPropertiesDevicesMetricsItem,
    IoTSecurityAlertedDevice: IoTSecurityAlertedDevice,
    IoTSecurityDeviceAlert: IoTSecurityDeviceAlert,
    IoTSecurityDeviceRecommendation: IoTSecurityDeviceRecommendation,
    IoTSecurityAggregatedAlertList: IoTSecurityAggregatedAlertList,
    IoTSecurityAggregatedAlertPropertiesTopDevicesListItem: IoTSecurityAggregatedAlertPropertiesTopDevicesListItem,
    IoTSecurityAggregatedRecommendationList: IoTSecurityAggregatedRecommendationList,
    AscLocationList: AscLocationList,
    OperationList: OperationList,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    SecurityTaskList: SecurityTaskList,
    SecurityTaskParameters: SecurityTaskParameters,
    AutoProvisioningSettingList: AutoProvisioningSettingList,
    ComplianceList: ComplianceList,
    ComplianceSegment: ComplianceSegment,
    SensitivityLabel: SensitivityLabel,
    InformationType: InformationType,
    InformationProtectionKeyword: InformationProtectionKeyword,
    InformationProtectionPolicyList: InformationProtectionPolicyList,
    SecurityContactList: SecurityContactList,
    WorkspaceSettingList: WorkspaceSettingList,
    RegulatoryComplianceStandardList: RegulatoryComplianceStandardList,
    RegulatoryComplianceControlList: RegulatoryComplianceControlList,
    RegulatoryComplianceAssessmentList: RegulatoryComplianceAssessmentList,
    SecuritySubAssessmentList: SecuritySubAssessmentList,
    SubAssessmentStatus: SubAssessmentStatus,
    ResourceDetails: ResourceDetails,
    AdditionalData: AdditionalData,
    AutomationList: AutomationList,
    AutomationScope: AutomationScope,
    AutomationSource: AutomationSource,
    AutomationRuleSet: AutomationRuleSet,
    AutomationTriggeringRule: AutomationTriggeringRule,
    AutomationAction: AutomationAction,
    AzureTrackedResourceLocation: AzureTrackedResourceLocation,
    KindAutoGenerated: KindAutoGenerated,
    ETag: ETag,
    Tags: Tags,
    AutomationValidationStatus: AutomationValidationStatus,
    AlertsSuppressionRulesList: AlertsSuppressionRulesList,
    SuppressionAlertsScope: SuppressionAlertsScope,
    ScopeElement: ScopeElement,
    ServerVulnerabilityAssessmentsList: ServerVulnerabilityAssessmentsList,
    SecurityAssessmentMetadataResponseList: SecurityAssessmentMetadataResponseList,
    SecurityAssessmentMetadataPropertiesResponsePublishDates: SecurityAssessmentMetadataPropertiesResponsePublishDates,
    SecurityAssessmentMetadataProperties: SecurityAssessmentMetadataProperties,
    SecurityAssessmentMetadataPartnerData: SecurityAssessmentMetadataPartnerData,
    SecurityAssessmentList: SecurityAssessmentList,
    AssessmentStatus: AssessmentStatus,
    SecurityAssessmentPropertiesBase: SecurityAssessmentPropertiesBase,
    AssessmentLinks: AssessmentLinks,
    SecurityAssessmentPartnerData: SecurityAssessmentPartnerData,
    AdaptiveApplicationControlGroups: AdaptiveApplicationControlGroups,
    ProtectionMode: ProtectionMode,
    AdaptiveApplicationControlIssueSummary: AdaptiveApplicationControlIssueSummary,
    VmRecommendation: VmRecommendation,
    PathRecommendation: PathRecommendation,
    PublisherInfo: PublisherInfo,
    UserRecommendation: UserRecommendation,
    Location: Location,
    AdaptiveNetworkHardeningsList: AdaptiveNetworkHardeningsList,
    Rule: Rule,
    EffectiveNetworkSecurityGroups: EffectiveNetworkSecurityGroups,
    AdaptiveNetworkHardeningEnforceRequest: AdaptiveNetworkHardeningEnforceRequest,
    AllowedConnectionsList: AllowedConnectionsList,
    ConnectableResource: ConnectableResource,
    ConnectedResource: ConnectedResource,
    TopologyList: TopologyList,
    TopologySingleResource: TopologySingleResource,
    TopologySingleResourceParent: TopologySingleResourceParent,
    TopologySingleResourceChild: TopologySingleResourceChild,
    JitNetworkAccessPoliciesList: JitNetworkAccessPoliciesList,
    JitNetworkAccessPolicyVirtualMachine: JitNetworkAccessPolicyVirtualMachine,
    JitNetworkAccessPortRule: JitNetworkAccessPortRule,
    JitNetworkAccessRequest: JitNetworkAccessRequest,
    JitNetworkAccessRequestVirtualMachine: JitNetworkAccessRequestVirtualMachine,
    JitNetworkAccessRequestPort: JitNetworkAccessRequestPort,
    JitNetworkAccessPolicyInitiateRequest: JitNetworkAccessPolicyInitiateRequest,
    JitNetworkAccessPolicyInitiateVirtualMachine: JitNetworkAccessPolicyInitiateVirtualMachine,
    JitNetworkAccessPolicyInitiatePort: JitNetworkAccessPolicyInitiatePort,
    DiscoveredSecuritySolutionList: DiscoveredSecuritySolutionList,
    SecuritySolutionsReferenceDataList: SecuritySolutionsReferenceDataList,
    ExternalSecuritySolutionList: ExternalSecuritySolutionList,
    ExternalSecuritySolutionKindAutoGenerated: ExternalSecuritySolutionKindAutoGenerated,
    SecureScoresList: SecureScoresList,
    SecureScoreControlList: SecureScoreControlList,
    SecureScoreControlDefinitionSource: SecureScoreControlDefinitionSource,
    AzureResourceLink: AzureResourceLink,
    SecureScoreControlDefinitionList: SecureScoreControlDefinitionList,
    SecuritySolutionList: SecuritySolutionList,
    ConnectorSettingList: ConnectorSettingList,
    HybridComputeSettingsProperties: HybridComputeSettingsProperties,
    ProxyServerProperties: ProxyServerProperties,
    ServicePrincipalProperties: ServicePrincipalProperties,
    AuthenticationDetailsProperties: AuthenticationDetailsProperties,
    ScanProperties: ScanProperties,
    Scans: Scans,
    ScanResultProperties: ScanResultProperties,
    Remediation: Remediation,
    BaselineAdjustedResult: BaselineAdjustedResult,
    Baseline: Baseline,
    VaRule: VaRule,
    QueryCheck: QueryCheck,
    BenchmarkReference: BenchmarkReference,
    ScanResults: ScanResults,
    RuleResultsInput: RuleResultsInput,
    RuleResultsProperties: RuleResultsProperties,
    RulesResults: RulesResults,
    RulesResultsInput: RulesResultsInput,
    AlertList: AlertList,
    ResourceIdentifier: ResourceIdentifier,
    AlertEntity: AlertEntity,
    AlertSimulatorRequestBody: AlertSimulatorRequestBody,
    AlertSimulatorRequestProperties: AlertSimulatorRequestProperties,
    SettingsList: SettingsList,
    IngestionSettingList: IngestionSettingList,
    IngestionSettingToken: IngestionSettingToken,
    ConnectionStrings: ConnectionStrings,
    IngestionConnectionString: IngestionConnectionString,
    SoftwaresList: SoftwaresList,
    SecurityConnectorsList: SecurityConnectorsList,
    CloudOffering: CloudOffering,
    SecurityConnectorPropertiesOrganizationalData: SecurityConnectorPropertiesOrganizationalData,
    Cvss: Cvss,
    Cve: Cve,
    VendorReference: VendorReference,
    ExternalSecuritySolutionProperties: ExternalSecuritySolutionProperties,
    ConnectedWorkspace: ConnectedWorkspace,
    AadConnectivityStateAutoGenerated: AadConnectivityStateAutoGenerated,
    SecureScoreControlScore: SecureScoreControlScore,
    CspmMonitorAwsOfferingNativeCloudConnection: CspmMonitorAwsOfferingNativeCloudConnection,
    DefenderForContainersAwsOfferingKubernetesService: DefenderForContainersAwsOfferingKubernetesService,
    DefenderForContainersAwsOfferingKubernetesScubaReader: DefenderForContainersAwsOfferingKubernetesScubaReader,
    DefenderForContainersAwsOfferingCloudWatchToKinesis: DefenderForContainersAwsOfferingCloudWatchToKinesis,
    DefenderForContainersAwsOfferingKinesisToS3: DefenderForContainersAwsOfferingKinesisToS3,
    DefenderForServersAwsOfferingDefenderForServers: DefenderForServersAwsOfferingDefenderForServers,
    DefenderForServersAwsOfferingArcAutoProvisioning: DefenderForServersAwsOfferingArcAutoProvisioning,
    DefenderForServersAwsOfferingArcAutoProvisioningServicePrincipalSecretMetadata: DefenderForServersAwsOfferingArcAutoProvisioningServicePrincipalSecretMetadata,
    InformationProtectionAwsOfferingInformationProtection: InformationProtectionAwsOfferingInformationProtection,
    MdeOnboardingData: MdeOnboardingData,
    CustomAssessmentAutomation: CustomAssessmentAutomation,
    CustomAssessmentAutomationRequest: CustomAssessmentAutomationRequest,
    CustomEntityStoreAssignment: CustomEntityStoreAssignment,
    ComplianceResult: ComplianceResult,
    Pricing: Pricing,
    AdvancedThreatProtectionSetting: AdvancedThreatProtectionSetting,
    DeviceSecurityGroup: DeviceSecurityGroup,
    IoTSecuritySolutionModel: IoTSecuritySolutionModel,
    IoTSecuritySolutionAnalyticsModel: IoTSecuritySolutionAnalyticsModel,
    IoTSecurityAggregatedAlert: IoTSecurityAggregatedAlert,
    IoTSecurityAggregatedRecommendation: IoTSecurityAggregatedRecommendation,
    AscLocation: AscLocation,
    SecurityTask: SecurityTask,
    AutoProvisioningSetting: AutoProvisioningSetting,
    Compliance: Compliance,
    InformationProtectionPolicy: InformationProtectionPolicy,
    SecurityContact: SecurityContact,
    WorkspaceSetting: WorkspaceSetting,
    RegulatoryComplianceStandard: RegulatoryComplianceStandard,
    RegulatoryComplianceControl: RegulatoryComplianceControl,
    RegulatoryComplianceAssessment: RegulatoryComplianceAssessment,
    SecuritySubAssessment: SecuritySubAssessment,
    TrackedResource: TrackedResource,
    AlertsSuppressionRule: AlertsSuppressionRule,
    ServerVulnerabilityAssessment: ServerVulnerabilityAssessment,
    SecurityAssessmentMetadataResponse: SecurityAssessmentMetadataResponse,
    SecurityAssessmentResponse: SecurityAssessmentResponse,
    SecurityAssessment: SecurityAssessment,
    AdaptiveApplicationControlGroup: AdaptiveApplicationControlGroup,
    AdaptiveNetworkHardening: AdaptiveNetworkHardening,
    AllowedConnectionsResource: AllowedConnectionsResource,
    TopologyResource: TopologyResource,
    JitNetworkAccessPolicy: JitNetworkAccessPolicy,
    DiscoveredSecuritySolution: DiscoveredSecuritySolution,
    SecuritySolutionsReferenceData: SecuritySolutionsReferenceData,
    ExternalSecuritySolution: ExternalSecuritySolution,
    SecureScoreItem: SecureScoreItem,
    SecureScoreControlDefinitionItem: SecureScoreControlDefinitionItem,
    SecureScoreControlDetails: SecureScoreControlDetails,
    SecuritySolution: SecuritySolution,
    ConnectorSetting: ConnectorSetting,
    Scan: Scan,
    ScanResult: ScanResult,
    RuleResults: RuleResults,
    Alert: Alert,
    Setting: Setting,
    IngestionSetting: IngestionSetting,
    Software: Software,
    SecurityAssessmentMetadata: SecurityAssessmentMetadata,
    ThresholdCustomAlertRule: ThresholdCustomAlertRule,
    ListCustomAlertRule: ListCustomAlertRule,
    UpdateIotSecuritySolutionData: UpdateIotSecuritySolutionData,
    AzureResourceDetails: AzureResourceDetails,
    OnPremiseResourceDetails: OnPremiseResourceDetails,
    SqlServerVulnerabilityProperties: SqlServerVulnerabilityProperties,
    ContainerRegistryVulnerabilityProperties: ContainerRegistryVulnerabilityProperties,
    ServerVulnerabilityProperties: ServerVulnerabilityProperties,
    AutomationActionLogicApp: AutomationActionLogicApp,
    AutomationActionEventHub: AutomationActionEventHub,
    AutomationActionWorkspace: AutomationActionWorkspace,
    SecurityAssessmentMetadataPropertiesResponse: SecurityAssessmentMetadataPropertiesResponse,
    AssessmentStatusResponse: AssessmentStatusResponse,
    SecurityAssessmentPropertiesResponse: SecurityAssessmentPropertiesResponse,
    SecurityAssessmentProperties: SecurityAssessmentProperties,
    AwsCredsAuthenticationDetailsProperties: AwsCredsAuthenticationDetailsProperties,
    AwAssumeRoleAuthenticationDetailsProperties: AwAssumeRoleAuthenticationDetailsProperties,
    GcpCredentialsDetailsProperties: GcpCredentialsDetailsProperties,
    AzureResourceIdentifier: AzureResourceIdentifier,
    LogAnalyticsIdentifier: LogAnalyticsIdentifier,
    AlertSimulatorBundlesRequestProperties: AlertSimulatorBundlesRequestProperties,
    CspmMonitorAwsOffering: CspmMonitorAwsOffering,
    DefenderForContainersAwsOffering: DefenderForContainersAwsOffering,
    DefenderForServersAwsOffering: DefenderForServersAwsOffering,
    InformationProtectionAwsOffering: InformationProtectionAwsOffering,
    CefSolutionProperties: CefSolutionProperties,
    AtaSolutionProperties: AtaSolutionProperties,
    AadSolutionProperties: AadSolutionProperties,
    Automation: Automation,
    SecurityConnector: SecurityConnector,
    CefExternalSecuritySolution: CefExternalSecuritySolution,
    AtaExternalSecuritySolution: AtaExternalSecuritySolution,
    AadExternalSecuritySolution: AadExternalSecuritySolution,
    DataExportSettings: DataExportSettings,
    AlertSyncSettings: AlertSyncSettings,
    TimeWindowCustomAlertRule: TimeWindowCustomAlertRule,
    AllowlistCustomAlertRule: AllowlistCustomAlertRule,
    DenylistCustomAlertRule: DenylistCustomAlertRule,
    OnPremiseSqlResourceDetails: OnPremiseSqlResourceDetails,
    ActiveConnectionsNotInAllowedRange: ActiveConnectionsNotInAllowedRange,
    AmqpC2DMessagesNotInAllowedRange: AmqpC2DMessagesNotInAllowedRange,
    MqttC2DMessagesNotInAllowedRange: MqttC2DMessagesNotInAllowedRange,
    HttpC2DMessagesNotInAllowedRange: HttpC2DMessagesNotInAllowedRange,
    AmqpC2DRejectedMessagesNotInAllowedRange: AmqpC2DRejectedMessagesNotInAllowedRange,
    MqttC2DRejectedMessagesNotInAllowedRange: MqttC2DRejectedMessagesNotInAllowedRange,
    HttpC2DRejectedMessagesNotInAllowedRange: HttpC2DRejectedMessagesNotInAllowedRange,
    AmqpD2CMessagesNotInAllowedRange: AmqpD2CMessagesNotInAllowedRange,
    MqttD2CMessagesNotInAllowedRange: MqttD2CMessagesNotInAllowedRange,
    HttpD2CMessagesNotInAllowedRange: HttpD2CMessagesNotInAllowedRange,
    DirectMethodInvokesNotInAllowedRange: DirectMethodInvokesNotInAllowedRange,
    FailedLocalLoginsNotInAllowedRange: FailedLocalLoginsNotInAllowedRange,
    FileUploadsNotInAllowedRange: FileUploadsNotInAllowedRange,
    QueuePurgesNotInAllowedRange: QueuePurgesNotInAllowedRange,
    TwinUpdatesNotInAllowedRange: TwinUpdatesNotInAllowedRange,
    UnauthorizedOperationsNotInAllowedRange: UnauthorizedOperationsNotInAllowedRange,
    ConnectionToIpNotAllowed: ConnectionToIpNotAllowed,
    ConnectionFromIpNotAllowed: ConnectionFromIpNotAllowed,
    LocalUserNotAllowed: LocalUserNotAllowed,
    ProcessNotAllowed: ProcessNotAllowed,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-10-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[0-9A-Fa-f]{8}-([0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}$")
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-07-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const customAssessmentAutomationName = {
    parameterPath: "customAssessmentAutomationName",
    mapper: {
        serializedName: "customAssessmentAutomationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const customAssessmentAutomationBody = {
    parameterPath: "customAssessmentAutomationBody",
    mapper: CustomAssessmentAutomationRequest
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const customEntityStoreAssignmentName = {
    parameterPath: "customEntityStoreAssignmentName",
    mapper: {
        serializedName: "customEntityStoreAssignmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const customEntityStoreAssignmentRequestBody = {
    parameterPath: "customEntityStoreAssignmentRequestBody",
    mapper: CustomEntityStoreAssignmentRequest
};
const apiVersion2 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2017-08-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceId = {
    parameterPath: "resourceId",
    mapper: {
        serializedName: "resourceId",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const complianceResultName = {
    parameterPath: "complianceResultName",
    mapper: {
        serializedName: "complianceResultName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion3 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-03-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const pricingName = {
    parameterPath: "pricingName",
    mapper: {
        serializedName: "pricingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const pricing = {
    parameterPath: "pricing",
    mapper: Pricing
};
const apiVersion4 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-01-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const settingName = {
    parameterPath: "settingName",
    mapper: {
        defaultValue: "current",
        isConstant: true,
        serializedName: "settingName",
        type: {
            name: "String"
        }
    }
};
const advancedThreatProtectionSetting = {
    parameterPath: "advancedThreatProtectionSetting",
    mapper: AdvancedThreatProtectionSetting
};
const apiVersion5 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-08-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const deviceSecurityGroupName = {
    parameterPath: "deviceSecurityGroupName",
    mapper: {
        serializedName: "deviceSecurityGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const deviceSecurityGroup = {
    parameterPath: "deviceSecurityGroup",
    mapper: DeviceSecurityGroup
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const solutionName = {
    parameterPath: "solutionName",
    mapper: {
        serializedName: "solutionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const iotSecuritySolutionData = {
    parameterPath: "iotSecuritySolutionData",
    mapper: IoTSecuritySolutionModel
};
const updateIotSecuritySolutionData = {
    parameterPath: "updateIotSecuritySolutionData",
    mapper: UpdateIotSecuritySolutionData
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const aggregatedAlertName = {
    parameterPath: "aggregatedAlertName",
    mapper: {
        serializedName: "aggregatedAlertName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const aggregatedRecommendationName = {
    parameterPath: "aggregatedRecommendationName",
    mapper: {
        serializedName: "aggregatedRecommendationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion6 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2015-06-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const ascLocation = {
    parameterPath: "ascLocation",
    mapper: {
        serializedName: "ascLocation",
        required: true,
        type: {
            name: "String"
        }
    }
};
const taskName = {
    parameterPath: "taskName",
    mapper: {
        serializedName: "taskName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const taskUpdateActionType = {
    parameterPath: "taskUpdateActionType",
    mapper: {
        serializedName: "taskUpdateActionType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion7 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2017-08-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const settingName1 = {
    parameterPath: "settingName",
    mapper: {
        serializedName: "settingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const setting = {
    parameterPath: "setting",
    mapper: AutoProvisioningSetting
};
const complianceName = {
    parameterPath: "complianceName",
    mapper: {
        serializedName: "complianceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const informationProtectionPolicyName = {
    parameterPath: "informationProtectionPolicyName",
    mapper: {
        serializedName: "informationProtectionPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const informationProtectionPolicy = {
    parameterPath: "informationProtectionPolicy",
    mapper: InformationProtectionPolicy
};
const securityContactName = {
    parameterPath: "securityContactName",
    mapper: {
        serializedName: "securityContactName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityContact = {
    parameterPath: "securityContact",
    mapper: SecurityContact
};
const workspaceSettingName = {
    parameterPath: "workspaceSettingName",
    mapper: {
        serializedName: "workspaceSettingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workspaceSetting = {
    parameterPath: "workspaceSetting",
    mapper: WorkspaceSetting
};
const apiVersion8 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-01-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const regulatoryComplianceStandardName = {
    parameterPath: "regulatoryComplianceStandardName",
    mapper: {
        serializedName: "regulatoryComplianceStandardName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const regulatoryComplianceControlName = {
    parameterPath: "regulatoryComplianceControlName",
    mapper: {
        serializedName: "regulatoryComplianceControlName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const regulatoryComplianceAssessmentName = {
    parameterPath: "regulatoryComplianceAssessmentName",
    mapper: {
        serializedName: "regulatoryComplianceAssessmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const assessmentName = {
    parameterPath: "assessmentName",
    mapper: {
        serializedName: "assessmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subAssessmentName = {
    parameterPath: "subAssessmentName",
    mapper: {
        serializedName: "subAssessmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const automationName = {
    parameterPath: "automationName",
    mapper: {
        serializedName: "automationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const automation = {
    parameterPath: "automation",
    mapper: Automation
};
const alertType = {
    parameterPath: ["options", "alertType"],
    mapper: {
        serializedName: "AlertType",
        type: {
            name: "String"
        }
    }
};
const alertsSuppressionRuleName = {
    parameterPath: "alertsSuppressionRuleName",
    mapper: {
        serializedName: "alertsSuppressionRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const alertsSuppressionRule = {
    parameterPath: "alertsSuppressionRule",
    mapper: AlertsSuppressionRule
};
const resourceNamespace = {
    parameterPath: "resourceNamespace",
    mapper: {
        serializedName: "resourceNamespace",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceType = {
    parameterPath: "resourceType",
    mapper: {
        serializedName: "resourceType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion9 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-01-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const serverVulnerabilityAssessment = {
    parameterPath: "serverVulnerabilityAssessment",
    mapper: {
        defaultValue: "default",
        isConstant: true,
        serializedName: "serverVulnerabilityAssessment",
        type: {
            name: "String"
        }
    }
};
const apiVersion10 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const assessmentMetadataName = {
    parameterPath: "assessmentMetadataName",
    mapper: {
        serializedName: "assessmentMetadataName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const assessmentMetadata = {
    parameterPath: "assessmentMetadata",
    mapper: SecurityAssessmentMetadataResponse
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const assessment = {
    parameterPath: "assessment",
    mapper: SecurityAssessment
};
const includePathRecommendations = {
    parameterPath: ["options", "includePathRecommendations"],
    mapper: {
        serializedName: "includePathRecommendations",
        type: {
            name: "Boolean"
        }
    }
};
const summary = {
    parameterPath: ["options", "summary"],
    mapper: {
        serializedName: "summary",
        type: {
            name: "Boolean"
        }
    }
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: AdaptiveApplicationControlGroup
};
const adaptiveNetworkHardeningResourceName = {
    parameterPath: "adaptiveNetworkHardeningResourceName",
    mapper: {
        serializedName: "adaptiveNetworkHardeningResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body1 = {
    parameterPath: "body",
    mapper: AdaptiveNetworkHardeningEnforceRequest
};
const adaptiveNetworkHardeningEnforceAction = {
    parameterPath: "adaptiveNetworkHardeningEnforceAction",
    mapper: {
        defaultValue: "enforce",
        isConstant: true,
        serializedName: "adaptiveNetworkHardeningEnforceAction",
        type: {
            name: "String"
        }
    }
};
const connectionType = {
    parameterPath: "connectionType",
    mapper: {
        serializedName: "connectionType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const topologyResourceName = {
    parameterPath: "topologyResourceName",
    mapper: {
        serializedName: "topologyResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jitNetworkAccessPolicyName = {
    parameterPath: "jitNetworkAccessPolicyName",
    mapper: {
        serializedName: "jitNetworkAccessPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body2 = {
    parameterPath: "body",
    mapper: JitNetworkAccessPolicy
};
const body3 = {
    parameterPath: "body",
    mapper: JitNetworkAccessPolicyInitiateRequest
};
const jitNetworkAccessPolicyInitiateType = {
    parameterPath: "jitNetworkAccessPolicyInitiateType",
    mapper: {
        defaultValue: "initiate",
        isConstant: true,
        serializedName: "jitNetworkAccessPolicyInitiateType",
        type: {
            name: "String"
        }
    }
};
const discoveredSecuritySolutionName = {
    parameterPath: "discoveredSecuritySolutionName",
    mapper: {
        serializedName: "discoveredSecuritySolutionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const externalSecuritySolutionsName = {
    parameterPath: "externalSecuritySolutionsName",
    mapper: {
        serializedName: "externalSecuritySolutionsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const secureScoreName = {
    parameterPath: "secureScoreName",
    mapper: {
        serializedName: "secureScoreName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand1 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const securitySolutionName = {
    parameterPath: "securitySolutionName",
    mapper: {
        serializedName: "securitySolutionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion11 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-01-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const connectorName = {
    parameterPath: "connectorName",
    mapper: {
        serializedName: "connectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const connectorSetting = {
    parameterPath: "connectorSetting",
    mapper: ConnectorSetting
};
const scanId = {
    parameterPath: "scanId",
    mapper: {
        serializedName: "scanId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workspaceId = {
    parameterPath: "workspaceId",
    mapper: {
        serializedName: "workspaceId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion12 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-07-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const scanResultId = {
    parameterPath: "scanResultId",
    mapper: {
        serializedName: "scanResultId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body4 = {
    parameterPath: ["options", "body"],
    mapper: RuleResultsInput
};
const ruleId = {
    parameterPath: "ruleId",
    mapper: {
        serializedName: "ruleId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body5 = {
    parameterPath: ["options", "body"],
    mapper: RulesResultsInput
};
const apiVersion13 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const alertName = {
    parameterPath: "alertName",
    mapper: {
        serializedName: "alertName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const alertSimulatorRequestBody = {
    parameterPath: "alertSimulatorRequestBody",
    mapper: AlertSimulatorRequestBody
};
const apiVersion14 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-07-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const settingName2 = {
    parameterPath: "settingName",
    mapper: {
        serializedName: "settingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const setting1 = {
    parameterPath: "setting",
    mapper: Setting
};
const apiVersion15 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-01-15-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const ingestionSettingName = {
    parameterPath: "ingestionSettingName",
    mapper: {
        serializedName: "ingestionSettingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ingestionSetting = {
    parameterPath: "ingestionSetting",
    mapper: IngestionSetting
};
const apiVersion16 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-05-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const softwareName = {
    parameterPath: "softwareName",
    mapper: {
        serializedName: "softwareName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityConnectorName = {
    parameterPath: "securityConnectorName",
    mapper: {
        serializedName: "securityConnectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityConnector = {
    parameterPath: "securityConnector",
    mapper: SecurityConnector
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MdeOnboardings operations. */
class MdeOnboardingsImpl {
    /**
     * Initialize a new instance of the class MdeOnboardings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The configuration or data needed to onboard the machine to MDE
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$F);
    }
    /**
     * The default configuration or data needed to onboard the machine to MDE
     * @param options The options parameters.
     */
    get(options) {
        return this.client.sendOperationRequest({ options }, getOperationSpec$G);
    }
}
// Operation Specifications
const serializer$M = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/mdeOnboardings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MdeOnboardingDataList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$M
};
const getOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/mdeOnboardings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MdeOnboardingData
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomAssessmentAutomations operations. */
class CustomAssessmentAutomationsImpl {
    /**
     * Initialize a new instance of the class CustomAssessmentAutomations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List custom assessment automations by provided subscription and resource group
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List custom assessment automations by provided subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a single custom assessment automation by name for the provided subscription and resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param customAssessmentAutomationName Name of the Custom Assessment Automation.
     * @param options The options parameters.
     */
    get(resourceGroupName, customAssessmentAutomationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customAssessmentAutomationName, options }, getOperationSpec$F);
    }
    /**
     * Creates or updates a custom assessment automation for the provided subscription. Please note that
     * providing an existing custom assessment automation will replace the existing record.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param customAssessmentAutomationName Name of the Custom Assessment Automation.
     * @param customAssessmentAutomationBody Custom Assessment Automation body
     * @param options The options parameters.
     */
    create(resourceGroupName, customAssessmentAutomationName, customAssessmentAutomationBody, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            customAssessmentAutomationName,
            customAssessmentAutomationBody,
            options
        }, createOperationSpec$6);
    }
    /**
     * Deletes a custom assessment automation by name for a provided subscription
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param customAssessmentAutomationName Name of the Custom Assessment Automation.
     * @param options The options parameters.
     */
    delete(resourceGroupName, customAssessmentAutomationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customAssessmentAutomationName, options }, deleteOperationSpec$f);
    }
    /**
     * List custom assessment automations by provided subscription and resource group
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$7);
    }
    /**
     * List custom assessment automations by provided subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$7);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$L = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customAssessmentAutomations/{customAssessmentAutomationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomAssessmentAutomation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        customAssessmentAutomationName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const createOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customAssessmentAutomations/{customAssessmentAutomationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomAssessmentAutomation
        },
        201: {
            bodyMapper: CustomAssessmentAutomation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: customAssessmentAutomationBody,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        customAssessmentAutomationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$L
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customAssessmentAutomations/{customAssessmentAutomationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        customAssessmentAutomationName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listByResourceGroupOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customAssessmentAutomations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomAssessmentAutomationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listBySubscriptionOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/customAssessmentAutomations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomAssessmentAutomationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$L
};
const listByResourceGroupNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomAssessmentAutomationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listBySubscriptionNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomAssessmentAutomationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomEntityStoreAssignments operations. */
class CustomEntityStoreAssignmentsImpl {
    /**
     * Initialize a new instance of the class CustomEntityStoreAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List custom entity store assignments by a provided subscription and resource group
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List custom entity store assignments by provided subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a single custom entity store assignment by name for the provided subscription and resource
     * group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param customEntityStoreAssignmentName Name of the custom entity store assignment. Generated name is
     *                                        GUID.
     * @param options The options parameters.
     */
    get(resourceGroupName, customEntityStoreAssignmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customEntityStoreAssignmentName, options }, getOperationSpec$E);
    }
    /**
     * Creates a custom entity store assignment for the provided subscription, if not already exists.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param customEntityStoreAssignmentName Name of the custom entity store assignment. Generated name is
     *                                        GUID.
     * @param customEntityStoreAssignmentRequestBody Custom entity store assignment body
     * @param options The options parameters.
     */
    create(resourceGroupName, customEntityStoreAssignmentName, customEntityStoreAssignmentRequestBody, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            customEntityStoreAssignmentName,
            customEntityStoreAssignmentRequestBody,
            options
        }, createOperationSpec$5);
    }
    /**
     * Delete a custom entity store assignment by name for a provided subscription
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param customEntityStoreAssignmentName Name of the custom entity store assignment. Generated name is
     *                                        GUID.
     * @param options The options parameters.
     */
    delete(resourceGroupName, customEntityStoreAssignmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customEntityStoreAssignmentName, options }, deleteOperationSpec$e);
    }
    /**
     * List custom entity store assignments by a provided subscription and resource group
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * List custom entity store assignments by provided subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$4);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$6);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$K = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customEntityStoreAssignments/{customEntityStoreAssignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomEntityStoreAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        customEntityStoreAssignmentName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const createOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customEntityStoreAssignments/{customEntityStoreAssignmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomEntityStoreAssignment
        },
        201: {
            bodyMapper: CustomEntityStoreAssignment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: customEntityStoreAssignmentRequestBody,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        customEntityStoreAssignmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$K
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customEntityStoreAssignments/{customEntityStoreAssignmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        customEntityStoreAssignmentName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Security/customEntityStoreAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomEntityStoreAssignmentsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const listBySubscriptionOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/customEntityStoreAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomEntityStoreAssignmentsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$K
};
const listByResourceGroupNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomEntityStoreAssignmentsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const listBySubscriptionNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomEntityStoreAssignmentsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ComplianceResults operations. */
class ComplianceResultsImpl {
    /**
     * Initialize a new instance of the class ComplianceResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Security compliance results in the subscription
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.listPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(scope, options);
            }
        };
    }
    listPagingPage(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(scope, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Security compliance results in the subscription
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    _list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$E);
    }
    /**
     * Security Compliance Result
     * @param resourceId The identifier of the resource.
     * @param complianceResultName name of the desired assessment compliance result
     * @param options The options parameters.
     */
    get(resourceId, complianceResultName, options) {
        return this.client.sendOperationRequest({ resourceId, complianceResultName, options }, getOperationSpec$D);
    }
    /**
     * ListNext
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listNextOperationSpec$x);
    }
}
// Operation Specifications
const serializer$J = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$E = {
    path: "/{scope}/providers/Microsoft.Security/complianceResults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComplianceResultList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOperationSpec$D = {
    path: "/{resourceId}/providers/Microsoft.Security/complianceResults/{complianceResultName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComplianceResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [
        $host,
        resourceId,
        complianceResultName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listNextOperationSpec$x = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComplianceResultList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion2],
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Pricings operations. */
class PricingsImpl {
    /**
     * Initialize a new instance of the class Pricings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists Security Center pricing configurations in the subscription.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$D);
    }
    /**
     * Gets a provided Security Center pricing configuration in the subscription.
     * @param pricingName name of the pricing configuration
     * @param options The options parameters.
     */
    get(pricingName, options) {
        return this.client.sendOperationRequest({ pricingName, options }, getOperationSpec$C);
    }
    /**
     * Updates a provided Security Center pricing configuration in the subscription.
     * @param pricingName name of the pricing configuration
     * @param pricing Pricing object
     * @param options The options parameters.
     */
    update(pricingName, pricing, options) {
        return this.client.sendOperationRequest({ pricingName, pricing, options }, updateOperationSpec$6);
    }
}
// Operation Specifications
const serializer$I = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/pricings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PricingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$I
};
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/pricings/{pricingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Pricing
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        pricingName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/pricings/{pricingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Pricing
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: pricing,
    queryParameters: [apiVersion3],
    urlParameters: [
        $host,
        subscriptionId,
        pricingName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing AdvancedThreatProtection operations. */
class AdvancedThreatProtectionImpl {
    /**
     * Initialize a new instance of the class AdvancedThreatProtection class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the Advanced Threat Protection settings for the specified resource.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    get(resourceId, options) {
        return this.client.sendOperationRequest({ resourceId, options }, getOperationSpec$B);
    }
    /**
     * Creates or updates the Advanced Threat Protection settings on a specified resource.
     * @param resourceId The identifier of the resource.
     * @param advancedThreatProtectionSetting Advanced Threat Protection Settings
     * @param options The options parameters.
     */
    create(resourceId, advancedThreatProtectionSetting, options) {
        return this.client.sendOperationRequest({ resourceId, advancedThreatProtectionSetting, options }, createOperationSpec$4);
    }
}
// Operation Specifications
const serializer$H = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$B = {
    path: "/{resourceId}/providers/Microsoft.Security/advancedThreatProtectionSettings/{settingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdvancedThreatProtectionSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        resourceId,
        settingName
    ],
    headerParameters: [accept],
    serializer: serializer$H
};
const createOperationSpec$4 = {
    path: "/{resourceId}/providers/Microsoft.Security/advancedThreatProtectionSettings/{settingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AdvancedThreatProtectionSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: advancedThreatProtectionSetting,
    queryParameters: [apiVersion4],
    urlParameters: [
        $host,
        resourceId,
        settingName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeviceSecurityGroups operations. */
class DeviceSecurityGroupsImpl {
    /**
     * Initialize a new instance of the class DeviceSecurityGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Use this method get the list of device security groups for the specified IoT Hub resource.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    list(resourceId, options) {
        const iter = this.listPagingAll(resourceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceId, options);
            }
        };
    }
    listPagingPage(resourceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceId, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceId, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Use this method get the list of device security groups for the specified IoT Hub resource.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    _list(resourceId, options) {
        return this.client.sendOperationRequest({ resourceId, options }, listOperationSpec$C);
    }
    /**
     * Use this method to get the device security group for the specified IoT Hub resource.
     * @param resourceId The identifier of the resource.
     * @param deviceSecurityGroupName The name of the device security group. Note that the name of the
     *                                device security group is case insensitive.
     * @param options The options parameters.
     */
    get(resourceId, deviceSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceId, deviceSecurityGroupName, options }, getOperationSpec$A);
    }
    /**
     * Use this method to creates or updates the device security group on a specified IoT Hub resource.
     * @param resourceId The identifier of the resource.
     * @param deviceSecurityGroupName The name of the device security group. Note that the name of the
     *                                device security group is case insensitive.
     * @param deviceSecurityGroup Security group object.
     * @param options The options parameters.
     */
    createOrUpdate(resourceId, deviceSecurityGroupName, deviceSecurityGroup, options) {
        return this.client.sendOperationRequest({ resourceId, deviceSecurityGroupName, deviceSecurityGroup, options }, createOrUpdateOperationSpec$9);
    }
    /**
     * User this method to deletes the device security group.
     * @param resourceId The identifier of the resource.
     * @param deviceSecurityGroupName The name of the device security group. Note that the name of the
     *                                device security group is case insensitive.
     * @param options The options parameters.
     */
    delete(resourceId, deviceSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceId, deviceSecurityGroupName, options }, deleteOperationSpec$d);
    }
    /**
     * ListNext
     * @param resourceId The identifier of the resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceId, nextLink, options }, listNextOperationSpec$w);
    }
}
// Operation Specifications
const serializer$G = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$C = {
    path: "/{resourceId}/providers/Microsoft.Security/deviceSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeviceSecurityGroupList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [$host, resourceId],
    headerParameters: [accept],
    serializer: serializer$G
};
const getOperationSpec$A = {
    path: "/{resourceId}/providers/Microsoft.Security/deviceSecurityGroups/{deviceSecurityGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeviceSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        resourceId,
        deviceSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const createOrUpdateOperationSpec$9 = {
    path: "/{resourceId}/providers/Microsoft.Security/deviceSecurityGroups/{deviceSecurityGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DeviceSecurityGroup
        },
        201: {
            bodyMapper: DeviceSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: deviceSecurityGroup,
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        resourceId,
        deviceSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$G
};
const deleteOperationSpec$d = {
    path: "/{resourceId}/providers/Microsoft.Security/deviceSecurityGroups/{deviceSecurityGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        resourceId,
        deviceSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const listNextOperationSpec$w = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeviceSecurityGroupList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [$host, nextLink, resourceId],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IotSecuritySolution operations. */
class IotSecuritySolutionImpl {
    /**
     * Initialize a new instance of the class IotSecuritySolution class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Use this method to get the list of IoT Security solutions by subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Use this method to get the list IoT Security solutions organized by resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Use this method to get the list of IoT Security solutions by subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * Use this method to get the list IoT Security solutions organized by resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * User this method to get details of a specific IoT Security solution based on solution name
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    get(resourceGroupName, solutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, options }, getOperationSpec$z);
    }
    /**
     * Use this method to create or update yours IoT Security solution
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param iotSecuritySolutionData The security solution data
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, solutionName, iotSecuritySolutionData, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, iotSecuritySolutionData, options }, createOrUpdateOperationSpec$8);
    }
    /**
     * Use this method to update existing IoT Security solution tags or user defined resources. To update
     * other fields use the CreateOrUpdate method.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param updateIotSecuritySolutionData The security solution data
     * @param options The options parameters.
     */
    update(resourceGroupName, solutionName, updateIotSecuritySolutionData, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            solutionName,
            updateIotSecuritySolutionData,
            options
        }, updateOperationSpec$5);
    }
    /**
     * Use this method to delete yours IoT Security solution
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    delete(resourceGroupName, solutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, options }, deleteOperationSpec$c);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$F = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/iotSecuritySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$F
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionModel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionModel
        },
        201: {
            bodyMapper: IoTSecuritySolutionModel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: iotSecuritySolutionData,
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionModel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: updateIotSecuritySolutionData,
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, filter],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing IotSecuritySolutionAnalytics operations. */
class IotSecuritySolutionAnalyticsImpl {
    /**
     * Initialize a new instance of the class IotSecuritySolutionAnalytics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Use this method to get IoT security Analytics metrics in an array.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    list(resourceGroupName, solutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, options }, listOperationSpec$B);
    }
    /**
     * Use this method to get IoT Security Analytics metrics.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    get(resourceGroupName, solutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, options }, getOperationSpec$y);
    }
}
// Operation Specifications
const serializer$E = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionAnalyticsModelList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecuritySolutionAnalyticsModel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IotSecuritySolutionsAnalyticsAggregatedAlert operations. */
class IotSecuritySolutionsAnalyticsAggregatedAlertImpl {
    /**
     * Initialize a new instance of the class IotSecuritySolutionsAnalyticsAggregatedAlert class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Use this method to get the aggregated alert list of yours IoT Security solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    list(resourceGroupName, solutionName, options) {
        const iter = this.listPagingAll(resourceGroupName, solutionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, solutionName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, solutionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, solutionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, solutionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, solutionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, solutionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Use this method to get the aggregated alert list of yours IoT Security solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    _list(resourceGroupName, solutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, options }, listOperationSpec$A);
    }
    /**
     * Use this method to get a single the aggregated alert of yours IoT Security solution. This
     * aggregation is performed by alert name.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param aggregatedAlertName Identifier of the aggregated alert.
     * @param options The options parameters.
     */
    get(resourceGroupName, solutionName, aggregatedAlertName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, aggregatedAlertName, options }, getOperationSpec$x);
    }
    /**
     * Use this method to dismiss an aggregated IoT Security Solution Alert.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param aggregatedAlertName Identifier of the aggregated alert.
     * @param options The options parameters.
     */
    dismiss(resourceGroupName, solutionName, aggregatedAlertName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, aggregatedAlertName, options }, dismissOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, solutionName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, nextLink, options }, listNextOperationSpec$v);
    }
}
// Operation Specifications
const serializer$D = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels/default/aggregatedAlerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecurityAggregatedAlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels/default/aggregatedAlerts/{aggregatedAlertName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecurityAggregatedAlert
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName,
        aggregatedAlertName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const dismissOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels/default/aggregatedAlerts/{aggregatedAlertName}/dismiss",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName,
        aggregatedAlertName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listNextOperationSpec$v = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecurityAggregatedAlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IotSecuritySolutionsAnalyticsRecommendation operations. */
class IotSecuritySolutionsAnalyticsRecommendationImpl {
    /**
     * Initialize a new instance of the class IotSecuritySolutionsAnalyticsRecommendation class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Use this method to get the list of aggregated security analytics recommendations of yours IoT
     * Security solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    list(resourceGroupName, solutionName, options) {
        const iter = this.listPagingAll(resourceGroupName, solutionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, solutionName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, solutionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, solutionName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, solutionName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, solutionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, solutionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Use this method to get the aggregated security analytics recommendation of yours IoT Security
     * solution. This aggregation is performed by recommendation name.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param aggregatedRecommendationName Name of the recommendation aggregated for this query.
     * @param options The options parameters.
     */
    get(resourceGroupName, solutionName, aggregatedRecommendationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            solutionName,
            aggregatedRecommendationName,
            options
        }, getOperationSpec$w);
    }
    /**
     * Use this method to get the list of aggregated security analytics recommendations of yours IoT
     * Security solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param options The options parameters.
     */
    _list(resourceGroupName, solutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, options }, listOperationSpec$z);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param solutionName The name of the IoT Security solution.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, solutionName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, solutionName, nextLink, options }, listNextOperationSpec$u);
    }
}
// Operation Specifications
const serializer$C = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels/default/aggregatedRecommendations/{aggregatedRecommendationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecurityAggregatedRecommendation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName,
        aggregatedRecommendationName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/iotSecuritySolutions/{solutionName}/analyticsModels/default/aggregatedRecommendations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecurityAggregatedRecommendationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listNextOperationSpec$u = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSecurityAggregatedRecommendationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion5, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        solutionName
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Locations operations. */
class LocationsImpl {
    /**
     * Initialize a new instance of the class Locations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The location of the responsible ASC of the specific subscription (home region). For each
     * subscription there is only one responsible location. The location in the response should be used to
     * read or write other resources in ASC according to their ID.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The location of the responsible ASC of the specific subscription (home region). For each
     * subscription there is only one responsible location. The location in the response should be used to
     * read or write other resources in ASC according to their ID.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$y);
    }
    /**
     * Details of a specific location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    get(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, getOperationSpec$v);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$t);
    }
}
// Operation Specifications
const serializer$B = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AscLocationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$B
};
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AscLocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listNextOperationSpec$t = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AscLocationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Exposes all available operations for discovery purposes.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Exposes all available operations for discovery purposes.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$x);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$s);
    }
}
// Operation Specifications
const serializer$A = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$x = {
    path: "/providers/Microsoft.Security/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$A
};
const listNextOperationSpec$s = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Tasks operations. */
class TasksImpl {
    /**
     * Initialize a new instance of the class Tasks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByHomeRegion(ascLocation, options) {
        const iter = this.listByHomeRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByHomeRegionPagingPage(ascLocation, options);
            }
        };
    }
    listByHomeRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByHomeRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByHomeRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByHomeRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHomeRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, ascLocation, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, ascLocation, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$w);
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByHomeRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByHomeRegionOperationSpec$5);
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param taskName Name of the task object, will be a GUID
     * @param options The options parameters.
     */
    getSubscriptionLevelTask(ascLocation, taskName, options) {
        return this.client.sendOperationRequest({ ascLocation, taskName, options }, getSubscriptionLevelTaskOperationSpec);
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param taskName Name of the task object, will be a GUID
     * @param taskUpdateActionType Type of the action to do on the task
     * @param options The options parameters.
     */
    updateSubscriptionLevelTaskState(ascLocation, taskName, taskUpdateActionType, options) {
        return this.client.sendOperationRequest({ ascLocation, taskName, taskUpdateActionType, options }, updateSubscriptionLevelTaskStateOperationSpec);
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, ascLocation, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param taskName Name of the task object, will be a GUID
     * @param options The options parameters.
     */
    getResourceGroupLevelTask(resourceGroupName, ascLocation, taskName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, taskName, options }, getResourceGroupLevelTaskOperationSpec);
    }
    /**
     * Recommended tasks that will help improve the security of the subscription proactively
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param taskName Name of the task object, will be a GUID
     * @param taskUpdateActionType Type of the action to do on the task
     * @param options The options parameters.
     */
    updateResourceGroupLevelTaskState(resourceGroupName, ascLocation, taskName, taskUpdateActionType, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            ascLocation,
            taskName,
            taskUpdateActionType,
            options
        }, updateResourceGroupLevelTaskStateOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$r);
    }
    /**
     * ListByHomeRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByHomeRegion method.
     * @param options The options parameters.
     */
    _listByHomeRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listByHomeRegionNextOperationSpec$4);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/tasks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTaskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion6],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByHomeRegionOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/tasks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTaskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const getSubscriptionLevelTaskOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/tasks/{taskName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTask
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        taskName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const updateSubscriptionLevelTaskStateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/tasks/{taskName}/{taskUpdateActionType}",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        taskName,
        taskUpdateActionType
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/tasks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTaskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const getResourceGroupLevelTaskOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/tasks/{taskName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTask
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        taskName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const updateResourceGroupLevelTaskStateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/tasks/{taskName}/{taskUpdateActionType}",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        taskName,
        taskUpdateActionType
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listNextOperationSpec$r = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTaskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByHomeRegionNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTaskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$z
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityTaskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion6],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AutoProvisioningSettings operations. */
class AutoProvisioningSettingsImpl {
    /**
     * Initialize a new instance of the class AutoProvisioningSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Exposes the auto provisioning settings of the subscriptions
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Exposes the auto provisioning settings of the subscriptions
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$v);
    }
    /**
     * Details of a specific setting
     * @param settingName Auto provisioning setting key
     * @param options The options parameters.
     */
    get(settingName, options) {
        return this.client.sendOperationRequest({ settingName, options }, getOperationSpec$u);
    }
    /**
     * Details of a specific setting
     * @param settingName Auto provisioning setting key
     * @param setting Auto provisioning setting key
     * @param options The options parameters.
     */
    create(settingName, setting, options) {
        return this.client.sendOperationRequest({ settingName, setting, options }, createOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$q);
    }
}
// Operation Specifications
const serializer$y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/autoProvisioningSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoProvisioningSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$y
};
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/autoProvisioningSettings/{settingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoProvisioningSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        settingName1
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/autoProvisioningSettings/{settingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AutoProvisioningSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: setting,
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        settingName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$y
};
const listNextOperationSpec$q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoProvisioningSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Compliances operations. */
class CompliancesImpl {
    /**
     * Initialize a new instance of the class Compliances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The Compliance scores of the specific management group.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.listPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(scope, options);
            }
        };
    }
    listPagingPage(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(scope, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The Compliance scores of the specific management group.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    _list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$u);
    }
    /**
     * Details of a specific Compliance.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param complianceName name of the Compliance
     * @param options The options parameters.
     */
    get(scope, complianceName, options) {
        return this.client.sendOperationRequest({ scope, complianceName, options }, getOperationSpec$t);
    }
    /**
     * ListNext
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listNextOperationSpec$p);
    }
}
// Operation Specifications
const serializer$x = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$u = {
    path: "/{scope}/providers/Microsoft.Security/compliances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComplianceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$x
};
const getOperationSpec$t = {
    path: "/{scope}/providers/Microsoft.Security/compliances/{complianceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Compliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        scope,
        complianceName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listNextOperationSpec$p = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComplianceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing InformationProtectionPolicies operations. */
class InformationProtectionPoliciesImpl {
    /**
     * Initialize a new instance of the class InformationProtectionPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Information protection policies of a specific management group.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.listPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(scope, options);
            }
        };
    }
    listPagingPage(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(scope, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Details of the information protection policy.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param informationProtectionPolicyName Name of the information protection policy.
     * @param options The options parameters.
     */
    get(scope, informationProtectionPolicyName, options) {
        return this.client.sendOperationRequest({ scope, informationProtectionPolicyName, options }, getOperationSpec$s);
    }
    /**
     * Details of the information protection policy.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param informationProtectionPolicyName Name of the information protection policy.
     * @param informationProtectionPolicy Information protection policy.
     * @param options The options parameters.
     */
    createOrUpdate(scope, informationProtectionPolicyName, informationProtectionPolicy, options) {
        return this.client.sendOperationRequest({
            scope,
            informationProtectionPolicyName,
            informationProtectionPolicy,
            options
        }, createOrUpdateOperationSpec$7);
    }
    /**
     * Information protection policies of a specific management group.
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    _list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$t);
    }
    /**
     * ListNext
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listNextOperationSpec$o);
    }
}
// Operation Specifications
const serializer$w = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$s = {
    path: "/{scope}/providers/Microsoft.Security/informationProtectionPolicies/{informationProtectionPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InformationProtectionPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        scope,
        informationProtectionPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const createOrUpdateOperationSpec$7 = {
    path: "/{scope}/providers/Microsoft.Security/informationProtectionPolicies/{informationProtectionPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InformationProtectionPolicy
        },
        201: {
            bodyMapper: InformationProtectionPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: informationProtectionPolicy,
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        scope,
        informationProtectionPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const listOperationSpec$t = {
    path: "/{scope}/providers/Microsoft.Security/informationProtectionPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InformationProtectionPolicyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$w
};
const listNextOperationSpec$o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InformationProtectionPolicyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityContacts operations. */
class SecurityContactsImpl {
    /**
     * Initialize a new instance of the class SecurityContacts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Security contact configurations for the subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Security contact configurations for the subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$s);
    }
    /**
     * Security contact configurations for the subscription
     * @param securityContactName Name of the security contact object
     * @param options The options parameters.
     */
    get(securityContactName, options) {
        return this.client.sendOperationRequest({ securityContactName, options }, getOperationSpec$r);
    }
    /**
     * Security contact configurations for the subscription
     * @param securityContactName Name of the security contact object
     * @param securityContact Security contact object
     * @param options The options parameters.
     */
    create(securityContactName, securityContact, options) {
        return this.client.sendOperationRequest({ securityContactName, securityContact, options }, createOperationSpec$2);
    }
    /**
     * Security contact configurations for the subscription
     * @param securityContactName Name of the security contact object
     * @param options The options parameters.
     */
    delete(securityContactName, options) {
        return this.client.sendOperationRequest({ securityContactName, options }, deleteOperationSpec$b);
    }
    /**
     * Security contact configurations for the subscription
     * @param securityContactName Name of the security contact object
     * @param securityContact Security contact object
     * @param options The options parameters.
     */
    update(securityContactName, securityContact, options) {
        return this.client.sendOperationRequest({ securityContactName, securityContact, options }, updateOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$v = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securityContacts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityContactList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$v
};
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securityContacts/{securityContactName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityContact
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        securityContactName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securityContacts/{securityContactName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityContact
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityContact,
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        securityContactName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securityContacts/{securityContactName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        securityContactName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securityContacts/{securityContactName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SecurityContact
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityContact,
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        securityContactName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const listNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityContactList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceSettings operations. */
class WorkspaceSettingsImpl {
    /**
     * Initialize a new instance of the class WorkspaceSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Settings about where we should store your security data and logs. If the result is empty, it means
     * that no custom-workspace configuration was set
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Settings about where we should store your security data and logs. If the result is empty, it means
     * that no custom-workspace configuration was set
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$r);
    }
    /**
     * Settings about where we should store your security data and logs. If the result is empty, it means
     * that no custom-workspace configuration was set
     * @param workspaceSettingName Name of the security setting
     * @param options The options parameters.
     */
    get(workspaceSettingName, options) {
        return this.client.sendOperationRequest({ workspaceSettingName, options }, getOperationSpec$q);
    }
    /**
     * creating settings about where we should store your security data and logs
     * @param workspaceSettingName Name of the security setting
     * @param workspaceSetting Security data setting object
     * @param options The options parameters.
     */
    create(workspaceSettingName, workspaceSetting, options) {
        return this.client.sendOperationRequest({ workspaceSettingName, workspaceSetting, options }, createOperationSpec$1);
    }
    /**
     * Settings about where we should store your security data and logs
     * @param workspaceSettingName Name of the security setting
     * @param workspaceSetting Security data setting object
     * @param options The options parameters.
     */
    update(workspaceSettingName, workspaceSetting, options) {
        return this.client.sendOperationRequest({ workspaceSettingName, workspaceSetting, options }, updateOperationSpec$3);
    }
    /**
     * Deletes the custom workspace settings for this subscription. new VMs will report to the default
     * workspace
     * @param workspaceSettingName Name of the security setting
     * @param options The options parameters.
     */
    delete(workspaceSettingName, options) {
        return this.client.sendOperationRequest({ workspaceSettingName, options }, deleteOperationSpec$a);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$m);
    }
}
// Operation Specifications
const serializer$u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/workspaceSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$u
};
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/workspaceSettings/{workspaceSettingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        workspaceSettingName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/workspaceSettings/{workspaceSettingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkspaceSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: workspaceSetting,
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        workspaceSettingName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/workspaceSettings/{workspaceSettingName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkspaceSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: workspaceSetting,
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        workspaceSettingName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/workspaceSettings/{workspaceSettingName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        workspaceSettingName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion7],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RegulatoryComplianceStandards operations. */
class RegulatoryComplianceStandardsImpl {
    /**
     * Initialize a new instance of the class RegulatoryComplianceStandards class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Supported regulatory compliance standards details and state
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Supported regulatory compliance standards details and state
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$q);
    }
    /**
     * Supported regulatory compliance details state for selected standard
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param options The options parameters.
     */
    get(regulatoryComplianceStandardName, options) {
        return this.client.sendOperationRequest({ regulatoryComplianceStandardName, options }, getOperationSpec$p);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/regulatoryComplianceStandards",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceStandardList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion8],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$t
};
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/regulatoryComplianceStandards/{regulatoryComplianceStandardName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceStandard
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        regulatoryComplianceStandardName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceStandardList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RegulatoryComplianceControls operations. */
class RegulatoryComplianceControlsImpl {
    /**
     * Initialize a new instance of the class RegulatoryComplianceControls class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * All supported regulatory compliance controls details and state for selected standard
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param options The options parameters.
     */
    list(regulatoryComplianceStandardName, options) {
        const iter = this.listPagingAll(regulatoryComplianceStandardName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(regulatoryComplianceStandardName, options);
            }
        };
    }
    listPagingPage(regulatoryComplianceStandardName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(regulatoryComplianceStandardName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regulatoryComplianceStandardName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(regulatoryComplianceStandardName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regulatoryComplianceStandardName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * All supported regulatory compliance controls details and state for selected standard
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param options The options parameters.
     */
    _list(regulatoryComplianceStandardName, options) {
        return this.client.sendOperationRequest({ regulatoryComplianceStandardName, options }, listOperationSpec$p);
    }
    /**
     * Selected regulatory compliance control details and state
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param regulatoryComplianceControlName Name of the regulatory compliance control object
     * @param options The options parameters.
     */
    get(regulatoryComplianceStandardName, regulatoryComplianceControlName, options) {
        return this.client.sendOperationRequest({
            regulatoryComplianceStandardName,
            regulatoryComplianceControlName,
            options
        }, getOperationSpec$o);
    }
    /**
     * ListNext
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regulatoryComplianceStandardName, nextLink, options) {
        return this.client.sendOperationRequest({ regulatoryComplianceStandardName, nextLink, options }, listNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/regulatoryComplianceStandards/{regulatoryComplianceStandardName}/regulatoryComplianceControls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceControlList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        regulatoryComplianceStandardName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/regulatoryComplianceStandards/{regulatoryComplianceStandardName}/regulatoryComplianceControls/{regulatoryComplianceControlName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceControl
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        regulatoryComplianceStandardName,
        regulatoryComplianceControlName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceControlList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        regulatoryComplianceStandardName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RegulatoryComplianceAssessments operations. */
class RegulatoryComplianceAssessmentsImpl {
    /**
     * Initialize a new instance of the class RegulatoryComplianceAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Details and state of assessments mapped to selected regulatory compliance control
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param regulatoryComplianceControlName Name of the regulatory compliance control object
     * @param options The options parameters.
     */
    list(regulatoryComplianceStandardName, regulatoryComplianceControlName, options) {
        const iter = this.listPagingAll(regulatoryComplianceStandardName, regulatoryComplianceControlName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(regulatoryComplianceStandardName, regulatoryComplianceControlName, options);
            }
        };
    }
    listPagingPage(regulatoryComplianceStandardName, regulatoryComplianceControlName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(regulatoryComplianceStandardName, regulatoryComplianceControlName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regulatoryComplianceStandardName, regulatoryComplianceControlName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(regulatoryComplianceStandardName, regulatoryComplianceControlName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regulatoryComplianceStandardName, regulatoryComplianceControlName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Details and state of assessments mapped to selected regulatory compliance control
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param regulatoryComplianceControlName Name of the regulatory compliance control object
     * @param options The options parameters.
     */
    _list(regulatoryComplianceStandardName, regulatoryComplianceControlName, options) {
        return this.client.sendOperationRequest({
            regulatoryComplianceStandardName,
            regulatoryComplianceControlName,
            options
        }, listOperationSpec$o);
    }
    /**
     * Supported regulatory compliance details and state for selected assessment
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param regulatoryComplianceControlName Name of the regulatory compliance control object
     * @param regulatoryComplianceAssessmentName Name of the regulatory compliance assessment object
     * @param options The options parameters.
     */
    get(regulatoryComplianceStandardName, regulatoryComplianceControlName, regulatoryComplianceAssessmentName, options) {
        return this.client.sendOperationRequest({
            regulatoryComplianceStandardName,
            regulatoryComplianceControlName,
            regulatoryComplianceAssessmentName,
            options
        }, getOperationSpec$n);
    }
    /**
     * ListNext
     * @param regulatoryComplianceStandardName Name of the regulatory compliance standard object
     * @param regulatoryComplianceControlName Name of the regulatory compliance control object
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regulatoryComplianceStandardName, regulatoryComplianceControlName, nextLink, options) {
        return this.client.sendOperationRequest({
            regulatoryComplianceStandardName,
            regulatoryComplianceControlName,
            nextLink,
            options
        }, listNextOperationSpec$j);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/regulatoryComplianceStandards/{regulatoryComplianceStandardName}/regulatoryComplianceControls/{regulatoryComplianceControlName}/regulatoryComplianceAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        regulatoryComplianceStandardName,
        regulatoryComplianceControlName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/regulatoryComplianceStandards/{regulatoryComplianceStandardName}/regulatoryComplianceControls/{regulatoryComplianceControlName}/regulatoryComplianceAssessments/{regulatoryComplianceAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceAssessment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        regulatoryComplianceStandardName,
        regulatoryComplianceControlName,
        regulatoryComplianceAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegulatoryComplianceAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [filter, apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        regulatoryComplianceStandardName,
        regulatoryComplianceControlName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SubAssessments operations. */
class SubAssessmentsImpl {
    /**
     * Initialize a new instance of the class SubAssessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get security sub-assessments on all your scanned resources inside a subscription scope
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    listAll(scope, options) {
        const iter = this.listAllPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listAllPagingPage(scope, options);
            }
        };
    }
    listAllPagingPage(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result = yield tslib.__await(this._listAll(scope, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listAllPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get security sub-assessments on all your scanned resources inside a scope
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    list(scope, assessmentName, options) {
        const iter = this.listPagingAll(scope, assessmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(scope, assessmentName, options);
            }
        };
    }
    listPagingPage(scope, assessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(scope, assessmentName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(scope, assessmentName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(scope, assessmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(scope, assessmentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get security sub-assessments on all your scanned resources inside a subscription scope
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    _listAll(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listAllOperationSpec);
    }
    /**
     * Get security sub-assessments on all your scanned resources inside a scope
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    _list(scope, assessmentName, options) {
        return this.client.sendOperationRequest({ scope, assessmentName, options }, listOperationSpec$n);
    }
    /**
     * Get a security sub-assessment on your scanned resource
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param subAssessmentName The Sub-Assessment Key - Unique key for the sub-assessment type
     * @param options The options parameters.
     */
    get(scope, assessmentName, subAssessmentName, options) {
        return this.client.sendOperationRequest({ scope, assessmentName, subAssessmentName, options }, getOperationSpec$m);
    }
    /**
     * ListAllNext
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listAllNextOperationSpec);
    }
    /**
     * ListNext
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(scope, assessmentName, nextLink, options) {
        return this.client.sendOperationRequest({ scope, assessmentName, nextLink, options }, listNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listAllOperationSpec = {
    path: "/{scope}/providers/Microsoft.Security/subAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySubAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$q
};
const listOperationSpec$n = {
    path: "/{scope}/providers/Microsoft.Security/assessments/{assessmentName}/subAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySubAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        scope,
        assessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOperationSpec$m = {
    path: "/{scope}/providers/Microsoft.Security/assessments/{assessmentName}/subAssessments/{subAssessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySubAssessment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        scope,
        assessmentName,
        subAssessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listAllNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySubAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$q
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySubAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        nextLink,
        scope,
        assessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Automations operations. */
class AutomationsImpl {
    /**
     * Initialize a new instance of the class Automations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the security automations in the specified subscription. Use the 'nextLink' property in the
     * response to get the next page of security automations for the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the security automations in the specified resource group. Use the 'nextLink' property in
     * the response to get the next page of security automations for the specified resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all the security automations in the specified subscription. Use the 'nextLink' property in the
     * response to get the next page of security automations for the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$m);
    }
    /**
     * Lists all the security automations in the specified resource group. Use the 'nextLink' property in
     * the response to get the next page of security automations for the specified resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Retrieves information about the model of a security automation.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param automationName The security automation name.
     * @param options The options parameters.
     */
    get(resourceGroupName, automationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, automationName, options }, getOperationSpec$l);
    }
    /**
     * Creates or updates a security automation. If a security automation is already created and a
     * subsequent request is issued for the same automation id, then it will be updated.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param automationName The security automation name.
     * @param automation The security automation resource
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, automationName, automation, options) {
        return this.client.sendOperationRequest({ resourceGroupName, automationName, automation, options }, createOrUpdateOperationSpec$6);
    }
    /**
     * Deletes a security automation.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param automationName The security automation name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, automationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, automationName, options }, deleteOperationSpec$9);
    }
    /**
     * Validates the security automation model before create or update. Any validation errors are returned
     * to the client.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param automationName The security automation name.
     * @param automation The security automation resource
     * @param options The options parameters.
     */
    validate(resourceGroupName, automationName, automation, options) {
        return this.client.sendOperationRequest({ resourceGroupName, automationName, automation, options }, validateOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$h);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/automations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutomationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$p
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/automations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutomationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/automations/{automationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Automation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        automationName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/automations/{automationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Automation
        },
        201: {
            bodyMapper: Automation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: automation,
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        automationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/automations/{automationName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        automationName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const validateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/automations/{automationName}/validate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AutomationValidationStatus
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: automation,
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        automationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutomationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutomationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AlertsSuppressionRules operations. */
class AlertsSuppressionRulesImpl {
    /**
     * Initialize a new instance of the class AlertsSuppressionRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of all the dismiss rules for the given subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of all the dismiss rules for the given subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$l);
    }
    /**
     * Get dismiss rule, with name: {alertsSuppressionRuleName}, for the given subscription
     * @param alertsSuppressionRuleName The unique name of the suppression alert rule
     * @param options The options parameters.
     */
    get(alertsSuppressionRuleName, options) {
        return this.client.sendOperationRequest({ alertsSuppressionRuleName, options }, getOperationSpec$k);
    }
    /**
     * Update existing rule or create new rule if it doesn't exist
     * @param alertsSuppressionRuleName The unique name of the suppression alert rule
     * @param alertsSuppressionRule Suppression rule object
     * @param options The options parameters.
     */
    update(alertsSuppressionRuleName, alertsSuppressionRule, options) {
        return this.client.sendOperationRequest({ alertsSuppressionRuleName, alertsSuppressionRule, options }, updateOperationSpec$2);
    }
    /**
     * Delete dismiss alert rule for this subscription.
     * @param alertsSuppressionRuleName The unique name of the suppression alert rule
     * @param options The options parameters.
     */
    delete(alertsSuppressionRuleName, options) {
        return this.client.sendOperationRequest({ alertsSuppressionRuleName, options }, deleteOperationSpec$8);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/alertsSuppressionRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertsSuppressionRulesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8, alertType],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$o
};
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/alertsSuppressionRules/{alertsSuppressionRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertsSuppressionRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        alertsSuppressionRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/alertsSuppressionRules/{alertsSuppressionRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AlertsSuppressionRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: alertsSuppressionRule,
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        alertsSuppressionRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/alertsSuppressionRules/{alertsSuppressionRuleName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8],
    urlParameters: [
        $host,
        subscriptionId,
        alertsSuppressionRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertsSuppressionRulesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion8, alertType],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServerVulnerabilityAssessmentOperations operations. */
class ServerVulnerabilityAssessmentOperationsImpl {
    /**
     * Initialize a new instance of the class ServerVulnerabilityAssessmentOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of server vulnerability assessment onboarding statuses on a given resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            options
        }, listByExtendedResourceOperationSpec$2);
    }
    /**
     * Gets a server vulnerability assessment onboarding statuses on a given resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            options
        }, getOperationSpec$j);
    }
    /**
     * Creating a server vulnerability assessment on a resource, which will onboard a resource for having a
     * vulnerability assessment on it
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            options
        }, createOrUpdateOperationSpec$5);
    }
    /**
     * Removing server vulnerability assessment from a resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                resourceNamespace,
                resourceType,
                resourceName,
                options
            }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Removing server vulnerability assessment from a resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceNamespace, resourceType, resourceName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByExtendedResourceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/serverVulnerabilityAssessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessmentsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/serverVulnerabilityAssessments/{serverVulnerabilityAssessment}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName,
        serverVulnerabilityAssessment
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/serverVulnerabilityAssessments/{serverVulnerabilityAssessment}",
    httpMethod: "PUT",
    responses: {
        202: {
            bodyMapper: ServerVulnerabilityAssessment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName,
        serverVulnerabilityAssessment
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/serverVulnerabilityAssessments/{serverVulnerabilityAssessment}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName,
        serverVulnerabilityAssessment
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AssessmentsMetadata operations. */
class AssessmentsMetadataImpl {
    /**
     * Initialize a new instance of the class AssessmentsMetadata class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get metadata information on all assessment types
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get metadata information on all assessment types in a specific subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get metadata information on all assessment types
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$k);
    }
    /**
     * Get metadata information on an assessment type
     * @param assessmentMetadataName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    get(assessmentMetadataName, options) {
        return this.client.sendOperationRequest({ assessmentMetadataName, options }, getOperationSpec$i);
    }
    /**
     * Get metadata information on all assessment types in a specific subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * Get metadata information on an assessment type in a specific subscription
     * @param assessmentMetadataName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    getInSubscription(assessmentMetadataName, options) {
        return this.client.sendOperationRequest({ assessmentMetadataName, options }, getInSubscriptionOperationSpec);
    }
    /**
     * Create metadata information on an assessment type in a specific subscription
     * @param assessmentMetadataName The Assessment Key - Unique key for the assessment type
     * @param assessmentMetadata AssessmentMetadata object
     * @param options The options parameters.
     */
    createInSubscription(assessmentMetadataName, assessmentMetadata, options) {
        return this.client.sendOperationRequest({ assessmentMetadataName, assessmentMetadata, options }, createInSubscriptionOperationSpec);
    }
    /**
     * Delete metadata information on an assessment type in a specific subscription, will cause the
     * deletion of all the assessments of that type in that subscription
     * @param assessmentMetadataName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    deleteInSubscription(assessmentMetadataName, options) {
        return this.client.sendOperationRequest({ assessmentMetadataName, options }, deleteInSubscriptionOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$f);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$k = {
    path: "/providers/Microsoft.Security/assessmentMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponseList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$m
};
const getOperationSpec$i = {
    path: "/providers/Microsoft.Security/assessmentMetadata/{assessmentMetadataName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [$host, assessmentMetadataName],
    headerParameters: [accept],
    serializer: serializer$m
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/assessmentMetadata",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponseList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$m
};
const getInSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/assessmentMetadata/{assessmentMetadataName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [
        $host,
        subscriptionId,
        assessmentMetadataName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createInSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/assessmentMetadata/{assessmentMetadataName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: assessmentMetadata,
    queryParameters: [apiVersion10],
    urlParameters: [
        $host,
        subscriptionId,
        assessmentMetadataName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteInSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/assessmentMetadata/{assessmentMetadataName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [
        $host,
        subscriptionId,
        assessmentMetadataName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponseList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$m
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentMetadataResponseList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Assessments operations. */
class AssessmentsImpl {
    /**
     * Initialize a new instance of the class Assessments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get security assessments on all your scanned resources inside a scope
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    list(scope, options) {
        const iter = this.listPagingAll(scope, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(scope, options);
            }
        };
    }
    listPagingPage(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(scope, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(scope, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(scope, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(scope, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get security assessments on all your scanned resources inside a scope
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param options The options parameters.
     */
    _list(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, listOperationSpec$j);
    }
    /**
     * Get a security assessment on your scanned resource
     * @param resourceId The identifier of the resource.
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    get(resourceId, assessmentName, options) {
        return this.client.sendOperationRequest({ resourceId, assessmentName, options }, getOperationSpec$h);
    }
    /**
     * Create a security assessment on your resource. An assessment metadata that describes this assessment
     * must be predefined with the same name before inserting the assessment result
     * @param resourceId The identifier of the resource.
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param assessment Calculated assessment on a pre-defined assessment metadata
     * @param options The options parameters.
     */
    createOrUpdate(resourceId, assessmentName, assessment, options) {
        return this.client.sendOperationRequest({ resourceId, assessmentName, assessment, options }, createOrUpdateOperationSpec$4);
    }
    /**
     * Delete a security assessment on your resource. An assessment metadata that describes this assessment
     * must be predefined with the same name before inserting the assessment result
     * @param resourceId The identifier of the resource.
     * @param assessmentName The Assessment Key - Unique key for the assessment type
     * @param options The options parameters.
     */
    delete(resourceId, assessmentName, options) {
        return this.client.sendOperationRequest({ resourceId, assessmentName, options }, deleteOperationSpec$6);
    }
    /**
     * ListNext
     * @param scope Scope of the query, can be subscription
     *              (/subscriptions/0b06d9ea-afe6-4779-bd59-30e5c2d9d13f) or management group
     *              (/providers/Microsoft.Management/managementGroups/mgName).
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(scope, nextLink, options) {
        return this.client.sendOperationRequest({ scope, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$j = {
    path: "/{scope}/providers/Microsoft.Security/assessments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [$host, scope],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$h = {
    path: "/{resourceId}/providers/Microsoft.Security/assessments/{assessmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10, expand],
    urlParameters: [
        $host,
        resourceId,
        assessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$4 = {
    path: "/{resourceId}/providers/Microsoft.Security/assessments/{assessmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentResponse
        },
        201: {
            bodyMapper: SecurityAssessmentResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: assessment,
    queryParameters: [apiVersion10],
    urlParameters: [
        $host,
        resourceId,
        assessmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$6 = {
    path: "/{resourceId}/providers/Microsoft.Security/assessments/{assessmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [
        $host,
        resourceId,
        assessmentName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAssessmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion10],
    urlParameters: [$host, nextLink, scope],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing AdaptiveApplicationControls operations. */
class AdaptiveApplicationControlsImpl {
    /**
     * Initialize a new instance of the class AdaptiveApplicationControls class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of application control machine groups for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$i);
    }
    /**
     * Gets an application control VM/server group.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param groupName Name of an application control machine group
     * @param options The options parameters.
     */
    get(ascLocation, groupName, options) {
        return this.client.sendOperationRequest({ ascLocation, groupName, options }, getOperationSpec$g);
    }
    /**
     * Update an application control machine group
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param groupName Name of an application control machine group
     * @param body
     * @param options The options parameters.
     */
    put(ascLocation, groupName, body, options) {
        return this.client.sendOperationRequest({ ascLocation, groupName, body, options }, putOperationSpec);
    }
    /**
     * Delete an application control machine group
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param groupName Name of an application control machine group
     * @param options The options parameters.
     */
    delete(ascLocation, groupName, options) {
        return this.client.sendOperationRequest({ ascLocation, groupName, options }, deleteOperationSpec$5);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/applicationWhitelistings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdaptiveApplicationControlGroups
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion9,
        includePathRecommendations,
        summary
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/applicationWhitelistings/{groupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdaptiveApplicationControlGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        groupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/applicationWhitelistings/{groupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AdaptiveApplicationControlGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body,
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        groupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/applicationWhitelistings/{groupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        groupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AdaptiveNetworkHardenings operations. */
class AdaptiveNetworkHardeningsImpl {
    /**
     * Initialize a new instance of the class AdaptiveNetworkHardenings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Adaptive Network Hardenings resources in scope of an extended resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        const iter = this.listByExtendedResourcePagingAll(resourceGroupName, resourceNamespace, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByExtendedResourcePagingPage(resourceGroupName, resourceNamespace, resourceType, resourceName, options);
            }
        };
    }
    listByExtendedResourcePagingPage(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByExtendedResourcePagingPage_1() {
            let result = yield tslib.__await(this._listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByExtendedResourceNext(resourceGroupName, resourceNamespace, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByExtendedResourcePagingAll(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByExtendedResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByExtendedResourcePagingPage(resourceGroupName, resourceNamespace, resourceType, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of Adaptive Network Hardenings resources in scope of an extended resource.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    _listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            options
        }, listByExtendedResourceOperationSpec$1);
    }
    /**
     * Gets a single Adaptive Network Hardening resource
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param adaptiveNetworkHardeningResourceName The name of the Adaptive Network Hardening resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceNamespace, resourceType, resourceName, adaptiveNetworkHardeningResourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            adaptiveNetworkHardeningResourceName,
            options
        }, getOperationSpec$f);
    }
    /**
     * Enforces the given rules on the NSG(s) listed in the request
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param adaptiveNetworkHardeningResourceName The name of the Adaptive Network Hardening resource.
     * @param body
     * @param options The options parameters.
     */
    beginEnforce(resourceGroupName, resourceNamespace, resourceType, resourceName, adaptiveNetworkHardeningResourceName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                resourceNamespace,
                resourceType,
                resourceName,
                adaptiveNetworkHardeningResourceName,
                body,
                options
            }, enforceOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Enforces the given rules on the NSG(s) listed in the request
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param adaptiveNetworkHardeningResourceName The name of the Adaptive Network Hardening resource.
     * @param body
     * @param options The options parameters.
     */
    beginEnforceAndWait(resourceGroupName, resourceNamespace, resourceType, resourceName, adaptiveNetworkHardeningResourceName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginEnforce(resourceGroupName, resourceNamespace, resourceType, resourceName, adaptiveNetworkHardeningResourceName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByExtendedResourceNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The Namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param nextLink The nextLink from the previous successful call to the ListByExtendedResource method.
     * @param options The options parameters.
     */
    _listByExtendedResourceNext(resourceGroupName, resourceNamespace, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listByExtendedResourceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByExtendedResourceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/adaptiveNetworkHardenings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdaptiveNetworkHardeningsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/adaptiveNetworkHardenings/{adaptiveNetworkHardeningResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdaptiveNetworkHardening
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName,
        adaptiveNetworkHardeningResourceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const enforceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/adaptiveNetworkHardenings/{adaptiveNetworkHardeningResourceName}/{adaptiveNetworkHardeningEnforceAction}",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName,
        adaptiveNetworkHardeningResourceName,
        adaptiveNetworkHardeningEnforceAction
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listByExtendedResourceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdaptiveNetworkHardeningsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceNamespace,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AllowedConnections operations. */
class AllowedConnectionsImpl {
    /**
     * Initialize a new instance of the class AllowedConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of all possible traffic between resources for the subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of all possible traffic between resources for the subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByHomeRegion(ascLocation, options) {
        const iter = this.listByHomeRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByHomeRegionPagingPage(ascLocation, options);
            }
        };
    }
    listByHomeRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByHomeRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByHomeRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByHomeRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHomeRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the list of all possible traffic between resources for the subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$h);
    }
    /**
     * Gets the list of all possible traffic between resources for the subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByHomeRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByHomeRegionOperationSpec$4);
    }
    /**
     * Gets the list of all possible traffic between resources for the subscription and location, based on
     * connection type.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param connectionType The type of allowed connections (Internal, External)
     * @param options The options parameters.
     */
    get(resourceGroupName, ascLocation, connectionType, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, connectionType, options }, getOperationSpec$e);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$d);
    }
    /**
     * ListByHomeRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByHomeRegion method.
     * @param options The options parameters.
     */
    _listByHomeRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listByHomeRegionNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/allowedConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AllowedConnectionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByHomeRegionOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/allowedConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AllowedConnectionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/allowedConnections/{connectionType}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AllowedConnectionsResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        connectionType
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AllowedConnectionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByHomeRegionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AllowedConnectionsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Topology operations. */
class TopologyImpl {
    /**
     * Initialize a new instance of the class Topology class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list that allows to build a topology view of a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list that allows to build a topology view of a subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByHomeRegion(ascLocation, options) {
        const iter = this.listByHomeRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByHomeRegionPagingPage(ascLocation, options);
            }
        };
    }
    listByHomeRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByHomeRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByHomeRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByHomeRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHomeRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list that allows to build a topology view of a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$g);
    }
    /**
     * Gets a list that allows to build a topology view of a subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByHomeRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByHomeRegionOperationSpec$3);
    }
    /**
     * Gets a specific topology component.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param topologyResourceName Name of a topology resources collection.
     * @param options The options parameters.
     */
    get(resourceGroupName, ascLocation, topologyResourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, topologyResourceName, options }, getOperationSpec$d);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$c);
    }
    /**
     * ListByHomeRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByHomeRegion method.
     * @param options The options parameters.
     */
    _listByHomeRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listByHomeRegionNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/topologies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopologyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByHomeRegionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/topologies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopologyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/topologies/{topologyResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopologyResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        topologyResourceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopologyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByHomeRegionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopologyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JitNetworkAccessPolicies operations. */
class JitNetworkAccessPoliciesImpl {
    /**
     * Initialize a new instance of the class JitNetworkAccessPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Policies for protecting resources using Just-in-Time access control.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByRegion(ascLocation, options) {
        const iter = this.listByRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByRegionPagingPage(ascLocation, options);
            }
        };
    }
    listByRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRegionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByResourceGroupAndRegion(resourceGroupName, ascLocation, options) {
        const iter = this.listByResourceGroupAndRegionPagingAll(resourceGroupName, ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupAndRegionPagingPage(resourceGroupName, ascLocation, options);
            }
        };
    }
    listByResourceGroupAndRegionPagingPage(resourceGroupName, ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupAndRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroupAndRegion(resourceGroupName, ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupAndRegionNext(resourceGroupName, ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupAndRegionPagingAll(resourceGroupName, ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupAndRegionPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupAndRegionPagingPage(resourceGroupName, ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Policies for protecting resources using Just-in-Time access control.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$f);
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByRegionOperationSpec);
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByResourceGroupAndRegion(resourceGroupName, ascLocation, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, options }, listByResourceGroupAndRegionOperationSpec);
    }
    /**
     * Policies for protecting resources using Just-in-Time access control for the subscription, location
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param jitNetworkAccessPolicyName Name of a Just-in-Time access configuration policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, ascLocation, jitNetworkAccessPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, jitNetworkAccessPolicyName, options }, getOperationSpec$c);
    }
    /**
     * Create a policy for protecting resources using Just-in-Time access control
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param jitNetworkAccessPolicyName Name of a Just-in-Time access configuration policy.
     * @param body
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, ascLocation, jitNetworkAccessPolicyName, body, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            ascLocation,
            jitNetworkAccessPolicyName,
            body,
            options
        }, createOrUpdateOperationSpec$3);
    }
    /**
     * Delete a Just-in-Time access control policy.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param jitNetworkAccessPolicyName Name of a Just-in-Time access configuration policy.
     * @param options The options parameters.
     */
    delete(resourceGroupName, ascLocation, jitNetworkAccessPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, jitNetworkAccessPolicyName, options }, deleteOperationSpec$4);
    }
    /**
     * Initiate a JIT access from a specific Just-in-Time policy configuration.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param jitNetworkAccessPolicyName Name of a Just-in-Time access configuration policy.
     * @param body
     * @param options The options parameters.
     */
    initiate(resourceGroupName, ascLocation, jitNetworkAccessPolicyName, body, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            ascLocation,
            jitNetworkAccessPolicyName,
            body,
            options
        }, initiateOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$b);
    }
    /**
     * ListByRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByRegion method.
     * @param options The options parameters.
     */
    _listByRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listByRegionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupAndRegionNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroupAndRegion
     *                 method.
     * @param options The options parameters.
     */
    _listByResourceGroupAndRegionNext(resourceGroupName, ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, nextLink, options }, listByResourceGroupAndRegionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/jitNetworkAccessPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/jitNetworkAccessPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/jitNetworkAccessPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupAndRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/jitNetworkAccessPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/jitNetworkAccessPolicies/{jitNetworkAccessPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        jitNetworkAccessPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/jitNetworkAccessPolicies/{jitNetworkAccessPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body2,
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        jitNetworkAccessPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/jitNetworkAccessPolicies/{jitNetworkAccessPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        jitNetworkAccessPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const initiateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/jitNetworkAccessPolicies/{jitNetworkAccessPolicyName}/{jitNetworkAccessPolicyInitiateType}",
    httpMethod: "POST",
    responses: {
        202: {
            bodyMapper: JitNetworkAccessRequest
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body3,
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        jitNetworkAccessPolicyName,
        jitNetworkAccessPolicyInitiateType
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByRegionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupAndRegionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JitNetworkAccessPoliciesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DiscoveredSecuritySolutions operations. */
class DiscoveredSecuritySolutionsImpl {
    /**
     * Initialize a new instance of the class DiscoveredSecuritySolutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of discovered Security Solutions for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of discovered Security Solutions for the subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByHomeRegion(ascLocation, options) {
        const iter = this.listByHomeRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByHomeRegionPagingPage(ascLocation, options);
            }
        };
    }
    listByHomeRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByHomeRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByHomeRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByHomeRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHomeRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of discovered Security Solutions for the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * Gets a list of discovered Security Solutions for the subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByHomeRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByHomeRegionOperationSpec$2);
    }
    /**
     * Gets a specific discovered Security Solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param discoveredSecuritySolutionName Name of a discovered security solution.
     * @param options The options parameters.
     */
    get(resourceGroupName, ascLocation, discoveredSecuritySolutionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            ascLocation,
            discoveredSecuritySolutionName,
            options
        }, getOperationSpec$b);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$a);
    }
    /**
     * ListByHomeRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByHomeRegion method.
     * @param options The options parameters.
     */
    _listByHomeRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listByHomeRegionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/discoveredSecuritySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiscoveredSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByHomeRegionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/discoveredSecuritySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiscoveredSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/discoveredSecuritySolutions/{discoveredSecuritySolutionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiscoveredSecuritySolution
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        discoveredSecuritySolutionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiscoveredSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByHomeRegionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiscoveredSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SecuritySolutionsReferenceDataOperations operations. */
class SecuritySolutionsReferenceDataOperationsImpl {
    /**
     * Initialize a new instance of the class SecuritySolutionsReferenceDataOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all supported Security Solutions for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$d);
    }
    /**
     * Gets list of all supported Security Solutions for subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByHomeRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByHomeRegionOperationSpec$1);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securitySolutionsReferenceData",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySolutionsReferenceDataList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByHomeRegionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/securitySolutionsReferenceData",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySolutionsReferenceDataList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExternalSecuritySolutions operations. */
class ExternalSecuritySolutionsImpl {
    /**
     * Initialize a new instance of the class ExternalSecuritySolutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of external security solutions for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of external Security Solutions for the subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listByHomeRegion(ascLocation, options) {
        const iter = this.listByHomeRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByHomeRegionPagingPage(ascLocation, options);
            }
        };
    }
    listByHomeRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingPage_1() {
            let result = yield tslib.__await(this._listByHomeRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByHomeRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByHomeRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHomeRegionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHomeRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of external security solutions for the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Gets a list of external Security Solutions for the subscription and location.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listByHomeRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listByHomeRegionOperationSpec);
    }
    /**
     * Gets a specific external Security Solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param externalSecuritySolutionsName Name of an external security solution.
     * @param options The options parameters.
     */
    get(resourceGroupName, ascLocation, externalSecuritySolutionsName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            ascLocation,
            externalSecuritySolutionsName,
            options
        }, getOperationSpec$a);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$9);
    }
    /**
     * ListByHomeRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListByHomeRegion method.
     * @param options The options parameters.
     */
    _listByHomeRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listByHomeRegionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/externalSecuritySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByHomeRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/ExternalSecuritySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/ExternalSecuritySolutions/{externalSecuritySolutionsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalSecuritySolution
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        externalSecuritySolutionsName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByHomeRegionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalSecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecureScores operations. */
class SecureScoresImpl {
    /**
     * Initialize a new instance of the class SecureScores class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List secure scores for all your Security Center initiatives within your current scope.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List secure scores for all your Security Center initiatives within your current scope.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$b);
    }
    /**
     * Get secure score for a specific Security Center initiative within your current scope. For the ASC
     * Default initiative, use 'ascScore'.
     * @param secureScoreName The initiative name. For the ASC Default initiative, use 'ascScore' as in the
     *                        sample request below.
     * @param options The options parameters.
     */
    get(secureScoreName, options) {
        return this.client.sendOperationRequest({ secureScoreName, options }, getOperationSpec$9);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/secureScores",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoresList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/secureScores/{secureScoreName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreItem
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        secureScoreName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoresList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecureScoreControls operations. */
class SecureScoreControlsImpl {
    /**
     * Initialize a new instance of the class SecureScoreControls class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all security controls for a specific initiative within a scope
     * @param secureScoreName The initiative name. For the ASC Default initiative, use 'ascScore' as in the
     *                        sample request below.
     * @param options The options parameters.
     */
    listBySecureScore(secureScoreName, options) {
        const iter = this.listBySecureScorePagingAll(secureScoreName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySecureScorePagingPage(secureScoreName, options);
            }
        };
    }
    listBySecureScorePagingPage(secureScoreName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySecureScorePagingPage_1() {
            let result = yield tslib.__await(this._listBySecureScore(secureScoreName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySecureScoreNext(secureScoreName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySecureScorePagingAll(secureScoreName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySecureScorePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySecureScorePagingPage(secureScoreName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all security controls within a scope
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all security controls for a specific initiative within a scope
     * @param secureScoreName The initiative name. For the ASC Default initiative, use 'ascScore' as in the
     *                        sample request below.
     * @param options The options parameters.
     */
    _listBySecureScore(secureScoreName, options) {
        return this.client.sendOperationRequest({ secureScoreName, options }, listBySecureScoreOperationSpec);
    }
    /**
     * Get all security controls within a scope
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$a);
    }
    /**
     * ListBySecureScoreNext
     * @param secureScoreName The initiative name. For the ASC Default initiative, use 'ascScore' as in the
     *                        sample request below.
     * @param nextLink The nextLink from the previous successful call to the ListBySecureScore method.
     * @param options The options parameters.
     */
    _listBySecureScoreNext(secureScoreName, nextLink, options) {
        return this.client.sendOperationRequest({ secureScoreName, nextLink, options }, listBySecureScoreNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySecureScoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/secureScores/{secureScoreName}/secureScoreControls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        secureScoreName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/secureScoreControls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9, expand1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listBySecureScoreNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        secureScoreName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecureScoreControlDefinitions operations. */
class SecureScoreControlDefinitionsImpl {
    /**
     * Initialize a new instance of the class SecureScoreControlDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the available security controls, their assessments, and the max score
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * For a specified subscription, list the available security controls, their assessments, and the max
     * score
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List the available security controls, their assessments, and the max score
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$9);
    }
    /**
     * For a specified subscription, list the available security controls, their assessments, and the max
     * score
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$6);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/providers/Microsoft.Security/secureScoreControlDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlDefinitionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/secureScoreControlDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlDefinitionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlDefinitionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecureScoreControlDefinitionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecuritySolutions operations. */
class SecuritySolutionsImpl {
    /**
     * Initialize a new instance of the class SecuritySolutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of Security Solutions for the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of Security Solutions for the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * Gets a specific Security Solution.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param securitySolutionName Name of security solution.
     * @param options The options parameters.
     */
    get(resourceGroupName, ascLocation, securitySolutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ascLocation, securitySolutionName, options }, getOperationSpec$8);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securitySolutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/securitySolutions/{securitySolutionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySolution
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        securitySolutionName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecuritySolutionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion9],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Connectors operations. */
class ConnectorsImpl {
    /**
     * Initialize a new instance of the class Connectors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Cloud accounts connectors of a subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Cloud accounts connectors of a subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$7);
    }
    /**
     * Details of a specific cloud account connector
     * @param connectorName Name of the cloud account connector
     * @param options The options parameters.
     */
    get(connectorName, options) {
        return this.client.sendOperationRequest({ connectorName, options }, getOperationSpec$7);
    }
    /**
     * Create a cloud account connector or update an existing one. Connect to your cloud account. For AWS,
     * use either account credentials or role-based authentication. For GCP, use account organization
     * credentials.
     * @param connectorName Name of the cloud account connector
     * @param connectorSetting Settings for the cloud account connector
     * @param options The options parameters.
     */
    createOrUpdate(connectorName, connectorSetting, options) {
        return this.client.sendOperationRequest({ connectorName, connectorSetting, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * Delete a cloud account connector from a subscription
     * @param connectorName Name of the cloud account connector
     * @param options The options parameters.
     */
    delete(connectorName, options) {
        return this.client.sendOperationRequest({ connectorName, options }, deleteOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/connectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion11],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/connectors/{connectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion11],
    urlParameters: [
        $host,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/connectors/{connectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectorSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: connectorSetting,
    queryParameters: [apiVersion11],
    urlParameters: [
        $host,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/connectors/{connectorName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion11],
    urlParameters: [
        $host,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion11],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlVulnerabilityAssessmentScans operations. */
class SqlVulnerabilityAssessmentScansImpl {
    /**
     * Initialize a new instance of the class SqlVulnerabilityAssessmentScans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the scan details of a single scan record.
     * @param scanId The scan Id. Type 'latest' to get the scan record for the latest scan.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    get(scanId, workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ scanId, workspaceId, resourceId, options }, getOperationSpec$6);
    }
    /**
     * Gets a list of scan records.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    list(workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ workspaceId, resourceId, options }, listOperationSpec$6);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$6 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/scans/{scanId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Scan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId, scanId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec$6 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/scans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Scans
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlVulnerabilityAssessmentScanResults operations. */
class SqlVulnerabilityAssessmentScanResultsImpl {
    /**
     * Initialize a new instance of the class SqlVulnerabilityAssessmentScanResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the scan results of a single rule in a scan record.
     * @param scanId The scan Id. Type 'latest' to get the scan results for the latest scan.
     * @param scanResultId The rule Id of the results.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    get(scanId, scanResultId, workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ scanId, scanResultId, workspaceId, resourceId, options }, getOperationSpec$5);
    }
    /**
     * Gets a list of scan results for a single scan record.
     * @param scanId The scan Id. Type 'latest' to get the scan results for the latest scan.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    list(scanId, workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ scanId, workspaceId, resourceId, options }, listOperationSpec$5);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/scans/{scanId}/scanResults/{scanResultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScanResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [
        $host,
        resourceId,
        scanId,
        scanResultId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listOperationSpec$5 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/scans/{scanId}/scanResults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScanResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId, scanId],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SqlVulnerabilityAssessmentBaselineRules operations. */
class SqlVulnerabilityAssessmentBaselineRulesImpl {
    /**
     * Initialize a new instance of the class SqlVulnerabilityAssessmentBaselineRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a Baseline for a rule in a database. Will overwrite any previously existing results.
     * @param ruleId The rule Id.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    createOrUpdate(ruleId, workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ ruleId, workspaceId, resourceId, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Gets the results for a given rule in the Baseline.
     * @param ruleId The rule Id.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    get(ruleId, workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ ruleId, workspaceId, resourceId, options }, getOperationSpec$4);
    }
    /**
     * Deletes a rule from the Baseline of a given database.
     * @param ruleId The rule Id.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    delete(ruleId, workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ ruleId, workspaceId, resourceId, options }, deleteOperationSpec$2);
    }
    /**
     * Gets the results for all rules in the Baseline.
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    list(workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ workspaceId, resourceId, options }, listOperationSpec$4);
    }
    /**
     * Add a list of baseline rules. Will overwrite any previously existing results (for all rules).
     * @param workspaceId The workspace Id.
     * @param resourceId The identifier of the resource.
     * @param options The options parameters.
     */
    add(workspaceId, resourceId, options) {
        return this.client.sendOperationRequest({ workspaceId, resourceId, options }, addOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/baselineRules/{ruleId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RuleResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body4,
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId, ruleId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/baselineRules/{ruleId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuleResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId, ruleId],
    headerParameters: [accept],
    serializer: serializer$5
};
const deleteOperationSpec$2 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/baselineRules/{ruleId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId, ruleId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listOperationSpec$4 = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/baselineRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RulesResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId],
    headerParameters: [accept],
    serializer: serializer$5
};
const addOperationSpec = {
    path: "/{resourceId}/providers/Microsoft.Security/sqlVulnerabilityAssessments/default/baselineRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RulesResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body5,
    queryParameters: [workspaceId, apiVersion12],
    urlParameters: [$host, resourceId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Alerts operations. */
class AlertsImpl {
    /**
     * Initialize a new instance of the class Alerts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the alerts that are associated with the subscription
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the alerts that are associated with the resource group
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all the alerts that are associated with the subscription that are stored in a specific location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    listSubscriptionLevelByRegion(ascLocation, options) {
        const iter = this.listSubscriptionLevelByRegionPagingAll(ascLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listSubscriptionLevelByRegionPagingPage(ascLocation, options);
            }
        };
    }
    listSubscriptionLevelByRegionPagingPage(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSubscriptionLevelByRegionPagingPage_1() {
            let result = yield tslib.__await(this._listSubscriptionLevelByRegion(ascLocation, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listSubscriptionLevelByRegionNext(ascLocation, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listSubscriptionLevelByRegionPagingAll(ascLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSubscriptionLevelByRegionPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSubscriptionLevelByRegionPagingPage(ascLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * List all the alerts that are associated with the resource group that are stored in a specific
     * location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listResourceGroupLevelByRegion(ascLocation, resourceGroupName, options) {
        const iter = this.listResourceGroupLevelByRegionPagingAll(ascLocation, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listResourceGroupLevelByRegionPagingPage(ascLocation, resourceGroupName, options);
            }
        };
    }
    listResourceGroupLevelByRegionPagingPage(ascLocation, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceGroupLevelByRegionPagingPage_1() {
            let result = yield tslib.__await(this._listResourceGroupLevelByRegion(ascLocation, resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listResourceGroupLevelByRegionNext(ascLocation, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listResourceGroupLevelByRegionPagingAll(ascLocation, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listResourceGroupLevelByRegionPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listResourceGroupLevelByRegionPagingPage(ascLocation, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * List all the alerts that are associated with the subscription
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * List all the alerts that are associated with the resource group
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * List all the alerts that are associated with the subscription that are stored in a specific location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param options The options parameters.
     */
    _listSubscriptionLevelByRegion(ascLocation, options) {
        return this.client.sendOperationRequest({ ascLocation, options }, listSubscriptionLevelByRegionOperationSpec);
    }
    /**
     * List all the alerts that are associated with the resource group that are stored in a specific
     * location
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listResourceGroupLevelByRegion(ascLocation, resourceGroupName, options) {
        return this.client.sendOperationRequest({ ascLocation, resourceGroupName, options }, listResourceGroupLevelByRegionOperationSpec);
    }
    /**
     * Get an alert that is associated with a subscription
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param options The options parameters.
     */
    getSubscriptionLevel(ascLocation, alertName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, options }, getSubscriptionLevelOperationSpec);
    }
    /**
     * Get an alert that is associated a resource group or a resource in a resource group
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    getResourceGroupLevel(ascLocation, alertName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, resourceGroupName, options }, getResourceGroupLevelOperationSpec);
    }
    /**
     * Update the alert's state
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param options The options parameters.
     */
    updateSubscriptionLevelStateToDismiss(ascLocation, alertName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, options }, updateSubscriptionLevelStateToDismissOperationSpec);
    }
    /**
     * Update the alert's state
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param options The options parameters.
     */
    updateSubscriptionLevelStateToResolve(ascLocation, alertName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, options }, updateSubscriptionLevelStateToResolveOperationSpec);
    }
    /**
     * Update the alert's state
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param options The options parameters.
     */
    updateSubscriptionLevelStateToActivate(ascLocation, alertName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, options }, updateSubscriptionLevelStateToActivateOperationSpec);
    }
    /**
     * Update the alert's state
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    updateResourceGroupLevelStateToResolve(ascLocation, alertName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, resourceGroupName, options }, updateResourceGroupLevelStateToResolveOperationSpec);
    }
    /**
     * Update the alert's state
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    updateResourceGroupLevelStateToDismiss(ascLocation, alertName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, resourceGroupName, options }, updateResourceGroupLevelStateToDismissOperationSpec);
    }
    /**
     * Update the alert's state
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertName Name of the alert object
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    updateResourceGroupLevelStateToActivate(ascLocation, alertName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ ascLocation, alertName, resourceGroupName, options }, updateResourceGroupLevelStateToActivateOperationSpec);
    }
    /**
     * Simulate security alerts
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param alertSimulatorRequestBody Alert Simulator Request Properties
     * @param options The options parameters.
     */
    simulate(ascLocation, alertSimulatorRequestBody, options) {
        return this.client.sendOperationRequest({ ascLocation, alertSimulatorRequestBody, options }, simulateOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListSubscriptionLevelByRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param nextLink The nextLink from the previous successful call to the ListSubscriptionLevelByRegion
     *                 method.
     * @param options The options parameters.
     */
    _listSubscriptionLevelByRegionNext(ascLocation, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, nextLink, options }, listSubscriptionLevelByRegionNextOperationSpec);
    }
    /**
     * ListResourceGroupLevelByRegionNext
     * @param ascLocation The location where ASC stores the data of the subscription. can be retrieved from
     *                    Get locations
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListResourceGroupLevelByRegion
     *                 method.
     * @param options The options parameters.
     */
    _listResourceGroupLevelByRegionNext(ascLocation, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ ascLocation, resourceGroupName, nextLink, options }, listResourceGroupLevelByRegionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listSubscriptionLevelByRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listResourceGroupLevelByRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getSubscriptionLevelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Alert
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getResourceGroupLevelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Alert
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateSubscriptionLevelStateToDismissOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}/dismiss",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateSubscriptionLevelStateToResolveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}/resolve",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateSubscriptionLevelStateToActivateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}/activate",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateResourceGroupLevelStateToResolveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}/resolve",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateResourceGroupLevelStateToDismissOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}/dismiss",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateResourceGroupLevelStateToActivateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/locations/{ascLocation}/alerts/{alertName}/activate",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        ascLocation,
        alertName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const simulateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/locations/{ascLocation}/alerts/default/simulate",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: alertSimulatorRequestBody,
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        ascLocation
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listSubscriptionLevelByRegionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listResourceGroupLevelByRegionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion13],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        ascLocation
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Settings operations. */
class SettingsImpl {
    /**
     * Initialize a new instance of the class Settings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Settings about different configurations in security center
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Settings about different configurations in security center
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Settings of different configurations in security center
     * @param settingName The name of the setting
     * @param options The options parameters.
     */
    get(settingName, options) {
        return this.client.sendOperationRequest({ settingName, options }, getOperationSpec$3);
    }
    /**
     * updating settings about different configurations in security center
     * @param settingName The name of the setting
     * @param setting Setting object
     * @param options The options parameters.
     */
    update(settingName, setting, options) {
        return this.client.sendOperationRequest({ settingName, setting, options }, updateOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/settings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SettingsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion14],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/settings/{settingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Setting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion14],
    urlParameters: [
        $host,
        subscriptionId,
        settingName2
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/settings/{settingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Setting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: setting1,
    queryParameters: [apiVersion14],
    urlParameters: [
        $host,
        subscriptionId,
        settingName2
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SettingsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion14],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IngestionSettings operations. */
class IngestionSettingsImpl {
    /**
     * Initialize a new instance of the class IngestionSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Settings for ingesting security data and logs to correlate with resources associated with the
     * subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Settings for ingesting security data and logs to correlate with resources associated with the
     * subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Settings for ingesting security data and logs to correlate with resources associated with the
     * subscription.
     * @param ingestionSettingName Name of the ingestion setting
     * @param options The options parameters.
     */
    get(ingestionSettingName, options) {
        return this.client.sendOperationRequest({ ingestionSettingName, options }, getOperationSpec$2);
    }
    /**
     * Create setting for ingesting security data and logs to correlate with resources associated with the
     * subscription.
     * @param ingestionSettingName Name of the ingestion setting
     * @param ingestionSetting Ingestion setting object
     * @param options The options parameters.
     */
    create(ingestionSettingName, ingestionSetting, options) {
        return this.client.sendOperationRequest({ ingestionSettingName, ingestionSetting, options }, createOperationSpec);
    }
    /**
     * Deletes the ingestion settings for this subscription.
     * @param ingestionSettingName Name of the ingestion setting
     * @param options The options parameters.
     */
    delete(ingestionSettingName, options) {
        return this.client.sendOperationRequest({ ingestionSettingName, options }, deleteOperationSpec$1);
    }
    /**
     * Returns the token that is used for correlating ingested telemetry with the resources in the
     * subscription.
     * @param ingestionSettingName Name of the ingestion setting
     * @param options The options parameters.
     */
    listTokens(ingestionSettingName, options) {
        return this.client.sendOperationRequest({ ingestionSettingName, options }, listTokensOperationSpec);
    }
    /**
     * Connection strings for ingesting security scan logs and data.
     * @param ingestionSettingName Name of the ingestion setting
     * @param options The options parameters.
     */
    listConnectionStrings(ingestionSettingName, options) {
        return this.client.sendOperationRequest({ ingestionSettingName, options }, listConnectionStringsOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/ingestionSettings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IngestionSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion15],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/ingestionSettings/{ingestionSettingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IngestionSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion15],
    urlParameters: [
        $host,
        subscriptionId,
        ingestionSettingName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/ingestionSettings/{ingestionSettingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IngestionSetting
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: ingestionSetting,
    queryParameters: [apiVersion15],
    urlParameters: [
        $host,
        subscriptionId,
        ingestionSettingName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/ingestionSettings/{ingestionSettingName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion15],
    urlParameters: [
        $host,
        subscriptionId,
        ingestionSettingName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listTokensOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/ingestionSettings/{ingestionSettingName}/listTokens",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IngestionSettingToken
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion15],
    urlParameters: [
        $host,
        subscriptionId,
        ingestionSettingName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listConnectionStringsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/ingestionSettings/{ingestionSettingName}/listConnectionStrings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionStrings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion15],
    urlParameters: [
        $host,
        subscriptionId,
        ingestionSettingName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IngestionSettingList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion15],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SoftwareInventories operations. */
class SoftwareInventoriesImpl {
    /**
     * Initialize a new instance of the class SoftwareInventories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the software inventory of the virtual machine.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        const iter = this.listByExtendedResourcePagingAll(resourceGroupName, resourceNamespace, resourceType, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByExtendedResourcePagingPage(resourceGroupName, resourceNamespace, resourceType, resourceName, options);
            }
        };
    }
    listByExtendedResourcePagingPage(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByExtendedResourcePagingPage_1() {
            let result = yield tslib.__await(this._listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByExtendedResourceNext(resourceGroupName, resourceNamespace, resourceType, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByExtendedResourcePagingAll(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByExtendedResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByExtendedResourcePagingPage(resourceGroupName, resourceNamespace, resourceType, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the software inventory of all virtual machines in the subscriptions.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the software inventory of the virtual machine.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    _listByExtendedResource(resourceGroupName, resourceNamespace, resourceType, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            options
        }, listByExtendedResourceOperationSpec);
    }
    /**
     * Gets the software inventory of all virtual machines in the subscriptions.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Gets a single software data of the virtual machine.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param softwareName Name of the installed software.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceNamespace, resourceType, resourceName, softwareName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            softwareName,
            options
        }, getOperationSpec$1);
    }
    /**
     * ListByExtendedResourceNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param resourceNamespace The namespace of the resource.
     * @param resourceType The type of the resource.
     * @param resourceName Name of the resource.
     * @param nextLink The nextLink from the previous successful call to the ListByExtendedResource method.
     * @param options The options parameters.
     */
    _listByExtendedResourceNext(resourceGroupName, resourceNamespace, resourceType, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceNamespace,
            resourceType,
            resourceName,
            nextLink,
            options
        }, listByExtendedResourceNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByExtendedResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/softwareInventories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SoftwaresList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion16],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/softwareInventories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SoftwaresList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion16],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Security/softwareInventories/{softwareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Software
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion16],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceNamespace,
        resourceType,
        resourceName,
        softwareName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByExtendedResourceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SoftwaresList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion16],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceNamespace,
        resourceType,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SoftwaresList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion16],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityConnectors operations. */
class SecurityConnectorsImpl {
    /**
     * Initialize a new instance of the class SecurityConnectors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the security connectors in the specified subscription. Use the 'nextLink' property in the
     * response to get the next page of security connectors for the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the security connectors in the specified resource group. Use the 'nextLink' property in
     * the response to get the next page of security connectors for the specified resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all the security connectors in the specified subscription. Use the 'nextLink' property in the
     * response to get the next page of security connectors for the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Lists all the security connectors in the specified resource group. Use the 'nextLink' property in
     * the response to get the next page of security connectors for the specified resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Retrieves details of a specific security connector
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param securityConnectorName The security connector name.
     * @param options The options parameters.
     */
    get(resourceGroupName, securityConnectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityConnectorName, options }, getOperationSpec);
    }
    /**
     * Creates or updates a security connector. If a security connector is already created and a subsequent
     * request is issued for the same security connector id, then it will be updated.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param securityConnectorName The security connector name.
     * @param securityConnector The security connector resource
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, securityConnectorName, securityConnector, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityConnectorName, securityConnector, options }, createOrUpdateOperationSpec);
    }
    /**
     * Updates a security connector
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param securityConnectorName The security connector name.
     * @param securityConnector The security connector resource
     * @param options The options parameters.
     */
    update(resourceGroupName, securityConnectorName, securityConnector, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityConnectorName, securityConnector, options }, updateOperationSpec);
    }
    /**
     * Deletes a security connector.
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param securityConnectorName The security connector name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, securityConnectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityConnectorName, options }, deleteOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription. The name is
     *                          case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Security/securityConnectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityConnectorsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/securityConnectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityConnectorsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/securityConnectors/{securityConnectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityConnector
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        securityConnectorName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/securityConnectors/{securityConnectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityConnector
        },
        201: {
            bodyMapper: SecurityConnector
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityConnector,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        securityConnectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/securityConnectors/{securityConnectorName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SecurityConnector
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityConnector,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        securityConnectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Security/securityConnectors/{securityConnectorName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        securityConnectorName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityConnectorsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityConnectorsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class SecurityCenter extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the SecurityCenter class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Azure subscription ID
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-security/5.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.mdeOnboardings = new MdeOnboardingsImpl(this);
        this.customAssessmentAutomations = new CustomAssessmentAutomationsImpl(this);
        this.customEntityStoreAssignments = new CustomEntityStoreAssignmentsImpl(this);
        this.complianceResults = new ComplianceResultsImpl(this);
        this.pricings = new PricingsImpl(this);
        this.advancedThreatProtection = new AdvancedThreatProtectionImpl(this);
        this.deviceSecurityGroups = new DeviceSecurityGroupsImpl(this);
        this.iotSecuritySolution = new IotSecuritySolutionImpl(this);
        this.iotSecuritySolutionAnalytics = new IotSecuritySolutionAnalyticsImpl(this);
        this.iotSecuritySolutionsAnalyticsAggregatedAlert = new IotSecuritySolutionsAnalyticsAggregatedAlertImpl(this);
        this.iotSecuritySolutionsAnalyticsRecommendation = new IotSecuritySolutionsAnalyticsRecommendationImpl(this);
        this.locations = new LocationsImpl(this);
        this.operations = new OperationsImpl(this);
        this.tasks = new TasksImpl(this);
        this.autoProvisioningSettings = new AutoProvisioningSettingsImpl(this);
        this.compliances = new CompliancesImpl(this);
        this.informationProtectionPolicies = new InformationProtectionPoliciesImpl(this);
        this.securityContacts = new SecurityContactsImpl(this);
        this.workspaceSettings = new WorkspaceSettingsImpl(this);
        this.regulatoryComplianceStandards = new RegulatoryComplianceStandardsImpl(this);
        this.regulatoryComplianceControls = new RegulatoryComplianceControlsImpl(this);
        this.regulatoryComplianceAssessments = new RegulatoryComplianceAssessmentsImpl(this);
        this.subAssessments = new SubAssessmentsImpl(this);
        this.automations = new AutomationsImpl(this);
        this.alertsSuppressionRules = new AlertsSuppressionRulesImpl(this);
        this.serverVulnerabilityAssessmentOperations = new ServerVulnerabilityAssessmentOperationsImpl(this);
        this.assessmentsMetadata = new AssessmentsMetadataImpl(this);
        this.assessments = new AssessmentsImpl(this);
        this.adaptiveApplicationControls = new AdaptiveApplicationControlsImpl(this);
        this.adaptiveNetworkHardenings = new AdaptiveNetworkHardeningsImpl(this);
        this.allowedConnections = new AllowedConnectionsImpl(this);
        this.topology = new TopologyImpl(this);
        this.jitNetworkAccessPolicies = new JitNetworkAccessPoliciesImpl(this);
        this.discoveredSecuritySolutions = new DiscoveredSecuritySolutionsImpl(this);
        this.securitySolutionsReferenceDataOperations = new SecuritySolutionsReferenceDataOperationsImpl(this);
        this.externalSecuritySolutions = new ExternalSecuritySolutionsImpl(this);
        this.secureScores = new SecureScoresImpl(this);
        this.secureScoreControls = new SecureScoreControlsImpl(this);
        this.secureScoreControlDefinitions = new SecureScoreControlDefinitionsImpl(this);
        this.securitySolutions = new SecuritySolutionsImpl(this);
        this.connectors = new ConnectorsImpl(this);
        this.sqlVulnerabilityAssessmentScans = new SqlVulnerabilityAssessmentScansImpl(this);
        this.sqlVulnerabilityAssessmentScanResults = new SqlVulnerabilityAssessmentScanResultsImpl(this);
        this.sqlVulnerabilityAssessmentBaselineRules = new SqlVulnerabilityAssessmentBaselineRulesImpl(this);
        this.alerts = new AlertsImpl(this);
        this.settings = new SettingsImpl(this);
        this.ingestionSettings = new IngestionSettingsImpl(this);
        this.softwareInventories = new SoftwareInventoriesImpl(this);
        this.securityConnectors = new SecurityConnectorsImpl(this);
    }
}

exports.SecurityCenter = SecurityCenter;
//# sourceMappingURL=index.js.map

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DatabaseAccountKind} that the service accepts. */
exports.KnownDatabaseAccountKind = void 0;
(function (KnownDatabaseAccountKind) {
    /** GlobalDocumentDB */
    KnownDatabaseAccountKind["GlobalDocumentDB"] = "GlobalDocumentDB";
    /** MongoDB */
    KnownDatabaseAccountKind["MongoDB"] = "MongoDB";
    /** Parse */
    KnownDatabaseAccountKind["Parse"] = "Parse";
})(exports.KnownDatabaseAccountKind || (exports.KnownDatabaseAccountKind = {}));
/** Known values of {@link ConnectorOffer} that the service accepts. */
exports.KnownConnectorOffer = void 0;
(function (KnownConnectorOffer) {
    /** Small */
    KnownConnectorOffer["Small"] = "Small";
})(exports.KnownConnectorOffer || (exports.KnownConnectorOffer = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
    /** SecuredByPerimeter */
    KnownPublicNetworkAccess["SecuredByPerimeter"] = "SecuredByPerimeter";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link ServerVersion} that the service accepts. */
exports.KnownServerVersion = void 0;
(function (KnownServerVersion) {
    /** Three2 */
    KnownServerVersion["Three2"] = "3.2";
    /** Three6 */
    KnownServerVersion["Three6"] = "3.6";
    /** Four0 */
    KnownServerVersion["Four0"] = "4.0";
    /** Four2 */
    KnownServerVersion["Four2"] = "4.2";
})(exports.KnownServerVersion || (exports.KnownServerVersion = {}));
/** Known values of {@link AnalyticalStorageSchemaType} that the service accepts. */
exports.KnownAnalyticalStorageSchemaType = void 0;
(function (KnownAnalyticalStorageSchemaType) {
    /** WellDefined */
    KnownAnalyticalStorageSchemaType["WellDefined"] = "WellDefined";
    /** FullFidelity */
    KnownAnalyticalStorageSchemaType["FullFidelity"] = "FullFidelity";
})(exports.KnownAnalyticalStorageSchemaType || (exports.KnownAnalyticalStorageSchemaType = {}));
/** Known values of {@link CreateMode} that the service accepts. */
exports.KnownCreateMode = void 0;
(function (KnownCreateMode) {
    /** Default */
    KnownCreateMode["Default"] = "Default";
    /** Restore */
    KnownCreateMode["Restore"] = "Restore";
})(exports.KnownCreateMode || (exports.KnownCreateMode = {}));
/** Known values of {@link RestoreMode} that the service accepts. */
exports.KnownRestoreMode = void 0;
(function (KnownRestoreMode) {
    /** PointInTime */
    KnownRestoreMode["PointInTime"] = "PointInTime";
})(exports.KnownRestoreMode || (exports.KnownRestoreMode = {}));
/** Known values of {@link BackupPolicyType} that the service accepts. */
exports.KnownBackupPolicyType = void 0;
(function (KnownBackupPolicyType) {
    /** Periodic */
    KnownBackupPolicyType["Periodic"] = "Periodic";
    /** Continuous */
    KnownBackupPolicyType["Continuous"] = "Continuous";
})(exports.KnownBackupPolicyType || (exports.KnownBackupPolicyType = {}));
/** Known values of {@link BackupPolicyMigrationStatus} that the service accepts. */
exports.KnownBackupPolicyMigrationStatus = void 0;
(function (KnownBackupPolicyMigrationStatus) {
    /** Invalid */
    KnownBackupPolicyMigrationStatus["Invalid"] = "Invalid";
    /** InProgress */
    KnownBackupPolicyMigrationStatus["InProgress"] = "InProgress";
    /** Completed */
    KnownBackupPolicyMigrationStatus["Completed"] = "Completed";
    /** Failed */
    KnownBackupPolicyMigrationStatus["Failed"] = "Failed";
})(exports.KnownBackupPolicyMigrationStatus || (exports.KnownBackupPolicyMigrationStatus = {}));
/** Known values of {@link MinimalTlsVersion} that the service accepts. */
exports.KnownMinimalTlsVersion = void 0;
(function (KnownMinimalTlsVersion) {
    /** Tls */
    KnownMinimalTlsVersion["Tls"] = "Tls";
    /** Tls11 */
    KnownMinimalTlsVersion["Tls11"] = "Tls11";
    /** Tls12 */
    KnownMinimalTlsVersion["Tls12"] = "Tls12";
})(exports.KnownMinimalTlsVersion || (exports.KnownMinimalTlsVersion = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link Kind} that the service accepts. */
exports.KnownKind = void 0;
(function (KnownKind) {
    /** Primary */
    KnownKind["Primary"] = "Primary";
    /** Secondary */
    KnownKind["Secondary"] = "Secondary";
    /** PrimaryReadonly */
    KnownKind["PrimaryReadonly"] = "PrimaryReadonly";
    /** SecondaryReadonly */
    KnownKind["SecondaryReadonly"] = "SecondaryReadonly";
})(exports.KnownKind || (exports.KnownKind = {}));
/** Known values of {@link Type} that the service accepts. */
exports.KnownType = void 0;
(function (KnownType) {
    /** Sql */
    KnownType["Sql"] = "Sql";
    /** Table */
    KnownType["Table"] = "Table";
    /** MongoDB */
    KnownType["MongoDB"] = "MongoDB";
    /** Cassandra */
    KnownType["Cassandra"] = "Cassandra";
    /** CassandraConnectorMetadata */
    KnownType["CassandraConnectorMetadata"] = "CassandraConnectorMetadata";
    /** Gremlin */
    KnownType["Gremlin"] = "Gremlin";
    /** SqlDedicatedGateway */
    KnownType["SqlDedicatedGateway"] = "SqlDedicatedGateway";
    /** GremlinV2 */
    KnownType["GremlinV2"] = "GremlinV2";
    /** Undefined */
    KnownType["Undefined"] = "Undefined";
})(exports.KnownType || (exports.KnownType = {}));
/** Known values of {@link KeyKind} that the service accepts. */
exports.KnownKeyKind = void 0;
(function (KnownKeyKind) {
    /** Primary */
    KnownKeyKind["Primary"] = "primary";
    /** Secondary */
    KnownKeyKind["Secondary"] = "secondary";
    /** PrimaryReadonly */
    KnownKeyKind["PrimaryReadonly"] = "primaryReadonly";
    /** SecondaryReadonly */
    KnownKeyKind["SecondaryReadonly"] = "secondaryReadonly";
})(exports.KnownKeyKind || (exports.KnownKeyKind = {}));
/** Known values of {@link UnitType} that the service accepts. */
exports.KnownUnitType = void 0;
(function (KnownUnitType) {
    /** Count */
    KnownUnitType["Count"] = "Count";
    /** Bytes */
    KnownUnitType["Bytes"] = "Bytes";
    /** Seconds */
    KnownUnitType["Seconds"] = "Seconds";
    /** Percent */
    KnownUnitType["Percent"] = "Percent";
    /** CountPerSecond */
    KnownUnitType["CountPerSecond"] = "CountPerSecond";
    /** BytesPerSecond */
    KnownUnitType["BytesPerSecond"] = "BytesPerSecond";
    /** Milliseconds */
    KnownUnitType["Milliseconds"] = "Milliseconds";
})(exports.KnownUnitType || (exports.KnownUnitType = {}));
/** Known values of {@link PrimaryAggregationType} that the service accepts. */
exports.KnownPrimaryAggregationType = void 0;
(function (KnownPrimaryAggregationType) {
    /** None */
    KnownPrimaryAggregationType["None"] = "None";
    /** Average */
    KnownPrimaryAggregationType["Average"] = "Average";
    /** Total */
    KnownPrimaryAggregationType["Total"] = "Total";
    /** Minimum */
    KnownPrimaryAggregationType["Minimum"] = "Minimum";
    /** Maximum */
    KnownPrimaryAggregationType["Maximum"] = "Maximum";
    /** Last */
    KnownPrimaryAggregationType["Last"] = "Last";
})(exports.KnownPrimaryAggregationType || (exports.KnownPrimaryAggregationType = {}));
/** Known values of {@link IndexingMode} that the service accepts. */
exports.KnownIndexingMode = void 0;
(function (KnownIndexingMode) {
    /** Consistent */
    KnownIndexingMode["Consistent"] = "consistent";
    /** Lazy */
    KnownIndexingMode["Lazy"] = "lazy";
    /** None */
    KnownIndexingMode["None"] = "none";
})(exports.KnownIndexingMode || (exports.KnownIndexingMode = {}));
/** Known values of {@link DataType} that the service accepts. */
exports.KnownDataType = void 0;
(function (KnownDataType) {
    /** String */
    KnownDataType["String"] = "String";
    /** Number */
    KnownDataType["Number"] = "Number";
    /** Point */
    KnownDataType["Point"] = "Point";
    /** Polygon */
    KnownDataType["Polygon"] = "Polygon";
    /** LineString */
    KnownDataType["LineString"] = "LineString";
    /** MultiPolygon */
    KnownDataType["MultiPolygon"] = "MultiPolygon";
})(exports.KnownDataType || (exports.KnownDataType = {}));
/** Known values of {@link IndexKind} that the service accepts. */
exports.KnownIndexKind = void 0;
(function (KnownIndexKind) {
    /** Hash */
    KnownIndexKind["Hash"] = "Hash";
    /** Range */
    KnownIndexKind["Range"] = "Range";
    /** Spatial */
    KnownIndexKind["Spatial"] = "Spatial";
})(exports.KnownIndexKind || (exports.KnownIndexKind = {}));
/** Known values of {@link CompositePathSortOrder} that the service accepts. */
exports.KnownCompositePathSortOrder = void 0;
(function (KnownCompositePathSortOrder) {
    /** Ascending */
    KnownCompositePathSortOrder["Ascending"] = "ascending";
    /** Descending */
    KnownCompositePathSortOrder["Descending"] = "descending";
})(exports.KnownCompositePathSortOrder || (exports.KnownCompositePathSortOrder = {}));
/** Known values of {@link SpatialType} that the service accepts. */
exports.KnownSpatialType = void 0;
(function (KnownSpatialType) {
    /** Point */
    KnownSpatialType["Point"] = "Point";
    /** LineString */
    KnownSpatialType["LineString"] = "LineString";
    /** Polygon */
    KnownSpatialType["Polygon"] = "Polygon";
    /** MultiPolygon */
    KnownSpatialType["MultiPolygon"] = "MultiPolygon";
})(exports.KnownSpatialType || (exports.KnownSpatialType = {}));
/** Known values of {@link PartitionKind} that the service accepts. */
exports.KnownPartitionKind = void 0;
(function (KnownPartitionKind) {
    /** Hash */
    KnownPartitionKind["Hash"] = "Hash";
    /** Range */
    KnownPartitionKind["Range"] = "Range";
    /** MultiHash */
    KnownPartitionKind["MultiHash"] = "MultiHash";
})(exports.KnownPartitionKind || (exports.KnownPartitionKind = {}));
/** Known values of {@link ConflictResolutionMode} that the service accepts. */
exports.KnownConflictResolutionMode = void 0;
(function (KnownConflictResolutionMode) {
    /** LastWriterWins */
    KnownConflictResolutionMode["LastWriterWins"] = "LastWriterWins";
    /** Custom */
    KnownConflictResolutionMode["Custom"] = "Custom";
})(exports.KnownConflictResolutionMode || (exports.KnownConflictResolutionMode = {}));
/** Known values of {@link TriggerType} that the service accepts. */
exports.KnownTriggerType = void 0;
(function (KnownTriggerType) {
    /** Pre */
    KnownTriggerType["Pre"] = "Pre";
    /** Post */
    KnownTriggerType["Post"] = "Post";
})(exports.KnownTriggerType || (exports.KnownTriggerType = {}));
/** Known values of {@link TriggerOperation} that the service accepts. */
exports.KnownTriggerOperation = void 0;
(function (KnownTriggerOperation) {
    /** All */
    KnownTriggerOperation["All"] = "All";
    /** Create */
    KnownTriggerOperation["Create"] = "Create";
    /** Update */
    KnownTriggerOperation["Update"] = "Update";
    /** Delete */
    KnownTriggerOperation["Delete"] = "Delete";
    /** Replace */
    KnownTriggerOperation["Replace"] = "Replace";
})(exports.KnownTriggerOperation || (exports.KnownTriggerOperation = {}));
/** Known values of {@link BackupStorageRedundancy} that the service accepts. */
exports.KnownBackupStorageRedundancy = void 0;
(function (KnownBackupStorageRedundancy) {
    /** Geo */
    KnownBackupStorageRedundancy["Geo"] = "Geo";
    /** Local */
    KnownBackupStorageRedundancy["Local"] = "Local";
    /** Zone */
    KnownBackupStorageRedundancy["Zone"] = "Zone";
})(exports.KnownBackupStorageRedundancy || (exports.KnownBackupStorageRedundancy = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    /** Uninitialized */
    KnownStatus["Uninitialized"] = "Uninitialized";
    /** Initializing */
    KnownStatus["Initializing"] = "Initializing";
    /** InternallyReady */
    KnownStatus["InternallyReady"] = "InternallyReady";
    /** Online */
    KnownStatus["Online"] = "Online";
    /** Deleting */
    KnownStatus["Deleting"] = "Deleting";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link ManagedCassandraProvisioningState} that the service accepts. */
exports.KnownManagedCassandraProvisioningState = void 0;
(function (KnownManagedCassandraProvisioningState) {
    /** Creating */
    KnownManagedCassandraProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownManagedCassandraProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownManagedCassandraProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownManagedCassandraProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownManagedCassandraProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownManagedCassandraProvisioningState["Canceled"] = "Canceled";
})(exports.KnownManagedCassandraProvisioningState || (exports.KnownManagedCassandraProvisioningState = {}));
/** Known values of {@link AuthenticationMethod} that the service accepts. */
exports.KnownAuthenticationMethod = void 0;
(function (KnownAuthenticationMethod) {
    /** None */
    KnownAuthenticationMethod["None"] = "None";
    /** Cassandra */
    KnownAuthenticationMethod["Cassandra"] = "Cassandra";
    /** Ldap */
    KnownAuthenticationMethod["Ldap"] = "Ldap";
})(exports.KnownAuthenticationMethod || (exports.KnownAuthenticationMethod = {}));
/** Known values of {@link ManagedCassandraResourceIdentityType} that the service accepts. */
exports.KnownManagedCassandraResourceIdentityType = void 0;
(function (KnownManagedCassandraResourceIdentityType) {
    /** SystemAssigned */
    KnownManagedCassandraResourceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** None */
    KnownManagedCassandraResourceIdentityType["None"] = "None";
})(exports.KnownManagedCassandraResourceIdentityType || (exports.KnownManagedCassandraResourceIdentityType = {}));
/** Known values of {@link ConnectionState} that the service accepts. */
exports.KnownConnectionState = void 0;
(function (KnownConnectionState) {
    /** Unknown */
    KnownConnectionState["Unknown"] = "Unknown";
    /** OK */
    KnownConnectionState["OK"] = "OK";
    /** OperatorToDataCenterNetworkError */
    KnownConnectionState["OperatorToDataCenterNetworkError"] = "OperatorToDataCenterNetworkError";
    /** DatacenterToDatacenterNetworkError */
    KnownConnectionState["DatacenterToDatacenterNetworkError"] = "DatacenterToDatacenterNetworkError";
    /** InternalOperatorToDataCenterCertificateError */
    KnownConnectionState["InternalOperatorToDataCenterCertificateError"] = "InternalOperatorToDataCenterCertificateError";
    /** InternalError */
    KnownConnectionState["InternalError"] = "InternalError";
})(exports.KnownConnectionState || (exports.KnownConnectionState = {}));
/** Known values of {@link NodeState} that the service accepts. */
exports.KnownNodeState = void 0;
(function (KnownNodeState) {
    /** Normal */
    KnownNodeState["Normal"] = "Normal";
    /** Leaving */
    KnownNodeState["Leaving"] = "Leaving";
    /** Joining */
    KnownNodeState["Joining"] = "Joining";
    /** Moving */
    KnownNodeState["Moving"] = "Moving";
    /** Stopped */
    KnownNodeState["Stopped"] = "Stopped";
})(exports.KnownNodeState || (exports.KnownNodeState = {}));
/** Known values of {@link NotebookWorkspaceName} that the service accepts. */
exports.KnownNotebookWorkspaceName = void 0;
(function (KnownNotebookWorkspaceName) {
    /** Default */
    KnownNotebookWorkspaceName["Default"] = "default";
})(exports.KnownNotebookWorkspaceName || (exports.KnownNotebookWorkspaceName = {}));
/** Known values of {@link ApiType} that the service accepts. */
exports.KnownApiType = void 0;
(function (KnownApiType) {
    /** MongoDB */
    KnownApiType["MongoDB"] = "MongoDB";
    /** Gremlin */
    KnownApiType["Gremlin"] = "Gremlin";
    /** Cassandra */
    KnownApiType["Cassandra"] = "Cassandra";
    /** Table */
    KnownApiType["Table"] = "Table";
    /** Sql */
    KnownApiType["Sql"] = "Sql";
    /** GremlinV2 */
    KnownApiType["GremlinV2"] = "GremlinV2";
})(exports.KnownApiType || (exports.KnownApiType = {}));
/** Known values of {@link OperationType} that the service accepts. */
exports.KnownOperationType = void 0;
(function (KnownOperationType) {
    /** Create */
    KnownOperationType["Create"] = "Create";
    /** Replace */
    KnownOperationType["Replace"] = "Replace";
    /** Delete */
    KnownOperationType["Delete"] = "Delete";
    /** Recreate */
    KnownOperationType["Recreate"] = "Recreate";
    /** SystemOperation */
    KnownOperationType["SystemOperation"] = "SystemOperation";
})(exports.KnownOperationType || (exports.KnownOperationType = {}));
/** Known values of {@link ServiceSize} that the service accepts. */
exports.KnownServiceSize = void 0;
(function (KnownServiceSize) {
    /** CosmosD4S */
    KnownServiceSize["CosmosD4S"] = "Cosmos.D4s";
    /** CosmosD8S */
    KnownServiceSize["CosmosD8S"] = "Cosmos.D8s";
    /** CosmosD16S */
    KnownServiceSize["CosmosD16S"] = "Cosmos.D16s";
})(exports.KnownServiceSize || (exports.KnownServiceSize = {}));
/** Known values of {@link ServiceType} that the service accepts. */
exports.KnownServiceType = void 0;
(function (KnownServiceType) {
    /** SqlDedicatedGateway */
    KnownServiceType["SqlDedicatedGateway"] = "SqlDedicatedGateway";
    /** DataTransfer */
    KnownServiceType["DataTransfer"] = "DataTransfer";
    /** GraphAPICompute */
    KnownServiceType["GraphAPICompute"] = "GraphAPICompute";
    /** MaterializedViewsBuilder */
    KnownServiceType["MaterializedViewsBuilder"] = "MaterializedViewsBuilder";
})(exports.KnownServiceType || (exports.KnownServiceType = {}));
/** Known values of {@link ServiceStatus} that the service accepts. */
exports.KnownServiceStatus = void 0;
(function (KnownServiceStatus) {
    /** Creating */
    KnownServiceStatus["Creating"] = "Creating";
    /** Running */
    KnownServiceStatus["Running"] = "Running";
    /** Updating */
    KnownServiceStatus["Updating"] = "Updating";
    /** Deleting */
    KnownServiceStatus["Deleting"] = "Deleting";
    /** Error */
    KnownServiceStatus["Error"] = "Error";
    /** Stopped */
    KnownServiceStatus["Stopped"] = "Stopped";
})(exports.KnownServiceStatus || (exports.KnownServiceStatus = {}));
/** Known values of {@link ContinuousTier} that the service accepts. */
exports.KnownContinuousTier = void 0;
(function (KnownContinuousTier) {
    /** Continuous7Days */
    KnownContinuousTier["Continuous7Days"] = "Continuous7Days";
    /** Continuous30Days */
    KnownContinuousTier["Continuous30Days"] = "Continuous30Days";
})(exports.KnownContinuousTier || (exports.KnownContinuousTier = {}));
/** Known values of {@link NodeStatus} that the service accepts. */
exports.KnownNodeStatus = void 0;
(function (KnownNodeStatus) {
    /** Up */
    KnownNodeStatus["Up"] = "Up";
    /** Down */
    KnownNodeStatus["Down"] = "Down";
})(exports.KnownNodeStatus || (exports.KnownNodeStatus = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned,UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties"
                        }
                    }
                }
            }
        }
    }
};
const Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties = {
    type: {
        name: "Composite",
        className: "Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpAddressOrRange = {
    type: {
        name: "Composite",
        className: "IpAddressOrRange",
        modelProperties: {
            ipAddressOrRange: {
                serializedName: "ipAddressOrRange",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConsistencyPolicy = {
    type: {
        name: "Composite",
        className: "ConsistencyPolicy",
        modelProperties: {
            defaultConsistencyLevel: {
                serializedName: "defaultConsistencyLevel",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Eventual",
                        "Session",
                        "BoundedStaleness",
                        "Strong",
                        "ConsistentPrefix"
                    ]
                }
            },
            maxStalenessPrefix: {
                constraints: {
                    InclusiveMaximum: 2147483647,
                    InclusiveMinimum: 1
                },
                serializedName: "maxStalenessPrefix",
                type: {
                    name: "Number"
                }
            },
            maxIntervalInSeconds: {
                constraints: {
                    InclusiveMaximum: 86400,
                    InclusiveMinimum: 5
                },
                serializedName: "maxIntervalInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Capability = {
    type: {
        name: "Composite",
        className: "Capability",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Location = {
    type: {
        name: "Composite",
        className: "Location",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            locationName: {
                serializedName: "locationName",
                type: {
                    name: "String"
                }
            },
            documentEndpoint: {
                serializedName: "documentEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            failoverPriority: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "failoverPriority",
                type: {
                    name: "Number"
                }
            },
            isZoneRedundant: {
                serializedName: "isZoneRedundant",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const FailoverPolicy = {
    type: {
        name: "Composite",
        className: "FailoverPolicy",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            locationName: {
                serializedName: "locationName",
                type: {
                    name: "String"
                }
            },
            failoverPriority: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "failoverPriority",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkRule",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            ignoreMissingVNetServiceEndpoint: {
                serializedName: "ignoreMissingVNetServiceEndpoint",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PrivateEndpointProperty = {
    type: {
        name: "Composite",
        className: "PrivateEndpointProperty",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionStateProperty = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionStateProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiProperties = {
    type: {
        name: "Composite",
        className: "ApiProperties",
        modelProperties: {
            serverVersion: {
                serializedName: "serverVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalyticalStorageConfiguration = {
    type: {
        name: "Composite",
        className: "AnalyticalStorageConfiguration",
        modelProperties: {
            schemaType: {
                serializedName: "schemaType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseRestoreResource = {
    type: {
        name: "Composite",
        className: "DatabaseRestoreResource",
        modelProperties: {
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            collectionNames: {
                serializedName: "collectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const GremlinDatabaseRestoreResource = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseRestoreResource",
        modelProperties: {
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            graphNames: {
                serializedName: "graphNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RestoreParametersBase = {
    type: {
        name: "Composite",
        className: "RestoreParametersBase",
        modelProperties: {
            restoreSource: {
                serializedName: "restoreSource",
                type: {
                    name: "String"
                }
            },
            restoreTimestampInUtc: {
                serializedName: "restoreTimestampInUtc",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const BackupPolicy = {
    type: {
        name: "Composite",
        className: "BackupPolicy",
        uberParent: "BackupPolicy",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            migrationState: {
                serializedName: "migrationState",
                type: {
                    name: "Composite",
                    className: "BackupPolicyMigrationState"
                }
            }
        }
    }
};
const BackupPolicyMigrationState = {
    type: {
        name: "Composite",
        className: "BackupPolicyMigrationState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            targetType: {
                serializedName: "targetType",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CorsPolicy = {
    type: {
        name: "Composite",
        className: "CorsPolicy",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                required: true,
                type: {
                    name: "String"
                }
            },
            allowedMethods: {
                serializedName: "allowedMethods",
                type: {
                    name: "String"
                }
            },
            allowedHeaders: {
                serializedName: "allowedHeaders",
                type: {
                    name: "String"
                }
            },
            exposedHeaders: {
                serializedName: "exposedHeaders",
                type: {
                    name: "String"
                }
            },
            maxAgeInSeconds: {
                constraints: {
                    InclusiveMaximum: 2147483647,
                    InclusiveMinimum: 1
                },
                serializedName: "maxAgeInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Capacity = {
    type: {
        name: "Composite",
        className: "Capacity",
        modelProperties: {
            totalThroughputLimit: {
                constraints: {
                    InclusiveMinimum: -1
                },
                serializedName: "totalThroughputLimit",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DatabaseAccountKeysMetadata = {
    type: {
        name: "Composite",
        className: "DatabaseAccountKeysMetadata",
        modelProperties: {
            primaryMasterKey: {
                serializedName: "primaryMasterKey",
                type: {
                    name: "Composite",
                    className: "AccountKeyMetadata"
                }
            },
            secondaryMasterKey: {
                serializedName: "secondaryMasterKey",
                type: {
                    name: "Composite",
                    className: "AccountKeyMetadata"
                }
            },
            primaryReadonlyMasterKey: {
                serializedName: "primaryReadonlyMasterKey",
                type: {
                    name: "Composite",
                    className: "AccountKeyMetadata"
                }
            },
            secondaryReadonlyMasterKey: {
                serializedName: "secondaryReadonlyMasterKey",
                type: {
                    name: "Composite",
                    className: "AccountKeyMetadata"
                }
            }
        }
    }
};
const AccountKeyMetadata = {
    type: {
        name: "Composite",
        className: "AccountKeyMetadata",
        modelProperties: {
            generationTime: {
                serializedName: "generationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ARMResourceProperties = {
    type: {
        name: "Composite",
        className: "ARMResourceProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DatabaseAccountUpdateParameters = {
    type: {
        name: "Composite",
        className: "DatabaseAccountUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            },
            consistencyPolicy: {
                serializedName: "properties.consistencyPolicy",
                type: {
                    name: "Composite",
                    className: "ConsistencyPolicy"
                }
            },
            locations: {
                serializedName: "properties.locations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Location"
                        }
                    }
                }
            },
            ipRules: {
                serializedName: "properties.ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressOrRange"
                        }
                    }
                }
            },
            isVirtualNetworkFilterEnabled: {
                serializedName: "properties.isVirtualNetworkFilterEnabled",
                type: {
                    name: "Boolean"
                }
            },
            enableAutomaticFailover: {
                serializedName: "properties.enableAutomaticFailover",
                type: {
                    name: "Boolean"
                }
            },
            capabilities: {
                serializedName: "properties.capabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability"
                        }
                    }
                }
            },
            virtualNetworkRules: {
                serializedName: "properties.virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            },
            enableMultipleWriteLocations: {
                serializedName: "properties.enableMultipleWriteLocations",
                type: {
                    name: "Boolean"
                }
            },
            enableCassandraConnector: {
                serializedName: "properties.enableCassandraConnector",
                type: {
                    name: "Boolean"
                }
            },
            connectorOffer: {
                serializedName: "properties.connectorOffer",
                type: {
                    name: "String"
                }
            },
            disableKeyBasedMetadataWriteAccess: {
                serializedName: "properties.disableKeyBasedMetadataWriteAccess",
                type: {
                    name: "Boolean"
                }
            },
            keyVaultKeyUri: {
                serializedName: "properties.keyVaultKeyUri",
                type: {
                    name: "String"
                }
            },
            defaultIdentity: {
                serializedName: "properties.defaultIdentity",
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            enableFreeTier: {
                serializedName: "properties.enableFreeTier",
                type: {
                    name: "Boolean"
                }
            },
            apiProperties: {
                serializedName: "properties.apiProperties",
                type: {
                    name: "Composite",
                    className: "ApiProperties"
                }
            },
            enableAnalyticalStorage: {
                serializedName: "properties.enableAnalyticalStorage",
                type: {
                    name: "Boolean"
                }
            },
            analyticalStorageConfiguration: {
                serializedName: "properties.analyticalStorageConfiguration",
                type: {
                    name: "Composite",
                    className: "AnalyticalStorageConfiguration"
                }
            },
            backupPolicy: {
                serializedName: "properties.backupPolicy",
                type: {
                    name: "Composite",
                    className: "BackupPolicy"
                }
            },
            cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsPolicy"
                        }
                    }
                }
            },
            networkAclBypass: {
                serializedName: "properties.networkAclBypass",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "AzureServices"]
                }
            },
            networkAclBypassResourceIds: {
                serializedName: "properties.networkAclBypassResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            },
            capacity: {
                serializedName: "properties.capacity",
                type: {
                    name: "Composite",
                    className: "Capacity"
                }
            },
            keysMetadata: {
                serializedName: "properties.keysMetadata",
                type: {
                    name: "Composite",
                    className: "DatabaseAccountKeysMetadata"
                }
            },
            enablePartitionMerge: {
                serializedName: "properties.enablePartitionMerge",
                type: {
                    name: "Boolean"
                }
            },
            minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            },
            enableBurstCapacity: {
                serializedName: "properties.enableBurstCapacity",
                type: {
                    name: "Boolean"
                }
            },
            customerManagedKeyStatus: {
                serializedName: "properties.customerManagedKeyStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FailoverPolicies = {
    type: {
        name: "Composite",
        className: "FailoverPolicies",
        modelProperties: {
            failoverPolicies: {
                serializedName: "failoverPolicies",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FailoverPolicy"
                        }
                    }
                }
            }
        }
    }
};
const DatabaseAccountsListResult = {
    type: {
        name: "Composite",
        className: "DatabaseAccountsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseAccountGetResults"
                        }
                    }
                }
            }
        }
    }
};
const DatabaseAccountListReadOnlyKeysResult = {
    type: {
        name: "Composite",
        className: "DatabaseAccountListReadOnlyKeysResult",
        modelProperties: {
            primaryReadonlyMasterKey: {
                serializedName: "primaryReadonlyMasterKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secondaryReadonlyMasterKey: {
                serializedName: "secondaryReadonlyMasterKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseAccountListConnectionStringsResult = {
    type: {
        name: "Composite",
        className: "DatabaseAccountListConnectionStringsResult",
        modelProperties: {
            connectionStrings: {
                serializedName: "connectionStrings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseAccountConnectionString"
                        }
                    }
                }
            }
        }
    }
};
const DatabaseAccountConnectionString = {
    type: {
        name: "Composite",
        className: "DatabaseAccountConnectionString",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyKind: {
                serializedName: "keyKind",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegionForOnlineOffline = {
    type: {
        name: "Composite",
        className: "RegionForOnlineOffline",
        modelProperties: {
            region: {
                serializedName: "region",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseAccountRegenerateKeyParameters = {
    type: {
        name: "Composite",
        className: "DatabaseAccountRegenerateKeyParameters",
        modelProperties: {
            keyKind: {
                serializedName: "keyKind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "Provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "Resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "Operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "Description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricListResult = {
    type: {
        name: "Composite",
        className: "MetricListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Metric"
                        }
                    }
                }
            }
        }
    }
};
const Metric = {
    type: {
        name: "Composite",
        className: "Metric",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "MetricName"
                }
            },
            metricValues: {
                serializedName: "metricValues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricValue"
                        }
                    }
                }
            }
        }
    }
};
const MetricName = {
    type: {
        name: "Composite",
        className: "MetricName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricValue = {
    type: {
        name: "Composite",
        className: "MetricValue",
        modelProperties: {
            count: {
                serializedName: "_count",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            average: {
                serializedName: "average",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            total: {
                serializedName: "total",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PercentileMetricListResult = {
    type: {
        name: "Composite",
        className: "PercentileMetricListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PercentileMetric"
                        }
                    }
                }
            }
        }
    }
};
const PercentileMetric = {
    type: {
        name: "Composite",
        className: "PercentileMetric",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "MetricName"
                }
            },
            metricValues: {
                serializedName: "metricValues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PercentileMetricValue"
                        }
                    }
                }
            }
        }
    }
};
const PartitionMetricListResult = {
    type: {
        name: "Composite",
        className: "PartitionMetricListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartitionMetric"
                        }
                    }
                }
            }
        }
    }
};
const UsagesResult = {
    type: {
        name: "Composite",
        className: "UsagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "MetricName"
                }
            },
            quotaPeriod: {
                serializedName: "quotaPeriod",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PartitionUsagesResult = {
    type: {
        name: "Composite",
        className: "PartitionUsagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartitionUsage"
                        }
                    }
                }
            }
        }
    }
};
const MetricDefinitionsListResult = {
    type: {
        name: "Composite",
        className: "MetricDefinitionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDefinition"
                        }
                    }
                }
            }
        }
    }
};
const MetricDefinition = {
    type: {
        name: "Composite",
        className: "MetricDefinition",
        modelProperties: {
            metricAvailabilities: {
                serializedName: "metricAvailabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricAvailability"
                        }
                    }
                }
            },
            primaryAggregationType: {
                serializedName: "primaryAggregationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceUri: {
                serializedName: "resourceUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "MetricName"
                }
            }
        }
    }
};
const MetricAvailability = {
    type: {
        name: "Composite",
        className: "MetricAvailability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            retention: {
                serializedName: "retention",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlDatabaseListResult = {
    type: {
        name: "Composite",
        className: "SqlDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlDatabaseGetResults"
                        }
                    }
                }
            }
        }
    }
};
const SqlDatabaseResource = {
    type: {
        name: "Composite",
        className: "SqlDatabaseResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedResourceProperties = {
    type: {
        name: "Composite",
        className: "ExtendedResourceProperties",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ts: {
                serializedName: "_ts",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            etag: {
                serializedName: "_etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OptionsResource = {
    type: {
        name: "Composite",
        className: "OptionsResource",
        modelProperties: {
            throughput: {
                serializedName: "throughput",
                type: {
                    name: "Number"
                }
            },
            autoscaleSettings: {
                serializedName: "autoscaleSettings",
                type: {
                    name: "Composite",
                    className: "AutoscaleSettings"
                }
            }
        }
    }
};
const AutoscaleSettings = {
    type: {
        name: "Composite",
        className: "AutoscaleSettings",
        modelProperties: {
            maxThroughput: {
                serializedName: "maxThroughput",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CreateUpdateOptions = {
    type: {
        name: "Composite",
        className: "CreateUpdateOptions",
        modelProperties: {
            throughput: {
                serializedName: "throughput",
                type: {
                    name: "Number"
                }
            },
            autoscaleSettings: {
                serializedName: "autoscaleSettings",
                type: {
                    name: "Composite",
                    className: "AutoscaleSettings"
                }
            }
        }
    }
};
const ThroughputSettingsResource = {
    type: {
        name: "Composite",
        className: "ThroughputSettingsResource",
        modelProperties: {
            throughput: {
                serializedName: "throughput",
                type: {
                    name: "Number"
                }
            },
            autoscaleSettings: {
                serializedName: "autoscaleSettings",
                type: {
                    name: "Composite",
                    className: "AutoscaleSettingsResource"
                }
            },
            minimumThroughput: {
                serializedName: "minimumThroughput",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            offerReplacePending: {
                serializedName: "offerReplacePending",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            instantMaximumThroughput: {
                serializedName: "instantMaximumThroughput",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            softAllowedMaximumThroughput: {
                serializedName: "softAllowedMaximumThroughput",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoscaleSettingsResource = {
    type: {
        name: "Composite",
        className: "AutoscaleSettingsResource",
        modelProperties: {
            maxThroughput: {
                serializedName: "maxThroughput",
                required: true,
                type: {
                    name: "Number"
                }
            },
            autoUpgradePolicy: {
                serializedName: "autoUpgradePolicy",
                type: {
                    name: "Composite",
                    className: "AutoUpgradePolicyResource"
                }
            },
            targetMaxThroughput: {
                serializedName: "targetMaxThroughput",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoUpgradePolicyResource = {
    type: {
        name: "Composite",
        className: "AutoUpgradePolicyResource",
        modelProperties: {
            throughputPolicy: {
                serializedName: "throughputPolicy",
                type: {
                    name: "Composite",
                    className: "ThroughputPolicyResource"
                }
            }
        }
    }
};
const ThroughputPolicyResource = {
    type: {
        name: "Composite",
        className: "ThroughputPolicyResource",
        modelProperties: {
            isEnabled: {
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            },
            incrementPercent: {
                serializedName: "incrementPercent",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            }
        }
    }
};
const SqlContainerListResult = {
    type: {
        name: "Composite",
        className: "SqlContainerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlContainerGetResults"
                        }
                    }
                }
            }
        }
    }
};
const SqlContainerResource = {
    type: {
        name: "Composite",
        className: "SqlContainerResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            indexingPolicy: {
                serializedName: "indexingPolicy",
                type: {
                    name: "Composite",
                    className: "IndexingPolicy"
                }
            },
            partitionKey: {
                serializedName: "partitionKey",
                type: {
                    name: "Composite",
                    className: "ContainerPartitionKey"
                }
            },
            defaultTtl: {
                serializedName: "defaultTtl",
                type: {
                    name: "Number"
                }
            },
            uniqueKeyPolicy: {
                serializedName: "uniqueKeyPolicy",
                type: {
                    name: "Composite",
                    className: "UniqueKeyPolicy"
                }
            },
            conflictResolutionPolicy: {
                serializedName: "conflictResolutionPolicy",
                type: {
                    name: "Composite",
                    className: "ConflictResolutionPolicy"
                }
            },
            clientEncryptionPolicy: {
                serializedName: "clientEncryptionPolicy",
                type: {
                    name: "Composite",
                    className: "ClientEncryptionPolicy"
                }
            },
            analyticalStorageTtl: {
                serializedName: "analyticalStorageTtl",
                type: {
                    name: "Number"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            },
            computedProperties: {
                serializedName: "computedProperties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputedProperty"
                        }
                    }
                }
            }
        }
    }
};
const IndexingPolicy = {
    type: {
        name: "Composite",
        className: "IndexingPolicy",
        modelProperties: {
            automatic: {
                serializedName: "automatic",
                type: {
                    name: "Boolean"
                }
            },
            indexingMode: {
                defaultValue: "consistent",
                serializedName: "indexingMode",
                type: {
                    name: "String"
                }
            },
            includedPaths: {
                serializedName: "includedPaths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IncludedPath"
                        }
                    }
                }
            },
            excludedPaths: {
                serializedName: "excludedPaths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExcludedPath"
                        }
                    }
                }
            },
            compositeIndexes: {
                serializedName: "compositeIndexes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Composite",
                                    className: "CompositePath"
                                }
                            }
                        }
                    }
                }
            },
            spatialIndexes: {
                serializedName: "spatialIndexes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SpatialSpec"
                        }
                    }
                }
            }
        }
    }
};
const IncludedPath = {
    type: {
        name: "Composite",
        className: "IncludedPath",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            indexes: {
                serializedName: "indexes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Indexes"
                        }
                    }
                }
            }
        }
    }
};
const Indexes = {
    type: {
        name: "Composite",
        className: "Indexes",
        modelProperties: {
            dataType: {
                defaultValue: "String",
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            },
            precision: {
                serializedName: "precision",
                type: {
                    name: "Number"
                }
            },
            kind: {
                defaultValue: "Hash",
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExcludedPath = {
    type: {
        name: "Composite",
        className: "ExcludedPath",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CompositePath = {
    type: {
        name: "Composite",
        className: "CompositePath",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SpatialSpec = {
    type: {
        name: "Composite",
        className: "SpatialSpec",
        modelProperties: {
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            types: {
                serializedName: "types",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ContainerPartitionKey = {
    type: {
        name: "Composite",
        className: "ContainerPartitionKey",
        modelProperties: {
            paths: {
                serializedName: "paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kind: {
                defaultValue: "Hash",
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            version: {
                constraints: {
                    InclusiveMaximum: 2,
                    InclusiveMinimum: 1
                },
                serializedName: "version",
                type: {
                    name: "Number"
                }
            },
            systemKey: {
                serializedName: "systemKey",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const UniqueKeyPolicy = {
    type: {
        name: "Composite",
        className: "UniqueKeyPolicy",
        modelProperties: {
            uniqueKeys: {
                serializedName: "uniqueKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UniqueKey"
                        }
                    }
                }
            }
        }
    }
};
const UniqueKey = {
    type: {
        name: "Composite",
        className: "UniqueKey",
        modelProperties: {
            paths: {
                serializedName: "paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ConflictResolutionPolicy = {
    type: {
        name: "Composite",
        className: "ConflictResolutionPolicy",
        modelProperties: {
            mode: {
                defaultValue: "LastWriterWins",
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            conflictResolutionPath: {
                serializedName: "conflictResolutionPath",
                type: {
                    name: "String"
                }
            },
            conflictResolutionProcedure: {
                serializedName: "conflictResolutionProcedure",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientEncryptionPolicy = {
    type: {
        name: "Composite",
        className: "ClientEncryptionPolicy",
        modelProperties: {
            includedPaths: {
                serializedName: "includedPaths",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientEncryptionIncludedPath"
                        }
                    }
                }
            },
            policyFormatVersion: {
                constraints: {
                    InclusiveMaximum: 2,
                    InclusiveMinimum: 1
                },
                serializedName: "policyFormatVersion",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClientEncryptionIncludedPath = {
    type: {
        name: "Composite",
        className: "ClientEncryptionIncludedPath",
        modelProperties: {
            path: {
                serializedName: "path",
                required: true,
                type: {
                    name: "String"
                }
            },
            clientEncryptionKeyId: {
                serializedName: "clientEncryptionKeyId",
                required: true,
                type: {
                    name: "String"
                }
            },
            encryptionType: {
                serializedName: "encryptionType",
                required: true,
                type: {
                    name: "String"
                }
            },
            encryptionAlgorithm: {
                serializedName: "encryptionAlgorithm",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputedProperty = {
    type: {
        name: "Composite",
        className: "ComputedProperty",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            query: {
                serializedName: "query",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientEncryptionKeysListResult = {
    type: {
        name: "Composite",
        className: "ClientEncryptionKeysListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientEncryptionKeyGetResults"
                        }
                    }
                }
            }
        }
    }
};
const ClientEncryptionKeyResource = {
    type: {
        name: "Composite",
        className: "ClientEncryptionKeyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            encryptionAlgorithm: {
                serializedName: "encryptionAlgorithm",
                type: {
                    name: "String"
                }
            },
            wrappedDataEncryptionKey: {
                serializedName: "wrappedDataEncryptionKey",
                type: {
                    name: "ByteArray"
                }
            },
            keyWrapMetadata: {
                serializedName: "keyWrapMetadata",
                type: {
                    name: "Composite",
                    className: "KeyWrapMetadata"
                }
            }
        }
    }
};
const KeyWrapMetadata = {
    type: {
        name: "Composite",
        className: "KeyWrapMetadata",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            algorithm: {
                serializedName: "algorithm",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ARMProxyResource = {
    type: {
        name: "Composite",
        className: "ARMProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientEncryptionKeyCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "ClientEncryptionKeyCreateUpdateParameters",
        modelProperties: {
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "ClientEncryptionKeyResource"
                }
            }
        }
    }
};
const SqlStoredProcedureListResult = {
    type: {
        name: "Composite",
        className: "SqlStoredProcedureListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlStoredProcedureGetResults"
                        }
                    }
                }
            }
        }
    }
};
const SqlStoredProcedureResource = {
    type: {
        name: "Composite",
        className: "SqlStoredProcedureResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            body: {
                serializedName: "body",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlUserDefinedFunctionListResult = {
    type: {
        name: "Composite",
        className: "SqlUserDefinedFunctionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlUserDefinedFunctionGetResults"
                        }
                    }
                }
            }
        }
    }
};
const SqlUserDefinedFunctionResource = {
    type: {
        name: "Composite",
        className: "SqlUserDefinedFunctionResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            body: {
                serializedName: "body",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlTriggerListResult = {
    type: {
        name: "Composite",
        className: "SqlTriggerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlTriggerGetResults"
                        }
                    }
                }
            }
        }
    }
};
const SqlTriggerResource = {
    type: {
        name: "Composite",
        className: "SqlTriggerResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            body: {
                serializedName: "body",
                type: {
                    name: "String"
                }
            },
            triggerType: {
                serializedName: "triggerType",
                type: {
                    name: "String"
                }
            },
            triggerOperation: {
                serializedName: "triggerOperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBDatabaseListResult = {
    type: {
        name: "Composite",
        className: "MongoDBDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MongoDBDatabaseGetResults"
                        }
                    }
                }
            }
        }
    }
};
const MongoDBDatabaseResource = {
    type: {
        name: "Composite",
        className: "MongoDBDatabaseResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBCollectionListResult = {
    type: {
        name: "Composite",
        className: "MongoDBCollectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MongoDBCollectionGetResults"
                        }
                    }
                }
            }
        }
    }
};
const MongoDBCollectionResource = {
    type: {
        name: "Composite",
        className: "MongoDBCollectionResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            shardKey: {
                serializedName: "shardKey",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            indexes: {
                serializedName: "indexes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MongoIndex"
                        }
                    }
                }
            },
            analyticalStorageTtl: {
                serializedName: "analyticalStorageTtl",
                type: {
                    name: "Number"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoIndex = {
    type: {
        name: "Composite",
        className: "MongoIndex",
        modelProperties: {
            key: {
                serializedName: "key",
                type: {
                    name: "Composite",
                    className: "MongoIndexKeys"
                }
            },
            options: {
                serializedName: "options",
                type: {
                    name: "Composite",
                    className: "MongoIndexOptions"
                }
            }
        }
    }
};
const MongoIndexKeys = {
    type: {
        name: "Composite",
        className: "MongoIndexKeys",
        modelProperties: {
            keys: {
                serializedName: "keys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MongoIndexOptions = {
    type: {
        name: "Composite",
        className: "MongoIndexOptions",
        modelProperties: {
            expireAfterSeconds: {
                serializedName: "expireAfterSeconds",
                type: {
                    name: "Number"
                }
            },
            unique: {
                serializedName: "unique",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TableListResult = {
    type: {
        name: "Composite",
        className: "TableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TableGetResults"
                        }
                    }
                }
            }
        }
    }
};
const TableResource = {
    type: {
        name: "Composite",
        className: "TableResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraKeyspaceListResult = {
    type: {
        name: "Composite",
        className: "CassandraKeyspaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CassandraKeyspaceGetResults"
                        }
                    }
                }
            }
        }
    }
};
const CassandraKeyspaceResource = {
    type: {
        name: "Composite",
        className: "CassandraKeyspaceResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraTableListResult = {
    type: {
        name: "Composite",
        className: "CassandraTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CassandraTableGetResults"
                        }
                    }
                }
            }
        }
    }
};
const CassandraTableResource = {
    type: {
        name: "Composite",
        className: "CassandraTableResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            defaultTtl: {
                serializedName: "defaultTtl",
                type: {
                    name: "Number"
                }
            },
            schema: {
                serializedName: "schema",
                type: {
                    name: "Composite",
                    className: "CassandraSchema"
                }
            },
            analyticalStorageTtl: {
                serializedName: "analyticalStorageTtl",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CassandraSchema = {
    type: {
        name: "Composite",
        className: "CassandraSchema",
        modelProperties: {
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Column"
                        }
                    }
                }
            },
            partitionKeys: {
                serializedName: "partitionKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CassandraPartitionKey"
                        }
                    }
                }
            },
            clusterKeys: {
                serializedName: "clusterKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterKey"
                        }
                    }
                }
            }
        }
    }
};
const Column = {
    type: {
        name: "Composite",
        className: "Column",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraPartitionKey = {
    type: {
        name: "Composite",
        className: "CassandraPartitionKey",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterKey = {
    type: {
        name: "Composite",
        className: "ClusterKey",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            orderBy: {
                serializedName: "orderBy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinDatabaseListResult = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GremlinDatabaseGetResults"
                        }
                    }
                }
            }
        }
    }
};
const GremlinDatabaseResource = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinGraphListResult = {
    type: {
        name: "Composite",
        className: "GremlinGraphListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GremlinGraphGetResults"
                        }
                    }
                }
            }
        }
    }
};
const GremlinGraphResource = {
    type: {
        name: "Composite",
        className: "GremlinGraphResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            indexingPolicy: {
                serializedName: "indexingPolicy",
                type: {
                    name: "Composite",
                    className: "IndexingPolicy"
                }
            },
            partitionKey: {
                serializedName: "partitionKey",
                type: {
                    name: "Composite",
                    className: "ContainerPartitionKey"
                }
            },
            defaultTtl: {
                serializedName: "defaultTtl",
                type: {
                    name: "Number"
                }
            },
            uniqueKeyPolicy: {
                serializedName: "uniqueKeyPolicy",
                type: {
                    name: "Composite",
                    className: "UniqueKeyPolicy"
                }
            },
            conflictResolutionPolicy: {
                serializedName: "conflictResolutionPolicy",
                type: {
                    name: "Composite",
                    className: "ConflictResolutionPolicy"
                }
            },
            analyticalStorageTtl: {
                serializedName: "analyticalStorageTtl",
                type: {
                    name: "Number"
                }
            },
            restoreParameters: {
                serializedName: "restoreParameters",
                type: {
                    name: "Composite",
                    className: "ResourceRestoreParameters"
                }
            },
            createMode: {
                defaultValue: "Default",
                serializedName: "createMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LocationListResult = {
    type: {
        name: "Composite",
        className: "LocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LocationGetResult"
                        }
                    }
                }
            }
        }
    }
};
const LocationProperties = {
    type: {
        name: "Composite",
        className: "LocationProperties",
        modelProperties: {
            supportsAvailabilityZone: {
                serializedName: "supportsAvailabilityZone",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            isResidencyRestricted: {
                serializedName: "isResidencyRestricted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            backupStorageRedundancies: {
                serializedName: "backupStorageRedundancies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isSubscriptionRegionAccessAllowedForRegular: {
                serializedName: "isSubscriptionRegionAccessAllowedForRegular",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            isSubscriptionRegionAccessAllowedForAz: {
                serializedName: "isSubscriptionRegionAccessAllowedForAz",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListClusters = {
    type: {
        name: "Composite",
        className: "ListClusters",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterResource"
                        }
                    }
                }
            }
        }
    }
};
const ClusterResourceProperties = {
    type: {
        name: "Composite",
        className: "ClusterResourceProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            restoreFromBackupId: {
                serializedName: "restoreFromBackupId",
                type: {
                    name: "String"
                }
            },
            delegatedManagementSubnetId: {
                serializedName: "delegatedManagementSubnetId",
                type: {
                    name: "String"
                }
            },
            cassandraVersion: {
                serializedName: "cassandraVersion",
                type: {
                    name: "String"
                }
            },
            clusterNameOverride: {
                serializedName: "clusterNameOverride",
                type: {
                    name: "String"
                }
            },
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            },
            initialCassandraAdminPassword: {
                serializedName: "initialCassandraAdminPassword",
                type: {
                    name: "String"
                }
            },
            prometheusEndpoint: {
                serializedName: "prometheusEndpoint",
                type: {
                    name: "Composite",
                    className: "SeedNode"
                }
            },
            repairEnabled: {
                serializedName: "repairEnabled",
                type: {
                    name: "Boolean"
                }
            },
            clientCertificates: {
                serializedName: "clientCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            externalGossipCertificates: {
                serializedName: "externalGossipCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            gossipCertificates: {
                serializedName: "gossipCertificates",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            externalSeedNodes: {
                serializedName: "externalSeedNodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SeedNode"
                        }
                    }
                }
            },
            seedNodes: {
                serializedName: "seedNodes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SeedNode"
                        }
                    }
                }
            },
            hoursBetweenBackups: {
                serializedName: "hoursBetweenBackups",
                type: {
                    name: "Number"
                }
            },
            deallocated: {
                serializedName: "deallocated",
                type: {
                    name: "Boolean"
                }
            },
            cassandraAuditLoggingEnabled: {
                serializedName: "cassandraAuditLoggingEnabled",
                type: {
                    name: "Boolean"
                }
            },
            provisionError: {
                serializedName: "provisionError",
                type: {
                    name: "Composite",
                    className: "CassandraError"
                }
            }
        }
    }
};
const SeedNode = {
    type: {
        name: "Composite",
        className: "SeedNode",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Certificate = {
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: {
            pem: {
                serializedName: "pem",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraError = {
    type: {
        name: "Composite",
        className: "CassandraError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            additionalErrorInfo: {
                serializedName: "additionalErrorInfo",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedCassandraARMResourceProperties = {
    type: {
        name: "Composite",
        className: "ManagedCassandraARMResourceProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedCassandraManagedServiceIdentity"
                }
            }
        }
    }
};
const ManagedCassandraManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedCassandraManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommandPostBody = {
    type: {
        name: "Composite",
        className: "CommandPostBody",
        modelProperties: {
            command: {
                serializedName: "command",
                required: true,
                type: {
                    name: "String"
                }
            },
            arguments: {
                serializedName: "arguments",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            host: {
                serializedName: "host",
                required: true,
                type: {
                    name: "String"
                }
            },
            cassandraStopStart: {
                serializedName: "cassandra-stop-start",
                type: {
                    name: "Boolean"
                }
            },
            readwrite: {
                serializedName: "readwrite",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CommandOutput = {
    type: {
        name: "Composite",
        className: "CommandOutput",
        modelProperties: {
            commandOutput: {
                serializedName: "commandOutput",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListDataCenters = {
    type: {
        name: "Composite",
        className: "ListDataCenters",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataCenterResource"
                        }
                    }
                }
            }
        }
    }
};
const DataCenterResourceProperties = {
    type: {
        name: "Composite",
        className: "DataCenterResourceProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            dataCenterLocation: {
                serializedName: "dataCenterLocation",
                type: {
                    name: "String"
                }
            },
            delegatedSubnetId: {
                serializedName: "delegatedSubnetId",
                type: {
                    name: "String"
                }
            },
            nodeCount: {
                serializedName: "nodeCount",
                type: {
                    name: "Number"
                }
            },
            seedNodes: {
                serializedName: "seedNodes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SeedNode"
                        }
                    }
                }
            },
            base64EncodedCassandraYamlFragment: {
                serializedName: "base64EncodedCassandraYamlFragment",
                type: {
                    name: "String"
                }
            },
            managedDiskCustomerKeyUri: {
                serializedName: "managedDiskCustomerKeyUri",
                type: {
                    name: "String"
                }
            },
            backupStorageCustomerKeyUri: {
                serializedName: "backupStorageCustomerKeyUri",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            },
            diskSku: {
                serializedName: "diskSku",
                type: {
                    name: "String"
                }
            },
            diskCapacity: {
                serializedName: "diskCapacity",
                type: {
                    name: "Number"
                }
            },
            availabilityZone: {
                serializedName: "availabilityZone",
                type: {
                    name: "Boolean"
                }
            },
            authenticationMethodLdapProperties: {
                serializedName: "authenticationMethodLdapProperties",
                type: {
                    name: "Composite",
                    className: "AuthenticationMethodLdapProperties"
                }
            },
            deallocated: {
                serializedName: "deallocated",
                type: {
                    name: "Boolean"
                }
            },
            provisionError: {
                serializedName: "provisionError",
                type: {
                    name: "Composite",
                    className: "CassandraError"
                }
            }
        }
    }
};
const AuthenticationMethodLdapProperties = {
    type: {
        name: "Composite",
        className: "AuthenticationMethodLdapProperties",
        modelProperties: {
            serverHostname: {
                serializedName: "serverHostname",
                type: {
                    name: "String"
                }
            },
            serverPort: {
                serializedName: "serverPort",
                type: {
                    name: "Number"
                }
            },
            serviceUserDistinguishedName: {
                serializedName: "serviceUserDistinguishedName",
                type: {
                    name: "String"
                }
            },
            serviceUserPassword: {
                serializedName: "serviceUserPassword",
                type: {
                    name: "String"
                }
            },
            searchBaseDistinguishedName: {
                serializedName: "searchBaseDistinguishedName",
                type: {
                    name: "String"
                }
            },
            searchFilterTemplate: {
                serializedName: "searchFilterTemplate",
                type: {
                    name: "String"
                }
            },
            serverCertificates: {
                serializedName: "serverCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            connectionTimeoutInMs: {
                serializedName: "connectionTimeoutInMs",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CassandraClusterPublicStatus = {
    type: {
        name: "Composite",
        className: "CassandraClusterPublicStatus",
        modelProperties: {
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            reaperStatus: {
                serializedName: "reaperStatus",
                type: {
                    name: "Composite",
                    className: "ManagedCassandraReaperStatus"
                }
            },
            connectionErrors: {
                serializedName: "connectionErrors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionError"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CassandraError"
                        }
                    }
                }
            },
            dataCenters: {
                serializedName: "dataCenters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CassandraClusterPublicStatusDataCentersItem"
                        }
                    }
                }
            }
        }
    }
};
const ManagedCassandraReaperStatus = {
    type: {
        name: "Composite",
        className: "ManagedCassandraReaperStatus",
        modelProperties: {
            healthy: {
                serializedName: "healthy",
                type: {
                    name: "Boolean"
                }
            },
            repairRunIds: {
                serializedName: "repairRunIds",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            repairSchedules: {
                serializedName: "repairSchedules",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ConnectionError = {
    type: {
        name: "Composite",
        className: "ConnectionError",
        modelProperties: {
            connectionState: {
                serializedName: "connectionState",
                type: {
                    name: "String"
                }
            },
            iPFrom: {
                serializedName: "iPFrom",
                type: {
                    name: "String"
                }
            },
            iPTo: {
                serializedName: "iPTo",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            exception: {
                serializedName: "exception",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraClusterPublicStatusDataCentersItem = {
    type: {
        name: "Composite",
        className: "CassandraClusterPublicStatusDataCentersItem",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            seedNodes: {
                serializedName: "seedNodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nodes: {
                serializedName: "nodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComponentsM9L909SchemasCassandraclusterpublicstatusPropertiesDatacentersItemsPropertiesNodesItems"
                        }
                    }
                }
            }
        }
    }
};
const ComponentsM9L909SchemasCassandraclusterpublicstatusPropertiesDatacentersItemsPropertiesNodesItems = {
    type: {
        name: "Composite",
        className: "ComponentsM9L909SchemasCassandraclusterpublicstatusPropertiesDatacentersItemsPropertiesNodesItems",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            cassandraProcessStatus: {
                serializedName: "cassandraProcessStatus",
                type: {
                    name: "String"
                }
            },
            load: {
                serializedName: "load",
                type: {
                    name: "String"
                }
            },
            tokens: {
                serializedName: "tokens",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            },
            hostID: {
                serializedName: "hostID",
                type: {
                    name: "String"
                }
            },
            rack: {
                serializedName: "rack",
                type: {
                    name: "String"
                }
            },
            timestamp: {
                serializedName: "timestamp",
                type: {
                    name: "String"
                }
            },
            diskUsedKB: {
                serializedName: "diskUsedKB",
                type: {
                    name: "Number"
                }
            },
            diskFreeKB: {
                serializedName: "diskFreeKB",
                type: {
                    name: "Number"
                }
            },
            memoryUsedKB: {
                serializedName: "memoryUsedKB",
                type: {
                    name: "Number"
                }
            },
            memoryBuffersAndCachedKB: {
                serializedName: "memoryBuffersAndCachedKB",
                type: {
                    name: "Number"
                }
            },
            memoryFreeKB: {
                serializedName: "memoryFreeKB",
                type: {
                    name: "Number"
                }
            },
            memoryTotalKB: {
                serializedName: "memoryTotalKB",
                type: {
                    name: "Number"
                }
            },
            cpuUsage: {
                serializedName: "cpuUsage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Privilege = {
    type: {
        name: "Composite",
        className: "Privilege",
        modelProperties: {
            resource: {
                serializedName: "resource",
                type: {
                    name: "Composite",
                    className: "PrivilegeResource"
                }
            },
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivilegeResource = {
    type: {
        name: "Composite",
        className: "PrivilegeResource",
        modelProperties: {
            db: {
                serializedName: "db",
                type: {
                    name: "String"
                }
            },
            collection: {
                serializedName: "collection",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Role = {
    type: {
        name: "Composite",
        className: "Role",
        modelProperties: {
            db: {
                serializedName: "db",
                type: {
                    name: "String"
                }
            },
            role: {
                serializedName: "role",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoRoleDefinitionCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "MongoRoleDefinitionCreateUpdateParameters",
        modelProperties: {
            roleName: {
                serializedName: "properties.roleName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["BuiltInRole", "CustomRole"]
                }
            },
            databaseName: {
                serializedName: "properties.databaseName",
                type: {
                    name: "String"
                }
            },
            privileges: {
                serializedName: "properties.privileges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Privilege"
                        }
                    }
                }
            },
            roles: {
                serializedName: "properties.roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Role"
                        }
                    }
                }
            }
        }
    }
};
const MongoRoleDefinitionListResult = {
    type: {
        name: "Composite",
        className: "MongoRoleDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MongoRoleDefinitionGetResults"
                        }
                    }
                }
            }
        }
    }
};
const MongoUserDefinitionCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "MongoUserDefinitionCreateUpdateParameters",
        modelProperties: {
            userName: {
                serializedName: "properties.userName",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "properties.databaseName",
                type: {
                    name: "String"
                }
            },
            customData: {
                serializedName: "properties.customData",
                type: {
                    name: "String"
                }
            },
            roles: {
                serializedName: "properties.roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Role"
                        }
                    }
                }
            },
            mechanisms: {
                serializedName: "properties.mechanisms",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoUserDefinitionListResult = {
    type: {
        name: "Composite",
        className: "MongoUserDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MongoUserDefinitionGetResults"
                        }
                    }
                }
            }
        }
    }
};
const NotebookWorkspaceListResult = {
    type: {
        name: "Composite",
        className: "NotebookWorkspaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NotebookWorkspace"
                        }
                    }
                }
            }
        }
    }
};
const NotebookWorkspaceConnectionInfoResult = {
    type: {
        name: "Composite",
        className: "NotebookWorkspaceConnectionInfoResult",
        modelProperties: {
            authToken: {
                serializedName: "authToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            notebookServerEndpoint: {
                serializedName: "notebookServerEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const Permission = {
    type: {
        name: "Composite",
        className: "Permission",
        modelProperties: {
            dataActions: {
                serializedName: "dataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            notDataActions: {
                serializedName: "notDataActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SqlRoleDefinitionCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlRoleDefinitionCreateUpdateParameters",
        modelProperties: {
            roleName: {
                serializedName: "properties.roleName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["BuiltInRole", "CustomRole"]
                }
            },
            assignableScopes: {
                serializedName: "properties.assignableScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            permissions: {
                serializedName: "properties.permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Permission"
                        }
                    }
                }
            }
        }
    }
};
const SqlRoleDefinitionListResult = {
    type: {
        name: "Composite",
        className: "SqlRoleDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlRoleDefinitionGetResults"
                        }
                    }
                }
            }
        }
    }
};
const SqlRoleAssignmentCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlRoleAssignmentCreateUpdateParameters",
        modelProperties: {
            roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlRoleAssignmentListResult = {
    type: {
        name: "Composite",
        className: "SqlRoleAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlRoleAssignmentGetResults"
                        }
                    }
                }
            }
        }
    }
};
const RestorableDatabaseAccountsListResult = {
    type: {
        name: "Composite",
        className: "RestorableDatabaseAccountsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableDatabaseAccountGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableDatabaseAccountGetResult = {
    type: {
        name: "Composite",
        className: "RestorableDatabaseAccountGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            accountName: {
                serializedName: "properties.accountName",
                type: {
                    name: "String"
                }
            },
            creationTime: {
                serializedName: "properties.creationTime",
                type: {
                    name: "DateTime"
                }
            },
            deletionTime: {
                serializedName: "properties.deletionTime",
                type: {
                    name: "DateTime"
                }
            },
            oldestRestorableTime: {
                serializedName: "properties.oldestRestorableTime",
                type: {
                    name: "DateTime"
                }
            },
            apiType: {
                serializedName: "properties.apiType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            restorableLocations: {
                serializedName: "properties.restorableLocations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableLocationResource"
                        }
                    }
                }
            }
        }
    }
};
const RestorableLocationResource = {
    type: {
        name: "Composite",
        className: "RestorableLocationResource",
        modelProperties: {
            locationName: {
                serializedName: "locationName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            regionalDatabaseAccountInstanceId: {
                serializedName: "regionalDatabaseAccountInstanceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            creationTime: {
                serializedName: "creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            deletionTime: {
                serializedName: "deletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ContinuousBackupRestoreLocation = {
    type: {
        name: "Composite",
        className: "ContinuousBackupRestoreLocation",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupInformation = {
    type: {
        name: "Composite",
        className: "BackupInformation",
        modelProperties: {
            continuousBackupInformation: {
                serializedName: "continuousBackupInformation",
                type: {
                    name: "Composite",
                    className: "ContinuousBackupInformation"
                }
            }
        }
    }
};
const ContinuousBackupInformation = {
    type: {
        name: "Composite",
        className: "ContinuousBackupInformation",
        modelProperties: {
            latestRestorableTimestamp: {
                serializedName: "latestRestorableTimestamp",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableSqlDatabasesListResult = {
    type: {
        name: "Composite",
        className: "RestorableSqlDatabasesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableSqlDatabaseGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableSqlDatabaseGetResult = {
    type: {
        name: "Composite",
        className: "RestorableSqlDatabaseGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableSqlDatabasePropertiesResource"
                }
            }
        }
    }
};
const RestorableSqlDatabasePropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableSqlDatabasePropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            database: {
                serializedName: "database",
                type: {
                    name: "Composite",
                    className: "RestorableSqlDatabasePropertiesResourceDatabase"
                }
            }
        }
    }
};
const RestorableSqlContainersListResult = {
    type: {
        name: "Composite",
        className: "RestorableSqlContainersListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableSqlContainerGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableSqlContainerGetResult = {
    type: {
        name: "Composite",
        className: "RestorableSqlContainerGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableSqlContainerPropertiesResource"
                }
            }
        }
    }
};
const RestorableSqlContainerPropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableSqlContainerPropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            container: {
                serializedName: "container",
                type: {
                    name: "Composite",
                    className: "RestorableSqlContainerPropertiesResourceContainer"
                }
            }
        }
    }
};
const RestorableSqlResourcesListResult = {
    type: {
        name: "Composite",
        className: "RestorableSqlResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableSqlResourcesGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableSqlResourcesGetResult = {
    type: {
        name: "Composite",
        className: "RestorableSqlResourcesGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            collectionNames: {
                serializedName: "collectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RestorableMongodbDatabasesListResult = {
    type: {
        name: "Composite",
        className: "RestorableMongodbDatabasesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableMongodbDatabaseGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableMongodbDatabaseGetResult = {
    type: {
        name: "Composite",
        className: "RestorableMongodbDatabaseGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableMongodbDatabasePropertiesResource"
                }
            }
        }
    }
};
const RestorableMongodbDatabasePropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableMongodbDatabasePropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableMongodbCollectionsListResult = {
    type: {
        name: "Composite",
        className: "RestorableMongodbCollectionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableMongodbCollectionGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableMongodbCollectionGetResult = {
    type: {
        name: "Composite",
        className: "RestorableMongodbCollectionGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableMongodbCollectionPropertiesResource"
                }
            }
        }
    }
};
const RestorableMongodbCollectionPropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableMongodbCollectionPropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableMongodbResourcesListResult = {
    type: {
        name: "Composite",
        className: "RestorableMongodbResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableMongodbResourcesGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableMongodbResourcesGetResult = {
    type: {
        name: "Composite",
        className: "RestorableMongodbResourcesGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            collectionNames: {
                serializedName: "collectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RestorableGremlinDatabasesListResult = {
    type: {
        name: "Composite",
        className: "RestorableGremlinDatabasesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableGremlinDatabaseGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableGremlinDatabaseGetResult = {
    type: {
        name: "Composite",
        className: "RestorableGremlinDatabaseGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableGremlinDatabasePropertiesResource"
                }
            }
        }
    }
};
const RestorableGremlinDatabasePropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableGremlinDatabasePropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableGremlinGraphsListResult = {
    type: {
        name: "Composite",
        className: "RestorableGremlinGraphsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableGremlinGraphGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableGremlinGraphGetResult = {
    type: {
        name: "Composite",
        className: "RestorableGremlinGraphGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableGremlinGraphPropertiesResource"
                }
            }
        }
    }
};
const RestorableGremlinGraphPropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableGremlinGraphPropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableGremlinResourcesListResult = {
    type: {
        name: "Composite",
        className: "RestorableGremlinResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableGremlinResourcesGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableGremlinResourcesGetResult = {
    type: {
        name: "Composite",
        className: "RestorableGremlinResourcesGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            databaseName: {
                serializedName: "databaseName",
                type: {
                    name: "String"
                }
            },
            graphNames: {
                serializedName: "graphNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RestorableTablesListResult = {
    type: {
        name: "Composite",
        className: "RestorableTablesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableTableGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableTableGetResult = {
    type: {
        name: "Composite",
        className: "RestorableTableGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "RestorableTablePropertiesResource"
                }
            }
        }
    }
};
const RestorableTablePropertiesResource = {
    type: {
        name: "Composite",
        className: "RestorableTablePropertiesResource",
        modelProperties: {
            rid: {
                serializedName: "_rid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operationType: {
                serializedName: "operationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndelete: {
                serializedName: "canUndelete",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            canUndeleteReason: {
                serializedName: "canUndeleteReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerId: {
                serializedName: "ownerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ownerResourceId: {
                serializedName: "ownerResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableTableResourcesListResult = {
    type: {
        name: "Composite",
        className: "RestorableTableResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableTableResourcesGetResult"
                        }
                    }
                }
            }
        }
    }
};
const RestorableTableResourcesGetResult = {
    type: {
        name: "Composite",
        className: "RestorableTableResourcesGetResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceResourceListResult = {
    type: {
        name: "Composite",
        className: "ServiceResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceResource"
                        }
                    }
                }
            }
        }
    }
};
const ServiceResourceProperties = {
    serializedName: "ServiceResourceProperties",
    type: {
        name: "Composite",
        className: "ServiceResourceProperties",
        uberParent: "ServiceResourceProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: {
            serializedName: "serviceType",
            clientName: "serviceType"
        },
        modelProperties: {
            creationTime: {
                serializedName: "creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            instanceSize: {
                serializedName: "instanceSize",
                type: {
                    name: "String"
                }
            },
            instanceCount: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "instanceCount",
                type: {
                    name: "Number"
                }
            },
            serviceType: {
                serializedName: "serviceType",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceResourceCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "ServiceResourceCreateUpdateParameters",
        modelProperties: {
            instanceSize: {
                serializedName: "properties.instanceSize",
                type: {
                    name: "String"
                }
            },
            instanceCount: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.instanceCount",
                type: {
                    name: "Number"
                }
            },
            serviceType: {
                serializedName: "properties.serviceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeriodicModeProperties = {
    type: {
        name: "Composite",
        className: "PeriodicModeProperties",
        modelProperties: {
            backupIntervalInMinutes: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "backupIntervalInMinutes",
                type: {
                    name: "Number"
                }
            },
            backupRetentionIntervalInHours: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "backupRetentionIntervalInHours",
                type: {
                    name: "Number"
                }
            },
            backupStorageRedundancy: {
                serializedName: "backupStorageRedundancy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContinuousModeProperties = {
    type: {
        name: "Composite",
        className: "ContinuousModeProperties",
        modelProperties: {
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataTransferServiceResource = {
    type: {
        name: "Composite",
        className: "DataTransferServiceResource",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataTransferServiceResourceProperties"
                }
            }
        }
    }
};
const RegionalServiceResource = {
    type: {
        name: "Composite",
        className: "RegionalServiceResource",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlDedicatedGatewayServiceResource = {
    type: {
        name: "Composite",
        className: "SqlDedicatedGatewayServiceResource",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SqlDedicatedGatewayServiceResourceProperties"
                }
            }
        }
    }
};
const GraphAPIComputeServiceResource = {
    type: {
        name: "Composite",
        className: "GraphAPIComputeServiceResource",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "GraphAPIComputeServiceResourceProperties"
                }
            }
        }
    }
};
const MaterializedViewsBuilderServiceResource = {
    type: {
        name: "Composite",
        className: "MaterializedViewsBuilderServiceResource",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MaterializedViewsBuilderServiceResourceProperties"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const RestoreParameters = {
    type: {
        name: "Composite",
        className: "RestoreParameters",
        modelProperties: Object.assign(Object.assign({}, RestoreParametersBase.type.modelProperties), { restoreMode: {
                serializedName: "restoreMode",
                type: {
                    name: "String"
                }
            }, databasesToRestore: {
                serializedName: "databasesToRestore",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DatabaseRestoreResource"
                        }
                    }
                }
            }, gremlinDatabasesToRestore: {
                serializedName: "gremlinDatabasesToRestore",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GremlinDatabaseRestoreResource"
                        }
                    }
                }
            }, tablesToRestore: {
                serializedName: "tablesToRestore",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ResourceRestoreParameters = {
    type: {
        name: "Composite",
        className: "ResourceRestoreParameters",
        modelProperties: Object.assign({}, RestoreParametersBase.type.modelProperties)
    }
};
const PeriodicModeBackupPolicy = {
    serializedName: "Periodic",
    type: {
        name: "Composite",
        className: "PeriodicModeBackupPolicy",
        uberParent: "BackupPolicy",
        polymorphicDiscriminator: BackupPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BackupPolicy.type.modelProperties), { periodicModeProperties: {
                serializedName: "periodicModeProperties",
                type: {
                    name: "Composite",
                    className: "PeriodicModeProperties"
                }
            } })
    }
};
const ContinuousModeBackupPolicy = {
    serializedName: "Continuous",
    type: {
        name: "Composite",
        className: "ContinuousModeBackupPolicy",
        uberParent: "BackupPolicy",
        polymorphicDiscriminator: BackupPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BackupPolicy.type.modelProperties), { continuousModeProperties: {
                serializedName: "continuousModeProperties",
                type: {
                    name: "Composite",
                    className: "ContinuousModeProperties"
                }
            } })
    }
};
const DatabaseAccountGetResults = {
    type: {
        name: "Composite",
        className: "DatabaseAccountGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, documentEndpoint: {
                serializedName: "properties.documentEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, databaseAccountOfferType: {
                defaultValue: "Standard",
                isConstant: true,
                serializedName: "properties.databaseAccountOfferType",
                type: {
                    name: "String"
                }
            }, ipRules: {
                serializedName: "properties.ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressOrRange"
                        }
                    }
                }
            }, isVirtualNetworkFilterEnabled: {
                serializedName: "properties.isVirtualNetworkFilterEnabled",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticFailover: {
                serializedName: "properties.enableAutomaticFailover",
                type: {
                    name: "Boolean"
                }
            }, consistencyPolicy: {
                serializedName: "properties.consistencyPolicy",
                type: {
                    name: "Composite",
                    className: "ConsistencyPolicy"
                }
            }, capabilities: {
                serializedName: "properties.capabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability"
                        }
                    }
                }
            }, writeLocations: {
                serializedName: "properties.writeLocations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Location"
                        }
                    }
                }
            }, readLocations: {
                serializedName: "properties.readLocations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Location"
                        }
                    }
                }
            }, locations: {
                serializedName: "properties.locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Location"
                        }
                    }
                }
            }, failoverPolicies: {
                serializedName: "properties.failoverPolicies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FailoverPolicy"
                        }
                    }
                }
            }, virtualNetworkRules: {
                serializedName: "properties.virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, enableMultipleWriteLocations: {
                serializedName: "properties.enableMultipleWriteLocations",
                type: {
                    name: "Boolean"
                }
            }, enableCassandraConnector: {
                serializedName: "properties.enableCassandraConnector",
                type: {
                    name: "Boolean"
                }
            }, connectorOffer: {
                serializedName: "properties.connectorOffer",
                type: {
                    name: "String"
                }
            }, disableKeyBasedMetadataWriteAccess: {
                serializedName: "properties.disableKeyBasedMetadataWriteAccess",
                type: {
                    name: "Boolean"
                }
            }, keyVaultKeyUri: {
                serializedName: "properties.keyVaultKeyUri",
                type: {
                    name: "String"
                }
            }, defaultIdentity: {
                serializedName: "properties.defaultIdentity",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, enableFreeTier: {
                serializedName: "properties.enableFreeTier",
                type: {
                    name: "Boolean"
                }
            }, apiProperties: {
                serializedName: "properties.apiProperties",
                type: {
                    name: "Composite",
                    className: "ApiProperties"
                }
            }, enableAnalyticalStorage: {
                serializedName: "properties.enableAnalyticalStorage",
                type: {
                    name: "Boolean"
                }
            }, analyticalStorageConfiguration: {
                serializedName: "properties.analyticalStorageConfiguration",
                type: {
                    name: "Composite",
                    className: "AnalyticalStorageConfiguration"
                }
            }, instanceId: {
                serializedName: "properties.instanceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createMode: {
                defaultValue: "Default",
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            }, restoreParameters: {
                serializedName: "properties.restoreParameters",
                type: {
                    name: "Composite",
                    className: "RestoreParameters"
                }
            }, backupPolicy: {
                serializedName: "properties.backupPolicy",
                type: {
                    name: "Composite",
                    className: "BackupPolicy"
                }
            }, cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsPolicy"
                        }
                    }
                }
            }, networkAclBypass: {
                serializedName: "properties.networkAclBypass",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "AzureServices"]
                }
            }, networkAclBypassResourceIds: {
                serializedName: "properties.networkAclBypassResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }, capacity: {
                serializedName: "properties.capacity",
                type: {
                    name: "Composite",
                    className: "Capacity"
                }
            }, keysMetadata: {
                serializedName: "properties.keysMetadata",
                type: {
                    name: "Composite",
                    className: "DatabaseAccountKeysMetadata"
                }
            }, enablePartitionMerge: {
                serializedName: "properties.enablePartitionMerge",
                type: {
                    name: "Boolean"
                }
            }, minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            }, enableBurstCapacity: {
                serializedName: "properties.enableBurstCapacity",
                type: {
                    name: "Boolean"
                }
            }, customerManagedKeyStatus: {
                serializedName: "properties.customerManagedKeyStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const DatabaseAccountCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "DatabaseAccountCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, consistencyPolicy: {
                serializedName: "properties.consistencyPolicy",
                type: {
                    name: "Composite",
                    className: "ConsistencyPolicy"
                }
            }, locations: {
                serializedName: "properties.locations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Location"
                        }
                    }
                }
            }, databaseAccountOfferType: {
                defaultValue: "Standard",
                isConstant: true,
                serializedName: "properties.databaseAccountOfferType",
                type: {
                    name: "String"
                }
            }, ipRules: {
                serializedName: "properties.ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAddressOrRange"
                        }
                    }
                }
            }, isVirtualNetworkFilterEnabled: {
                serializedName: "properties.isVirtualNetworkFilterEnabled",
                type: {
                    name: "Boolean"
                }
            }, enableAutomaticFailover: {
                serializedName: "properties.enableAutomaticFailover",
                type: {
                    name: "Boolean"
                }
            }, capabilities: {
                serializedName: "properties.capabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Capability"
                        }
                    }
                }
            }, virtualNetworkRules: {
                serializedName: "properties.virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            }, enableMultipleWriteLocations: {
                serializedName: "properties.enableMultipleWriteLocations",
                type: {
                    name: "Boolean"
                }
            }, enableCassandraConnector: {
                serializedName: "properties.enableCassandraConnector",
                type: {
                    name: "Boolean"
                }
            }, connectorOffer: {
                serializedName: "properties.connectorOffer",
                type: {
                    name: "String"
                }
            }, disableKeyBasedMetadataWriteAccess: {
                serializedName: "properties.disableKeyBasedMetadataWriteAccess",
                type: {
                    name: "Boolean"
                }
            }, keyVaultKeyUri: {
                serializedName: "properties.keyVaultKeyUri",
                type: {
                    name: "String"
                }
            }, defaultIdentity: {
                serializedName: "properties.defaultIdentity",
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, enableFreeTier: {
                serializedName: "properties.enableFreeTier",
                type: {
                    name: "Boolean"
                }
            }, apiProperties: {
                serializedName: "properties.apiProperties",
                type: {
                    name: "Composite",
                    className: "ApiProperties"
                }
            }, enableAnalyticalStorage: {
                serializedName: "properties.enableAnalyticalStorage",
                type: {
                    name: "Boolean"
                }
            }, analyticalStorageConfiguration: {
                serializedName: "properties.analyticalStorageConfiguration",
                type: {
                    name: "Composite",
                    className: "AnalyticalStorageConfiguration"
                }
            }, createMode: {
                defaultValue: "Default",
                serializedName: "properties.createMode",
                type: {
                    name: "String"
                }
            }, backupPolicy: {
                serializedName: "properties.backupPolicy",
                type: {
                    name: "Composite",
                    className: "BackupPolicy"
                }
            }, cors: {
                serializedName: "properties.cors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsPolicy"
                        }
                    }
                }
            }, networkAclBypass: {
                serializedName: "properties.networkAclBypass",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "AzureServices"]
                }
            }, networkAclBypassResourceIds: {
                serializedName: "properties.networkAclBypassResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }, restoreParameters: {
                serializedName: "properties.restoreParameters",
                type: {
                    name: "Composite",
                    className: "RestoreParameters"
                }
            }, capacity: {
                serializedName: "properties.capacity",
                type: {
                    name: "Composite",
                    className: "Capacity"
                }
            }, keysMetadata: {
                serializedName: "properties.keysMetadata",
                type: {
                    name: "Composite",
                    className: "DatabaseAccountKeysMetadata"
                }
            }, enablePartitionMerge: {
                serializedName: "properties.enablePartitionMerge",
                type: {
                    name: "Boolean"
                }
            }, minimalTlsVersion: {
                serializedName: "properties.minimalTlsVersion",
                type: {
                    name: "String"
                }
            }, enableBurstCapacity: {
                serializedName: "properties.enableBurstCapacity",
                type: {
                    name: "Boolean"
                }
            }, customerManagedKeyStatus: {
                serializedName: "properties.customerManagedKeyStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlDatabaseGetResults = {
    type: {
        name: "Composite",
        className: "SqlDatabaseGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlDatabaseGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "SqlDatabaseGetPropertiesOptions"
                }
            } })
    }
};
const SqlDatabaseCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlDatabaseCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlDatabaseResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const ThroughputSettingsGetResults = {
    type: {
        name: "Composite",
        className: "ThroughputSettingsGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "ThroughputSettingsGetPropertiesResource"
                }
            } })
    }
};
const ThroughputSettingsUpdateParameters = {
    type: {
        name: "Composite",
        className: "ThroughputSettingsUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "ThroughputSettingsResource"
                }
            } })
    }
};
const SqlContainerGetResults = {
    type: {
        name: "Composite",
        className: "SqlContainerGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlContainerGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "SqlContainerGetPropertiesOptions"
                }
            } })
    }
};
const SqlContainerCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlContainerCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlContainerResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const SqlStoredProcedureGetResults = {
    type: {
        name: "Composite",
        className: "SqlStoredProcedureGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlStoredProcedureGetPropertiesResource"
                }
            } })
    }
};
const SqlStoredProcedureCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlStoredProcedureCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlStoredProcedureResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const SqlUserDefinedFunctionGetResults = {
    type: {
        name: "Composite",
        className: "SqlUserDefinedFunctionGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlUserDefinedFunctionGetPropertiesResource"
                }
            } })
    }
};
const SqlUserDefinedFunctionCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlUserDefinedFunctionCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlUserDefinedFunctionResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const SqlTriggerGetResults = {
    type: {
        name: "Composite",
        className: "SqlTriggerGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlTriggerGetPropertiesResource"
                }
            } })
    }
};
const SqlTriggerCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "SqlTriggerCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "SqlTriggerResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const MongoDBDatabaseGetResults = {
    type: {
        name: "Composite",
        className: "MongoDBDatabaseGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "MongoDBDatabaseGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "MongoDBDatabaseGetPropertiesOptions"
                }
            } })
    }
};
const MongoDBDatabaseCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "MongoDBDatabaseCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "MongoDBDatabaseResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const MongoDBCollectionGetResults = {
    type: {
        name: "Composite",
        className: "MongoDBCollectionGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "MongoDBCollectionGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "MongoDBCollectionGetPropertiesOptions"
                }
            } })
    }
};
const MongoDBCollectionCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "MongoDBCollectionCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "MongoDBCollectionResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const TableGetResults = {
    type: {
        name: "Composite",
        className: "TableGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "TableGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "TableGetPropertiesOptions"
                }
            } })
    }
};
const TableCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "TableCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "TableResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const CassandraKeyspaceGetResults = {
    type: {
        name: "Composite",
        className: "CassandraKeyspaceGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "CassandraKeyspaceGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CassandraKeyspaceGetPropertiesOptions"
                }
            } })
    }
};
const CassandraKeyspaceCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "CassandraKeyspaceCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "CassandraKeyspaceResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const CassandraTableGetResults = {
    type: {
        name: "Composite",
        className: "CassandraTableGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "CassandraTableGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CassandraTableGetPropertiesOptions"
                }
            } })
    }
};
const CassandraTableCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "CassandraTableCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "CassandraTableResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const GremlinDatabaseGetResults = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "GremlinDatabaseGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "GremlinDatabaseGetPropertiesOptions"
                }
            } })
    }
};
const GremlinDatabaseCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "GremlinDatabaseResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const GremlinGraphGetResults = {
    type: {
        name: "Composite",
        className: "GremlinGraphGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "GremlinGraphGetPropertiesResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "GremlinGraphGetPropertiesOptions"
                }
            } })
    }
};
const GremlinGraphCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "GremlinGraphCreateUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ARMResourceProperties.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "GremlinGraphResource"
                }
            }, options: {
                serializedName: "properties.options",
                type: {
                    name: "Composite",
                    className: "CreateUpdateOptions"
                }
            } })
    }
};
const DatabaseAccountListKeysResult = {
    type: {
        name: "Composite",
        className: "DatabaseAccountListKeysResult",
        modelProperties: Object.assign(Object.assign({}, DatabaseAccountListReadOnlyKeysResult.type.modelProperties), { primaryMasterKey: {
                serializedName: "primaryMasterKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, secondaryMasterKey: {
                serializedName: "secondaryMasterKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PartitionMetric = {
    type: {
        name: "Composite",
        className: "PartitionMetric",
        modelProperties: Object.assign(Object.assign({}, Metric.type.modelProperties), { partitionId: {
                serializedName: "partitionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partitionKeyRangeId: {
                serializedName: "partitionKeyRangeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PercentileMetricValue = {
    type: {
        name: "Composite",
        className: "PercentileMetricValue",
        modelProperties: Object.assign(Object.assign({}, MetricValue.type.modelProperties), { p10: {
                serializedName: "P10",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, p25: {
                serializedName: "P25",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, p50: {
                serializedName: "P50",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, p75: {
                serializedName: "P75",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, p90: {
                serializedName: "P90",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, p95: {
                serializedName: "P95",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, p99: {
                serializedName: "P99",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const PartitionUsage = {
    type: {
        name: "Composite",
        className: "PartitionUsage",
        modelProperties: Object.assign(Object.assign({}, Usage.type.modelProperties), { partitionId: {
                serializedName: "partitionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partitionKeyRangeId: {
                serializedName: "partitionKeyRangeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlDatabaseGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "SqlDatabaseGetPropertiesResource",
        modelProperties: Object.assign(Object.assign(Object.assign({}, SqlDatabaseResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties), { colls: {
                serializedName: "_colls",
                type: {
                    name: "String"
                }
            }, users: {
                serializedName: "_users",
                type: {
                    name: "String"
                }
            } })
    }
};
const RestorableSqlDatabasePropertiesResourceDatabase = {
    type: {
        name: "Composite",
        className: "RestorableSqlDatabasePropertiesResourceDatabase",
        modelProperties: Object.assign(Object.assign(Object.assign({}, SqlDatabaseResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties), { colls: {
                serializedName: "_colls",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, users: {
                serializedName: "_users",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, self: {
                serializedName: "_self",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ThroughputSettingsGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "ThroughputSettingsGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, ThroughputSettingsResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const SqlContainerGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "SqlContainerGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, SqlContainerResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const ClientEncryptionKeyGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "ClientEncryptionKeyGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, ClientEncryptionKeyResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const SqlStoredProcedureGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "SqlStoredProcedureGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, SqlStoredProcedureResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const SqlUserDefinedFunctionGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "SqlUserDefinedFunctionGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, SqlUserDefinedFunctionResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const SqlTriggerGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "SqlTriggerGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, SqlTriggerResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const MongoDBDatabaseGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "MongoDBDatabaseGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, MongoDBDatabaseResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const MongoDBCollectionGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "MongoDBCollectionGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, MongoDBCollectionResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const TableGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "TableGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, TableResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const CassandraKeyspaceGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "CassandraKeyspaceGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, CassandraKeyspaceResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const CassandraTableGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "CassandraTableGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, CassandraTableResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const GremlinDatabaseGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, GremlinDatabaseResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const GremlinGraphGetPropertiesResource = {
    type: {
        name: "Composite",
        className: "GremlinGraphGetPropertiesResource",
        modelProperties: Object.assign(Object.assign({}, GremlinGraphResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties)
    }
};
const RestorableSqlContainerPropertiesResourceContainer = {
    type: {
        name: "Composite",
        className: "RestorableSqlContainerPropertiesResourceContainer",
        modelProperties: Object.assign(Object.assign(Object.assign({}, SqlContainerResource.type.modelProperties), ExtendedResourceProperties.type.modelProperties), { self: {
                serializedName: "_self",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SqlDatabaseGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "SqlDatabaseGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const SqlContainerGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "SqlContainerGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const MongoDBDatabaseGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "MongoDBDatabaseGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const MongoDBCollectionGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "MongoDBCollectionGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const TableGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "TableGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const CassandraKeyspaceGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "CassandraKeyspaceGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const CassandraTableGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "CassandraTableGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const GremlinDatabaseGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "GremlinDatabaseGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const GremlinGraphGetPropertiesOptions = {
    type: {
        name: "Composite",
        className: "GremlinGraphGetPropertiesOptions",
        modelProperties: Object.assign({}, OptionsResource.type.modelProperties)
    }
};
const ClientEncryptionKeyGetResults = {
    type: {
        name: "Composite",
        className: "ClientEncryptionKeyGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { resource: {
                serializedName: "properties.resource",
                type: {
                    name: "Composite",
                    className: "ClientEncryptionKeyGetPropertiesResource"
                }
            } })
    }
};
const LocationGetResult = {
    type: {
        name: "Composite",
        className: "LocationGetResult",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "LocationProperties"
                }
            } })
    }
};
const DataCenterResource = {
    type: {
        name: "Composite",
        className: "DataCenterResource",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataCenterResourceProperties"
                }
            } })
    }
};
const MongoRoleDefinitionGetResults = {
    type: {
        name: "Composite",
        className: "MongoRoleDefinitionGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { roleName: {
                serializedName: "properties.roleName",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["BuiltInRole", "CustomRole"]
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                type: {
                    name: "String"
                }
            }, privileges: {
                serializedName: "properties.privileges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Privilege"
                        }
                    }
                }
            }, roles: {
                serializedName: "properties.roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Role"
                        }
                    }
                }
            } })
    }
};
const MongoUserDefinitionGetResults = {
    type: {
        name: "Composite",
        className: "MongoUserDefinitionGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { userName: {
                serializedName: "properties.userName",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, databaseName: {
                serializedName: "properties.databaseName",
                type: {
                    name: "String"
                }
            }, customData: {
                serializedName: "properties.customData",
                type: {
                    name: "String"
                }
            }, roles: {
                serializedName: "properties.roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Role"
                        }
                    }
                }
            }, mechanisms: {
                serializedName: "properties.mechanisms",
                type: {
                    name: "String"
                }
            } })
    }
};
const NotebookWorkspace = {
    type: {
        name: "Composite",
        className: "NotebookWorkspace",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { notebookServerEndpoint: {
                serializedName: "properties.notebookServerEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NotebookWorkspaceCreateUpdateParameters = {
    type: {
        name: "Composite",
        className: "NotebookWorkspaceCreateUpdateParameters",
        modelProperties: Object.assign({}, ARMProxyResource.type.modelProperties)
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SqlRoleDefinitionGetResults = {
    type: {
        name: "Composite",
        className: "SqlRoleDefinitionGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { roleName: {
                serializedName: "properties.roleName",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "Enum",
                    allowedValues: ["BuiltInRole", "CustomRole"]
                }
            }, assignableScopes: {
                serializedName: "properties.assignableScopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, permissions: {
                serializedName: "properties.permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Permission"
                        }
                    }
                }
            } })
    }
};
const SqlRoleAssignmentGetResults = {
    type: {
        name: "Composite",
        className: "SqlRoleAssignmentGetResults",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { roleDefinitionId: {
                serializedName: "properties.roleDefinitionId",
                type: {
                    name: "String"
                }
            }, scope: {
                serializedName: "properties.scope",
                type: {
                    name: "String"
                }
            }, principalId: {
                serializedName: "properties.principalId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceResource = {
    type: {
        name: "Composite",
        className: "ServiceResource",
        modelProperties: Object.assign(Object.assign({}, ARMProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ServiceResourceProperties"
                }
            } })
    }
};
const ClusterResource = {
    type: {
        name: "Composite",
        className: "ClusterResource",
        modelProperties: Object.assign(Object.assign({}, ManagedCassandraARMResourceProperties.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ClusterResourceProperties"
                }
            } })
    }
};
const DataTransferServiceResourceProperties = {
    serializedName: "DataTransfer",
    type: {
        name: "Composite",
        className: "DataTransferServiceResourceProperties",
        uberParent: "ServiceResourceProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: ServiceResourceProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceProperties.type.modelProperties), { locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataTransferRegionalServiceResource"
                        }
                    }
                }
            } })
    }
};
const SqlDedicatedGatewayServiceResourceProperties = {
    serializedName: "SqlDedicatedGateway",
    type: {
        name: "Composite",
        className: "SqlDedicatedGatewayServiceResourceProperties",
        uberParent: "ServiceResourceProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: ServiceResourceProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceProperties.type.modelProperties), { sqlDedicatedGatewayEndpoint: {
                serializedName: "sqlDedicatedGatewayEndpoint",
                type: {
                    name: "String"
                }
            }, locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SqlDedicatedGatewayRegionalServiceResource"
                        }
                    }
                }
            } })
    }
};
const GraphAPIComputeServiceResourceProperties = {
    serializedName: "GraphAPICompute",
    type: {
        name: "Composite",
        className: "GraphAPIComputeServiceResourceProperties",
        uberParent: "ServiceResourceProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: ServiceResourceProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceProperties.type.modelProperties), { graphApiComputeEndpoint: {
                serializedName: "graphApiComputeEndpoint",
                type: {
                    name: "String"
                }
            }, locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GraphAPIComputeRegionalServiceResource"
                        }
                    }
                }
            } })
    }
};
const MaterializedViewsBuilderServiceResourceProperties = {
    serializedName: "MaterializedViewsBuilder",
    type: {
        name: "Composite",
        className: "MaterializedViewsBuilderServiceResourceProperties",
        uberParent: "ServiceResourceProperties",
        additionalProperties: { type: { name: "Object" } },
        polymorphicDiscriminator: ServiceResourceProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceProperties.type.modelProperties), { locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaterializedViewsBuilderRegionalServiceResource"
                        }
                    }
                }
            } })
    }
};
const DataTransferRegionalServiceResource = {
    type: {
        name: "Composite",
        className: "DataTransferRegionalServiceResource",
        modelProperties: Object.assign({}, RegionalServiceResource.type.modelProperties)
    }
};
const SqlDedicatedGatewayRegionalServiceResource = {
    type: {
        name: "Composite",
        className: "SqlDedicatedGatewayRegionalServiceResource",
        modelProperties: Object.assign(Object.assign({}, RegionalServiceResource.type.modelProperties), { sqlDedicatedGatewayEndpoint: {
                serializedName: "sqlDedicatedGatewayEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const GraphAPIComputeRegionalServiceResource = {
    type: {
        name: "Composite",
        className: "GraphAPIComputeRegionalServiceResource",
        modelProperties: Object.assign(Object.assign({}, RegionalServiceResource.type.modelProperties), { graphApiComputeEndpoint: {
                serializedName: "graphApiComputeEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const MaterializedViewsBuilderRegionalServiceResource = {
    type: {
        name: "Composite",
        className: "MaterializedViewsBuilderRegionalServiceResource",
        modelProperties: Object.assign({}, RegionalServiceResource.type.modelProperties)
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointProperty"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionStateProperty"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const DatabaseAccountsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "DatabaseAccountsDeleteHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseAccountsFailoverPriorityChangeHeaders = {
    type: {
        name: "Composite",
        className: "DatabaseAccountsFailoverPriorityChangeHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseAccountsOfflineRegionHeaders = {
    type: {
        name: "Composite",
        className: "DatabaseAccountsOfflineRegionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseAccountsOnlineRegionHeaders = {
    type: {
        name: "Composite",
        className: "DatabaseAccountsOnlineRegionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabaseAccountsRegenerateKeyHeaders = {
    type: {
        name: "Composite",
        className: "DatabaseAccountsRegenerateKeyHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesCreateUpdateSqlDatabaseHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesCreateUpdateSqlDatabaseHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesDeleteSqlDatabaseHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesDeleteSqlDatabaseHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesUpdateSqlDatabaseThroughputHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesUpdateSqlDatabaseThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesMigrateSqlDatabaseToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesMigrateSqlDatabaseToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesMigrateSqlDatabaseToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesMigrateSqlDatabaseToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesCreateUpdateSqlContainerHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesCreateUpdateSqlContainerHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesDeleteSqlContainerHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesDeleteSqlContainerHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesUpdateSqlContainerThroughputHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesUpdateSqlContainerThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesMigrateSqlContainerToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesMigrateSqlContainerToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesMigrateSqlContainerToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesMigrateSqlContainerToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesCreateUpdateClientEncryptionKeyHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesCreateUpdateClientEncryptionKeyHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesCreateUpdateSqlStoredProcedureHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesCreateUpdateSqlStoredProcedureHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesDeleteSqlStoredProcedureHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesDeleteSqlStoredProcedureHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesCreateUpdateSqlUserDefinedFunctionHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesCreateUpdateSqlUserDefinedFunctionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesDeleteSqlUserDefinedFunctionHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesDeleteSqlUserDefinedFunctionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesCreateUpdateSqlTriggerHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesCreateUpdateSqlTriggerHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SqlResourcesDeleteSqlTriggerHeaders = {
    type: {
        name: "Composite",
        className: "SqlResourcesDeleteSqlTriggerHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesCreateUpdateMongoDBDatabaseHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesCreateUpdateMongoDBDatabaseHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesDeleteMongoDBDatabaseHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesDeleteMongoDBDatabaseHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesUpdateMongoDBDatabaseThroughputHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesUpdateMongoDBDatabaseThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesCreateUpdateMongoDBCollectionHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesCreateUpdateMongoDBCollectionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesDeleteMongoDBCollectionHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesDeleteMongoDBCollectionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesUpdateMongoDBCollectionThroughputHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesUpdateMongoDBCollectionThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesMigrateMongoDBCollectionToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesMigrateMongoDBCollectionToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MongoDBResourcesMigrateMongoDBCollectionToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "MongoDBResourcesMigrateMongoDBCollectionToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableResourcesCreateUpdateTableHeaders = {
    type: {
        name: "Composite",
        className: "TableResourcesCreateUpdateTableHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableResourcesDeleteTableHeaders = {
    type: {
        name: "Composite",
        className: "TableResourcesDeleteTableHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableResourcesUpdateTableThroughputHeaders = {
    type: {
        name: "Composite",
        className: "TableResourcesUpdateTableThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableResourcesMigrateTableToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "TableResourcesMigrateTableToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableResourcesMigrateTableToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "TableResourcesMigrateTableToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesCreateUpdateCassandraKeyspaceHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesCreateUpdateCassandraKeyspaceHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesDeleteCassandraKeyspaceHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesDeleteCassandraKeyspaceHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesUpdateCassandraKeyspaceThroughputHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesUpdateCassandraKeyspaceThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesMigrateCassandraKeyspaceToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesMigrateCassandraKeyspaceToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesMigrateCassandraKeyspaceToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesMigrateCassandraKeyspaceToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesCreateUpdateCassandraTableHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesCreateUpdateCassandraTableHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesDeleteCassandraTableHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesDeleteCassandraTableHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesUpdateCassandraTableThroughputHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesUpdateCassandraTableThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesMigrateCassandraTableToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesMigrateCassandraTableToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CassandraResourcesMigrateCassandraTableToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "CassandraResourcesMigrateCassandraTableToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesCreateUpdateGremlinDatabaseHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesCreateUpdateGremlinDatabaseHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesDeleteGremlinDatabaseHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesDeleteGremlinDatabaseHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesUpdateGremlinDatabaseThroughputHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesUpdateGremlinDatabaseThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesMigrateGremlinDatabaseToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesMigrateGremlinDatabaseToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesMigrateGremlinDatabaseToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesMigrateGremlinDatabaseToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesCreateUpdateGremlinGraphHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesCreateUpdateGremlinGraphHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesDeleteGremlinGraphHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesDeleteGremlinGraphHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesUpdateGremlinGraphThroughputHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesUpdateGremlinGraphThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesMigrateGremlinGraphToAutoscaleHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesMigrateGremlinGraphToAutoscaleHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GremlinResourcesMigrateGremlinGraphToManualThroughputHeaders = {
    type: {
        name: "Composite",
        className: "GremlinResourcesMigrateGremlinGraphToManualThroughputHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceCreateHeaders = {
    type: {
        name: "Composite",
        className: "ServiceCreateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ServiceDeleteHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    BackupPolicy: BackupPolicy,
    ServiceResourceProperties: ServiceResourceProperties,
    "BackupPolicy.Periodic": PeriodicModeBackupPolicy,
    "BackupPolicy.Continuous": ContinuousModeBackupPolicy,
    "ServiceResourceProperties.DataTransfer": DataTransferServiceResourceProperties,
    "ServiceResourceProperties.SqlDedicatedGateway": SqlDedicatedGatewayServiceResourceProperties,
    "ServiceResourceProperties.GraphAPICompute": GraphAPIComputeServiceResourceProperties,
    "ServiceResourceProperties.MaterializedViewsBuilder": MaterializedViewsBuilderServiceResourceProperties
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ARMProxyResource: ARMProxyResource,
    ARMResourceProperties: ARMResourceProperties,
    AccountKeyMetadata: AccountKeyMetadata,
    AnalyticalStorageConfiguration: AnalyticalStorageConfiguration,
    ApiProperties: ApiProperties,
    AuthenticationMethodLdapProperties: AuthenticationMethodLdapProperties,
    AutoUpgradePolicyResource: AutoUpgradePolicyResource,
    AutoscaleSettings: AutoscaleSettings,
    AutoscaleSettingsResource: AutoscaleSettingsResource,
    BackupInformation: BackupInformation,
    BackupPolicy: BackupPolicy,
    BackupPolicyMigrationState: BackupPolicyMigrationState,
    Capability: Capability,
    Capacity: Capacity,
    CassandraClusterPublicStatus: CassandraClusterPublicStatus,
    CassandraClusterPublicStatusDataCentersItem: CassandraClusterPublicStatusDataCentersItem,
    CassandraError: CassandraError,
    CassandraKeyspaceCreateUpdateParameters: CassandraKeyspaceCreateUpdateParameters,
    CassandraKeyspaceGetPropertiesOptions: CassandraKeyspaceGetPropertiesOptions,
    CassandraKeyspaceGetPropertiesResource: CassandraKeyspaceGetPropertiesResource,
    CassandraKeyspaceGetResults: CassandraKeyspaceGetResults,
    CassandraKeyspaceListResult: CassandraKeyspaceListResult,
    CassandraKeyspaceResource: CassandraKeyspaceResource,
    CassandraPartitionKey: CassandraPartitionKey,
    CassandraResourcesCreateUpdateCassandraKeyspaceHeaders: CassandraResourcesCreateUpdateCassandraKeyspaceHeaders,
    CassandraResourcesCreateUpdateCassandraTableHeaders: CassandraResourcesCreateUpdateCassandraTableHeaders,
    CassandraResourcesDeleteCassandraKeyspaceHeaders: CassandraResourcesDeleteCassandraKeyspaceHeaders,
    CassandraResourcesDeleteCassandraTableHeaders: CassandraResourcesDeleteCassandraTableHeaders,
    CassandraResourcesMigrateCassandraKeyspaceToAutoscaleHeaders: CassandraResourcesMigrateCassandraKeyspaceToAutoscaleHeaders,
    CassandraResourcesMigrateCassandraKeyspaceToManualThroughputHeaders: CassandraResourcesMigrateCassandraKeyspaceToManualThroughputHeaders,
    CassandraResourcesMigrateCassandraTableToAutoscaleHeaders: CassandraResourcesMigrateCassandraTableToAutoscaleHeaders,
    CassandraResourcesMigrateCassandraTableToManualThroughputHeaders: CassandraResourcesMigrateCassandraTableToManualThroughputHeaders,
    CassandraResourcesUpdateCassandraKeyspaceThroughputHeaders: CassandraResourcesUpdateCassandraKeyspaceThroughputHeaders,
    CassandraResourcesUpdateCassandraTableThroughputHeaders: CassandraResourcesUpdateCassandraTableThroughputHeaders,
    CassandraSchema: CassandraSchema,
    CassandraTableCreateUpdateParameters: CassandraTableCreateUpdateParameters,
    CassandraTableGetPropertiesOptions: CassandraTableGetPropertiesOptions,
    CassandraTableGetPropertiesResource: CassandraTableGetPropertiesResource,
    CassandraTableGetResults: CassandraTableGetResults,
    CassandraTableListResult: CassandraTableListResult,
    CassandraTableResource: CassandraTableResource,
    Certificate: Certificate,
    ClientEncryptionIncludedPath: ClientEncryptionIncludedPath,
    ClientEncryptionKeyCreateUpdateParameters: ClientEncryptionKeyCreateUpdateParameters,
    ClientEncryptionKeyGetPropertiesResource: ClientEncryptionKeyGetPropertiesResource,
    ClientEncryptionKeyGetResults: ClientEncryptionKeyGetResults,
    ClientEncryptionKeyResource: ClientEncryptionKeyResource,
    ClientEncryptionKeysListResult: ClientEncryptionKeysListResult,
    ClientEncryptionPolicy: ClientEncryptionPolicy,
    CloudError: CloudError,
    ClusterKey: ClusterKey,
    ClusterResource: ClusterResource,
    ClusterResourceProperties: ClusterResourceProperties,
    Column: Column,
    CommandOutput: CommandOutput,
    CommandPostBody: CommandPostBody,
    Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties: Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties,
    ComponentsM9L909SchemasCassandraclusterpublicstatusPropertiesDatacentersItemsPropertiesNodesItems: ComponentsM9L909SchemasCassandraclusterpublicstatusPropertiesDatacentersItemsPropertiesNodesItems,
    CompositePath: CompositePath,
    ComputedProperty: ComputedProperty,
    ConflictResolutionPolicy: ConflictResolutionPolicy,
    ConnectionError: ConnectionError,
    ConsistencyPolicy: ConsistencyPolicy,
    ContainerPartitionKey: ContainerPartitionKey,
    ContinuousBackupInformation: ContinuousBackupInformation,
    ContinuousBackupRestoreLocation: ContinuousBackupRestoreLocation,
    ContinuousModeBackupPolicy: ContinuousModeBackupPolicy,
    ContinuousModeProperties: ContinuousModeProperties,
    CorsPolicy: CorsPolicy,
    CreateUpdateOptions: CreateUpdateOptions,
    DataCenterResource: DataCenterResource,
    DataCenterResourceProperties: DataCenterResourceProperties,
    DataTransferRegionalServiceResource: DataTransferRegionalServiceResource,
    DataTransferServiceResource: DataTransferServiceResource,
    DataTransferServiceResourceProperties: DataTransferServiceResourceProperties,
    DatabaseAccountConnectionString: DatabaseAccountConnectionString,
    DatabaseAccountCreateUpdateParameters: DatabaseAccountCreateUpdateParameters,
    DatabaseAccountGetResults: DatabaseAccountGetResults,
    DatabaseAccountKeysMetadata: DatabaseAccountKeysMetadata,
    DatabaseAccountListConnectionStringsResult: DatabaseAccountListConnectionStringsResult,
    DatabaseAccountListKeysResult: DatabaseAccountListKeysResult,
    DatabaseAccountListReadOnlyKeysResult: DatabaseAccountListReadOnlyKeysResult,
    DatabaseAccountRegenerateKeyParameters: DatabaseAccountRegenerateKeyParameters,
    DatabaseAccountUpdateParameters: DatabaseAccountUpdateParameters,
    DatabaseAccountsDeleteHeaders: DatabaseAccountsDeleteHeaders,
    DatabaseAccountsFailoverPriorityChangeHeaders: DatabaseAccountsFailoverPriorityChangeHeaders,
    DatabaseAccountsListResult: DatabaseAccountsListResult,
    DatabaseAccountsOfflineRegionHeaders: DatabaseAccountsOfflineRegionHeaders,
    DatabaseAccountsOnlineRegionHeaders: DatabaseAccountsOnlineRegionHeaders,
    DatabaseAccountsRegenerateKeyHeaders: DatabaseAccountsRegenerateKeyHeaders,
    DatabaseRestoreResource: DatabaseRestoreResource,
    ErrorResponse: ErrorResponse,
    ExcludedPath: ExcludedPath,
    ExtendedResourceProperties: ExtendedResourceProperties,
    FailoverPolicies: FailoverPolicies,
    FailoverPolicy: FailoverPolicy,
    GraphAPIComputeRegionalServiceResource: GraphAPIComputeRegionalServiceResource,
    GraphAPIComputeServiceResource: GraphAPIComputeServiceResource,
    GraphAPIComputeServiceResourceProperties: GraphAPIComputeServiceResourceProperties,
    GremlinDatabaseCreateUpdateParameters: GremlinDatabaseCreateUpdateParameters,
    GremlinDatabaseGetPropertiesOptions: GremlinDatabaseGetPropertiesOptions,
    GremlinDatabaseGetPropertiesResource: GremlinDatabaseGetPropertiesResource,
    GremlinDatabaseGetResults: GremlinDatabaseGetResults,
    GremlinDatabaseListResult: GremlinDatabaseListResult,
    GremlinDatabaseResource: GremlinDatabaseResource,
    GremlinDatabaseRestoreResource: GremlinDatabaseRestoreResource,
    GremlinGraphCreateUpdateParameters: GremlinGraphCreateUpdateParameters,
    GremlinGraphGetPropertiesOptions: GremlinGraphGetPropertiesOptions,
    GremlinGraphGetPropertiesResource: GremlinGraphGetPropertiesResource,
    GremlinGraphGetResults: GremlinGraphGetResults,
    GremlinGraphListResult: GremlinGraphListResult,
    GremlinGraphResource: GremlinGraphResource,
    GremlinResourcesCreateUpdateGremlinDatabaseHeaders: GremlinResourcesCreateUpdateGremlinDatabaseHeaders,
    GremlinResourcesCreateUpdateGremlinGraphHeaders: GremlinResourcesCreateUpdateGremlinGraphHeaders,
    GremlinResourcesDeleteGremlinDatabaseHeaders: GremlinResourcesDeleteGremlinDatabaseHeaders,
    GremlinResourcesDeleteGremlinGraphHeaders: GremlinResourcesDeleteGremlinGraphHeaders,
    GremlinResourcesMigrateGremlinDatabaseToAutoscaleHeaders: GremlinResourcesMigrateGremlinDatabaseToAutoscaleHeaders,
    GremlinResourcesMigrateGremlinDatabaseToManualThroughputHeaders: GremlinResourcesMigrateGremlinDatabaseToManualThroughputHeaders,
    GremlinResourcesMigrateGremlinGraphToAutoscaleHeaders: GremlinResourcesMigrateGremlinGraphToAutoscaleHeaders,
    GremlinResourcesMigrateGremlinGraphToManualThroughputHeaders: GremlinResourcesMigrateGremlinGraphToManualThroughputHeaders,
    GremlinResourcesUpdateGremlinDatabaseThroughputHeaders: GremlinResourcesUpdateGremlinDatabaseThroughputHeaders,
    GremlinResourcesUpdateGremlinGraphThroughputHeaders: GremlinResourcesUpdateGremlinGraphThroughputHeaders,
    IncludedPath: IncludedPath,
    Indexes: Indexes,
    IndexingPolicy: IndexingPolicy,
    IpAddressOrRange: IpAddressOrRange,
    KeyWrapMetadata: KeyWrapMetadata,
    ListClusters: ListClusters,
    ListDataCenters: ListDataCenters,
    Location: Location,
    LocationGetResult: LocationGetResult,
    LocationListResult: LocationListResult,
    LocationProperties: LocationProperties,
    ManagedCassandraARMResourceProperties: ManagedCassandraARMResourceProperties,
    ManagedCassandraManagedServiceIdentity: ManagedCassandraManagedServiceIdentity,
    ManagedCassandraReaperStatus: ManagedCassandraReaperStatus,
    ManagedServiceIdentity: ManagedServiceIdentity,
    MaterializedViewsBuilderRegionalServiceResource: MaterializedViewsBuilderRegionalServiceResource,
    MaterializedViewsBuilderServiceResource: MaterializedViewsBuilderServiceResource,
    MaterializedViewsBuilderServiceResourceProperties: MaterializedViewsBuilderServiceResourceProperties,
    Metric: Metric,
    MetricAvailability: MetricAvailability,
    MetricDefinition: MetricDefinition,
    MetricDefinitionsListResult: MetricDefinitionsListResult,
    MetricListResult: MetricListResult,
    MetricName: MetricName,
    MetricValue: MetricValue,
    MongoDBCollectionCreateUpdateParameters: MongoDBCollectionCreateUpdateParameters,
    MongoDBCollectionGetPropertiesOptions: MongoDBCollectionGetPropertiesOptions,
    MongoDBCollectionGetPropertiesResource: MongoDBCollectionGetPropertiesResource,
    MongoDBCollectionGetResults: MongoDBCollectionGetResults,
    MongoDBCollectionListResult: MongoDBCollectionListResult,
    MongoDBCollectionResource: MongoDBCollectionResource,
    MongoDBDatabaseCreateUpdateParameters: MongoDBDatabaseCreateUpdateParameters,
    MongoDBDatabaseGetPropertiesOptions: MongoDBDatabaseGetPropertiesOptions,
    MongoDBDatabaseGetPropertiesResource: MongoDBDatabaseGetPropertiesResource,
    MongoDBDatabaseGetResults: MongoDBDatabaseGetResults,
    MongoDBDatabaseListResult: MongoDBDatabaseListResult,
    MongoDBDatabaseResource: MongoDBDatabaseResource,
    MongoDBResourcesCreateUpdateMongoDBCollectionHeaders: MongoDBResourcesCreateUpdateMongoDBCollectionHeaders,
    MongoDBResourcesCreateUpdateMongoDBDatabaseHeaders: MongoDBResourcesCreateUpdateMongoDBDatabaseHeaders,
    MongoDBResourcesDeleteMongoDBCollectionHeaders: MongoDBResourcesDeleteMongoDBCollectionHeaders,
    MongoDBResourcesDeleteMongoDBDatabaseHeaders: MongoDBResourcesDeleteMongoDBDatabaseHeaders,
    MongoDBResourcesMigrateMongoDBCollectionToAutoscaleHeaders: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleHeaders,
    MongoDBResourcesMigrateMongoDBCollectionToManualThroughputHeaders: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputHeaders,
    MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleHeaders: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleHeaders,
    MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputHeaders: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputHeaders,
    MongoDBResourcesUpdateMongoDBCollectionThroughputHeaders: MongoDBResourcesUpdateMongoDBCollectionThroughputHeaders,
    MongoDBResourcesUpdateMongoDBDatabaseThroughputHeaders: MongoDBResourcesUpdateMongoDBDatabaseThroughputHeaders,
    MongoIndex: MongoIndex,
    MongoIndexKeys: MongoIndexKeys,
    MongoIndexOptions: MongoIndexOptions,
    MongoRoleDefinitionCreateUpdateParameters: MongoRoleDefinitionCreateUpdateParameters,
    MongoRoleDefinitionGetResults: MongoRoleDefinitionGetResults,
    MongoRoleDefinitionListResult: MongoRoleDefinitionListResult,
    MongoUserDefinitionCreateUpdateParameters: MongoUserDefinitionCreateUpdateParameters,
    MongoUserDefinitionGetResults: MongoUserDefinitionGetResults,
    MongoUserDefinitionListResult: MongoUserDefinitionListResult,
    NotebookWorkspace: NotebookWorkspace,
    NotebookWorkspaceConnectionInfoResult: NotebookWorkspaceConnectionInfoResult,
    NotebookWorkspaceCreateUpdateParameters: NotebookWorkspaceCreateUpdateParameters,
    NotebookWorkspaceListResult: NotebookWorkspaceListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationListResult: OperationListResult,
    OptionsResource: OptionsResource,
    PartitionMetric: PartitionMetric,
    PartitionMetricListResult: PartitionMetricListResult,
    PartitionUsage: PartitionUsage,
    PartitionUsagesResult: PartitionUsagesResult,
    PercentileMetric: PercentileMetric,
    PercentileMetricListResult: PercentileMetricListResult,
    PercentileMetricValue: PercentileMetricValue,
    PeriodicModeBackupPolicy: PeriodicModeBackupPolicy,
    PeriodicModeProperties: PeriodicModeProperties,
    Permission: Permission,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateEndpointProperty: PrivateEndpointProperty,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateLinkServiceConnectionStateProperty: PrivateLinkServiceConnectionStateProperty,
    Privilege: Privilege,
    PrivilegeResource: PrivilegeResource,
    ProxyResource: ProxyResource,
    RegionForOnlineOffline: RegionForOnlineOffline,
    RegionalServiceResource: RegionalServiceResource,
    Resource: Resource,
    ResourceRestoreParameters: ResourceRestoreParameters,
    RestorableDatabaseAccountGetResult: RestorableDatabaseAccountGetResult,
    RestorableDatabaseAccountsListResult: RestorableDatabaseAccountsListResult,
    RestorableGremlinDatabaseGetResult: RestorableGremlinDatabaseGetResult,
    RestorableGremlinDatabasePropertiesResource: RestorableGremlinDatabasePropertiesResource,
    RestorableGremlinDatabasesListResult: RestorableGremlinDatabasesListResult,
    RestorableGremlinGraphGetResult: RestorableGremlinGraphGetResult,
    RestorableGremlinGraphPropertiesResource: RestorableGremlinGraphPropertiesResource,
    RestorableGremlinGraphsListResult: RestorableGremlinGraphsListResult,
    RestorableGremlinResourcesGetResult: RestorableGremlinResourcesGetResult,
    RestorableGremlinResourcesListResult: RestorableGremlinResourcesListResult,
    RestorableLocationResource: RestorableLocationResource,
    RestorableMongodbCollectionGetResult: RestorableMongodbCollectionGetResult,
    RestorableMongodbCollectionPropertiesResource: RestorableMongodbCollectionPropertiesResource,
    RestorableMongodbCollectionsListResult: RestorableMongodbCollectionsListResult,
    RestorableMongodbDatabaseGetResult: RestorableMongodbDatabaseGetResult,
    RestorableMongodbDatabasePropertiesResource: RestorableMongodbDatabasePropertiesResource,
    RestorableMongodbDatabasesListResult: RestorableMongodbDatabasesListResult,
    RestorableMongodbResourcesGetResult: RestorableMongodbResourcesGetResult,
    RestorableMongodbResourcesListResult: RestorableMongodbResourcesListResult,
    RestorableSqlContainerGetResult: RestorableSqlContainerGetResult,
    RestorableSqlContainerPropertiesResource: RestorableSqlContainerPropertiesResource,
    RestorableSqlContainerPropertiesResourceContainer: RestorableSqlContainerPropertiesResourceContainer,
    RestorableSqlContainersListResult: RestorableSqlContainersListResult,
    RestorableSqlDatabaseGetResult: RestorableSqlDatabaseGetResult,
    RestorableSqlDatabasePropertiesResource: RestorableSqlDatabasePropertiesResource,
    RestorableSqlDatabasePropertiesResourceDatabase: RestorableSqlDatabasePropertiesResourceDatabase,
    RestorableSqlDatabasesListResult: RestorableSqlDatabasesListResult,
    RestorableSqlResourcesGetResult: RestorableSqlResourcesGetResult,
    RestorableSqlResourcesListResult: RestorableSqlResourcesListResult,
    RestorableTableGetResult: RestorableTableGetResult,
    RestorableTablePropertiesResource: RestorableTablePropertiesResource,
    RestorableTableResourcesGetResult: RestorableTableResourcesGetResult,
    RestorableTableResourcesListResult: RestorableTableResourcesListResult,
    RestorableTablesListResult: RestorableTablesListResult,
    RestoreParameters: RestoreParameters,
    RestoreParametersBase: RestoreParametersBase,
    Role: Role,
    SeedNode: SeedNode,
    ServiceCreateHeaders: ServiceCreateHeaders,
    ServiceDeleteHeaders: ServiceDeleteHeaders,
    ServiceResource: ServiceResource,
    ServiceResourceCreateUpdateParameters: ServiceResourceCreateUpdateParameters,
    ServiceResourceListResult: ServiceResourceListResult,
    ServiceResourceProperties: ServiceResourceProperties,
    SpatialSpec: SpatialSpec,
    SqlContainerCreateUpdateParameters: SqlContainerCreateUpdateParameters,
    SqlContainerGetPropertiesOptions: SqlContainerGetPropertiesOptions,
    SqlContainerGetPropertiesResource: SqlContainerGetPropertiesResource,
    SqlContainerGetResults: SqlContainerGetResults,
    SqlContainerListResult: SqlContainerListResult,
    SqlContainerResource: SqlContainerResource,
    SqlDatabaseCreateUpdateParameters: SqlDatabaseCreateUpdateParameters,
    SqlDatabaseGetPropertiesOptions: SqlDatabaseGetPropertiesOptions,
    SqlDatabaseGetPropertiesResource: SqlDatabaseGetPropertiesResource,
    SqlDatabaseGetResults: SqlDatabaseGetResults,
    SqlDatabaseListResult: SqlDatabaseListResult,
    SqlDatabaseResource: SqlDatabaseResource,
    SqlDedicatedGatewayRegionalServiceResource: SqlDedicatedGatewayRegionalServiceResource,
    SqlDedicatedGatewayServiceResource: SqlDedicatedGatewayServiceResource,
    SqlDedicatedGatewayServiceResourceProperties: SqlDedicatedGatewayServiceResourceProperties,
    SqlResourcesCreateUpdateClientEncryptionKeyHeaders: SqlResourcesCreateUpdateClientEncryptionKeyHeaders,
    SqlResourcesCreateUpdateSqlContainerHeaders: SqlResourcesCreateUpdateSqlContainerHeaders,
    SqlResourcesCreateUpdateSqlDatabaseHeaders: SqlResourcesCreateUpdateSqlDatabaseHeaders,
    SqlResourcesCreateUpdateSqlStoredProcedureHeaders: SqlResourcesCreateUpdateSqlStoredProcedureHeaders,
    SqlResourcesCreateUpdateSqlTriggerHeaders: SqlResourcesCreateUpdateSqlTriggerHeaders,
    SqlResourcesCreateUpdateSqlUserDefinedFunctionHeaders: SqlResourcesCreateUpdateSqlUserDefinedFunctionHeaders,
    SqlResourcesDeleteSqlContainerHeaders: SqlResourcesDeleteSqlContainerHeaders,
    SqlResourcesDeleteSqlDatabaseHeaders: SqlResourcesDeleteSqlDatabaseHeaders,
    SqlResourcesDeleteSqlStoredProcedureHeaders: SqlResourcesDeleteSqlStoredProcedureHeaders,
    SqlResourcesDeleteSqlTriggerHeaders: SqlResourcesDeleteSqlTriggerHeaders,
    SqlResourcesDeleteSqlUserDefinedFunctionHeaders: SqlResourcesDeleteSqlUserDefinedFunctionHeaders,
    SqlResourcesMigrateSqlContainerToAutoscaleHeaders: SqlResourcesMigrateSqlContainerToAutoscaleHeaders,
    SqlResourcesMigrateSqlContainerToManualThroughputHeaders: SqlResourcesMigrateSqlContainerToManualThroughputHeaders,
    SqlResourcesMigrateSqlDatabaseToAutoscaleHeaders: SqlResourcesMigrateSqlDatabaseToAutoscaleHeaders,
    SqlResourcesMigrateSqlDatabaseToManualThroughputHeaders: SqlResourcesMigrateSqlDatabaseToManualThroughputHeaders,
    SqlResourcesUpdateSqlContainerThroughputHeaders: SqlResourcesUpdateSqlContainerThroughputHeaders,
    SqlResourcesUpdateSqlDatabaseThroughputHeaders: SqlResourcesUpdateSqlDatabaseThroughputHeaders,
    SqlRoleAssignmentCreateUpdateParameters: SqlRoleAssignmentCreateUpdateParameters,
    SqlRoleAssignmentGetResults: SqlRoleAssignmentGetResults,
    SqlRoleAssignmentListResult: SqlRoleAssignmentListResult,
    SqlRoleDefinitionCreateUpdateParameters: SqlRoleDefinitionCreateUpdateParameters,
    SqlRoleDefinitionGetResults: SqlRoleDefinitionGetResults,
    SqlRoleDefinitionListResult: SqlRoleDefinitionListResult,
    SqlStoredProcedureCreateUpdateParameters: SqlStoredProcedureCreateUpdateParameters,
    SqlStoredProcedureGetPropertiesResource: SqlStoredProcedureGetPropertiesResource,
    SqlStoredProcedureGetResults: SqlStoredProcedureGetResults,
    SqlStoredProcedureListResult: SqlStoredProcedureListResult,
    SqlStoredProcedureResource: SqlStoredProcedureResource,
    SqlTriggerCreateUpdateParameters: SqlTriggerCreateUpdateParameters,
    SqlTriggerGetPropertiesResource: SqlTriggerGetPropertiesResource,
    SqlTriggerGetResults: SqlTriggerGetResults,
    SqlTriggerListResult: SqlTriggerListResult,
    SqlTriggerResource: SqlTriggerResource,
    SqlUserDefinedFunctionCreateUpdateParameters: SqlUserDefinedFunctionCreateUpdateParameters,
    SqlUserDefinedFunctionGetPropertiesResource: SqlUserDefinedFunctionGetPropertiesResource,
    SqlUserDefinedFunctionGetResults: SqlUserDefinedFunctionGetResults,
    SqlUserDefinedFunctionListResult: SqlUserDefinedFunctionListResult,
    SqlUserDefinedFunctionResource: SqlUserDefinedFunctionResource,
    SystemData: SystemData,
    TableCreateUpdateParameters: TableCreateUpdateParameters,
    TableGetPropertiesOptions: TableGetPropertiesOptions,
    TableGetPropertiesResource: TableGetPropertiesResource,
    TableGetResults: TableGetResults,
    TableListResult: TableListResult,
    TableResource: TableResource,
    TableResourcesCreateUpdateTableHeaders: TableResourcesCreateUpdateTableHeaders,
    TableResourcesDeleteTableHeaders: TableResourcesDeleteTableHeaders,
    TableResourcesMigrateTableToAutoscaleHeaders: TableResourcesMigrateTableToAutoscaleHeaders,
    TableResourcesMigrateTableToManualThroughputHeaders: TableResourcesMigrateTableToManualThroughputHeaders,
    TableResourcesUpdateTableThroughputHeaders: TableResourcesUpdateTableThroughputHeaders,
    ThroughputPolicyResource: ThroughputPolicyResource,
    ThroughputSettingsGetPropertiesResource: ThroughputSettingsGetPropertiesResource,
    ThroughputSettingsGetResults: ThroughputSettingsGetResults,
    ThroughputSettingsResource: ThroughputSettingsResource,
    ThroughputSettingsUpdateParameters: ThroughputSettingsUpdateParameters,
    UniqueKey: UniqueKey,
    UniqueKeyPolicy: UniqueKeyPolicy,
    Usage: Usage,
    UsagesResult: UsagesResult,
    VirtualNetworkRule: VirtualNetworkRule,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accountName = {
    parameterPath: "accountName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-z0-9]+(-[a-z0-9]+)*"),
            MaxLength: 50,
            MinLength: 3
        },
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-11-15",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const updateParameters = {
    parameterPath: "updateParameters",
    mapper: DatabaseAccountUpdateParameters
};
const createUpdateParameters = {
    parameterPath: "createUpdateParameters",
    mapper: DatabaseAccountCreateUpdateParameters
};
const failoverParameters = {
    parameterPath: "failoverParameters",
    mapper: FailoverPolicies
};
const regionParameterForOffline = {
    parameterPath: "regionParameterForOffline",
    mapper: RegionForOnlineOffline
};
const regionParameterForOnline = {
    parameterPath: "regionParameterForOnline",
    mapper: RegionForOnlineOffline
};
const keyToRegenerate = {
    parameterPath: "keyToRegenerate",
    mapper: DatabaseAccountRegenerateKeyParameters
};
const filter = {
    parameterPath: "filter",
    mapper: {
        serializedName: "$filter",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter1 = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const databaseRid = {
    parameterPath: "databaseRid",
    mapper: {
        serializedName: "databaseRid",
        required: true,
        type: {
            name: "String"
        }
    }
};
const collectionRid = {
    parameterPath: "collectionRid",
    mapper: {
        serializedName: "collectionRid",
        required: true,
        type: {
            name: "String"
        }
    }
};
const region = {
    parameterPath: "region",
    mapper: {
        serializedName: "region",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sourceRegion = {
    parameterPath: "sourceRegion",
    mapper: {
        serializedName: "sourceRegion",
        required: true,
        type: {
            name: "String"
        }
    }
};
const targetRegion = {
    parameterPath: "targetRegion",
    mapper: {
        serializedName: "targetRegion",
        required: true,
        type: {
            name: "String"
        }
    }
};
const partitionKeyRangeId = {
    parameterPath: "partitionKeyRangeId",
    mapper: {
        serializedName: "partitionKeyRangeId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const databaseName = {
    parameterPath: "databaseName",
    mapper: {
        serializedName: "databaseName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlDatabaseParameters = {
    parameterPath: "createUpdateSqlDatabaseParameters",
    mapper: SqlDatabaseCreateUpdateParameters
};
const updateThroughputParameters = {
    parameterPath: "updateThroughputParameters",
    mapper: ThroughputSettingsUpdateParameters
};
const containerName = {
    parameterPath: "containerName",
    mapper: {
        serializedName: "containerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlContainerParameters = {
    parameterPath: "createUpdateSqlContainerParameters",
    mapper: SqlContainerCreateUpdateParameters
};
const clientEncryptionKeyName = {
    parameterPath: "clientEncryptionKeyName",
    mapper: {
        serializedName: "clientEncryptionKeyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateClientEncryptionKeyParameters = {
    parameterPath: "createUpdateClientEncryptionKeyParameters",
    mapper: ClientEncryptionKeyCreateUpdateParameters
};
const storedProcedureName = {
    parameterPath: "storedProcedureName",
    mapper: {
        serializedName: "storedProcedureName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlStoredProcedureParameters = {
    parameterPath: "createUpdateSqlStoredProcedureParameters",
    mapper: SqlStoredProcedureCreateUpdateParameters
};
const userDefinedFunctionName = {
    parameterPath: "userDefinedFunctionName",
    mapper: {
        serializedName: "userDefinedFunctionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlUserDefinedFunctionParameters = {
    parameterPath: "createUpdateSqlUserDefinedFunctionParameters",
    mapper: SqlUserDefinedFunctionCreateUpdateParameters
};
const triggerName = {
    parameterPath: "triggerName",
    mapper: {
        serializedName: "triggerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlTriggerParameters = {
    parameterPath: "createUpdateSqlTriggerParameters",
    mapper: SqlTriggerCreateUpdateParameters
};
const roleDefinitionId = {
    parameterPath: "roleDefinitionId",
    mapper: {
        serializedName: "roleDefinitionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlRoleDefinitionParameters = {
    parameterPath: "createUpdateSqlRoleDefinitionParameters",
    mapper: SqlRoleDefinitionCreateUpdateParameters
};
const roleAssignmentId = {
    parameterPath: "roleAssignmentId",
    mapper: {
        serializedName: "roleAssignmentId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateSqlRoleAssignmentParameters = {
    parameterPath: "createUpdateSqlRoleAssignmentParameters",
    mapper: SqlRoleAssignmentCreateUpdateParameters
};
const location = {
    parameterPath: "location",
    mapper: ContinuousBackupRestoreLocation
};
const createUpdateMongoDBDatabaseParameters = {
    parameterPath: "createUpdateMongoDBDatabaseParameters",
    mapper: MongoDBDatabaseCreateUpdateParameters
};
const collectionName = {
    parameterPath: "collectionName",
    mapper: {
        serializedName: "collectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateMongoDBCollectionParameters = {
    parameterPath: "createUpdateMongoDBCollectionParameters",
    mapper: MongoDBCollectionCreateUpdateParameters
};
const mongoRoleDefinitionId = {
    parameterPath: "mongoRoleDefinitionId",
    mapper: {
        serializedName: "mongoRoleDefinitionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateMongoRoleDefinitionParameters = {
    parameterPath: "createUpdateMongoRoleDefinitionParameters",
    mapper: MongoRoleDefinitionCreateUpdateParameters
};
const mongoUserDefinitionId = {
    parameterPath: "mongoUserDefinitionId",
    mapper: {
        serializedName: "mongoUserDefinitionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateMongoUserDefinitionParameters = {
    parameterPath: "createUpdateMongoUserDefinitionParameters",
    mapper: MongoUserDefinitionCreateUpdateParameters
};
const tableName = {
    parameterPath: "tableName",
    mapper: {
        serializedName: "tableName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateTableParameters = {
    parameterPath: "createUpdateTableParameters",
    mapper: TableCreateUpdateParameters
};
const keyspaceName = {
    parameterPath: "keyspaceName",
    mapper: {
        serializedName: "keyspaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateCassandraKeyspaceParameters = {
    parameterPath: "createUpdateCassandraKeyspaceParameters",
    mapper: CassandraKeyspaceCreateUpdateParameters
};
const createUpdateCassandraTableParameters = {
    parameterPath: "createUpdateCassandraTableParameters",
    mapper: CassandraTableCreateUpdateParameters
};
const createUpdateGremlinDatabaseParameters = {
    parameterPath: "createUpdateGremlinDatabaseParameters",
    mapper: GremlinDatabaseCreateUpdateParameters
};
const graphName = {
    parameterPath: "graphName",
    mapper: {
        serializedName: "graphName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const createUpdateGremlinGraphParameters = {
    parameterPath: "createUpdateGremlinGraphParameters",
    mapper: GremlinGraphCreateUpdateParameters
};
const location1 = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const clusterName = {
    parameterPath: "clusterName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "clusterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: ClusterResource
};
const body1 = {
    parameterPath: "body",
    mapper: CommandPostBody
};
const dataCenterName = {
    parameterPath: "dataCenterName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "dataCenterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body2 = {
    parameterPath: "body",
    mapper: DataCenterResource
};
const notebookWorkspaceName = {
    parameterPath: "notebookWorkspaceName",
    mapper: {
        serializedName: "notebookWorkspaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const notebookCreateUpdateParameters = {
    parameterPath: "notebookCreateUpdateParameters",
    mapper: NotebookWorkspaceCreateUpdateParameters
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const instanceId = {
    parameterPath: "instanceId",
    mapper: {
        serializedName: "instanceId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const restorableSqlDatabaseRid = {
    parameterPath: ["options", "restorableSqlDatabaseRid"],
    mapper: {
        serializedName: "restorableSqlDatabaseRid",
        type: {
            name: "String"
        }
    }
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        type: {
            name: "String"
        }
    }
};
const endTime = {
    parameterPath: ["options", "endTime"],
    mapper: {
        serializedName: "endTime",
        type: {
            name: "String"
        }
    }
};
const restoreLocation = {
    parameterPath: ["options", "restoreLocation"],
    mapper: {
        serializedName: "restoreLocation",
        type: {
            name: "String"
        }
    }
};
const restoreTimestampInUtc = {
    parameterPath: ["options", "restoreTimestampInUtc"],
    mapper: {
        serializedName: "restoreTimestampInUtc",
        type: {
            name: "String"
        }
    }
};
const restorableMongodbDatabaseRid = {
    parameterPath: ["options", "restorableMongodbDatabaseRid"],
    mapper: {
        serializedName: "restorableMongodbDatabaseRid",
        type: {
            name: "String"
        }
    }
};
const restorableGremlinDatabaseRid = {
    parameterPath: ["options", "restorableGremlinDatabaseRid"],
    mapper: {
        serializedName: "restorableGremlinDatabaseRid",
        type: {
            name: "String"
        }
    }
};
const createUpdateParameters1 = {
    parameterPath: "createUpdateParameters",
    mapper: ServiceResourceCreateUpdateParameters
};
const serviceName = {
    parameterPath: "serviceName",
    mapper: {
        constraints: {
            MaxLength: 50,
            MinLength: 3
        },
        serializedName: "serviceName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseAccounts operations. */
class DatabaseAccountsImpl {
    /**
     * Initialize a new instance of the class DatabaseAccounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the Azure Cosmos DB database accounts available under the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the Azure Cosmos DB database accounts available under the given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Retrieves the usages (most recent data) for the given database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, accountName, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listUsages(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listUsagesPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Retrieves metric definitions for the given database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMetricDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listMetricDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMetricDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetricDefinitions(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getOperationSpec$7);
    }
    /**
     * Updates the properties of an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param updateParameters The parameters to provide for the current database account.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, updateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, updateParameters, options },
                spec: updateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the properties of an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param updateParameters The parameters to provide for the current database account.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, updateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, updateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB database account. The "Update" method is preferred when
     * performing updates on an account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateParameters The parameters to provide for the current database account.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, createUpdateParameters, options },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB database account. The "Update" method is preferred when
     * performing updates on an account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateParameters The parameters to provide for the current database account.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, createUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, options },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Changes the failover priority for the Azure Cosmos DB database account. A failover priority of 0
     * indicates a write region. The maximum value for a failover priority = (total number of regions - 1).
     * Failover priority values must be unique for each of the regions in which the database account
     * exists.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param failoverParameters The new failover policies for the database account.
     * @param options The options parameters.
     */
    beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, failoverParameters, options },
                spec: failoverPriorityChangeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Changes the failover priority for the Azure Cosmos DB database account. A failover priority of 0
     * indicates a write region. The maximum value for a failover priority = (total number of regions - 1).
     * Failover priority values must be unique for each of the regions in which the database account
     * exists.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param failoverParameters The new failover policies for the database account.
     * @param options The options parameters.
     */
    beginFailoverPriorityChangeAndWait(resourceGroupName, accountName, failoverParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the Azure Cosmos DB database accounts available under the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$g);
    }
    /**
     * Lists all the Azure Cosmos DB database accounts available under the given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Lists the access keys for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listKeysOperationSpec);
    }
    /**
     * Lists the connection strings for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listConnectionStrings(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listConnectionStringsOperationSpec);
    }
    /**
     * Offline the specified region for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param regionParameterForOffline Cosmos DB region to offline for the database account.
     * @param options The options parameters.
     */
    beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    regionParameterForOffline,
                    options
                },
                spec: offlineRegionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Offline the specified region for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param regionParameterForOffline Cosmos DB region to offline for the database account.
     * @param options The options parameters.
     */
    beginOfflineRegionAndWait(resourceGroupName, accountName, regionParameterForOffline, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Online the specified region for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param regionParameterForOnline Cosmos DB region to online for the database account.
     * @param options The options parameters.
     */
    beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    regionParameterForOnline,
                    options
                },
                spec: onlineRegionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Online the specified region for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param regionParameterForOnline Cosmos DB region to online for the database account.
     * @param options The options parameters.
     */
    beginOnlineRegionAndWait(resourceGroupName, accountName, regionParameterForOnline, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the read-only access keys for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getReadOnlyKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getReadOnlyKeysOperationSpec);
    }
    /**
     * Lists the read-only access keys for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listReadOnlyKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listReadOnlyKeysOperationSpec);
    }
    /**
     * Regenerates an access key for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyToRegenerate The name of the key to regenerate.
     * @param options The options parameters.
     */
    beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, keyToRegenerate, options },
                spec: regenerateKeyOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Regenerates an access key for the specified Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyToRegenerate The name of the key to regenerate.
     * @param options The options parameters.
     */
    beginRegenerateKeyAndWait(resourceGroupName, accountName, keyToRegenerate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks that the Azure Cosmos DB account name already exists. A valid account name may contain only
     * lowercase letters, numbers, and the '-' character, and must be between 3 and 50 characters.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    checkNameExists(accountName, options) {
        return this.client.sendOperationRequest({ accountName, options }, checkNameExistsOperationSpec);
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, filter, options }, listMetricsOperationSpec$b);
    }
    /**
     * Retrieves the usages (most recent data) for the given database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listUsagesOperationSpec$3);
    }
    /**
     * Retrieves metric definitions for the given database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMetricDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMetricDefinitionsOperationSpec$2);
    }
}
// Operation Specifications
const serializer$A = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseAccountGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DatabaseAccountGetResults
        },
        201: {
            bodyMapper: DatabaseAccountGetResults
        },
        202: {
            bodyMapper: DatabaseAccountGetResults
        },
        204: {
            bodyMapper: DatabaseAccountGetResults
        }
    },
    requestBody: updateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DatabaseAccountGetResults
        },
        201: {
            bodyMapper: DatabaseAccountGetResults
        },
        202: {
            bodyMapper: DatabaseAccountGetResults
        },
        204: {
            bodyMapper: DatabaseAccountGetResults
        }
    },
    requestBody: createUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: DatabaseAccountsDeleteHeaders
        },
        201: {
            headersMapper: DatabaseAccountsDeleteHeaders
        },
        202: {
            headersMapper: DatabaseAccountsDeleteHeaders
        },
        204: {
            headersMapper: DatabaseAccountsDeleteHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    serializer: serializer$A
};
const failoverPriorityChangeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/failoverPriorityChange",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: DatabaseAccountsFailoverPriorityChangeHeaders
        },
        201: {
            headersMapper: DatabaseAccountsFailoverPriorityChangeHeaders
        },
        202: {
            headersMapper: DatabaseAccountsFailoverPriorityChangeHeaders
        },
        204: {
            headersMapper: DatabaseAccountsFailoverPriorityChangeHeaders
        }
    },
    requestBody: failoverParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$A
};
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/databaseAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseAccountsListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$A
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseAccountsListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseAccountListKeysResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listConnectionStringsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/listConnectionStrings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseAccountListConnectionStringsResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const offlineRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/offlineRegion",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: regionParameterForOffline,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const onlineRegionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/onlineRegion",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: regionParameterForOnline,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const getReadOnlyKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/readonlykeys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatabaseAccountListReadOnlyKeysResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listReadOnlyKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/readonlykeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatabaseAccountListReadOnlyKeysResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const regenerateKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/regenerateKey",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    requestBody: keyToRegenerate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$A
};
const checkNameExistsOperationSpec = {
    path: "/providers/Microsoft.DocumentDB/databaseAccountNames/{accountName}",
    httpMethod: "HEAD",
    responses: { 200: {}, 404: {} },
    queryParameters: [apiVersion],
    urlParameters: [$host, accountName],
    serializer: serializer$A
};
const listMetricsOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listUsagesOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesResult
        }
    },
    queryParameters: [apiVersion, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listMetricDefinitionsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/metricDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricDefinitionsListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Cosmos DB Resource Provider operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Cosmos DB Resource Provider operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$f);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/providers/Microsoft.DocumentDB/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$z
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Database operations. */
class DatabaseImpl {
    /**
     * Initialize a new instance of the class Database class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account and database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, databaseRid, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, databaseRid, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, databaseRid, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, databaseRid, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, databaseRid, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the usages (most recent data) for the given database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, accountName, databaseRid, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, accountName, databaseRid, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, accountName, databaseRid, options, settings);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, accountName, databaseRid, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listUsages(resourceGroupName, accountName, databaseRid, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listUsagesPagingAll(resourceGroupName, accountName, databaseRid, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, accountName, databaseRid, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves metric definitions for the given database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param options The options parameters.
     */
    listMetricDefinitions(resourceGroupName, accountName, databaseRid, options) {
        const iter = this.listMetricDefinitionsPagingAll(resourceGroupName, accountName, databaseRid, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricDefinitionsPagingPage(resourceGroupName, accountName, databaseRid, options, settings);
            }
        };
    }
    listMetricDefinitionsPagingPage(resourceGroupName, accountName, databaseRid, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetricDefinitions(resourceGroupName, accountName, databaseRid, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricDefinitionsPagingAll(resourceGroupName, accountName, databaseRid, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricDefinitionsPagingPage(resourceGroupName, accountName, databaseRid, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account and database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, databaseRid, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseRid, filter, options }, listMetricsOperationSpec$a);
    }
    /**
     * Retrieves the usages (most recent data) for the given database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, accountName, databaseRid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseRid, options }, listUsagesOperationSpec$2);
    }
    /**
     * Retrieves metric definitions for the given database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param options The options parameters.
     */
    _listMetricDefinitions(resourceGroupName, accountName, databaseRid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseRid, options }, listMetricDefinitionsOperationSpec$1);
    }
}
// Operation Specifications
const serializer$y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listUsagesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesResult
        }
    },
    queryParameters: [apiVersion, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid
    ],
    headerParameters: [accept],
    serializer: serializer$y
};
const listMetricDefinitionsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/metricDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricDefinitionsListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Collection operations. */
class CollectionImpl {
    /**
     * Initialize a new instance of the class Collection class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account and collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the usages (most recent storage data) for the given collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options, settings);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listUsages(resourceGroupName, accountName, databaseRid, collectionRid, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listUsagesPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves metric definitions for the given collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param options The options parameters.
     */
    listMetricDefinitions(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        const iter = this.listMetricDefinitionsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricDefinitionsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options, settings);
            }
        };
    }
    listMetricDefinitionsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetricDefinitions(resourceGroupName, accountName, databaseRid, collectionRid, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricDefinitionsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricDefinitionsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricDefinitionsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account and collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseRid,
            collectionRid,
            filter,
            options
        }, listMetricsOperationSpec$9);
    }
    /**
     * Retrieves the usages (most recent storage data) for the given collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseRid, collectionRid, options }, listUsagesOperationSpec$1);
    }
    /**
     * Retrieves metric definitions for the given collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param options The options parameters.
     */
    _listMetricDefinitions(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseRid, collectionRid, options }, listMetricDefinitionsOperationSpec);
    }
}
// Operation Specifications
const serializer$x = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/collections/{collectionRid}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listUsagesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/collections/{collectionRid}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesResult
        }
    },
    queryParameters: [apiVersion, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listMetricDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/collections/{collectionRid}/metricDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricDefinitionsListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid
    ],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CollectionRegion operations. */
class CollectionRegionImpl {
    /**
     * Initialize a new instance of the class CollectionRegion class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account, collection and
     * region.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account, collection and
     * region.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            region,
            databaseRid,
            collectionRid,
            filter,
            options
        }, listMetricsOperationSpec$8);
    }
}
// Operation Specifications
const serializer$w = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/region/{region}/databases/{databaseRid}/collections/{collectionRid}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid,
        region
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DatabaseAccountRegion operations. */
class DatabaseAccountRegionImpl {
    /**
     * Initialize a new instance of the class DatabaseAccountRegion class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account and region.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, region, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, region, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, region, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, region, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, region, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, region, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, region, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account and region.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, region, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, region, filter, options }, listMetricsOperationSpec$7);
    }
}
// Operation Specifications
const serializer$v = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/region/{region}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        region
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PercentileSourceTarget operations. */
class PercentileSourceTargetImpl {
    /**
     * Initialize a new instance of the class PercentileSourceTarget class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given account, source and target
     * region. This url is only for PBS and Replication Latency data
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param sourceRegion Source region from which data is written. Cosmos DB region, with spaces between
     *                     words and each word capitalized.
     * @param targetRegion Target region to which data is written. Cosmos DB region, with spaces between
     *                     words and each word capitalized.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given account, source and target
     * region. This url is only for PBS and Replication Latency data
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param sourceRegion Source region from which data is written. Cosmos DB region, with spaces between
     *                     words and each word capitalized.
     * @param targetRegion Target region to which data is written. Cosmos DB region, with spaces between
     *                     words and each word capitalized.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, sourceRegion, targetRegion, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            sourceRegion,
            targetRegion,
            filter,
            options
        }, listMetricsOperationSpec$6);
    }
}
// Operation Specifications
const serializer$u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sourceRegion/{sourceRegion}/targetRegion/{targetRegion}/percentile/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PercentileMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        sourceRegion,
        targetRegion
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PercentileTarget operations. */
class PercentileTargetImpl {
    /**
     * Initialize a new instance of the class PercentileTarget class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given account target region. This url
     * is only for PBS and Replication Latency data
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param targetRegion Target region to which data is written. Cosmos DB region, with spaces between
     *                     words and each word capitalized.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, targetRegion, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, targetRegion, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, targetRegion, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, targetRegion, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, targetRegion, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, targetRegion, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, targetRegion, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given account target region. This url
     * is only for PBS and Replication Latency data
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param targetRegion Target region to which data is written. Cosmos DB region, with spaces between
     *                     words and each word capitalized.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, targetRegion, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, targetRegion, filter, options }, listMetricsOperationSpec$5);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/targetRegion/{targetRegion}/percentile/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PercentileMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        targetRegion
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Percentile operations. */
class PercentileImpl {
    /**
     * Initialize a new instance of the class Percentile class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account. This url is
     * only for PBS and Replication Latency data
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given database account. This url is
     * only for PBS and Replication Latency data
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, filter, options }, listMetricsOperationSpec$4);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/percentile/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PercentileMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CollectionPartitionRegion operations. */
class CollectionPartitionRegionImpl {
    /**
     * Initialize a new instance of the class CollectionPartitionRegion class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given collection and region, split by
     * partition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given collection and region, split by
     * partition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            region,
            databaseRid,
            collectionRid,
            filter,
            options
        }, listMetricsOperationSpec$3);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/region/{region}/databases/{databaseRid}/collections/{collectionRid}/partitions/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartitionMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid,
        region
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CollectionPartition operations. */
class CollectionPartitionImpl {
    /**
     * Initialize a new instance of the class CollectionPartition class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given collection, split by partition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the usages (most recent storage data) for the given collection, split by partition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param options The options parameters.
     */
    listUsages(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        const iter = this.listUsagesPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagesPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options, settings);
            }
        };
    }
    listUsagesPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listUsages(resourceGroupName, accountName, databaseRid, collectionRid, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listUsagesPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listUsagesPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given collection, split by partition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseRid,
            collectionRid,
            filter,
            options
        }, listMetricsOperationSpec$2);
    }
    /**
     * Retrieves the usages (most recent storage data) for the given collection, split by partition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param options The options parameters.
     */
    _listUsages(resourceGroupName, accountName, databaseRid, collectionRid, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseRid, collectionRid, options }, listUsagesOperationSpec);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/collections/{collectionRid}/partitions/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartitionMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/collections/{collectionRid}/partitions/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartitionUsagesResult
        }
    },
    queryParameters: [apiVersion, filter1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartitionKeyRangeId operations. */
class PartitionKeyRangeIdImpl {
    /**
     * Initialize a new instance of the class PartitionKeyRangeId class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given partition key range id.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param partitionKeyRangeId Partition Key Range Id for which to get data.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given partition key range id.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param partitionKeyRangeId Partition Key Range Id for which to get data.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, databaseRid, collectionRid, partitionKeyRangeId, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseRid,
            collectionRid,
            partitionKeyRangeId,
            filter,
            options
        }, listMetricsOperationSpec$1);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/databases/{databaseRid}/collections/{collectionRid}/partitionKeyRangeId/{partitionKeyRangeId}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartitionMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid,
        partitionKeyRangeId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartitionKeyRangeIdRegion operations. */
class PartitionKeyRangeIdRegionImpl {
    /**
     * Initialize a new instance of the class PartitionKeyRangeIdRegion class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the metrics determined by the given filter for the given partition key range id and
     * region.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param partitionKeyRangeId Partition Key Range Id for which to get data.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options) {
        const iter = this.listMetricsPagingAll(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options, settings);
            }
        };
    }
    listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMetricsPagingAll(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMetricsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMetricsPagingPage(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the metrics determined by the given filter for the given partition key range id and
     * region.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param region Cosmos DB region, with spaces between words and each word capitalized.
     * @param databaseRid Cosmos DB database rid.
     * @param collectionRid Cosmos DB collection rid.
     * @param partitionKeyRangeId Partition Key Range Id for which to get data.
     * @param filter An OData filter expression that describes a subset of metrics to return. The
     *               parameters that can be filtered are name.value (name of the metric, can have an or of multiple
     *               names), startTime, endTime, and timeGrain. The supported operator is eq.
     * @param options The options parameters.
     */
    _listMetrics(resourceGroupName, accountName, region, databaseRid, collectionRid, partitionKeyRangeId, filter, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            region,
            databaseRid,
            collectionRid,
            partitionKeyRangeId,
            filter,
            options
        }, listMetricsOperationSpec);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMetricsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/region/{region}/databases/{databaseRid}/collections/{collectionRid}/partitionKeyRangeId/{partitionKeyRangeId}/metrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartitionMetricListResult
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseRid,
        collectionRid,
        region,
        partitionKeyRangeId
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SqlResources operations. */
class SqlResourcesImpl {
    /**
     * Initialize a new instance of the class SqlResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the SQL databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listSqlDatabases(resourceGroupName, accountName, options) {
        const iter = this.listSqlDatabasesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlDatabasesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listSqlDatabasesPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlDatabasesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlDatabases(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlDatabasesPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlDatabasesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlDatabasesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listSqlContainers(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listSqlContainersPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlContainersPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listSqlContainersPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlContainersPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlContainers(resourceGroupName, accountName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlContainersPagingAll(resourceGroupName, accountName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlContainersPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlContainersPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listClientEncryptionKeys(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listClientEncryptionKeysPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listClientEncryptionKeysPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listClientEncryptionKeysPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listClientEncryptionKeysPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listClientEncryptionKeys(resourceGroupName, accountName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listClientEncryptionKeysPagingAll(resourceGroupName, accountName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listClientEncryptionKeysPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listClientEncryptionKeysPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    listSqlStoredProcedures(resourceGroupName, accountName, databaseName, containerName, options) {
        const iter = this.listSqlStoredProceduresPagingAll(resourceGroupName, accountName, databaseName, containerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlStoredProceduresPagingPage(resourceGroupName, accountName, databaseName, containerName, options, settings);
            }
        };
    }
    listSqlStoredProceduresPagingPage(resourceGroupName, accountName, databaseName, containerName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlStoredProceduresPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlStoredProcedures(resourceGroupName, accountName, databaseName, containerName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlStoredProceduresPagingAll(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlStoredProceduresPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlStoredProceduresPagingPage(resourceGroupName, accountName, databaseName, containerName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    listSqlUserDefinedFunctions(resourceGroupName, accountName, databaseName, containerName, options) {
        const iter = this.listSqlUserDefinedFunctionsPagingAll(resourceGroupName, accountName, databaseName, containerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlUserDefinedFunctionsPagingPage(resourceGroupName, accountName, databaseName, containerName, options, settings);
            }
        };
    }
    listSqlUserDefinedFunctionsPagingPage(resourceGroupName, accountName, databaseName, containerName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlUserDefinedFunctionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlUserDefinedFunctions(resourceGroupName, accountName, databaseName, containerName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlUserDefinedFunctionsPagingAll(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlUserDefinedFunctionsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlUserDefinedFunctionsPagingPage(resourceGroupName, accountName, databaseName, containerName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Lists the SQL trigger under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    listSqlTriggers(resourceGroupName, accountName, databaseName, containerName, options) {
        const iter = this.listSqlTriggersPagingAll(resourceGroupName, accountName, databaseName, containerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlTriggersPagingPage(resourceGroupName, accountName, databaseName, containerName, options, settings);
            }
        };
    }
    listSqlTriggersPagingPage(resourceGroupName, accountName, databaseName, containerName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlTriggersPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlTriggers(resourceGroupName, accountName, databaseName, containerName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlTriggersPagingAll(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlTriggersPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlTriggersPagingPage(resourceGroupName, accountName, databaseName, containerName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listSqlRoleDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listSqlRoleDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlRoleDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listSqlRoleDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlRoleDefinitionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlRoleDefinitions(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlRoleDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlRoleDefinitionsPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlRoleDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listSqlRoleAssignments(resourceGroupName, accountName, options) {
        const iter = this.listSqlRoleAssignmentsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSqlRoleAssignmentsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listSqlRoleAssignmentsPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlRoleAssignmentsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSqlRoleAssignments(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSqlRoleAssignmentsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSqlRoleAssignmentsPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSqlRoleAssignmentsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Lists the SQL databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listSqlDatabases(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listSqlDatabasesOperationSpec);
    }
    /**
     * Gets the SQL database under an existing Azure Cosmos DB database account with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getSqlDatabase(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getSqlDatabaseOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    createUpdateSqlDatabaseParameters,
                    options
                },
                spec: createUpdateSqlDatabaseOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlDatabaseAndWait(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: deleteSqlDatabaseOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteSqlDatabaseAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the SQL database under an existing Azure Cosmos DB database account with
     * the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getSqlDatabaseThroughput(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getSqlDatabaseThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL database.
     * @param options The options parameters.
     */
    beginUpdateSqlDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    updateThroughputParameters,
                    options
                },
                spec: updateSqlDatabaseThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL database.
     * @param options The options parameters.
     */
    beginUpdateSqlDatabaseThroughputAndWait(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateSqlDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateSqlDatabaseToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToAutoscaleAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateSqlDatabaseToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateSqlDatabaseToManualThroughputAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listSqlContainers(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listSqlContainersOperationSpec);
    }
    /**
     * Gets the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, getSqlContainerOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    createUpdateSqlContainerParameters,
                    options
                },
                spec: createUpdateSqlContainerOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlContainerAndWait(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    options
                },
                spec: deleteSqlContainerOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginDeleteSqlContainerAndWait(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the SQL container under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    getSqlContainerThroughput(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, getSqlContainerThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL container.
     * @param options The options parameters.
     */
    beginUpdateSqlContainerThroughput(resourceGroupName, accountName, databaseName, containerName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    updateThroughputParameters,
                    options
                },
                spec: updateSqlContainerThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB SQL container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   SQL container.
     * @param options The options parameters.
     */
    beginUpdateSqlContainerThroughputAndWait(resourceGroupName, accountName, databaseName, containerName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateSqlContainerThroughput(resourceGroupName, accountName, databaseName, containerName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToAutoscale(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    options
                },
                spec: migrateSqlContainerToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToAutoscaleAndWait(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlContainerToAutoscale(resourceGroupName, accountName, databaseName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToManualThroughput(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    options
                },
                spec: migrateSqlContainerToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    beginMigrateSqlContainerToManualThroughputAndWait(resourceGroupName, accountName, databaseName, containerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateSqlContainerToManualThroughput(resourceGroupName, accountName, databaseName, containerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listClientEncryptionKeys(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listClientEncryptionKeysOperationSpec);
    }
    /**
     * Gets the ClientEncryptionKey under an existing Azure Cosmos DB SQL database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
     * @param options The options parameters.
     */
    getClientEncryptionKey(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            clientEncryptionKeyName,
            options
        }, getClientEncryptionKeyOperationSpec);
    }
    /**
     * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
     * Powershell (instead of directly).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
     * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
     *                                                  key.
     * @param options The options parameters.
     */
    beginCreateUpdateClientEncryptionKey(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, createUpdateClientEncryptionKeyParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    clientEncryptionKeyName,
                    createUpdateClientEncryptionKeyParameters,
                    options
                },
                spec: createUpdateClientEncryptionKeyOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
     * Powershell (instead of directly).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
     * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
     *                                                  key.
     * @param options The options parameters.
     */
    beginCreateUpdateClientEncryptionKeyAndWait(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, createUpdateClientEncryptionKeyParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateClientEncryptionKey(resourceGroupName, accountName, databaseName, clientEncryptionKeyName, createUpdateClientEncryptionKeyParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    _listSqlStoredProcedures(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, listSqlStoredProceduresOperationSpec);
    }
    /**
     * Gets the SQL storedProcedure under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param options The options parameters.
     */
    getSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            containerName,
            storedProcedureName,
            options
        }, getSqlStoredProcedureOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL storedProcedure
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
     *                                                 storedProcedure.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, createUpdateSqlStoredProcedureParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    storedProcedureName,
                    createUpdateSqlStoredProcedureParameters,
                    options
                },
                spec: createUpdateSqlStoredProcedureOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL storedProcedure
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
     *                                                 storedProcedure.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlStoredProcedureAndWait(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, createUpdateSqlStoredProcedureParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, createUpdateSqlStoredProcedureParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL storedProcedure.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param options The options parameters.
     */
    beginDeleteSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    storedProcedureName,
                    options
                },
                spec: deleteSqlStoredProcedureOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL storedProcedure.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param storedProcedureName Cosmos DB storedProcedure name.
     * @param options The options parameters.
     */
    beginDeleteSqlStoredProcedureAndWait(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlStoredProcedure(resourceGroupName, accountName, databaseName, containerName, storedProcedureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    _listSqlUserDefinedFunctions(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, listSqlUserDefinedFunctionsOperationSpec);
    }
    /**
     * Gets the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param options The options parameters.
     */
    getSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            containerName,
            userDefinedFunctionName,
            options
        }, getSqlUserDefinedFunctionOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL userDefinedFunction
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
     *                                                     userDefinedFunction.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, createUpdateSqlUserDefinedFunctionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    userDefinedFunctionName,
                    createUpdateSqlUserDefinedFunctionParameters,
                    options
                },
                spec: createUpdateSqlUserDefinedFunctionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL userDefinedFunction
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
     *                                                     userDefinedFunction.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlUserDefinedFunctionAndWait(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, createUpdateSqlUserDefinedFunctionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, createUpdateSqlUserDefinedFunctionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param options The options parameters.
     */
    beginDeleteSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    userDefinedFunctionName,
                    options
                },
                spec: deleteSqlUserDefinedFunctionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
     * @param options The options parameters.
     */
    beginDeleteSqlUserDefinedFunctionAndWait(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlUserDefinedFunction(resourceGroupName, accountName, databaseName, containerName, userDefinedFunctionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the SQL trigger under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param options The options parameters.
     */
    _listSqlTriggers(resourceGroupName, accountName, databaseName, containerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, containerName, options }, listSqlTriggersOperationSpec);
    }
    /**
     * Gets the SQL trigger under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param options The options parameters.
     */
    getSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            databaseName,
            containerName,
            triggerName,
            options
        }, getSqlTriggerOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB SQL trigger
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, createUpdateSqlTriggerParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    triggerName,
                    createUpdateSqlTriggerParameters,
                    options
                },
                spec: createUpdateSqlTriggerOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB SQL trigger
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlTriggerAndWait(resourceGroupName, accountName, databaseName, containerName, triggerName, createUpdateSqlTriggerParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, createUpdateSqlTriggerParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL trigger.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param options The options parameters.
     */
    beginDeleteSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    triggerName,
                    options
                },
                spec: deleteSqlTriggerOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL trigger.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param triggerName Cosmos DB trigger name.
     * @param options The options parameters.
     */
    beginDeleteSqlTriggerAndWait(resourceGroupName, accountName, databaseName, containerName, triggerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlTrigger(resourceGroupName, accountName, databaseName, containerName, triggerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB SQL Role Definition with the given Id.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ roleDefinitionId, resourceGroupName, accountName, options }, getSqlRoleDefinitionOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
     *                                                Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, createUpdateSqlRoleDefinitionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    roleDefinitionId,
                    resourceGroupName,
                    accountName,
                    createUpdateSqlRoleDefinitionParameters,
                    options
                },
                spec: createUpdateSqlRoleDefinitionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
     *                                                Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleDefinitionAndWait(roleDefinitionId, resourceGroupName, accountName, createUpdateSqlRoleDefinitionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, createUpdateSqlRoleDefinitionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { roleDefinitionId, resourceGroupName, accountName, options },
                spec: deleteSqlRoleDefinitionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Definition.
     * @param roleDefinitionId The GUID for the Role Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleDefinitionAndWait(roleDefinitionId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlRoleDefinition(roleDefinitionId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listSqlRoleDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listSqlRoleDefinitionsOperationSpec);
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB SQL Role Assignment with the given Id.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ roleAssignmentId, resourceGroupName, accountName, options }, getSqlRoleAssignmentOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
     *                                                Assignment.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, createUpdateSqlRoleAssignmentParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    roleAssignmentId,
                    resourceGroupName,
                    accountName,
                    createUpdateSqlRoleAssignmentParameters,
                    options
                },
                spec: createUpdateSqlRoleAssignmentOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
     *                                                Assignment.
     * @param options The options parameters.
     */
    beginCreateUpdateSqlRoleAssignmentAndWait(roleAssignmentId, resourceGroupName, accountName, createUpdateSqlRoleAssignmentParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, createUpdateSqlRoleAssignmentParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { roleAssignmentId, resourceGroupName, accountName, options },
                spec: deleteSqlRoleAssignmentOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB SQL Role Assignment.
     * @param roleAssignmentId The GUID for the Role Assignment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteSqlRoleAssignmentAndWait(roleAssignmentId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSqlRoleAssignment(roleAssignmentId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listSqlRoleAssignments(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listSqlRoleAssignmentsOperationSpec);
    }
    /**
     * Retrieves continuous backup information for a container resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, containerName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    containerName,
                    location,
                    options
                },
                spec: retrieveContinuousBackupInformationOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves continuous backup information for a container resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param containerName Cosmos DB container name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformationAndWait(resourceGroupName, accountName, databaseName, containerName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, containerName, location, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listSqlDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlDatabaseListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getSqlDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlDatabaseGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlDatabaseGetResults
        },
        201: {
            bodyMapper: SqlDatabaseGetResults
        },
        202: {
            bodyMapper: SqlDatabaseGetResults
        },
        204: {
            bodyMapper: SqlDatabaseGetResults
        }
    },
    requestBody: createUpdateSqlDatabaseParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: SqlResourcesDeleteSqlDatabaseHeaders
        },
        201: {
            headersMapper: SqlResourcesDeleteSqlDatabaseHeaders
        },
        202: {
            headersMapper: SqlResourcesDeleteSqlDatabaseHeaders
        },
        204: {
            headersMapper: SqlResourcesDeleteSqlDatabaseHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    serializer: serializer$n
};
const getSqlDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateSqlDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const migrateSqlDatabaseToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const migrateSqlDatabaseToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listSqlContainersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlContainerListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getSqlContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlContainerGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlContainerGetResults
        },
        201: {
            bodyMapper: SqlContainerGetResults
        },
        202: {
            bodyMapper: SqlContainerGetResults
        },
        204: {
            bodyMapper: SqlContainerGetResults
        }
    },
    requestBody: createUpdateSqlContainerParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlContainerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: SqlResourcesDeleteSqlContainerHeaders
        },
        201: {
            headersMapper: SqlResourcesDeleteSqlContainerHeaders
        },
        202: {
            headersMapper: SqlResourcesDeleteSqlContainerHeaders
        },
        204: {
            headersMapper: SqlResourcesDeleteSqlContainerHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    serializer: serializer$n
};
const getSqlContainerThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateSqlContainerThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const migrateSqlContainerToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const migrateSqlContainerToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listClientEncryptionKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClientEncryptionKeysListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getClientEncryptionKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClientEncryptionKeyGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        clientEncryptionKeyName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateClientEncryptionKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ClientEncryptionKeyGetResults
        },
        201: {
            bodyMapper: ClientEncryptionKeyGetResults
        },
        202: {
            bodyMapper: ClientEncryptionKeyGetResults
        },
        204: {
            bodyMapper: ClientEncryptionKeyGetResults
        }
    },
    requestBody: createUpdateClientEncryptionKeyParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        clientEncryptionKeyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const listSqlStoredProceduresOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlStoredProcedureListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getSqlStoredProcedureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlStoredProcedureGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlStoredProcedureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlStoredProcedureGetResults
        },
        201: {
            bodyMapper: SqlStoredProcedureGetResults
        },
        202: {
            bodyMapper: SqlStoredProcedureGetResults
        },
        204: {
            bodyMapper: SqlStoredProcedureGetResults
        }
    },
    requestBody: createUpdateSqlStoredProcedureParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlStoredProcedureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: SqlResourcesDeleteSqlStoredProcedureHeaders
        },
        201: {
            headersMapper: SqlResourcesDeleteSqlStoredProcedureHeaders
        },
        202: {
            headersMapper: SqlResourcesDeleteSqlStoredProcedureHeaders
        },
        204: {
            headersMapper: SqlResourcesDeleteSqlStoredProcedureHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName
    ],
    serializer: serializer$n
};
const listSqlUserDefinedFunctionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlUserDefinedFunctionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getSqlUserDefinedFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlUserDefinedFunctionGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlUserDefinedFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlUserDefinedFunctionGetResults
        },
        201: {
            bodyMapper: SqlUserDefinedFunctionGetResults
        },
        202: {
            bodyMapper: SqlUserDefinedFunctionGetResults
        },
        204: {
            bodyMapper: SqlUserDefinedFunctionGetResults
        }
    },
    requestBody: createUpdateSqlUserDefinedFunctionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlUserDefinedFunctionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        },
        201: {
            headersMapper: SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        },
        202: {
            headersMapper: SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        },
        204: {
            headersMapper: SqlResourcesDeleteSqlUserDefinedFunctionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName
    ],
    serializer: serializer$n
};
const listSqlTriggersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlTriggerListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getSqlTriggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlTriggerGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlTriggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlTriggerGetResults
        },
        201: {
            bodyMapper: SqlTriggerGetResults
        },
        202: {
            bodyMapper: SqlTriggerGetResults
        },
        204: {
            bodyMapper: SqlTriggerGetResults
        }
    },
    requestBody: createUpdateSqlTriggerParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlTriggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: SqlResourcesDeleteSqlTriggerHeaders
        },
        201: {
            headersMapper: SqlResourcesDeleteSqlTriggerHeaders
        },
        202: {
            headersMapper: SqlResourcesDeleteSqlTriggerHeaders
        },
        204: {
            headersMapper: SqlResourcesDeleteSqlTriggerHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName
    ],
    serializer: serializer$n
};
const getSqlRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlRoleDefinitionGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        roleDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlRoleDefinitionGetResults
        },
        201: {
            bodyMapper: SqlRoleDefinitionGetResults
        },
        202: {
            bodyMapper: SqlRoleDefinitionGetResults
        },
        204: {
            bodyMapper: SqlRoleDefinitionGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: createUpdateSqlRoleDefinitionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        roleDefinitionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        roleDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listSqlRoleDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlRoleDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getSqlRoleAssignmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlRoleAssignmentGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        roleAssignmentId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createUpdateSqlRoleAssignmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SqlRoleAssignmentGetResults
        },
        201: {
            bodyMapper: SqlRoleAssignmentGetResults
        },
        202: {
            bodyMapper: SqlRoleAssignmentGetResults
        },
        204: {
            bodyMapper: SqlRoleAssignmentGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: createUpdateSqlRoleAssignmentParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        roleAssignmentId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteSqlRoleAssignmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        roleAssignmentId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listSqlRoleAssignmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SqlRoleAssignmentListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const retrieveContinuousBackupInformationOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupInformation
        },
        201: {
            bodyMapper: BackupInformation
        },
        202: {
            bodyMapper: BackupInformation
        },
        204: {
            bodyMapper: BackupInformation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: location,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MongoDBResources operations. */
class MongoDBResourcesImpl {
    /**
     * Initialize a new instance of the class MongoDBResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMongoDBDatabases(resourceGroupName, accountName, options) {
        const iter = this.listMongoDBDatabasesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoDBDatabasesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMongoDBDatabasesPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoDBDatabasesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMongoDBDatabases(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMongoDBDatabasesPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoDBDatabasesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMongoDBDatabasesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listMongoDBCollections(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listMongoDBCollectionsPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoDBCollectionsPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listMongoDBCollectionsPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoDBCollectionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMongoDBCollections(resourceGroupName, accountName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMongoDBCollectionsPagingAll(resourceGroupName, accountName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoDBCollectionsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMongoDBCollectionsPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMongoRoleDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listMongoRoleDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoRoleDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMongoRoleDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoRoleDefinitionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMongoRoleDefinitions(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMongoRoleDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoRoleDefinitionsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMongoRoleDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMongoUserDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listMongoUserDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoUserDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMongoUserDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoUserDefinitionsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listMongoUserDefinitions(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listMongoUserDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMongoUserDefinitionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMongoUserDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMongoDBDatabases(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMongoDBDatabasesOperationSpec);
    }
    /**
     * Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
     * name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getMongoDBDatabase(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getMongoDBDatabaseOperationSpec);
    }
    /**
     * Create or updates Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
     *                                              database.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    createUpdateMongoDBDatabaseParameters,
                    options
                },
                spec: createUpdateMongoDBDatabaseOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or updates Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
     *                                              database.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBDatabaseAndWait(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: deleteMongoDBDatabaseOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBDatabaseAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getMongoDBDatabaseThroughput(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getMongoDBDatabaseThroughputOperationSpec);
    }
    /**
     * Update RUs per second of the an Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB database.
     * @param options The options parameters.
     */
    beginUpdateMongoDBDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    updateThroughputParameters,
                    options
                },
                spec: updateMongoDBDatabaseThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of the an Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB database.
     * @param options The options parameters.
     */
    beginUpdateMongoDBDatabaseThroughputAndWait(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateMongoDBDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateMongoDBDatabaseToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToAutoscaleAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateMongoDBDatabaseToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToManualThroughputAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listMongoDBCollections(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listMongoDBCollectionsOperationSpec);
    }
    /**
     * Gets the MongoDB collection under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, collectionName, options }, getMongoDBCollectionOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB MongoDB Collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
     *                                                Collection.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    createUpdateMongoDBCollectionParameters,
                    options
                },
                spec: createUpdateMongoDBCollectionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB MongoDB Collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
     *                                                Collection.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBCollectionAndWait(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB Collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    options
                },
                spec: deleteMongoDBCollectionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB Collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBCollectionAndWait(resourceGroupName, accountName, databaseName, collectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    getMongoDBCollectionThroughput(resourceGroupName, accountName, databaseName, collectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, collectionName, options }, getMongoDBCollectionThroughputOperationSpec);
    }
    /**
     * Update the RUs per second of an Azure Cosmos DB MongoDB collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB collection.
     * @param options The options parameters.
     */
    beginUpdateMongoDBCollectionThroughput(resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    updateThroughputParameters,
                    options
                },
                spec: updateMongoDBCollectionThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update the RUs per second of an Azure Cosmos DB MongoDB collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB collection.
     * @param options The options parameters.
     */
    beginUpdateMongoDBCollectionThroughputAndWait(resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateMongoDBCollectionThroughput(resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToAutoscale(resourceGroupName, accountName, databaseName, collectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    options
                },
                spec: migrateMongoDBCollectionToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToAutoscaleAndWait(resourceGroupName, accountName, databaseName, collectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBCollectionToAutoscale(resourceGroupName, accountName, databaseName, collectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToManualThroughput(resourceGroupName, accountName, databaseName, collectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    options
                },
                spec: migrateMongoDBCollectionToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToManualThroughputAndWait(resourceGroupName, accountName, databaseName, collectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBCollectionToManualThroughput(resourceGroupName, accountName, databaseName, collectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB Mongo Role Definition with the given Id.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ mongoRoleDefinitionId, resourceGroupName, accountName, options }, getMongoRoleDefinitionOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, createUpdateMongoRoleDefinitionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    mongoRoleDefinitionId,
                    resourceGroupName,
                    accountName,
                    createUpdateMongoRoleDefinitionParameters,
                    options
                },
                spec: createUpdateMongoRoleDefinitionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoRoleDefinitionAndWait(mongoRoleDefinitionId, resourceGroupName, accountName, createUpdateMongoRoleDefinitionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, createUpdateMongoRoleDefinitionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { mongoRoleDefinitionId, resourceGroupName, accountName, options },
                spec: deleteMongoRoleDefinitionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoRoleDefinitionAndWait(mongoRoleDefinitionId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMongoRoleDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMongoRoleDefinitionsOperationSpec);
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB Mongo User Definition with the given Id.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ mongoUserDefinitionId, resourceGroupName, accountName, options }, getMongoUserDefinitionOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, createUpdateMongoUserDefinitionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    mongoUserDefinitionId,
                    resourceGroupName,
                    accountName,
                    createUpdateMongoUserDefinitionParameters,
                    options
                },
                spec: createUpdateMongoUserDefinitionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoUserDefinitionAndWait(mongoUserDefinitionId, resourceGroupName, accountName, createUpdateMongoUserDefinitionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, createUpdateMongoUserDefinitionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { mongoUserDefinitionId, resourceGroupName, accountName, options },
                spec: deleteMongoUserDefinitionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoUserDefinitionAndWait(mongoUserDefinitionId, resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMongoUserDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMongoUserDefinitionsOperationSpec);
    }
    /**
     * Retrieves continuous backup information for a Mongodb collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, collectionName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    location,
                    options
                },
                spec: retrieveContinuousBackupInformationOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves continuous backup information for a Mongodb collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformationAndWait(resourceGroupName, accountName, databaseName, collectionName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, collectionName, location, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listMongoDBDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoDBDatabaseListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getMongoDBDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoDBDatabaseGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createUpdateMongoDBDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MongoDBDatabaseGetResults
        },
        201: {
            bodyMapper: MongoDBDatabaseGetResults
        },
        202: {
            bodyMapper: MongoDBDatabaseGetResults
        },
        204: {
            bodyMapper: MongoDBDatabaseGetResults
        }
    },
    requestBody: createUpdateMongoDBDatabaseParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteMongoDBDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: MongoDBResourcesDeleteMongoDBDatabaseHeaders
        },
        201: {
            headersMapper: MongoDBResourcesDeleteMongoDBDatabaseHeaders
        },
        202: {
            headersMapper: MongoDBResourcesDeleteMongoDBDatabaseHeaders
        },
        204: {
            headersMapper: MongoDBResourcesDeleteMongoDBDatabaseHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    serializer: serializer$m
};
const getMongoDBDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const updateMongoDBDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const migrateMongoDBDatabaseToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const migrateMongoDBDatabaseToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listMongoDBCollectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoDBCollectionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getMongoDBCollectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoDBCollectionGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createUpdateMongoDBCollectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MongoDBCollectionGetResults
        },
        201: {
            bodyMapper: MongoDBCollectionGetResults
        },
        202: {
            bodyMapper: MongoDBCollectionGetResults
        },
        204: {
            bodyMapper: MongoDBCollectionGetResults
        }
    },
    requestBody: createUpdateMongoDBCollectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteMongoDBCollectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: MongoDBResourcesDeleteMongoDBCollectionHeaders
        },
        201: {
            headersMapper: MongoDBResourcesDeleteMongoDBCollectionHeaders
        },
        202: {
            headersMapper: MongoDBResourcesDeleteMongoDBCollectionHeaders
        },
        204: {
            headersMapper: MongoDBResourcesDeleteMongoDBCollectionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    serializer: serializer$m
};
const getMongoDBCollectionThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const updateMongoDBCollectionThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const migrateMongoDBCollectionToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const migrateMongoDBCollectionToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getMongoRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoRoleDefinitionGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        mongoRoleDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createUpdateMongoRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MongoRoleDefinitionGetResults
        },
        201: {
            bodyMapper: MongoRoleDefinitionGetResults
        },
        202: {
            bodyMapper: MongoRoleDefinitionGetResults
        },
        204: {
            bodyMapper: MongoRoleDefinitionGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: createUpdateMongoRoleDefinitionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        mongoRoleDefinitionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteMongoRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        mongoRoleDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listMongoRoleDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoRoleDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getMongoUserDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoUserDefinitionGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        mongoUserDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const createUpdateMongoUserDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MongoUserDefinitionGetResults
        },
        201: {
            bodyMapper: MongoUserDefinitionGetResults
        },
        202: {
            bodyMapper: MongoUserDefinitionGetResults
        },
        204: {
            bodyMapper: MongoUserDefinitionGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: createUpdateMongoUserDefinitionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        mongoUserDefinitionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const deleteMongoUserDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        mongoUserDefinitionId
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listMongoUserDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MongoUserDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const retrieveContinuousBackupInformationOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupInformation
        },
        201: {
            bodyMapper: BackupInformation
        },
        202: {
            bodyMapper: BackupInformation
        },
        204: {
            bodyMapper: BackupInformation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: location,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        collectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TableResources operations. */
class TableResourcesImpl {
    /**
     * Initialize a new instance of the class TableResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the Tables under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listTables(resourceGroupName, accountName, options) {
        const iter = this.listTablesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listTablesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listTablesPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listTablesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listTables(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listTablesPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listTablesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listTablesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the Tables under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listTables(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listTablesOperationSpec);
    }
    /**
     * Gets the Tables under an existing Azure Cosmos DB database account with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    getTable(resourceGroupName, accountName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, tableName, options }, getTableOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB Table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param createUpdateTableParameters The parameters to provide for the current Table.
     * @param options The options parameters.
     */
    beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    tableName,
                    createUpdateTableParameters,
                    options
                },
                spec: createUpdateTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB Table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param createUpdateTableParameters The parameters to provide for the current Table.
     * @param options The options parameters.
     */
    beginCreateUpdateTableAndWait(resourceGroupName, accountName, tableName, createUpdateTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Table.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginDeleteTable(resourceGroupName, accountName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, tableName, options },
                spec: deleteTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Table.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginDeleteTableAndWait(resourceGroupName, accountName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteTable(resourceGroupName, accountName, tableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the Table under an existing Azure Cosmos DB database account with the
     * provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    getTableThroughput(resourceGroupName, accountName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, tableName, options }, getTableThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   Table.
     * @param options The options parameters.
     */
    beginUpdateTableThroughput(resourceGroupName, accountName, tableName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    tableName,
                    updateThroughputParameters,
                    options
                },
                spec: updateTableThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
     *                                   Table.
     * @param options The options parameters.
     */
    beginUpdateTableThroughputAndWait(resourceGroupName, accountName, tableName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTableThroughput(resourceGroupName, accountName, tableName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Table from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateTableToAutoscale(resourceGroupName, accountName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, tableName, options },
                spec: migrateTableToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Table from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateTableToAutoscaleAndWait(resourceGroupName, accountName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateTableToAutoscale(resourceGroupName, accountName, tableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Table from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateTableToManualThroughput(resourceGroupName, accountName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, tableName, options },
                spec: migrateTableToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Table from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateTableToManualThroughputAndWait(resourceGroupName, accountName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateTableToManualThroughput(resourceGroupName, accountName, tableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves continuous backup information for a table.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, tableName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, tableName, location, options },
                spec: retrieveContinuousBackupInformationOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves continuous backup information for a table.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param tableName Cosmos DB table name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformationAndWait(resourceGroupName, accountName, tableName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, tableName, location, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listTablesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TableListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TableGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createUpdateTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TableGetResults
        },
        201: {
            bodyMapper: TableGetResults
        },
        202: {
            bodyMapper: TableGetResults
        },
        204: {
            bodyMapper: TableGetResults
        }
    },
    requestBody: createUpdateTableParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const deleteTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: TableResourcesDeleteTableHeaders
        },
        201: {
            headersMapper: TableResourcesDeleteTableHeaders
        },
        202: {
            headersMapper: TableResourcesDeleteTableHeaders
        },
        204: {
            headersMapper: TableResourcesDeleteTableHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    serializer: serializer$l
};
const getTableThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const updateTableThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const migrateTableToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const migrateTableToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const retrieveContinuousBackupInformationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/tables/{tableName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupInformation
        },
        201: {
            bodyMapper: BackupInformation
        },
        202: {
            bodyMapper: BackupInformation
        },
        204: {
            bodyMapper: BackupInformation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: location,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CassandraResources operations. */
class CassandraResourcesImpl {
    /**
     * Initialize a new instance of the class CassandraResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the Cassandra keyspaces under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listCassandraKeyspaces(resourceGroupName, accountName, options) {
        const iter = this.listCassandraKeyspacesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCassandraKeyspacesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listCassandraKeyspacesPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCassandraKeyspacesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listCassandraKeyspaces(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listCassandraKeyspacesPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCassandraKeyspacesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listCassandraKeyspacesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the Cassandra table under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    listCassandraTables(resourceGroupName, accountName, keyspaceName, options) {
        const iter = this.listCassandraTablesPagingAll(resourceGroupName, accountName, keyspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCassandraTablesPagingPage(resourceGroupName, accountName, keyspaceName, options, settings);
            }
        };
    }
    listCassandraTablesPagingPage(resourceGroupName, accountName, keyspaceName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCassandraTablesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listCassandraTables(resourceGroupName, accountName, keyspaceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listCassandraTablesPagingAll(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCassandraTablesPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listCassandraTablesPagingPage(resourceGroupName, accountName, keyspaceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the Cassandra keyspaces under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listCassandraKeyspaces(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listCassandraKeyspacesOperationSpec);
    }
    /**
     * Gets the Cassandra keyspaces under an existing Azure Cosmos DB database account with the provided
     * name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    getCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, keyspaceName, options }, getCassandraKeyspaceOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB Cassandra keyspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param createUpdateCassandraKeyspaceParameters The parameters to provide for the current Cassandra
     *                                                keyspace.
     * @param options The options parameters.
     */
    beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    createUpdateCassandraKeyspaceParameters,
                    options
                },
                spec: createUpdateCassandraKeyspaceOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB Cassandra keyspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param createUpdateCassandraKeyspaceParameters The parameters to provide for the current Cassandra
     *                                                keyspace.
     * @param options The options parameters.
     */
    beginCreateUpdateCassandraKeyspaceAndWait(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Cassandra keyspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, keyspaceName, options },
                spec: deleteCassandraKeyspaceOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Cassandra keyspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    beginDeleteCassandraKeyspaceAndWait(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the Cassandra Keyspace under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    getCassandraKeyspaceThroughput(resourceGroupName, accountName, keyspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, keyspaceName, options }, getCassandraKeyspaceThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Cassandra Keyspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Cassandra Keyspace.
     * @param options The options parameters.
     */
    beginUpdateCassandraKeyspaceThroughput(resourceGroupName, accountName, keyspaceName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    updateThroughputParameters,
                    options
                },
                spec: updateCassandraKeyspaceThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Cassandra Keyspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Cassandra Keyspace.
     * @param options The options parameters.
     */
    beginUpdateCassandraKeyspaceThroughputAndWait(resourceGroupName, accountName, keyspaceName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateCassandraKeyspaceThroughput(resourceGroupName, accountName, keyspaceName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra Keyspace from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    beginMigrateCassandraKeyspaceToAutoscale(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, keyspaceName, options },
                spec: migrateCassandraKeyspaceToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra Keyspace from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    beginMigrateCassandraKeyspaceToAutoscaleAndWait(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateCassandraKeyspaceToAutoscale(resourceGroupName, accountName, keyspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra Keyspace from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    beginMigrateCassandraKeyspaceToManualThroughput(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, keyspaceName, options },
                spec: migrateCassandraKeyspaceToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra Keyspace from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    beginMigrateCassandraKeyspaceToManualThroughputAndWait(resourceGroupName, accountName, keyspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateCassandraKeyspaceToManualThroughput(resourceGroupName, accountName, keyspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the Cassandra table under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param options The options parameters.
     */
    _listCassandraTables(resourceGroupName, accountName, keyspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, keyspaceName, options }, listCassandraTablesOperationSpec);
    }
    /**
     * Gets the Cassandra table under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    getCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, keyspaceName, tableName, options }, getCassandraTableOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB Cassandra Table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param createUpdateCassandraTableParameters The parameters to provide for the current Cassandra
     *                                             Table.
     * @param options The options parameters.
     */
    beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    tableName,
                    createUpdateCassandraTableParameters,
                    options
                },
                spec: createUpdateCassandraTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB Cassandra Table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param createUpdateCassandraTableParameters The parameters to provide for the current Cassandra
     *                                             Table.
     * @param options The options parameters.
     */
    beginCreateUpdateCassandraTableAndWait(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Cassandra table.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    tableName,
                    options
                },
                spec: deleteCassandraTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Cassandra table.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginDeleteCassandraTableAndWait(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the Cassandra table under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    getCassandraTableThroughput(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, keyspaceName, tableName, options }, getCassandraTableThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Cassandra table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Cassandra table.
     * @param options The options parameters.
     */
    beginUpdateCassandraTableThroughput(resourceGroupName, accountName, keyspaceName, tableName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    tableName,
                    updateThroughputParameters,
                    options
                },
                spec: updateCassandraTableThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Cassandra table
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Cassandra table.
     * @param options The options parameters.
     */
    beginUpdateCassandraTableThroughputAndWait(resourceGroupName, accountName, keyspaceName, tableName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateCassandraTableThroughput(resourceGroupName, accountName, keyspaceName, tableName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra table from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateCassandraTableToAutoscale(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    tableName,
                    options
                },
                spec: migrateCassandraTableToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra table from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateCassandraTableToAutoscaleAndWait(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateCassandraTableToAutoscale(resourceGroupName, accountName, keyspaceName, tableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra table from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateCassandraTableToManualThroughput(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    keyspaceName,
                    tableName,
                    options
                },
                spec: migrateCassandraTableToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Cassandra table from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param keyspaceName Cosmos DB keyspace name.
     * @param tableName Cosmos DB table name.
     * @param options The options parameters.
     */
    beginMigrateCassandraTableToManualThroughputAndWait(resourceGroupName, accountName, keyspaceName, tableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateCassandraTableToManualThroughput(resourceGroupName, accountName, keyspaceName, tableName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listCassandraKeyspacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CassandraKeyspaceListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getCassandraKeyspaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CassandraKeyspaceGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createUpdateCassandraKeyspaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CassandraKeyspaceGetResults
        },
        201: {
            bodyMapper: CassandraKeyspaceGetResults
        },
        202: {
            bodyMapper: CassandraKeyspaceGetResults
        },
        204: {
            bodyMapper: CassandraKeyspaceGetResults
        }
    },
    requestBody: createUpdateCassandraKeyspaceParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteCassandraKeyspaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: CassandraResourcesDeleteCassandraKeyspaceHeaders
        },
        201: {
            headersMapper: CassandraResourcesDeleteCassandraKeyspaceHeaders
        },
        202: {
            headersMapper: CassandraResourcesDeleteCassandraKeyspaceHeaders
        },
        204: {
            headersMapper: CassandraResourcesDeleteCassandraKeyspaceHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    serializer: serializer$k
};
const getCassandraKeyspaceThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const updateCassandraKeyspaceThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const migrateCassandraKeyspaceToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const migrateCassandraKeyspaceToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listCassandraTablesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CassandraTableListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getCassandraTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CassandraTableGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createUpdateCassandraTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CassandraTableGetResults
        },
        201: {
            bodyMapper: CassandraTableGetResults
        },
        202: {
            bodyMapper: CassandraTableGetResults
        },
        204: {
            bodyMapper: CassandraTableGetResults
        }
    },
    requestBody: createUpdateCassandraTableParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteCassandraTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: CassandraResourcesDeleteCassandraTableHeaders
        },
        201: {
            headersMapper: CassandraResourcesDeleteCassandraTableHeaders
        },
        202: {
            headersMapper: CassandraResourcesDeleteCassandraTableHeaders
        },
        204: {
            headersMapper: CassandraResourcesDeleteCassandraTableHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    serializer: serializer$k
};
const getCassandraTableThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const updateCassandraTableThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const migrateCassandraTableToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const migrateCassandraTableToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/cassandraKeyspaces/{keyspaceName}/tables/{tableName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        tableName,
        keyspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GremlinResources operations. */
class GremlinResourcesImpl {
    /**
     * Initialize a new instance of the class GremlinResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the Gremlin databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listGremlinDatabases(resourceGroupName, accountName, options) {
        const iter = this.listGremlinDatabasesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGremlinDatabasesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listGremlinDatabasesPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGremlinDatabasesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listGremlinDatabases(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listGremlinDatabasesPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listGremlinDatabasesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listGremlinDatabasesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the Gremlin graph under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listGremlinGraphs(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listGremlinGraphsPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGremlinGraphsPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listGremlinGraphsPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGremlinGraphsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listGremlinGraphs(resourceGroupName, accountName, databaseName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listGremlinGraphsPagingAll(resourceGroupName, accountName, databaseName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listGremlinGraphsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listGremlinGraphsPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists the Gremlin databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listGremlinDatabases(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listGremlinDatabasesOperationSpec);
    }
    /**
     * Gets the Gremlin databases under an existing Azure Cosmos DB database account with the provided
     * name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getGremlinDatabase(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getGremlinDatabaseOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB Gremlin database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateGremlinDatabaseParameters The parameters to provide for the current Gremlin
     *                                              database.
     * @param options The options parameters.
     */
    beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    createUpdateGremlinDatabaseParameters,
                    options
                },
                spec: createUpdateGremlinDatabaseOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB Gremlin database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateGremlinDatabaseParameters The parameters to provide for the current Gremlin
     *                                              database.
     * @param options The options parameters.
     */
    beginCreateUpdateGremlinDatabaseAndWait(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Gremlin database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: deleteGremlinDatabaseOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Gremlin database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteGremlinDatabaseAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the Gremlin database under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getGremlinDatabaseThroughput(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getGremlinDatabaseThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Gremlin database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Gremlin database.
     * @param options The options parameters.
     */
    beginUpdateGremlinDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    updateThroughputParameters,
                    options
                },
                spec: updateGremlinDatabaseThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Gremlin database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Gremlin database.
     * @param options The options parameters.
     */
    beginUpdateGremlinDatabaseThroughputAndWait(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateGremlinDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateGremlinDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateGremlinDatabaseToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateGremlinDatabaseToAutoscaleAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateGremlinDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateGremlinDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateGremlinDatabaseToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateGremlinDatabaseToManualThroughputAndWait(resourceGroupName, accountName, databaseName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateGremlinDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the Gremlin graph under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listGremlinGraphs(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listGremlinGraphsOperationSpec);
    }
    /**
     * Gets the Gremlin graph under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    getGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, graphName, options }, getGremlinGraphOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB Gremlin graph
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param createUpdateGremlinGraphParameters The parameters to provide for the current Gremlin graph.
     * @param options The options parameters.
     */
    beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    graphName,
                    createUpdateGremlinGraphParameters,
                    options
                },
                spec: createUpdateGremlinGraphOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB Gremlin graph
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param createUpdateGremlinGraphParameters The parameters to provide for the current Gremlin graph.
     * @param options The options parameters.
     */
    beginCreateUpdateGremlinGraphAndWait(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Gremlin graph.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    graphName,
                    options
                },
                spec: deleteGremlinGraphOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Gremlin graph.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    beginDeleteGremlinGraphAndWait(resourceGroupName, accountName, databaseName, graphName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the Gremlin graph throughput under an existing Azure Cosmos DB database account with the
     * provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    getGremlinGraphThroughput(resourceGroupName, accountName, databaseName, graphName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, graphName, options }, getGremlinGraphThroughputOperationSpec);
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Gremlin graph
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Gremlin graph.
     * @param options The options parameters.
     */
    beginUpdateGremlinGraphThroughput(resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    graphName,
                    updateThroughputParameters,
                    options
                },
                spec: updateGremlinGraphThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of an Azure Cosmos DB Gremlin graph
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   Gremlin graph.
     * @param options The options parameters.
     */
    beginUpdateGremlinGraphThroughputAndWait(resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateGremlinGraphThroughput(resourceGroupName, accountName, databaseName, graphName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    beginMigrateGremlinGraphToAutoscale(resourceGroupName, accountName, databaseName, graphName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    graphName,
                    options
                },
                spec: migrateGremlinGraphToAutoscaleOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin graph from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    beginMigrateGremlinGraphToAutoscaleAndWait(resourceGroupName, accountName, databaseName, graphName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateGremlinGraphToAutoscale(resourceGroupName, accountName, databaseName, graphName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    beginMigrateGremlinGraphToManualThroughput(resourceGroupName, accountName, databaseName, graphName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    graphName,
                    options
                },
                spec: migrateGremlinGraphToManualThroughputOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB Gremlin graph from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param options The options parameters.
     */
    beginMigrateGremlinGraphToManualThroughputAndWait(resourceGroupName, accountName, databaseName, graphName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateGremlinGraphToManualThroughput(resourceGroupName, accountName, databaseName, graphName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves continuous backup information for a gremlin graph.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, graphName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    graphName,
                    location,
                    options
                },
                spec: retrieveContinuousBackupInformationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves continuous backup information for a gremlin graph.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param graphName Cosmos DB graph name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformationAndWait(resourceGroupName, accountName, databaseName, graphName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, graphName, location, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listGremlinDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GremlinDatabaseListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getGremlinDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GremlinDatabaseGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createUpdateGremlinDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GremlinDatabaseGetResults
        },
        201: {
            bodyMapper: GremlinDatabaseGetResults
        },
        202: {
            bodyMapper: GremlinDatabaseGetResults
        },
        204: {
            bodyMapper: GremlinDatabaseGetResults
        }
    },
    requestBody: createUpdateGremlinDatabaseParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const deleteGremlinDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: GremlinResourcesDeleteGremlinDatabaseHeaders
        },
        201: {
            headersMapper: GremlinResourcesDeleteGremlinDatabaseHeaders
        },
        202: {
            headersMapper: GremlinResourcesDeleteGremlinDatabaseHeaders
        },
        204: {
            headersMapper: GremlinResourcesDeleteGremlinDatabaseHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    serializer: serializer$j
};
const getGremlinDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const updateGremlinDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const migrateGremlinDatabaseToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const migrateGremlinDatabaseToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listGremlinGraphsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GremlinGraphListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getGremlinGraphOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GremlinGraphGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createUpdateGremlinGraphOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GremlinGraphGetResults
        },
        201: {
            bodyMapper: GremlinGraphGetResults
        },
        202: {
            bodyMapper: GremlinGraphGetResults
        },
        204: {
            bodyMapper: GremlinGraphGetResults
        }
    },
    requestBody: createUpdateGremlinGraphParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const deleteGremlinGraphOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: GremlinResourcesDeleteGremlinGraphHeaders
        },
        201: {
            headersMapper: GremlinResourcesDeleteGremlinGraphHeaders
        },
        202: {
            headersMapper: GremlinResourcesDeleteGremlinGraphHeaders
        },
        204: {
            headersMapper: GremlinResourcesDeleteGremlinGraphHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    serializer: serializer$j
};
const getGremlinGraphThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const updateGremlinGraphThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        }
    },
    requestBody: updateThroughputParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const migrateGremlinGraphToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const migrateGremlinGraphToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const retrieveContinuousBackupInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/gremlinDatabases/{databaseName}/graphs/{graphName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackupInformation
        },
        201: {
            bodyMapper: BackupInformation
        },
        202: {
            bodyMapper: BackupInformation
        },
        204: {
            bodyMapper: BackupInformation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: location,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        databaseName,
        graphName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Locations operations. */
class LocationsImpl {
    /**
     * Initialize a new instance of the class Locations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List Cosmos DB locations and their properties
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List Cosmos DB locations and their properties
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * Get the properties of an existing Cosmos DB location
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param options The options parameters.
     */
    get(location, options) {
        return this.client.sendOperationRequest({ location, options }, getOperationSpec$6);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocationGetResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CassandraClusters operations. */
class CassandraClustersImpl {
    /**
     * Initialize a new instance of the class CassandraClusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all managed Cassandra clusters in this subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all managed Cassandra clusters in this resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all managed Cassandra clusters in this subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * List all managed Cassandra clusters in this resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Get the properties of a managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getOperationSpec$5);
    }
    /**
     * Deletes a managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, options },
                spec: deleteOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a managed Cassandra cluster. When updating, you must specify all writable
     * properties. To update only some properties, use PATCH.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param body The properties specifying the desired state of the managed Cassandra cluster.
     * @param options The options parameters.
     */
    beginCreateUpdate(resourceGroupName, clusterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, body, options },
                spec: createUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a managed Cassandra cluster. When updating, you must specify all writable
     * properties. To update only some properties, use PATCH.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param body The properties specifying the desired state of the managed Cassandra cluster.
     * @param options The options parameters.
     */
    beginCreateUpdateAndWait(resourceGroupName, clusterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdate(resourceGroupName, clusterName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates some of the properties of a managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param body Parameters to provide for specifying the managed Cassandra cluster.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, body, options },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates some of the properties of a managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param body Parameters to provide for specifying the managed Cassandra cluster.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Invoke a command like nodetool for cassandra maintenance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param body Specification which command to run where
     * @param options The options parameters.
     */
    beginInvokeCommand(resourceGroupName, clusterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, body, options },
                spec: invokeCommandOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Invoke a command like nodetool for cassandra maintenance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param body Specification which command to run where
     * @param options The options parameters.
     */
    beginInvokeCommandAndWait(resourceGroupName, clusterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInvokeCommand(resourceGroupName, clusterName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deallocate the Managed Cassandra Cluster and Associated Data Centers. Deallocation will deallocate
     * the host virtual machine of this cluster, and reserved the data disk. This won't do anything on an
     * already deallocated cluster. Use Start to restart the cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    beginDeallocate(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, options },
                spec: deallocateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deallocate the Managed Cassandra Cluster and Associated Data Centers. Deallocation will deallocate
     * the host virtual machine of this cluster, and reserved the data disk. This won't do anything on an
     * already deallocated cluster. Use Start to restart the cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    beginDeallocateAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeallocate(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Start the Managed Cassandra Cluster and Associated Data Centers. Start will start the host virtual
     * machine of this cluster with reserved data disk. This won't do anything on an already running
     * cluster. Use Deallocate to deallocate the cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, options },
                spec: startOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Start the Managed Cassandra Cluster and Associated Data Centers. Start will start the host virtual
     * machine of this cluster with reserved data disk. This won't do anything on an already running
     * cluster. Use Deallocate to deallocate the cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the CPU, memory, and disk usage statistics for each Cassandra node in a cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    status(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, statusOperationSpec);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/cassandraClusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListClusters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListClusters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ClusterResource
        },
        201: {
            bodyMapper: ClusterResource
        },
        202: {
            bodyMapper: ClusterResource
        },
        204: {
            bodyMapper: ClusterResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ClusterResource
        },
        201: {
            bodyMapper: ClusterResource
        },
        202: {
            bodyMapper: ClusterResource
        },
        204: {
            bodyMapper: ClusterResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const invokeCommandOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/invokeCommand",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CommandOutput
        },
        201: {
            bodyMapper: CommandOutput
        },
        202: {
            bodyMapper: CommandOutput
        },
        204: {
            bodyMapper: CommandOutput
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deallocateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/deallocate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const statusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/status",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CassandraClusterPublicStatus
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CassandraDataCenters operations. */
class CassandraDataCentersImpl {
    /**
     * Initialize a new instance of the class CassandraDataCenters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all data centers in a particular managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    list(resourceGroupName, clusterName, options) {
        const iter = this.listPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, clusterName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, clusterName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, clusterName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all data centers in a particular managed Cassandra cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listOperationSpec$d);
    }
    /**
     * Get the properties of a managed Cassandra data center.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, dataCenterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, dataCenterName, options }, getOperationSpec$4);
    }
    /**
     * Delete a managed Cassandra data center.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, dataCenterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, dataCenterName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a managed Cassandra data center.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, dataCenterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, dataCenterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a managed Cassandra data center. When updating, overwrite all properties. To update
     * only some properties, use PATCH.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param body Parameters specifying the managed Cassandra data center.
     * @param options The options parameters.
     */
    beginCreateUpdate(resourceGroupName, clusterName, dataCenterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, dataCenterName, body, options },
                spec: createUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a managed Cassandra data center. When updating, overwrite all properties. To update
     * only some properties, use PATCH.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param body Parameters specifying the managed Cassandra data center.
     * @param options The options parameters.
     */
    beginCreateUpdateAndWait(resourceGroupName, clusterName, dataCenterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdate(resourceGroupName, clusterName, dataCenterName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update some of the properties of a managed Cassandra data center.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param body Parameters to provide for specifying the managed Cassandra data center.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, dataCenterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, dataCenterName, body, options },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update some of the properties of a managed Cassandra data center.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param clusterName Managed Cassandra cluster name.
     * @param dataCenterName Data center name in a managed Cassandra cluster.
     * @param body Parameters to provide for specifying the managed Cassandra data center.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, dataCenterName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, dataCenterName, body, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/dataCenters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListDataCenters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/dataCenters/{dataCenterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataCenterResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        dataCenterName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/dataCenters/{dataCenterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        dataCenterName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/dataCenters/{dataCenterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataCenterResource
        },
        201: {
            bodyMapper: DataCenterResource
        },
        202: {
            bodyMapper: DataCenterResource
        },
        204: {
            bodyMapper: DataCenterResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        dataCenterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/cassandraClusters/{clusterName}/dataCenters/{dataCenterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DataCenterResource
        },
        201: {
            bodyMapper: DataCenterResource
        },
        202: {
            bodyMapper: DataCenterResource
        },
        204: {
            bodyMapper: DataCenterResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        dataCenterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NotebookWorkspaces operations. */
class NotebookWorkspacesImpl {
    /**
     * Initialize a new instance of the class NotebookWorkspaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the notebook workspace resources of an existing Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listByDatabaseAccount(resourceGroupName, accountName, options) {
        const iter = this.listByDatabaseAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDatabaseAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByDatabaseAccountPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabaseAccountPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByDatabaseAccount(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByDatabaseAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabaseAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByDatabaseAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the notebook workspace resources of an existing Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listByDatabaseAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByDatabaseAccountOperationSpec$2);
    }
    /**
     * Gets the notebook workspace for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, notebookWorkspaceName, options }, getOperationSpec$3);
    }
    /**
     * Creates the notebook workspace for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param notebookCreateUpdateParameters The notebook workspace to create for the current database
     *                                       account.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, notebookWorkspaceName, notebookCreateUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    notebookWorkspaceName,
                    notebookCreateUpdateParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates the notebook workspace for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param notebookCreateUpdateParameters The notebook workspace to create for the current database
     *                                       account.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, notebookWorkspaceName, notebookCreateUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, notebookWorkspaceName, notebookCreateUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the notebook workspace for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, notebookWorkspaceName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the notebook workspace for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, notebookWorkspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the connection info for the notebook workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    listConnectionInfo(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, notebookWorkspaceName, options }, listConnectionInfoOperationSpec);
    }
    /**
     * Regenerates the auth token for the notebook workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    beginRegenerateAuthToken(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, notebookWorkspaceName, options },
                spec: regenerateAuthTokenOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Regenerates the auth token for the notebook workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    beginRegenerateAuthTokenAndWait(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegenerateAuthToken(resourceGroupName, accountName, notebookWorkspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts the notebook workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, notebookWorkspaceName, options },
                spec: startOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts the notebook workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param notebookWorkspaceName The name of the notebook workspace resource.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, accountName, notebookWorkspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, accountName, notebookWorkspaceName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseAccountOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotebookWorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces/{notebookWorkspaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotebookWorkspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        notebookWorkspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces/{notebookWorkspaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NotebookWorkspace
        },
        201: {
            bodyMapper: NotebookWorkspace
        },
        202: {
            bodyMapper: NotebookWorkspace
        },
        204: {
            bodyMapper: NotebookWorkspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: notebookCreateUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        notebookWorkspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces/{notebookWorkspaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        notebookWorkspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listConnectionInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces/{notebookWorkspaceName}/listConnectionInfo",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NotebookWorkspaceConnectionInfoResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        notebookWorkspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const regenerateAuthTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces/{notebookWorkspaceName}/regenerateAuthToken",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        notebookWorkspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/notebookWorkspaces/{notebookWorkspaceName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        notebookWorkspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all private endpoint connections on a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listByDatabaseAccount(resourceGroupName, accountName, options) {
        const iter = this.listByDatabaseAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDatabaseAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByDatabaseAccountPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabaseAccountPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByDatabaseAccount(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByDatabaseAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabaseAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByDatabaseAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all private endpoint connections on a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listByDatabaseAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByDatabaseAccountOperationSpec$1);
    }
    /**
     * Gets a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    privateEndpointConnectionName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, privateEndpointConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    privateEndpointConnectionName,
                    options
                },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseAccountOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources that need to be created for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listByDatabaseAccount(resourceGroupName, accountName, options) {
        const iter = this.listByDatabaseAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDatabaseAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByDatabaseAccountPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabaseAccountPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByDatabaseAccount(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByDatabaseAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDatabaseAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByDatabaseAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the private link resources that need to be created for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listByDatabaseAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByDatabaseAccountOperationSpec);
    }
    /**
     * Gets the private link resources that need to be created for a Cosmos DB account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param groupName The name of the private link resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, groupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, groupName, options }, getOperationSpec$1);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDatabaseAccountOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/privateLinkResources/{groupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        groupName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableDatabaseAccounts operations. */
class RestorableDatabaseAccountsImpl {
    /**
     * Initialize a new instance of the class RestorableDatabaseAccounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the restorable Azure Cosmos DB database accounts available under the subscription and in a
     * region.  This call requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read'
     * permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLocationPagingPage(location, options, settings);
            }
        };
    }
    listByLocationPagingPage(location, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByLocation(location, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the restorable Azure Cosmos DB database accounts available under the subscription. This
     * call requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read' permission.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all the restorable Azure Cosmos DB database accounts available under the subscription and in a
     * region.  This call requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read'
     * permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec);
    }
    /**
     * Lists all the restorable Azure Cosmos DB database accounts available under the subscription. This
     * call requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read' permission.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB restorable database account.  This call
     * requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/read/*' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    getByLocation(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, getByLocationOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDatabaseAccountsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/restorableDatabaseAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDatabaseAccountsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$c
};
const getByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableDatabaseAccountGetResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableSqlDatabases operations. */
class RestorableSqlDatabasesImpl {
    /**
     * Initialize a new instance of the class RestorableSqlDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB SQL databases under the
     * restorable account.  This helps in scenario where database was accidentally deleted to get the
     * deletion time.  This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB SQL databases under the
     * restorable account.  This helps in scenario where database was accidentally deleted to get the
     * deletion time.  This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$b);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableSqlDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableSqlDatabasesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableSqlContainers operations. */
class RestorableSqlContainersImpl {
    /**
     * Initialize a new instance of the class RestorableSqlContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB SQL containers under a specific
     * database.  This helps in scenario where container was accidentally deleted.  This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB SQL containers under a specific
     * database.  This helps in scenario where container was accidentally deleted.  This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$a);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableSqlContainers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableSqlContainersListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        restorableSqlDatabaseRid,
        startTime,
        endTime
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableSqlResources operations. */
class RestorableSqlResourcesImpl {
    /**
     * Initialize a new instance of the class RestorableSqlResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return a list of database and container combo that exist on the account at the given timestamp and
     * location. This helps in scenarios to validate what resources exist at given timestamp and location.
     * This API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return a list of database and container combo that exist on the account at the given timestamp and
     * location. This helps in scenarios to validate what resources exist at given timestamp and location.
     * This API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$9);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableSqlResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableSqlResourcesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        restoreLocation,
        restoreTimestampInUtc
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableMongodbDatabases operations. */
class RestorableMongodbDatabasesImpl {
    /**
     * Initialize a new instance of the class RestorableMongodbDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB MongoDB databases under the
     * restorable account.  This helps in scenario where database was accidentally deleted to get the
     * deletion time.  This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB MongoDB databases under the
     * restorable account.  This helps in scenario where database was accidentally deleted to get the
     * deletion time.  This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$8);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableMongodbDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableMongodbDatabasesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableMongodbCollections operations. */
class RestorableMongodbCollectionsImpl {
    /**
     * Initialize a new instance of the class RestorableMongodbCollections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB MongoDB collections under a
     * specific database.  This helps in scenario where container was accidentally deleted.  This API
     * requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB MongoDB collections under a
     * specific database.  This helps in scenario where container was accidentally deleted.  This API
     * requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$7);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableMongodbCollections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableMongodbCollectionsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        restorableMongodbDatabaseRid
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableMongodbResources operations. */
class RestorableMongodbResourcesImpl {
    /**
     * Initialize a new instance of the class RestorableMongodbResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return a list of database and collection combo that exist on the account at the given timestamp and
     * location. This helps in scenarios to validate what resources exist at given timestamp and location.
     * This API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return a list of database and collection combo that exist on the account at the given timestamp and
     * location. This helps in scenarios to validate what resources exist at given timestamp and location.
     * This API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$6);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableMongodbResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableMongodbResourcesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        restoreLocation,
        restoreTimestampInUtc
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableGremlinDatabases operations. */
class RestorableGremlinDatabasesImpl {
    /**
     * Initialize a new instance of the class RestorableGremlinDatabases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB Gremlin databases under the
     * restorable account. This helps in scenario where database was accidentally deleted to get the
     * deletion time. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB Gremlin databases under the
     * restorable account. This helps in scenario where database was accidentally deleted to get the
     * deletion time. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableGremlinDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableGremlinDatabasesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableGremlinGraphs operations. */
class RestorableGremlinGraphsImpl {
    /**
     * Initialize a new instance of the class RestorableGremlinGraphs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB Gremlin graphs under a specific
     * database. This helps in scenario where container was accidentally deleted. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB Gremlin graphs under a specific
     * database. This helps in scenario where container was accidentally deleted. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableGraphs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableGremlinGraphsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime,
        restorableGremlinDatabaseRid
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableGremlinResources operations. */
class RestorableGremlinResourcesImpl {
    /**
     * Initialize a new instance of the class RestorableGremlinResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return a list of gremlin database and graphs combo that exist on the account at the given timestamp
     * and location. This helps in scenarios to validate what resources exist at given timestamp and
     * location. This API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read'
     * permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return a list of gremlin database and graphs combo that exist on the account at the given timestamp
     * and location. This helps in scenarios to validate what resources exist at given timestamp and
     * location. This API requires 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read'
     * permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableGremlinResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableGremlinResourcesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        restoreLocation,
        restoreTimestampInUtc
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableTables operations. */
class RestorableTablesImpl {
    /**
     * Initialize a new instance of the class RestorableTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB Tables. This helps in scenario
     * where table was accidentally deleted. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Show the event feed of all mutations done on all the Azure Cosmos DB Tables. This helps in scenario
     * where table was accidentally deleted. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableTablesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        startTime,
        endTime
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RestorableTableResources operations. */
class RestorableTableResourcesImpl {
    /**
     * Initialize a new instance of the class RestorableTableResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return a list of tables that exist on the account at the given timestamp and location. This helps in
     * scenarios to validate what resources exist at given timestamp and location. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    list(location, instanceId, options) {
        const iter = this.listPagingAll(location, instanceId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, instanceId, options, settings);
            }
        };
    }
    listPagingPage(location, instanceId, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, instanceId, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, instanceId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, instanceId, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return a list of tables that exist on the account at the given timestamp and location. This helps in
     * scenarios to validate what resources exist at given timestamp and location. This API requires
     * 'Microsoft.DocumentDB/locations/restorableDatabaseAccounts/.../read' permission.
     * @param location Cosmos DB region, with spaces between words and each word capitalized.
     * @param instanceId The instanceId GUID of a restorable database account.
     * @param options The options parameters.
     */
    _list(location, instanceId, options) {
        return this.client.sendOperationRequest({ location, instanceId, options }, listOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{instanceId}/restorableTableResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestorableTableResourcesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        restoreLocation,
        restoreTimestampInUtc
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location1,
        instanceId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Service operations. */
class ServiceImpl {
    /**
     * Initialize a new instance of the class Service class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the status of service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the status of service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec);
    }
    /**
     * Creates a service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param serviceName Cosmos DB service name.
     * @param createUpdateParameters The Service resource parameters.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, serviceName, createUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    serviceName,
                    createUpdateParameters,
                    options
                },
                spec: createOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param serviceName Cosmos DB service name.
     * @param createUpdateParameters The Service resource parameters.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, serviceName, createUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, serviceName, createUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param serviceName Cosmos DB service name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, serviceName, options }, getOperationSpec);
    }
    /**
     * Deletes service with the given serviceName.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param serviceName Cosmos DB service name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, serviceName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes service with the given serviceName.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param serviceName Cosmos DB service name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/services",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/services/{serviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceResource
        },
        201: {
            bodyMapper: ServiceResource
        },
        202: {
            bodyMapper: ServiceResource
        },
        204: {
            bodyMapper: ServiceResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: createUpdateParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/services/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        serviceName
    ],
    headerParameters: [accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/services/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        serviceName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class CosmosDBManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the CosmosDBManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-cosmosdb/15.6.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-11-15";
        this.databaseAccounts = new DatabaseAccountsImpl(this);
        this.operations = new OperationsImpl(this);
        this.database = new DatabaseImpl(this);
        this.collection = new CollectionImpl(this);
        this.collectionRegion = new CollectionRegionImpl(this);
        this.databaseAccountRegion = new DatabaseAccountRegionImpl(this);
        this.percentileSourceTarget = new PercentileSourceTargetImpl(this);
        this.percentileTarget = new PercentileTargetImpl(this);
        this.percentile = new PercentileImpl(this);
        this.collectionPartitionRegion = new CollectionPartitionRegionImpl(this);
        this.collectionPartition = new CollectionPartitionImpl(this);
        this.partitionKeyRangeId = new PartitionKeyRangeIdImpl(this);
        this.partitionKeyRangeIdRegion = new PartitionKeyRangeIdRegionImpl(this);
        this.sqlResources = new SqlResourcesImpl(this);
        this.mongoDBResources = new MongoDBResourcesImpl(this);
        this.tableResources = new TableResourcesImpl(this);
        this.cassandraResources = new CassandraResourcesImpl(this);
        this.gremlinResources = new GremlinResourcesImpl(this);
        this.locations = new LocationsImpl(this);
        this.cassandraClusters = new CassandraClustersImpl(this);
        this.cassandraDataCenters = new CassandraDataCentersImpl(this);
        this.notebookWorkspaces = new NotebookWorkspacesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.restorableDatabaseAccounts = new RestorableDatabaseAccountsImpl(this);
        this.restorableSqlDatabases = new RestorableSqlDatabasesImpl(this);
        this.restorableSqlContainers = new RestorableSqlContainersImpl(this);
        this.restorableSqlResources = new RestorableSqlResourcesImpl(this);
        this.restorableMongodbDatabases = new RestorableMongodbDatabasesImpl(this);
        this.restorableMongodbCollections = new RestorableMongodbCollectionsImpl(this);
        this.restorableMongodbResources = new RestorableMongodbResourcesImpl(this);
        this.restorableGremlinDatabases = new RestorableGremlinDatabasesImpl(this);
        this.restorableGremlinGraphs = new RestorableGremlinGraphsImpl(this);
        this.restorableGremlinResources = new RestorableGremlinResourcesImpl(this);
        this.restorableTables = new RestorableTablesImpl(this);
        this.restorableTableResources = new RestorableTableResourcesImpl(this);
        this.service = new ServiceImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.CosmosDBManagementClient = CosmosDBManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map

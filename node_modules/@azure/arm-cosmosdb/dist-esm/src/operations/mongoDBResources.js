/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { createHttpPoller } from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
/// <reference lib="esnext.asynciterable" />
/** Class containing MongoDBResources operations. */
export class MongoDBResourcesImpl {
    /**
     * Initialize a new instance of the class MongoDBResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMongoDBDatabases(resourceGroupName, accountName, options) {
        const iter = this.listMongoDBDatabasesPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoDBDatabasesPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMongoDBDatabasesPagingPage(resourceGroupName, accountName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listMongoDBDatabasesPagingPage_1() {
            let result;
            result = yield __await(this._listMongoDBDatabases(resourceGroupName, accountName, options));
            yield yield __await(result.value || []);
        });
    }
    listMongoDBDatabasesPagingAll(resourceGroupName, accountName, options) {
        return __asyncGenerator(this, arguments, function* listMongoDBDatabasesPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listMongoDBDatabasesPagingPage(resourceGroupName, accountName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    listMongoDBCollections(resourceGroupName, accountName, databaseName, options) {
        const iter = this.listMongoDBCollectionsPagingAll(resourceGroupName, accountName, databaseName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoDBCollectionsPagingPage(resourceGroupName, accountName, databaseName, options, settings);
            }
        };
    }
    listMongoDBCollectionsPagingPage(resourceGroupName, accountName, databaseName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listMongoDBCollectionsPagingPage_1() {
            let result;
            result = yield __await(this._listMongoDBCollections(resourceGroupName, accountName, databaseName, options));
            yield yield __await(result.value || []);
        });
    }
    listMongoDBCollectionsPagingAll(resourceGroupName, accountName, databaseName, options) {
        return __asyncGenerator(this, arguments, function* listMongoDBCollectionsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listMongoDBCollectionsPagingPage(resourceGroupName, accountName, databaseName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMongoRoleDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listMongoRoleDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoRoleDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMongoRoleDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listMongoRoleDefinitionsPagingPage_1() {
            let result;
            result = yield __await(this._listMongoRoleDefinitions(resourceGroupName, accountName, options));
            yield yield __await(result.value || []);
        });
    }
    listMongoRoleDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return __asyncGenerator(this, arguments, function* listMongoRoleDefinitionsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listMongoRoleDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    listMongoUserDefinitions(resourceGroupName, accountName, options) {
        const iter = this.listMongoUserDefinitionsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMongoUserDefinitionsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listMongoUserDefinitionsPagingPage(resourceGroupName, accountName, options, _settings) {
        return __asyncGenerator(this, arguments, function* listMongoUserDefinitionsPagingPage_1() {
            let result;
            result = yield __await(this._listMongoUserDefinitions(resourceGroupName, accountName, options));
            yield yield __await(result.value || []);
        });
    }
    listMongoUserDefinitionsPagingAll(resourceGroupName, accountName, options) {
        return __asyncGenerator(this, arguments, function* listMongoUserDefinitionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listMongoUserDefinitionsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMongoDBDatabases(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMongoDBDatabasesOperationSpec);
    }
    /**
     * Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
     * name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getMongoDBDatabase(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getMongoDBDatabaseOperationSpec);
    }
    /**
     * Create or updates Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
     *                                              database.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    createUpdateMongoDBDatabaseParameters,
                    options
                },
                spec: createUpdateMongoDBDatabaseOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or updates Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
     *                                              database.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBDatabaseAndWait(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: deleteMongoDBDatabaseOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB database.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBDatabaseAndWait(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    getMongoDBDatabaseThroughput(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, getMongoDBDatabaseThroughputOperationSpec);
    }
    /**
     * Update RUs per second of the an Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB database.
     * @param options The options parameters.
     */
    beginUpdateMongoDBDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    updateThroughputParameters,
                    options
                },
                spec: updateMongoDBDatabaseThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update RUs per second of the an Azure Cosmos DB MongoDB database
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB database.
     * @param options The options parameters.
     */
    beginUpdateMongoDBDatabaseThroughputAndWait(resourceGroupName, accountName, databaseName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateMongoDBDatabaseThroughput(resourceGroupName, accountName, databaseName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateMongoDBDatabaseToAutoscaleOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToAutoscaleAndWait(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBDatabaseToAutoscale(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, databaseName, options },
                spec: migrateMongoDBDatabaseToManualThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBDatabaseToManualThroughputAndWait(resourceGroupName, accountName, databaseName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBDatabaseToManualThroughput(resourceGroupName, accountName, databaseName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param options The options parameters.
     */
    _listMongoDBCollections(resourceGroupName, accountName, databaseName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, options }, listMongoDBCollectionsOperationSpec);
    }
    /**
     * Gets the MongoDB collection under an existing Azure Cosmos DB database account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, collectionName, options }, getMongoDBCollectionOperationSpec);
    }
    /**
     * Create or update an Azure Cosmos DB MongoDB Collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
     *                                                Collection.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    createUpdateMongoDBCollectionParameters,
                    options
                },
                spec: createUpdateMongoDBCollectionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an Azure Cosmos DB MongoDB Collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
     *                                                Collection.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoDBCollectionAndWait(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB Collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    options
                },
                spec: deleteMongoDBCollectionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB MongoDB Collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginDeleteMongoDBCollectionAndWait(resourceGroupName, accountName, databaseName, collectionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account
     * with the provided name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    getMongoDBCollectionThroughput(resourceGroupName, accountName, databaseName, collectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, databaseName, collectionName, options }, getMongoDBCollectionThroughputOperationSpec);
    }
    /**
     * Update the RUs per second of an Azure Cosmos DB MongoDB collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB collection.
     * @param options The options parameters.
     */
    beginUpdateMongoDBCollectionThroughput(resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    updateThroughputParameters,
                    options
                },
                spec: updateMongoDBCollectionThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update the RUs per second of an Azure Cosmos DB MongoDB collection
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
     *                                   MongoDB collection.
     * @param options The options parameters.
     */
    beginUpdateMongoDBCollectionThroughputAndWait(resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateMongoDBCollectionThroughput(resourceGroupName, accountName, databaseName, collectionName, updateThroughputParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToAutoscale(resourceGroupName, accountName, databaseName, collectionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    options
                },
                spec: migrateMongoDBCollectionToAutoscaleOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToAutoscaleAndWait(resourceGroupName, accountName, databaseName, collectionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBCollectionToAutoscale(resourceGroupName, accountName, databaseName, collectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToManualThroughput(resourceGroupName, accountName, databaseName, collectionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    options
                },
                spec: migrateMongoDBCollectionToManualThroughputOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param options The options parameters.
     */
    beginMigrateMongoDBCollectionToManualThroughputAndWait(resourceGroupName, accountName, databaseName, collectionName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginMigrateMongoDBCollectionToManualThroughput(resourceGroupName, accountName, databaseName, collectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB Mongo Role Definition with the given Id.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ mongoRoleDefinitionId, resourceGroupName, accountName, options }, getMongoRoleDefinitionOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, createUpdateMongoRoleDefinitionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    mongoRoleDefinitionId,
                    resourceGroupName,
                    accountName,
                    createUpdateMongoRoleDefinitionParameters,
                    options
                },
                spec: createUpdateMongoRoleDefinitionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoRoleDefinitionAndWait(mongoRoleDefinitionId, resourceGroupName, accountName, createUpdateMongoRoleDefinitionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, createUpdateMongoRoleDefinitionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { mongoRoleDefinitionId, resourceGroupName, accountName, options },
                spec: deleteMongoRoleDefinitionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo Role Definition.
     * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoRoleDefinitionAndWait(mongoRoleDefinitionId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoRoleDefinition(mongoRoleDefinitionId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMongoRoleDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMongoRoleDefinitionsOperationSpec);
    }
    /**
     * Retrieves the properties of an existing Azure Cosmos DB Mongo User Definition with the given Id.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    getMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ mongoUserDefinitionId, resourceGroupName, accountName, options }, getMongoUserDefinitionOperationSpec);
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, createUpdateMongoUserDefinitionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    mongoUserDefinitionId,
                    resourceGroupName,
                    accountName,
                    createUpdateMongoUserDefinitionParameters,
                    options
                },
                spec: createUpdateMongoUserDefinitionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
     *                                                  Definition.
     * @param options The options parameters.
     */
    beginCreateUpdateMongoUserDefinitionAndWait(mongoUserDefinitionId, resourceGroupName, accountName, createUpdateMongoUserDefinitionParameters, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateUpdateMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, createUpdateMongoUserDefinitionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { mongoUserDefinitionId, resourceGroupName, accountName, options },
                spec: deleteMongoUserDefinitionOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an existing Azure Cosmos DB Mongo User Definition.
     * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    beginDeleteMongoUserDefinitionAndWait(mongoUserDefinitionId, resourceGroupName, accountName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteMongoUserDefinition(mongoUserDefinitionId, resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param options The options parameters.
     */
    _listMongoUserDefinitions(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listMongoUserDefinitionsOperationSpec);
    }
    /**
     * Retrieves continuous backup information for a Mongodb collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, collectionName, location, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    databaseName,
                    collectionName,
                    location,
                    options
                },
                spec: retrieveContinuousBackupInformationOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves continuous backup information for a Mongodb collection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName Cosmos DB database account name.
     * @param databaseName Cosmos DB database name.
     * @param collectionName Cosmos DB collection name.
     * @param location The name of the continuous backup restore location.
     * @param options The options parameters.
     */
    beginRetrieveContinuousBackupInformationAndWait(resourceGroupName, accountName, databaseName, collectionName, location, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetrieveContinuousBackupInformation(resourceGroupName, accountName, databaseName, collectionName, location, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const listMongoDBDatabasesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoDBDatabaseListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getMongoDBDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoDBDatabaseGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateMongoDBDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.MongoDBDatabaseGetResults
        },
        201: {
            bodyMapper: Mappers.MongoDBDatabaseGetResults
        },
        202: {
            bodyMapper: Mappers.MongoDBDatabaseGetResults
        },
        204: {
            bodyMapper: Mappers.MongoDBDatabaseGetResults
        }
    },
    requestBody: Parameters.createUpdateMongoDBDatabaseParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteMongoDBDatabaseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders
        },
        201: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders
        },
        202: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders
        },
        204: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    serializer
};
const getMongoDBDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const updateMongoDBDatabaseThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.updateThroughputParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const migrateMongoDBDatabaseToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const migrateMongoDBDatabaseToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listMongoDBCollectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoDBCollectionListResult
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getMongoDBCollectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoDBCollectionGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateMongoDBCollectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.MongoDBCollectionGetResults
        },
        201: {
            bodyMapper: Mappers.MongoDBCollectionGetResults
        },
        202: {
            bodyMapper: Mappers.MongoDBCollectionGetResults
        },
        204: {
            bodyMapper: Mappers.MongoDBCollectionGetResults
        }
    },
    requestBody: Parameters.createUpdateMongoDBCollectionParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteMongoDBCollectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders
        },
        201: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders
        },
        202: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders
        },
        204: {
            headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    serializer
};
const getMongoDBCollectionThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const updateMongoDBCollectionThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        }
    },
    requestBody: Parameters.updateThroughputParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const migrateMongoDBCollectionToAutoscaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const migrateMongoDBCollectionToManualThroughputOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        201: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        202: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        204: {
            bodyMapper: Mappers.ThroughputSettingsGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getMongoRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoRoleDefinitionGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.mongoRoleDefinitionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateMongoRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.MongoRoleDefinitionGetResults
        },
        201: {
            bodyMapper: Mappers.MongoRoleDefinitionGetResults
        },
        202: {
            bodyMapper: Mappers.MongoRoleDefinitionGetResults
        },
        204: {
            bodyMapper: Mappers.MongoRoleDefinitionGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.createUpdateMongoRoleDefinitionParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.mongoRoleDefinitionId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteMongoRoleDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.mongoRoleDefinitionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listMongoRoleDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoRoleDefinitionListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getMongoUserDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoUserDefinitionGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.mongoUserDefinitionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createUpdateMongoUserDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.MongoUserDefinitionGetResults
        },
        201: {
            bodyMapper: Mappers.MongoUserDefinitionGetResults
        },
        202: {
            bodyMapper: Mappers.MongoUserDefinitionGetResults
        },
        204: {
            bodyMapper: Mappers.MongoUserDefinitionGetResults
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.createUpdateMongoUserDefinitionParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.mongoUserDefinitionId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteMongoUserDefinitionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.mongoUserDefinitionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listMongoUserDefinitionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.MongoUserDefinitionListResult
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const retrieveContinuousBackupInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BackupInformation
        },
        201: {
            bodyMapper: Mappers.BackupInformation
        },
        202: {
            bodyMapper: Mappers.BackupInformation
        },
        204: {
            bodyMapper: Mappers.BackupInformation
        },
        default: {
            bodyMapper: Mappers.CloudError
        }
    },
    requestBody: Parameters.location,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.accountName,
        Parameters.databaseName,
        Parameters.collectionName
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
//# sourceMappingURL=mongoDBResources.js.map
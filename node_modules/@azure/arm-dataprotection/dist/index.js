'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link AlertsState} that the service accepts. */
exports.KnownAlertsState = void 0;
(function (KnownAlertsState) {
    /** Enabled */
    KnownAlertsState["Enabled"] = "Enabled";
    /** Disabled */
    KnownAlertsState["Disabled"] = "Disabled";
})(exports.KnownAlertsState || (exports.KnownAlertsState = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Provisioning */
    KnownProvisioningState["Provisioning"] = "Provisioning";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Unknown */
    KnownProvisioningState["Unknown"] = "Unknown";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link ResourceMoveState} that the service accepts. */
exports.KnownResourceMoveState = void 0;
(function (KnownResourceMoveState) {
    /** Unknown */
    KnownResourceMoveState["Unknown"] = "Unknown";
    /** InProgress */
    KnownResourceMoveState["InProgress"] = "InProgress";
    /** PrepareFailed */
    KnownResourceMoveState["PrepareFailed"] = "PrepareFailed";
    /** CommitFailed */
    KnownResourceMoveState["CommitFailed"] = "CommitFailed";
    /** Failed */
    KnownResourceMoveState["Failed"] = "Failed";
    /** PrepareTimedout */
    KnownResourceMoveState["PrepareTimedout"] = "PrepareTimedout";
    /** CommitTimedout */
    KnownResourceMoveState["CommitTimedout"] = "CommitTimedout";
    /** CriticalFailure */
    KnownResourceMoveState["CriticalFailure"] = "CriticalFailure";
    /** PartialSuccess */
    KnownResourceMoveState["PartialSuccess"] = "PartialSuccess";
    /** MoveSucceeded */
    KnownResourceMoveState["MoveSucceeded"] = "MoveSucceeded";
})(exports.KnownResourceMoveState || (exports.KnownResourceMoveState = {}));
/** Known values of {@link SoftDeleteState} that the service accepts. */
exports.KnownSoftDeleteState = void 0;
(function (KnownSoftDeleteState) {
    /** Soft Delete is turned off for the BackupVault */
    KnownSoftDeleteState["Off"] = "Off";
    /** Soft Delete is enabled for the BackupVault but can be turned off */
    KnownSoftDeleteState["On"] = "On";
    /** Soft Delete is permanently enabled for the BackupVault and the setting cannot be changed */
    KnownSoftDeleteState["AlwaysOn"] = "AlwaysOn";
})(exports.KnownSoftDeleteState || (exports.KnownSoftDeleteState = {}));
/** Known values of {@link ImmutabilityState} that the service accepts. */
exports.KnownImmutabilityState = void 0;
(function (KnownImmutabilityState) {
    /** Disabled */
    KnownImmutabilityState["Disabled"] = "Disabled";
    /** Unlocked */
    KnownImmutabilityState["Unlocked"] = "Unlocked";
    /** Locked */
    KnownImmutabilityState["Locked"] = "Locked";
})(exports.KnownImmutabilityState || (exports.KnownImmutabilityState = {}));
/** Known values of {@link StorageSettingStoreTypes} that the service accepts. */
exports.KnownStorageSettingStoreTypes = void 0;
(function (KnownStorageSettingStoreTypes) {
    /** ArchiveStore */
    KnownStorageSettingStoreTypes["ArchiveStore"] = "ArchiveStore";
    /** OperationalStore */
    KnownStorageSettingStoreTypes["OperationalStore"] = "OperationalStore";
    /** VaultStore */
    KnownStorageSettingStoreTypes["VaultStore"] = "VaultStore";
})(exports.KnownStorageSettingStoreTypes || (exports.KnownStorageSettingStoreTypes = {}));
/** Known values of {@link StorageSettingTypes} that the service accepts. */
exports.KnownStorageSettingTypes = void 0;
(function (KnownStorageSettingTypes) {
    /** GeoRedundant */
    KnownStorageSettingTypes["GeoRedundant"] = "GeoRedundant";
    /** LocallyRedundant */
    KnownStorageSettingTypes["LocallyRedundant"] = "LocallyRedundant";
    /** ZoneRedundant */
    KnownStorageSettingTypes["ZoneRedundant"] = "ZoneRedundant";
})(exports.KnownStorageSettingTypes || (exports.KnownStorageSettingTypes = {}));
/** Known values of {@link CrossSubscriptionRestoreState} that the service accepts. */
exports.KnownCrossSubscriptionRestoreState = void 0;
(function (KnownCrossSubscriptionRestoreState) {
    /** Disabled */
    KnownCrossSubscriptionRestoreState["Disabled"] = "Disabled";
    /** PermanentlyDisabled */
    KnownCrossSubscriptionRestoreState["PermanentlyDisabled"] = "PermanentlyDisabled";
    /** Enabled */
    KnownCrossSubscriptionRestoreState["Enabled"] = "Enabled";
})(exports.KnownCrossSubscriptionRestoreState || (exports.KnownCrossSubscriptionRestoreState = {}));
/** Known values of {@link CrossRegionRestoreState} that the service accepts. */
exports.KnownCrossRegionRestoreState = void 0;
(function (KnownCrossRegionRestoreState) {
    /** Disabled */
    KnownCrossRegionRestoreState["Disabled"] = "Disabled";
    /** Enabled */
    KnownCrossRegionRestoreState["Enabled"] = "Enabled";
})(exports.KnownCrossRegionRestoreState || (exports.KnownCrossRegionRestoreState = {}));
/** Known values of {@link SecureScoreLevel} that the service accepts. */
exports.KnownSecureScoreLevel = void 0;
(function (KnownSecureScoreLevel) {
    /** None */
    KnownSecureScoreLevel["None"] = "None";
    /** Minimum */
    KnownSecureScoreLevel["Minimum"] = "Minimum";
    /** Adequate */
    KnownSecureScoreLevel["Adequate"] = "Adequate";
    /** Maximum */
    KnownSecureScoreLevel["Maximum"] = "Maximum";
    /** NotSupported */
    KnownSecureScoreLevel["NotSupported"] = "NotSupported";
})(exports.KnownSecureScoreLevel || (exports.KnownSecureScoreLevel = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link DataStoreTypes} that the service accepts. */
exports.KnownDataStoreTypes = void 0;
(function (KnownDataStoreTypes) {
    /** OperationalStore */
    KnownDataStoreTypes["OperationalStore"] = "OperationalStore";
    /** VaultStore */
    KnownDataStoreTypes["VaultStore"] = "VaultStore";
    /** ArchiveStore */
    KnownDataStoreTypes["ArchiveStore"] = "ArchiveStore";
})(exports.KnownDataStoreTypes || (exports.KnownDataStoreTypes = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    /** ConfiguringProtection */
    KnownStatus["ConfiguringProtection"] = "ConfiguringProtection";
    /** ConfiguringProtectionFailed */
    KnownStatus["ConfiguringProtectionFailed"] = "ConfiguringProtectionFailed";
    /** ProtectionConfigured */
    KnownStatus["ProtectionConfigured"] = "ProtectionConfigured";
    /** ProtectionStopped */
    KnownStatus["ProtectionStopped"] = "ProtectionStopped";
    /** SoftDeleted */
    KnownStatus["SoftDeleted"] = "SoftDeleted";
    /** SoftDeleting */
    KnownStatus["SoftDeleting"] = "SoftDeleting";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link CurrentProtectionState} that the service accepts. */
exports.KnownCurrentProtectionState = void 0;
(function (KnownCurrentProtectionState) {
    /** Invalid */
    KnownCurrentProtectionState["Invalid"] = "Invalid";
    /** NotProtected */
    KnownCurrentProtectionState["NotProtected"] = "NotProtected";
    /** ConfiguringProtection */
    KnownCurrentProtectionState["ConfiguringProtection"] = "ConfiguringProtection";
    /** ProtectionConfigured */
    KnownCurrentProtectionState["ProtectionConfigured"] = "ProtectionConfigured";
    /** BackupSchedulesSuspended */
    KnownCurrentProtectionState["BackupSchedulesSuspended"] = "BackupSchedulesSuspended";
    /** RetentionSchedulesSuspended */
    KnownCurrentProtectionState["RetentionSchedulesSuspended"] = "RetentionSchedulesSuspended";
    /** ProtectionStopped */
    KnownCurrentProtectionState["ProtectionStopped"] = "ProtectionStopped";
    /** ProtectionError */
    KnownCurrentProtectionState["ProtectionError"] = "ProtectionError";
    /** ConfiguringProtectionFailed */
    KnownCurrentProtectionState["ConfiguringProtectionFailed"] = "ConfiguringProtectionFailed";
    /** SoftDeleting */
    KnownCurrentProtectionState["SoftDeleting"] = "SoftDeleting";
    /** SoftDeleted */
    KnownCurrentProtectionState["SoftDeleted"] = "SoftDeleted";
    /** UpdatingProtection */
    KnownCurrentProtectionState["UpdatingProtection"] = "UpdatingProtection";
})(exports.KnownCurrentProtectionState || (exports.KnownCurrentProtectionState = {}));
/** Known values of {@link ValidationType} that the service accepts. */
exports.KnownValidationType = void 0;
(function (KnownValidationType) {
    /** ShallowValidation */
    KnownValidationType["ShallowValidation"] = "ShallowValidation";
    /** DeepValidation */
    KnownValidationType["DeepValidation"] = "DeepValidation";
})(exports.KnownValidationType || (exports.KnownValidationType = {}));
/** Known values of {@link RehydrationPriority} that the service accepts. */
exports.KnownRehydrationPriority = void 0;
(function (KnownRehydrationPriority) {
    /** Invalid */
    KnownRehydrationPriority["Invalid"] = "Invalid";
    /** High */
    KnownRehydrationPriority["High"] = "High";
    /** Standard */
    KnownRehydrationPriority["Standard"] = "Standard";
})(exports.KnownRehydrationPriority || (exports.KnownRehydrationPriority = {}));
/** Known values of {@link RecoveryOption} that the service accepts. */
exports.KnownRecoveryOption = void 0;
(function (KnownRecoveryOption) {
    /** FailIfExists */
    KnownRecoveryOption["FailIfExists"] = "FailIfExists";
})(exports.KnownRecoveryOption || (exports.KnownRecoveryOption = {}));
/** Known values of {@link SourceDataStoreType} that the service accepts. */
exports.KnownSourceDataStoreType = void 0;
(function (KnownSourceDataStoreType) {
    /** ArchiveStore */
    KnownSourceDataStoreType["ArchiveStore"] = "ArchiveStore";
    /** SnapshotStore */
    KnownSourceDataStoreType["SnapshotStore"] = "SnapshotStore";
    /** OperationalStore */
    KnownSourceDataStoreType["OperationalStore"] = "OperationalStore";
    /** VaultStore */
    KnownSourceDataStoreType["VaultStore"] = "VaultStore";
})(exports.KnownSourceDataStoreType || (exports.KnownSourceDataStoreType = {}));
/** Known values of {@link SyncType} that the service accepts. */
exports.KnownSyncType = void 0;
(function (KnownSyncType) {
    /** Default */
    KnownSyncType["Default"] = "Default";
    /** ForceResync */
    KnownSyncType["ForceResync"] = "ForceResync";
})(exports.KnownSyncType || (exports.KnownSyncType = {}));
/** Known values of {@link RestoreSourceDataStoreType} that the service accepts. */
exports.KnownRestoreSourceDataStoreType = void 0;
(function (KnownRestoreSourceDataStoreType) {
    /** OperationalStore */
    KnownRestoreSourceDataStoreType["OperationalStore"] = "OperationalStore";
    /** VaultStore */
    KnownRestoreSourceDataStoreType["VaultStore"] = "VaultStore";
    /** ArchiveStore */
    KnownRestoreSourceDataStoreType["ArchiveStore"] = "ArchiveStore";
})(exports.KnownRestoreSourceDataStoreType || (exports.KnownRestoreSourceDataStoreType = {}));
/** Known values of {@link RehydrationStatus} that the service accepts. */
exports.KnownRehydrationStatus = void 0;
(function (KnownRehydrationStatus) {
    /** CreateINProgress */
    KnownRehydrationStatus["CreateINProgress"] = "CREATE_IN_PROGRESS";
    /** Completed */
    KnownRehydrationStatus["Completed"] = "COMPLETED";
    /** DeleteINProgress */
    KnownRehydrationStatus["DeleteINProgress"] = "DELETE_IN_PROGRESS";
    /** Deleted */
    KnownRehydrationStatus["Deleted"] = "DELETED";
    /** Failed */
    KnownRehydrationStatus["Failed"] = "FAILED";
})(exports.KnownRehydrationStatus || (exports.KnownRehydrationStatus = {}));
/** Known values of {@link FeatureType} that the service accepts. */
exports.KnownFeatureType = void 0;
(function (KnownFeatureType) {
    /** Invalid */
    KnownFeatureType["Invalid"] = "Invalid";
    /** DataSourceType */
    KnownFeatureType["DataSourceType"] = "DataSourceType";
})(exports.KnownFeatureType || (exports.KnownFeatureType = {}));
/** Known values of {@link FeatureSupportStatus} that the service accepts. */
exports.KnownFeatureSupportStatus = void 0;
(function (KnownFeatureSupportStatus) {
    /** Invalid */
    KnownFeatureSupportStatus["Invalid"] = "Invalid";
    /** NotSupported */
    KnownFeatureSupportStatus["NotSupported"] = "NotSupported";
    /** AlphaPreview */
    KnownFeatureSupportStatus["AlphaPreview"] = "AlphaPreview";
    /** PrivatePreview */
    KnownFeatureSupportStatus["PrivatePreview"] = "PrivatePreview";
    /** PublicPreview */
    KnownFeatureSupportStatus["PublicPreview"] = "PublicPreview";
    /** GenerallyAvailable */
    KnownFeatureSupportStatus["GenerallyAvailable"] = "GenerallyAvailable";
})(exports.KnownFeatureSupportStatus || (exports.KnownFeatureSupportStatus = {}));
/** Known values of {@link PersistentVolumeRestoreMode} that the service accepts. */
exports.KnownPersistentVolumeRestoreMode = void 0;
(function (KnownPersistentVolumeRestoreMode) {
    /** RestoreWithVolumeData */
    KnownPersistentVolumeRestoreMode["RestoreWithVolumeData"] = "RestoreWithVolumeData";
    /** RestoreWithoutVolumeData */
    KnownPersistentVolumeRestoreMode["RestoreWithoutVolumeData"] = "RestoreWithoutVolumeData";
})(exports.KnownPersistentVolumeRestoreMode || (exports.KnownPersistentVolumeRestoreMode = {}));
/** Known values of {@link ExistingResourcePolicy} that the service accepts. */
exports.KnownExistingResourcePolicy = void 0;
(function (KnownExistingResourcePolicy) {
    /** Skip */
    KnownExistingResourcePolicy["Skip"] = "Skip";
    /** Patch */
    KnownExistingResourcePolicy["Patch"] = "Patch";
})(exports.KnownExistingResourcePolicy || (exports.KnownExistingResourcePolicy = {}));
/** Known values of {@link RestoreTargetLocationType} that the service accepts. */
exports.KnownRestoreTargetLocationType = void 0;
(function (KnownRestoreTargetLocationType) {
    /** Invalid */
    KnownRestoreTargetLocationType["Invalid"] = "Invalid";
    /** AzureBlobs */
    KnownRestoreTargetLocationType["AzureBlobs"] = "AzureBlobs";
    /** AzureFiles */
    KnownRestoreTargetLocationType["AzureFiles"] = "AzureFiles";
})(exports.KnownRestoreTargetLocationType || (exports.KnownRestoreTargetLocationType = {}));
/** Known values of {@link AbsoluteMarker} that the service accepts. */
exports.KnownAbsoluteMarker = void 0;
(function (KnownAbsoluteMarker) {
    /** AllBackup */
    KnownAbsoluteMarker["AllBackup"] = "AllBackup";
    /** FirstOfDay */
    KnownAbsoluteMarker["FirstOfDay"] = "FirstOfDay";
    /** FirstOfMonth */
    KnownAbsoluteMarker["FirstOfMonth"] = "FirstOfMonth";
    /** FirstOfWeek */
    KnownAbsoluteMarker["FirstOfWeek"] = "FirstOfWeek";
    /** FirstOfYear */
    KnownAbsoluteMarker["FirstOfYear"] = "FirstOfYear";
})(exports.KnownAbsoluteMarker || (exports.KnownAbsoluteMarker = {}));
/** Known values of {@link DayOfWeek} that the service accepts. */
exports.KnownDayOfWeek = void 0;
(function (KnownDayOfWeek) {
    /** Friday */
    KnownDayOfWeek["Friday"] = "Friday";
    /** Monday */
    KnownDayOfWeek["Monday"] = "Monday";
    /** Saturday */
    KnownDayOfWeek["Saturday"] = "Saturday";
    /** Sunday */
    KnownDayOfWeek["Sunday"] = "Sunday";
    /** Thursday */
    KnownDayOfWeek["Thursday"] = "Thursday";
    /** Tuesday */
    KnownDayOfWeek["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownDayOfWeek["Wednesday"] = "Wednesday";
})(exports.KnownDayOfWeek || (exports.KnownDayOfWeek = {}));
/** Known values of {@link Month} that the service accepts. */
exports.KnownMonth = void 0;
(function (KnownMonth) {
    /** April */
    KnownMonth["April"] = "April";
    /** August */
    KnownMonth["August"] = "August";
    /** December */
    KnownMonth["December"] = "December";
    /** February */
    KnownMonth["February"] = "February";
    /** January */
    KnownMonth["January"] = "January";
    /** July */
    KnownMonth["July"] = "July";
    /** June */
    KnownMonth["June"] = "June";
    /** March */
    KnownMonth["March"] = "March";
    /** May */
    KnownMonth["May"] = "May";
    /** November */
    KnownMonth["November"] = "November";
    /** October */
    KnownMonth["October"] = "October";
    /** September */
    KnownMonth["September"] = "September";
})(exports.KnownMonth || (exports.KnownMonth = {}));
/** Known values of {@link WeekNumber} that the service accepts. */
exports.KnownWeekNumber = void 0;
(function (KnownWeekNumber) {
    /** First */
    KnownWeekNumber["First"] = "First";
    /** Fourth */
    KnownWeekNumber["Fourth"] = "Fourth";
    /** Last */
    KnownWeekNumber["Last"] = "Last";
    /** Second */
    KnownWeekNumber["Second"] = "Second";
    /** Third */
    KnownWeekNumber["Third"] = "Third";
})(exports.KnownWeekNumber || (exports.KnownWeekNumber = {}));
/** Known values of {@link SecretStoreType} that the service accepts. */
exports.KnownSecretStoreType = void 0;
(function (KnownSecretStoreType) {
    /** Invalid */
    KnownSecretStoreType["Invalid"] = "Invalid";
    /** AzureKeyVault */
    KnownSecretStoreType["AzureKeyVault"] = "AzureKeyVault";
})(exports.KnownSecretStoreType || (exports.KnownSecretStoreType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const BackupVault = {
    type: {
        name: "Composite",
        className: "BackupVault",
        modelProperties: {
            monitoringSettings: {
                serializedName: "monitoringSettings",
                type: {
                    name: "Composite",
                    className: "MonitoringSettings"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceMoveState: {
                serializedName: "resourceMoveState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceMoveDetails: {
                serializedName: "resourceMoveDetails",
                type: {
                    name: "Composite",
                    className: "ResourceMoveDetails"
                }
            },
            securitySettings: {
                serializedName: "securitySettings",
                type: {
                    name: "Composite",
                    className: "SecuritySettings"
                }
            },
            storageSettings: {
                serializedName: "storageSettings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageSetting"
                        }
                    }
                }
            },
            isVaultProtectedByResourceGuard: {
                serializedName: "isVaultProtectedByResourceGuard",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            featureSettings: {
                serializedName: "featureSettings",
                type: {
                    name: "Composite",
                    className: "FeatureSettings"
                }
            },
            secureScore: {
                serializedName: "secureScore",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MonitoringSettings = {
    type: {
        name: "Composite",
        className: "MonitoringSettings",
        modelProperties: {
            azureMonitorAlertSettings: {
                serializedName: "azureMonitorAlertSettings",
                type: {
                    name: "Composite",
                    className: "AzureMonitorAlertSettings"
                }
            }
        }
    }
};
const AzureMonitorAlertSettings = {
    type: {
        name: "Composite",
        className: "AzureMonitorAlertSettings",
        modelProperties: {
            alertsForAllJobFailures: {
                serializedName: "alertsForAllJobFailures",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceMoveDetails = {
    type: {
        name: "Composite",
        className: "ResourceMoveDetails",
        modelProperties: {
            operationId: {
                serializedName: "operationId",
                type: {
                    name: "String"
                }
            },
            startTimeUtc: {
                serializedName: "startTimeUtc",
                type: {
                    name: "String"
                }
            },
            completionTimeUtc: {
                serializedName: "completionTimeUtc",
                type: {
                    name: "String"
                }
            },
            sourceResourcePath: {
                serializedName: "sourceResourcePath",
                type: {
                    name: "String"
                }
            },
            targetResourcePath: {
                serializedName: "targetResourcePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecuritySettings = {
    type: {
        name: "Composite",
        className: "SecuritySettings",
        modelProperties: {
            softDeleteSettings: {
                serializedName: "softDeleteSettings",
                type: {
                    name: "Composite",
                    className: "SoftDeleteSettings"
                }
            },
            immutabilitySettings: {
                serializedName: "immutabilitySettings",
                type: {
                    name: "Composite",
                    className: "ImmutabilitySettings"
                }
            }
        }
    }
};
const SoftDeleteSettings = {
    type: {
        name: "Composite",
        className: "SoftDeleteSettings",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            retentionDurationInDays: {
                serializedName: "retentionDurationInDays",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ImmutabilitySettings = {
    type: {
        name: "Composite",
        className: "ImmutabilitySettings",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageSetting = {
    type: {
        name: "Composite",
        className: "StorageSetting",
        modelProperties: {
            datastoreType: {
                serializedName: "datastoreType",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FeatureSettings = {
    type: {
        name: "Composite",
        className: "FeatureSettings",
        modelProperties: {
            crossSubscriptionRestoreSettings: {
                serializedName: "crossSubscriptionRestoreSettings",
                type: {
                    name: "Composite",
                    className: "CrossSubscriptionRestoreSettings"
                }
            },
            crossRegionRestoreSettings: {
                serializedName: "crossRegionRestoreSettings",
                type: {
                    name: "Composite",
                    className: "CrossRegionRestoreSettings"
                }
            }
        }
    }
};
const CrossSubscriptionRestoreSettings = {
    type: {
        name: "Composite",
        className: "CrossSubscriptionRestoreSettings",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CrossRegionRestoreSettings = {
    type: {
        name: "Composite",
        className: "CrossRegionRestoreSettings",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppIdentityDetails = {
    type: {
        name: "Composite",
        className: "DppIdentityDetails",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const DppBaseTrackedResource = {
    type: {
        name: "Composite",
        className: "DppBaseTrackedResource",
        modelProperties: {
            eTag: {
                serializedName: "eTag",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DppResourceList = {
    type: {
        name: "Composite",
        className: "DppResourceList",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorModel"
                        }
                    }
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationExtendedInfo = {
    type: {
        name: "Composite",
        className: "OperationExtendedInfo",
        uberParent: "OperationExtendedInfo",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationResource = {
    type: {
        name: "Composite",
        className: "OperationResource",
        modelProperties: {
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OperationExtendedInfo"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PatchResourceRequestInput = {
    type: {
        name: "Composite",
        className: "PatchResourceRequestInput",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "DppIdentityDetails"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PatchBackupVaultInput"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PatchBackupVaultInput = {
    type: {
        name: "Composite",
        className: "PatchBackupVaultInput",
        modelProperties: {
            monitoringSettings: {
                serializedName: "monitoringSettings",
                type: {
                    name: "Composite",
                    className: "MonitoringSettings"
                }
            },
            securitySettings: {
                serializedName: "securitySettings",
                type: {
                    name: "Composite",
                    className: "SecuritySettings"
                }
            },
            featureSettings: {
                serializedName: "featureSettings",
                type: {
                    name: "Composite",
                    className: "FeatureSettings"
                }
            }
        }
    }
};
const CheckNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResult",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FeatureValidationRequestBase = {
    type: {
        name: "Composite",
        className: "FeatureValidationRequestBase",
        uberParent: "FeatureValidationRequestBase",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FeatureValidationResponseBase = {
    type: {
        name: "Composite",
        className: "FeatureValidationResponseBase",
        uberParent: "FeatureValidationResponseBase",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientDiscoveryResponse = {
    type: {
        name: "Composite",
        className: "ClientDiscoveryResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientDiscoveryValueForSingleApi"
                        }
                    }
                }
            }
        }
    }
};
const ClientDiscoveryValueForSingleApi = {
    type: {
        name: "Composite",
        className: "ClientDiscoveryValueForSingleApi",
        modelProperties: {
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "ClientDiscoveryDisplay"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ClientDiscoveryForProperties"
                }
            }
        }
    }
};
const ClientDiscoveryDisplay = {
    type: {
        name: "Composite",
        className: "ClientDiscoveryDisplay",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientDiscoveryForProperties = {
    type: {
        name: "Composite",
        className: "ClientDiscoveryForProperties",
        modelProperties: {
            serviceSpecification: {
                serializedName: "serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ClientDiscoveryForServiceSpecification"
                }
            }
        }
    }
};
const ClientDiscoveryForServiceSpecification = {
    type: {
        name: "Composite",
        className: "ClientDiscoveryForServiceSpecification",
        modelProperties: {
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientDiscoveryForLogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const ClientDiscoveryForLogSpecification = {
    type: {
        name: "Composite",
        className: "ClientDiscoveryForLogSpecification",
        modelProperties: {
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BaseBackupPolicy = {
    type: {
        name: "Composite",
        className: "BaseBackupPolicy",
        uberParent: "BaseBackupPolicy",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            datasourceTypes: {
                serializedName: "datasourceTypes",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppResource = {
    type: {
        name: "Composite",
        className: "DppResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const BackupInstance = {
    type: {
        name: "Composite",
        className: "BackupInstance",
        modelProperties: {
            friendlyName: {
                serializedName: "friendlyName",
                type: {
                    name: "String"
                }
            },
            dataSourceInfo: {
                serializedName: "dataSourceInfo",
                type: {
                    name: "Composite",
                    className: "Datasource"
                }
            },
            dataSourceSetInfo: {
                serializedName: "dataSourceSetInfo",
                type: {
                    name: "Composite",
                    className: "DatasourceSet"
                }
            },
            policyInfo: {
                serializedName: "policyInfo",
                type: {
                    name: "Composite",
                    className: "PolicyInfo"
                }
            },
            protectionStatus: {
                serializedName: "protectionStatus",
                type: {
                    name: "Composite",
                    className: "ProtectionStatusDetails"
                }
            },
            currentProtectionState: {
                serializedName: "currentProtectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            protectionErrorDetails: {
                serializedName: "protectionErrorDetails",
                type: {
                    name: "Composite",
                    className: "UserFacingError"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            datasourceAuthCredentials: {
                serializedName: "datasourceAuthCredentials",
                type: {
                    name: "Composite",
                    className: "AuthCredentials"
                }
            },
            validationType: {
                serializedName: "validationType",
                type: {
                    name: "String"
                }
            },
            identityDetails: {
                serializedName: "identityDetails",
                type: {
                    name: "Composite",
                    className: "IdentityDetails"
                }
            },
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Datasource = {
    type: {
        name: "Composite",
        className: "Datasource",
        modelProperties: {
            datasourceType: {
                serializedName: "datasourceType",
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                type: {
                    name: "String"
                }
            },
            resourceID: {
                serializedName: "resourceID",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceLocation: {
                serializedName: "resourceLocation",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            resourceUri: {
                serializedName: "resourceUri",
                type: {
                    name: "String"
                }
            },
            resourceProperties: {
                serializedName: "resourceProperties",
                type: {
                    name: "Composite",
                    className: "BaseResourceProperties"
                }
            }
        }
    }
};
const BaseResourceProperties = {
    serializedName: "BaseResourceProperties",
    type: {
        name: "Composite",
        className: "BaseResourceProperties",
        uberParent: "BaseResourceProperties",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatasourceSet = {
    type: {
        name: "Composite",
        className: "DatasourceSet",
        modelProperties: {
            datasourceType: {
                serializedName: "datasourceType",
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                type: {
                    name: "String"
                }
            },
            resourceID: {
                serializedName: "resourceID",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceLocation: {
                serializedName: "resourceLocation",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            resourceUri: {
                serializedName: "resourceUri",
                type: {
                    name: "String"
                }
            },
            resourceProperties: {
                serializedName: "resourceProperties",
                type: {
                    name: "Composite",
                    className: "BaseResourceProperties"
                }
            }
        }
    }
};
const PolicyInfo = {
    type: {
        name: "Composite",
        className: "PolicyInfo",
        modelProperties: {
            policyId: {
                serializedName: "policyId",
                required: true,
                type: {
                    name: "String"
                }
            },
            policyVersion: {
                serializedName: "policyVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            policyParameters: {
                serializedName: "policyParameters",
                type: {
                    name: "Composite",
                    className: "PolicyParameters"
                }
            }
        }
    }
};
const PolicyParameters = {
    type: {
        name: "Composite",
        className: "PolicyParameters",
        modelProperties: {
            dataStoreParametersList: {
                serializedName: "dataStoreParametersList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataStoreParameters"
                        }
                    }
                }
            },
            backupDatasourceParametersList: {
                serializedName: "backupDatasourceParametersList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupDatasourceParameters"
                        }
                    }
                }
            }
        }
    }
};
const DataStoreParameters = {
    type: {
        name: "Composite",
        className: "DataStoreParameters",
        uberParent: "DataStoreParameters",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataStoreType: {
                serializedName: "dataStoreType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupDatasourceParameters = {
    type: {
        name: "Composite",
        className: "BackupDatasourceParameters",
        uberParent: "BackupDatasourceParameters",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProtectionStatusDetails = {
    type: {
        name: "Composite",
        className: "ProtectionStatusDetails",
        modelProperties: {
            errorDetails: {
                serializedName: "errorDetails",
                type: {
                    name: "Composite",
                    className: "UserFacingError"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserFacingError = {
    type: {
        name: "Composite",
        className: "UserFacingError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserFacingError"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innerError",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            isRetryable: {
                serializedName: "isRetryable",
                type: {
                    name: "Boolean"
                }
            },
            isUserError: {
                serializedName: "isUserError",
                type: {
                    name: "Boolean"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            recommendedAction: {
                serializedName: "recommendedAction",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            additionalInfo: {
                serializedName: "additionalInfo",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            embeddedInnerError: {
                serializedName: "embeddedInnerError",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const AuthCredentials = {
    type: {
        name: "Composite",
        className: "AuthCredentials",
        uberParent: "AuthCredentials",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityDetails = {
    type: {
        name: "Composite",
        className: "IdentityDetails",
        modelProperties: {
            useSystemAssignedIdentity: {
                serializedName: "useSystemAssignedIdentity",
                type: {
                    name: "Boolean"
                }
            },
            userAssignedIdentityArmUrl: {
                serializedName: "userAssignedIdentityArmUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppProxyResource = {
    type: {
        name: "Composite",
        className: "DppProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const TriggerBackupRequest = {
    type: {
        name: "Composite",
        className: "TriggerBackupRequest",
        modelProperties: {
            backupRuleOptions: {
                serializedName: "backupRuleOptions",
                type: {
                    name: "Composite",
                    className: "AdHocBackupRuleOptions"
                }
            }
        }
    }
};
const AdHocBackupRuleOptions = {
    type: {
        name: "Composite",
        className: "AdHocBackupRuleOptions",
        modelProperties: {
            ruleName: {
                serializedName: "ruleName",
                required: true,
                type: {
                    name: "String"
                }
            },
            triggerOption: {
                serializedName: "triggerOption",
                type: {
                    name: "Composite",
                    className: "AdhocBackupTriggerOption"
                }
            }
        }
    }
};
const AdhocBackupTriggerOption = {
    type: {
        name: "Composite",
        className: "AdhocBackupTriggerOption",
        modelProperties: {
            retentionTagOverride: {
                serializedName: "retentionTagOverride",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateForBackupRequest = {
    type: {
        name: "Composite",
        className: "ValidateForBackupRequest",
        modelProperties: {
            backupInstance: {
                serializedName: "backupInstance",
                type: {
                    name: "Composite",
                    className: "BackupInstance"
                }
            }
        }
    }
};
const AzureBackupRecoveryPoint = {
    type: {
        name: "Composite",
        className: "AzureBackupRecoveryPoint",
        uberParent: "AzureBackupRecoveryPoint",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureBackupRehydrationRequest = {
    type: {
        name: "Composite",
        className: "AzureBackupRehydrationRequest",
        modelProperties: {
            recoveryPointId: {
                serializedName: "recoveryPointId",
                required: true,
                type: {
                    name: "String"
                }
            },
            rehydrationPriority: {
                serializedName: "rehydrationPriority",
                type: {
                    name: "String"
                }
            },
            rehydrationRetentionDuration: {
                serializedName: "rehydrationRetentionDuration",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureBackupRestoreRequest = {
    type: {
        name: "Composite",
        className: "AzureBackupRestoreRequest",
        uberParent: "AzureBackupRestoreRequest",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreTargetInfo: {
                serializedName: "restoreTargetInfo",
                type: {
                    name: "Composite",
                    className: "RestoreTargetInfoBase"
                }
            },
            sourceDataStoreType: {
                serializedName: "sourceDataStoreType",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceResourceId: {
                serializedName: "sourceResourceId",
                type: {
                    name: "String"
                }
            },
            identityDetails: {
                serializedName: "identityDetails",
                type: {
                    name: "Composite",
                    className: "IdentityDetails"
                }
            }
        }
    }
};
const RestoreTargetInfoBase = {
    type: {
        name: "Composite",
        className: "RestoreTargetInfoBase",
        uberParent: "RestoreTargetInfoBase",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            },
            recoveryOption: {
                serializedName: "recoveryOption",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreLocation: {
                serializedName: "restoreLocation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SyncBackupInstanceRequest = {
    type: {
        name: "Composite",
        className: "SyncBackupInstanceRequest",
        modelProperties: {
            syncType: {
                serializedName: "syncType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ValidateRestoreRequestObject = {
    type: {
        name: "Composite",
        className: "ValidateRestoreRequestObject",
        modelProperties: {
            restoreRequestObject: {
                serializedName: "restoreRequestObject",
                type: {
                    name: "Composite",
                    className: "AzureBackupRestoreRequest"
                }
            }
        }
    }
};
const AzureBackupJob = {
    type: {
        name: "Composite",
        className: "AzureBackupJob",
        modelProperties: {
            activityID: {
                serializedName: "activityID",
                required: true,
                type: {
                    name: "String"
                }
            },
            backupInstanceFriendlyName: {
                serializedName: "backupInstanceFriendlyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            backupInstanceId: {
                serializedName: "backupInstanceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dataSourceId: {
                serializedName: "dataSourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceLocation: {
                serializedName: "dataSourceLocation",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceName: {
                serializedName: "dataSourceName",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceSetName: {
                serializedName: "dataSourceSetName",
                type: {
                    name: "String"
                }
            },
            dataSourceType: {
                serializedName: "dataSourceType",
                required: true,
                type: {
                    name: "String"
                }
            },
            duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            errorDetails: {
                serializedName: "errorDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserFacingError"
                        }
                    }
                }
            },
            extendedInfo: {
                serializedName: "extendedInfo",
                type: {
                    name: "Composite",
                    className: "JobExtendedInfo"
                }
            },
            isUserTriggered: {
                serializedName: "isUserTriggered",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            operation: {
                serializedName: "operation",
                required: true,
                type: {
                    name: "String"
                }
            },
            operationCategory: {
                serializedName: "operationCategory",
                required: true,
                type: {
                    name: "String"
                }
            },
            policyId: {
                serializedName: "policyId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            policyName: {
                serializedName: "policyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            progressEnabled: {
                serializedName: "progressEnabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            progressUrl: {
                serializedName: "progressUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rehydrationPriority: {
                serializedName: "rehydrationPriority",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            restoreType: {
                serializedName: "restoreType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourceResourceGroup: {
                serializedName: "sourceResourceGroup",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceSubscriptionID: {
                serializedName: "sourceSubscriptionID",
                required: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                required: true,
                type: {
                    name: "String"
                }
            },
            supportedActions: {
                serializedName: "supportedActions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vaultName: {
                serializedName: "vaultName",
                required: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            sourceDataStoreName: {
                serializedName: "sourceDataStoreName",
                type: {
                    name: "String"
                }
            },
            destinationDataStoreName: {
                serializedName: "destinationDataStoreName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobExtendedInfo = {
    type: {
        name: "Composite",
        className: "JobExtendedInfo",
        modelProperties: {
            additionalDetails: {
                serializedName: "additionalDetails",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            backupInstanceState: {
                serializedName: "backupInstanceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dataTransferredInBytes: {
                serializedName: "dataTransferredInBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            recoveryDestination: {
                serializedName: "recoveryDestination",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourceRecoverPoint: {
                serializedName: "sourceRecoverPoint",
                type: {
                    name: "Composite",
                    className: "RestoreJobRecoveryPointDetails"
                }
            },
            subTasks: {
                serializedName: "subTasks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobSubTask"
                        }
                    }
                }
            },
            targetRecoverPoint: {
                serializedName: "targetRecoverPoint",
                type: {
                    name: "Composite",
                    className: "RestoreJobRecoveryPointDetails"
                }
            }
        }
    }
};
const RestoreJobRecoveryPointDetails = {
    type: {
        name: "Composite",
        className: "RestoreJobRecoveryPointDetails",
        modelProperties: {
            recoveryPointID: {
                serializedName: "recoveryPointID",
                type: {
                    name: "String"
                }
            },
            recoveryPointTime: {
                serializedName: "recoveryPointTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const JobSubTask = {
    type: {
        name: "Composite",
        className: "JobSubTask",
        modelProperties: {
            additionalDetails: {
                serializedName: "additionalDetails",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            taskId: {
                serializedName: "taskId",
                required: true,
                type: {
                    name: "Number"
                }
            },
            taskName: {
                serializedName: "taskName",
                required: true,
                type: {
                    name: "String"
                }
            },
            taskProgress: {
                serializedName: "taskProgress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            taskStatus: {
                serializedName: "taskStatus",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureBackupFindRestorableTimeRangesRequest = {
    type: {
        name: "Composite",
        className: "AzureBackupFindRestorableTimeRangesRequest",
        modelProperties: {
            sourceDataStoreType: {
                serializedName: "sourceDataStoreType",
                required: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureBackupFindRestorableTimeRangesResponse = {
    type: {
        name: "Composite",
        className: "AzureBackupFindRestorableTimeRangesResponse",
        modelProperties: {
            restorableTimeRanges: {
                serializedName: "restorableTimeRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RestorableTimeRange"
                        }
                    }
                }
            },
            objectType: {
                serializedName: "objectType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RestorableTimeRange = {
    type: {
        name: "Composite",
        className: "RestorableTimeRange",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                required: true,
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExportJobsResult = {
    type: {
        name: "Composite",
        className: "ExportJobsResult",
        modelProperties: {
            blobUrl: {
                serializedName: "blobUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            blobSasKey: {
                serializedName: "blobSasKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            excelFileBlobUrl: {
                serializedName: "excelFileBlobUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            excelFileBlobSasKey: {
                serializedName: "excelFileBlobSasKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletionInfo = {
    type: {
        name: "Composite",
        className: "DeletionInfo",
        modelProperties: {
            deletionTime: {
                serializedName: "deletionTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            billingEndDate: {
                serializedName: "billingEndDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scheduledPurgeTime: {
                serializedName: "scheduledPurgeTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deleteActivityID: {
                serializedName: "deleteActivityID",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGuard = {
    type: {
        name: "Composite",
        className: "ResourceGuard",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            allowAutoApprovals: {
                serializedName: "allowAutoApprovals",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            resourceGuardOperations: {
                serializedName: "resourceGuardOperations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceGuardOperation"
                        }
                    }
                }
            },
            vaultCriticalOperationExclusionList: {
                serializedName: "vaultCriticalOperationExclusionList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGuardOperation = {
    type: {
        name: "Composite",
        className: "ResourceGuardOperation",
        modelProperties: {
            vaultCriticalOperation: {
                serializedName: "vaultCriticalOperation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requestResourceType: {
                serializedName: "requestResourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppTrackedResourceList = {
    type: {
        name: "Composite",
        className: "DppTrackedResourceList",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PatchResourceGuardInput = {
    type: {
        name: "Composite",
        className: "PatchResourceGuardInput",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DppBaseResourceList = {
    type: {
        name: "Composite",
        className: "DppBaseResourceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DppBaseResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppBaseResource = {
    type: {
        name: "Composite",
        className: "DppBaseResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGuardProxyBase = {
    type: {
        name: "Composite",
        className: "ResourceGuardProxyBase",
        modelProperties: {
            resourceGuardResourceId: {
                serializedName: "resourceGuardResourceId",
                type: {
                    name: "String"
                }
            },
            resourceGuardOperationDetails: {
                serializedName: "resourceGuardOperationDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceGuardOperationDetail"
                        }
                    }
                }
            },
            lastUpdatedTime: {
                serializedName: "lastUpdatedTime",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceGuardOperationDetail = {
    type: {
        name: "Composite",
        className: "ResourceGuardOperationDetail",
        modelProperties: {
            vaultCriticalOperation: {
                serializedName: "vaultCriticalOperation",
                type: {
                    name: "String"
                }
            },
            defaultResourceRequest: {
                serializedName: "defaultResourceRequest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UnlockDeleteRequest = {
    type: {
        name: "Composite",
        className: "UnlockDeleteRequest",
        modelProperties: {
            resourceGuardOperationRequests: {
                serializedName: "resourceGuardOperationRequests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            resourceToBeDeleted: {
                serializedName: "resourceToBeDeleted",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UnlockDeleteResponse = {
    type: {
        name: "Composite",
        className: "UnlockDeleteResponse",
        modelProperties: {
            unlockDeleteExpiryTime: {
                serializedName: "unlockDeleteExpiryTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeleteOption = {
    type: {
        name: "Composite",
        className: "DeleteOption",
        uberParent: "DeleteOption",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecoveryPointsFilters = {
    type: {
        name: "Composite",
        className: "RecoveryPointsFilters",
        modelProperties: {
            restorePointDataStoreId: {
                serializedName: "restorePointDataStoreId",
                type: {
                    name: "String"
                }
            },
            isVisible: {
                serializedName: "isVisible",
                type: {
                    name: "Boolean"
                }
            },
            startDate: {
                serializedName: "startDate",
                type: {
                    name: "String"
                }
            },
            endDate: {
                serializedName: "endDate",
                type: {
                    name: "String"
                }
            },
            extendedInfo: {
                serializedName: "extendedInfo",
                type: {
                    name: "Boolean"
                }
            },
            restorePointState: {
                serializedName: "restorePointState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdhocBasedTaggingCriteria = {
    type: {
        name: "Composite",
        className: "AdhocBasedTaggingCriteria",
        modelProperties: {
            tagInfo: {
                serializedName: "tagInfo",
                type: {
                    name: "Composite",
                    className: "RetentionTag"
                }
            }
        }
    }
};
const RetentionTag = {
    type: {
        name: "Composite",
        className: "RetentionTag",
        modelProperties: {
            eTag: {
                serializedName: "eTag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tagName: {
                serializedName: "tagName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggerContext = {
    type: {
        name: "Composite",
        className: "TriggerContext",
        uberParent: "TriggerContext",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecoveryPointDataStoreDetails = {
    type: {
        name: "Composite",
        className: "RecoveryPointDataStoreDetails",
        modelProperties: {
            creationTime: {
                serializedName: "creationTime",
                type: {
                    name: "DateTime"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "DateTime"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            metaData: {
                serializedName: "metaData",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            visible: {
                serializedName: "visible",
                type: {
                    name: "Boolean"
                }
            },
            rehydrationExpiryTime: {
                serializedName: "rehydrationExpiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            rehydrationStatus: {
                serializedName: "rehydrationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppWorkerRequest = {
    type: {
        name: "Composite",
        className: "DppWorkerRequest",
        modelProperties: {
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            },
            supportedGroupVersions: {
                serializedName: "supportedGroupVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cultureInfo: {
                serializedName: "cultureInfo",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            httpMethod: {
                serializedName: "httpMethod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupParameters = {
    type: {
        name: "Composite",
        className: "BackupParameters",
        uberParent: "BackupParameters",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataStoreInfoBase = {
    type: {
        name: "Composite",
        className: "DataStoreInfoBase",
        modelProperties: {
            dataStoreType: {
                serializedName: "dataStoreType",
                required: true,
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BasePolicyRule = {
    type: {
        name: "Composite",
        className: "BasePolicyRule",
        uberParent: "BasePolicyRule",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NamespacedNameResource = {
    type: {
        name: "Composite",
        className: "NamespacedNameResource",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            namespace: {
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SourceLifeCycle = {
    type: {
        name: "Composite",
        className: "SourceLifeCycle",
        modelProperties: {
            deleteAfter: {
                serializedName: "deleteAfter",
                type: {
                    name: "Composite",
                    className: "DeleteOption"
                }
            },
            sourceDataStore: {
                serializedName: "sourceDataStore",
                type: {
                    name: "Composite",
                    className: "DataStoreInfoBase"
                }
            },
            targetDataStoreCopySettings: {
                serializedName: "targetDataStoreCopySettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TargetCopySetting"
                        }
                    }
                }
            }
        }
    }
};
const TargetCopySetting = {
    type: {
        name: "Composite",
        className: "TargetCopySetting",
        modelProperties: {
            copyAfter: {
                serializedName: "copyAfter",
                type: {
                    name: "Composite",
                    className: "CopyOption"
                }
            },
            dataStore: {
                serializedName: "dataStore",
                type: {
                    name: "Composite",
                    className: "DataStoreInfoBase"
                }
            }
        }
    }
};
const CopyOption = {
    type: {
        name: "Composite",
        className: "CopyOption",
        uberParent: "CopyOption",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupCriteria = {
    type: {
        name: "Composite",
        className: "BackupCriteria",
        uberParent: "BackupCriteria",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupSchedule = {
    type: {
        name: "Composite",
        className: "BackupSchedule",
        modelProperties: {
            repeatingTimeIntervals: {
                serializedName: "repeatingTimeIntervals",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            timeZone: {
                serializedName: "timeZone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Day = {
    type: {
        name: "Composite",
        className: "Day",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "Number"
                }
            },
            isLast: {
                serializedName: "isLast",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SupportedFeature = {
    type: {
        name: "Composite",
        className: "SupportedFeature",
        modelProperties: {
            featureName: {
                serializedName: "featureName",
                type: {
                    name: "String"
                }
            },
            supportStatus: {
                serializedName: "supportStatus",
                type: {
                    name: "String"
                }
            },
            exposureControlledFeatures: {
                serializedName: "exposureControlledFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ItemLevelRestoreCriteria = {
    type: {
        name: "Composite",
        className: "ItemLevelRestoreCriteria",
        uberParent: "ItemLevelRestoreCriteria",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: {
            objectType: {
                serializedName: "objectType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TargetDetails = {
    type: {
        name: "Composite",
        className: "TargetDetails",
        modelProperties: {
            filePrefix: {
                serializedName: "filePrefix",
                required: true,
                type: {
                    name: "String"
                }
            },
            restoreTargetLocationType: {
                serializedName: "restoreTargetLocationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetResourceArmId: {
                serializedName: "targetResourceArmId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TaggingCriteria = {
    type: {
        name: "Composite",
        className: "TaggingCriteria",
        modelProperties: {
            criteria: {
                serializedName: "criteria",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupCriteria"
                        }
                    }
                }
            },
            isDefault: {
                serializedName: "isDefault",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            taggingPriority: {
                serializedName: "taggingPriority",
                required: true,
                type: {
                    name: "Number"
                }
            },
            tagInfo: {
                serializedName: "tagInfo",
                type: {
                    name: "Composite",
                    className: "RetentionTag"
                }
            }
        }
    }
};
const SecretStoreResource = {
    type: {
        name: "Composite",
        className: "SecretStoreResource",
        modelProperties: {
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            secretStoreType: {
                serializedName: "secretStoreType",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DppTrackedResource = {
    type: {
        name: "Composite",
        className: "DppTrackedResource",
        modelProperties: Object.assign(Object.assign({}, DppBaseTrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "DppIdentityDetails"
                }
            } })
    }
};
const ResourceGuardResource = {
    type: {
        name: "Composite",
        className: "ResourceGuardResource",
        modelProperties: Object.assign(Object.assign({}, DppBaseTrackedResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ResourceGuard"
                }
            } })
    }
};
const BackupVaultResourceList = {
    type: {
        name: "Composite",
        className: "BackupVaultResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupVaultResource"
                        }
                    }
                }
            } })
    }
};
const BaseBackupPolicyResourceList = {
    type: {
        name: "Composite",
        className: "BaseBackupPolicyResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BaseBackupPolicyResource"
                        }
                    }
                }
            } })
    }
};
const BackupInstanceResourceList = {
    type: {
        name: "Composite",
        className: "BackupInstanceResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupInstanceResource"
                        }
                    }
                }
            } })
    }
};
const AzureBackupRecoveryPointResourceList = {
    type: {
        name: "Composite",
        className: "AzureBackupRecoveryPointResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureBackupRecoveryPointResource"
                        }
                    }
                }
            } })
    }
};
const AzureBackupJobResourceList = {
    type: {
        name: "Composite",
        className: "AzureBackupJobResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureBackupJobResource"
                        }
                    }
                }
            } })
    }
};
const DeletedBackupInstanceResourceList = {
    type: {
        name: "Composite",
        className: "DeletedBackupInstanceResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedBackupInstanceResource"
                        }
                    }
                }
            } })
    }
};
const ResourceGuardProxyBaseResourceList = {
    type: {
        name: "Composite",
        className: "ResourceGuardProxyBaseResourceList",
        modelProperties: Object.assign(Object.assign({}, DppResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceGuardProxyBaseResource"
                        }
                    }
                }
            } })
    }
};
const OperationJobExtendedInfo = {
    serializedName: "OperationJobExtendedInfo",
    type: {
        name: "Composite",
        className: "OperationJobExtendedInfo",
        uberParent: "OperationExtendedInfo",
        polymorphicDiscriminator: OperationExtendedInfo.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OperationExtendedInfo.type.modelProperties), { jobId: {
                serializedName: "jobId",
                type: {
                    name: "String"
                }
            } })
    }
};
const FeatureValidationRequest = {
    serializedName: "FeatureValidationRequest",
    type: {
        name: "Composite",
        className: "FeatureValidationRequest",
        uberParent: "FeatureValidationRequestBase",
        modelProperties: Object.assign(Object.assign({}, FeatureValidationRequestBase.type.modelProperties), { featureType: {
                serializedName: "featureType",
                type: {
                    name: "String"
                }
            }, featureName: {
                serializedName: "featureName",
                type: {
                    name: "String"
                }
            } })
    }
};
FeatureValidationRequestBase.type.polymorphicDiscriminator =
    FeatureValidationRequestBase.type.polymorphicDiscriminator;
const FeatureValidationResponse = {
    serializedName: "FeatureValidationResponse",
    type: {
        name: "Composite",
        className: "FeatureValidationResponse",
        uberParent: "FeatureValidationResponseBase",
        modelProperties: Object.assign(Object.assign({}, FeatureValidationResponseBase.type.modelProperties), { featureType: {
                serializedName: "featureType",
                type: {
                    name: "String"
                }
            }, features: {
                serializedName: "features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SupportedFeature"
                        }
                    }
                }
            } })
    }
};
FeatureValidationResponseBase.type.polymorphicDiscriminator =
    FeatureValidationResponseBase.type.polymorphicDiscriminator;
const BackupPolicy = {
    serializedName: "BackupPolicy",
    type: {
        name: "Composite",
        className: "BackupPolicy",
        uberParent: "BaseBackupPolicy",
        polymorphicDiscriminator: BaseBackupPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BaseBackupPolicy.type.modelProperties), { policyRules: {
                serializedName: "policyRules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BasePolicyRule"
                        }
                    }
                }
            } })
    }
};
const BaseBackupPolicyResource = {
    type: {
        name: "Composite",
        className: "BaseBackupPolicyResource",
        modelProperties: Object.assign(Object.assign({}, DppResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BaseBackupPolicy"
                }
            } })
    }
};
const AzureBackupRecoveryPointResource = {
    type: {
        name: "Composite",
        className: "AzureBackupRecoveryPointResource",
        modelProperties: Object.assign(Object.assign({}, DppResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AzureBackupRecoveryPoint"
                }
            } })
    }
};
const AzureBackupJobResource = {
    type: {
        name: "Composite",
        className: "AzureBackupJobResource",
        modelProperties: Object.assign(Object.assign({}, DppResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AzureBackupJob"
                }
            } })
    }
};
const AzureBackupFindRestorableTimeRangesResponseResource = {
    type: {
        name: "Composite",
        className: "AzureBackupFindRestorableTimeRangesResponseResource",
        modelProperties: Object.assign(Object.assign({}, DppResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AzureBackupFindRestorableTimeRangesResponse"
                }
            } })
    }
};
const DeletedBackupInstanceResource = {
    type: {
        name: "Composite",
        className: "DeletedBackupInstanceResource",
        modelProperties: Object.assign(Object.assign({}, DppResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeletedBackupInstance"
                }
            } })
    }
};
const ResourceGuardProxyBaseResource = {
    type: {
        name: "Composite",
        className: "ResourceGuardProxyBaseResource",
        modelProperties: Object.assign(Object.assign({}, DppResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ResourceGuardProxyBase"
                }
            } })
    }
};
const DeletedBackupInstance = {
    type: {
        name: "Composite",
        className: "DeletedBackupInstance",
        modelProperties: Object.assign(Object.assign({}, BackupInstance.type.modelProperties), { deletionInfo: {
                serializedName: "deletionInfo",
                type: {
                    name: "Composite",
                    className: "DeletionInfo"
                }
            } })
    }
};
const AzureOperationalStoreParameters = {
    serializedName: "AzureOperationalStoreParameters",
    type: {
        name: "Composite",
        className: "AzureOperationalStoreParameters",
        uberParent: "DataStoreParameters",
        polymorphicDiscriminator: DataStoreParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataStoreParameters.type.modelProperties), { resourceGroupId: {
                serializedName: "resourceGroupId",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubernetesClusterBackupDatasourceParameters = {
    serializedName: "KubernetesClusterBackupDatasourceParameters",
    type: {
        name: "Composite",
        className: "KubernetesClusterBackupDatasourceParameters",
        uberParent: "BackupDatasourceParameters",
        polymorphicDiscriminator: BackupDatasourceParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BackupDatasourceParameters.type.modelProperties), { snapshotVolumes: {
                serializedName: "snapshotVolumes",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, includeClusterScopeResources: {
                serializedName: "includeClusterScopeResources",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, includedNamespaces: {
                serializedName: "includedNamespaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, excludedNamespaces: {
                serializedName: "excludedNamespaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, includedResourceTypes: {
                serializedName: "includedResourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, excludedResourceTypes: {
                serializedName: "excludedResourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, labelSelectors: {
                serializedName: "labelSelectors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, backupHookReferences: {
                serializedName: "backupHookReferences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NamespacedNameResource"
                        }
                    }
                }
            } })
    }
};
const BlobBackupDatasourceParameters = {
    serializedName: "BlobBackupDatasourceParameters",
    type: {
        name: "Composite",
        className: "BlobBackupDatasourceParameters",
        uberParent: "BackupDatasourceParameters",
        polymorphicDiscriminator: BackupDatasourceParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BackupDatasourceParameters.type.modelProperties), { containersList: {
                serializedName: "containersList",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SecretStoreBasedAuthCredentials = {
    serializedName: "SecretStoreBasedAuthCredentials",
    type: {
        name: "Composite",
        className: "SecretStoreBasedAuthCredentials",
        uberParent: "AuthCredentials",
        polymorphicDiscriminator: AuthCredentials.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AuthCredentials.type.modelProperties), { secretStoreResource: {
                serializedName: "secretStoreResource",
                type: {
                    name: "Composite",
                    className: "SecretStoreResource"
                }
            } })
    }
};
const BackupInstanceResource = {
    type: {
        name: "Composite",
        className: "BackupInstanceResource",
        modelProperties: Object.assign(Object.assign({}, DppProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BackupInstance"
                }
            } })
    }
};
const AzureBackupDiscreteRecoveryPoint = {
    serializedName: "AzureBackupDiscreteRecoveryPoint",
    type: {
        name: "Composite",
        className: "AzureBackupDiscreteRecoveryPoint",
        uberParent: "AzureBackupRecoveryPoint",
        polymorphicDiscriminator: AzureBackupRecoveryPoint.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AzureBackupRecoveryPoint.type.modelProperties), { friendlyName: {
                serializedName: "friendlyName",
                type: {
                    name: "String"
                }
            }, recoveryPointDataStoresDetails: {
                serializedName: "recoveryPointDataStoresDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecoveryPointDataStoreDetails"
                        }
                    }
                }
            }, recoveryPointTime: {
                serializedName: "recoveryPointTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }, policyName: {
                serializedName: "policyName",
                type: {
                    name: "String"
                }
            }, policyVersion: {
                serializedName: "policyVersion",
                type: {
                    name: "String"
                }
            }, recoveryPointId: {
                serializedName: "recoveryPointId",
                type: {
                    name: "String"
                }
            }, recoveryPointType: {
                serializedName: "recoveryPointType",
                type: {
                    name: "String"
                }
            }, retentionTagName: {
                serializedName: "retentionTagName",
                type: {
                    name: "String"
                }
            }, retentionTagVersion: {
                serializedName: "retentionTagVersion",
                type: {
                    name: "String"
                }
            }, expiryTime: {
                serializedName: "expiryTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const AzureBackupRecoveryPointBasedRestoreRequest = {
    serializedName: "AzureBackupRecoveryPointBasedRestoreRequest",
    type: {
        name: "Composite",
        className: "AzureBackupRecoveryPointBasedRestoreRequest",
        uberParent: "AzureBackupRestoreRequest",
        polymorphicDiscriminator: {
            serializedName: "objectType",
            clientName: "objectType"
        },
        modelProperties: Object.assign(Object.assign({}, AzureBackupRestoreRequest.type.modelProperties), { recoveryPointId: {
                serializedName: "recoveryPointId",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureBackupRecoveryTimeBasedRestoreRequest = {
    serializedName: "AzureBackupRecoveryTimeBasedRestoreRequest",
    type: {
        name: "Composite",
        className: "AzureBackupRecoveryTimeBasedRestoreRequest",
        uberParent: "AzureBackupRestoreRequest",
        polymorphicDiscriminator: AzureBackupRestoreRequest.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AzureBackupRestoreRequest.type.modelProperties), { recoveryPointTime: {
                serializedName: "recoveryPointTime",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ItemLevelRestoreTargetInfo = {
    serializedName: "ItemLevelRestoreTargetInfo",
    type: {
        name: "Composite",
        className: "ItemLevelRestoreTargetInfo",
        uberParent: "RestoreTargetInfoBase",
        polymorphicDiscriminator: RestoreTargetInfoBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RestoreTargetInfoBase.type.modelProperties), { restoreCriteria: {
                serializedName: "restoreCriteria",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ItemLevelRestoreCriteria"
                        }
                    }
                }
            }, datasourceInfo: {
                serializedName: "datasourceInfo",
                type: {
                    name: "Composite",
                    className: "Datasource"
                }
            }, datasourceSetInfo: {
                serializedName: "datasourceSetInfo",
                type: {
                    name: "Composite",
                    className: "DatasourceSet"
                }
            }, datasourceAuthCredentials: {
                serializedName: "datasourceAuthCredentials",
                type: {
                    name: "Composite",
                    className: "AuthCredentials"
                }
            } })
    }
};
const RestoreFilesTargetInfo = {
    serializedName: "RestoreFilesTargetInfo",
    type: {
        name: "Composite",
        className: "RestoreFilesTargetInfo",
        uberParent: "RestoreTargetInfoBase",
        polymorphicDiscriminator: RestoreTargetInfoBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, RestoreTargetInfoBase.type.modelProperties), { targetDetails: {
                serializedName: "targetDetails",
                type: {
                    name: "Composite",
                    className: "TargetDetails"
                }
            } })
    }
};
const RestoreTargetInfo = {
    serializedName: "RestoreTargetInfo",
    type: {
        name: "Composite",
        className: "RestoreTargetInfo",
        uberParent: "RestoreTargetInfoBase",
        modelProperties: Object.assign(Object.assign({}, RestoreTargetInfoBase.type.modelProperties), { datasourceInfo: {
                serializedName: "datasourceInfo",
                type: {
                    name: "Composite",
                    className: "Datasource"
                }
            }, datasourceSetInfo: {
                serializedName: "datasourceSetInfo",
                type: {
                    name: "Composite",
                    className: "DatasourceSet"
                }
            }, datasourceAuthCredentials: {
                serializedName: "datasourceAuthCredentials",
                type: {
                    name: "Composite",
                    className: "AuthCredentials"
                }
            } })
    }
};
RestoreTargetInfoBase.type.polymorphicDiscriminator =
    RestoreTargetInfoBase.type.polymorphicDiscriminator;
const ResourceGuardResourceList = {
    type: {
        name: "Composite",
        className: "ResourceGuardResourceList",
        modelProperties: Object.assign(Object.assign({}, DppTrackedResourceList.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceGuardResource"
                        }
                    }
                }
            } })
    }
};
const AbsoluteDeleteOption = {
    serializedName: "AbsoluteDeleteOption",
    type: {
        name: "Composite",
        className: "AbsoluteDeleteOption",
        uberParent: "DeleteOption",
        polymorphicDiscriminator: DeleteOption.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, DeleteOption.type.modelProperties)
    }
};
const AdhocBasedTriggerContext = {
    serializedName: "AdhocBasedTriggerContext",
    type: {
        name: "Composite",
        className: "AdhocBasedTriggerContext",
        uberParent: "TriggerContext",
        polymorphicDiscriminator: TriggerContext.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TriggerContext.type.modelProperties), { taggingCriteria: {
                serializedName: "taggingCriteria",
                type: {
                    name: "Composite",
                    className: "AdhocBasedTaggingCriteria"
                }
            } })
    }
};
const ScheduleBasedTriggerContext = {
    serializedName: "ScheduleBasedTriggerContext",
    type: {
        name: "Composite",
        className: "ScheduleBasedTriggerContext",
        uberParent: "TriggerContext",
        polymorphicDiscriminator: TriggerContext.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TriggerContext.type.modelProperties), { schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "BackupSchedule"
                }
            }, taggingCriteria: {
                serializedName: "taggingCriteria",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TaggingCriteria"
                        }
                    }
                }
            } })
    }
};
const AzureBackupFindRestorableTimeRangesRequestResource = {
    type: {
        name: "Composite",
        className: "AzureBackupFindRestorableTimeRangesRequestResource",
        modelProperties: Object.assign(Object.assign({}, DppWorkerRequest.type.modelProperties), { content: {
                serializedName: "content",
                type: {
                    name: "Composite",
                    className: "AzureBackupFindRestorableTimeRangesRequest"
                }
            } })
    }
};
const AzureBackupParams = {
    serializedName: "AzureBackupParams",
    type: {
        name: "Composite",
        className: "AzureBackupParams",
        uberParent: "BackupParameters",
        polymorphicDiscriminator: BackupParameters.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BackupParameters.type.modelProperties), { backupType: {
                serializedName: "backupType",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureBackupRule = {
    serializedName: "AzureBackupRule",
    type: {
        name: "Composite",
        className: "AzureBackupRule",
        uberParent: "BasePolicyRule",
        polymorphicDiscriminator: BasePolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BasePolicyRule.type.modelProperties), { backupParameters: {
                serializedName: "backupParameters",
                type: {
                    name: "Composite",
                    className: "BackupParameters"
                }
            }, dataStore: {
                serializedName: "dataStore",
                type: {
                    name: "Composite",
                    className: "DataStoreInfoBase"
                }
            }, trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "TriggerContext"
                }
            } })
    }
};
const AzureRetentionRule = {
    serializedName: "AzureRetentionRule",
    type: {
        name: "Composite",
        className: "AzureRetentionRule",
        uberParent: "BasePolicyRule",
        polymorphicDiscriminator: BasePolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BasePolicyRule.type.modelProperties), { isDefault: {
                serializedName: "isDefault",
                type: {
                    name: "Boolean"
                }
            }, lifecycles: {
                serializedName: "lifecycles",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceLifeCycle"
                        }
                    }
                }
            } })
    }
};
const CopyOnExpiryOption = {
    serializedName: "CopyOnExpiryOption",
    type: {
        name: "Composite",
        className: "CopyOnExpiryOption",
        uberParent: "CopyOption",
        polymorphicDiscriminator: CopyOption.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, CopyOption.type.modelProperties)
    }
};
const CustomCopyOption = {
    serializedName: "CustomCopyOption",
    type: {
        name: "Composite",
        className: "CustomCopyOption",
        uberParent: "CopyOption",
        polymorphicDiscriminator: CopyOption.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CopyOption.type.modelProperties), { duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            } })
    }
};
const ImmediateCopyOption = {
    serializedName: "ImmediateCopyOption",
    type: {
        name: "Composite",
        className: "ImmediateCopyOption",
        uberParent: "CopyOption",
        polymorphicDiscriminator: CopyOption.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, CopyOption.type.modelProperties)
    }
};
const ScheduleBasedBackupCriteria = {
    serializedName: "ScheduleBasedBackupCriteria",
    type: {
        name: "Composite",
        className: "ScheduleBasedBackupCriteria",
        uberParent: "BackupCriteria",
        polymorphicDiscriminator: BackupCriteria.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BackupCriteria.type.modelProperties), { absoluteCriteria: {
                serializedName: "absoluteCriteria",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, daysOfMonth: {
                serializedName: "daysOfMonth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Day"
                        }
                    }
                }
            }, daysOfTheWeek: {
                serializedName: "daysOfTheWeek",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, monthsOfYear: {
                serializedName: "monthsOfYear",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, scheduleTimes: {
                serializedName: "scheduleTimes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "DateTime"
                        }
                    }
                }
            }, weeksOfTheMonth: {
                serializedName: "weeksOfTheMonth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ItemPathBasedRestoreCriteria = {
    serializedName: "ItemPathBasedRestoreCriteria",
    type: {
        name: "Composite",
        className: "ItemPathBasedRestoreCriteria",
        uberParent: "ItemLevelRestoreCriteria",
        polymorphicDiscriminator: ItemLevelRestoreCriteria.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ItemLevelRestoreCriteria.type.modelProperties), { itemPath: {
                serializedName: "itemPath",
                required: true,
                type: {
                    name: "String"
                }
            }, isPathRelativeToBackupItem: {
                serializedName: "isPathRelativeToBackupItem",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, subItemPathPrefix: {
                serializedName: "subItemPathPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const RangeBasedItemLevelRestoreCriteria = {
    serializedName: "RangeBasedItemLevelRestoreCriteria",
    type: {
        name: "Composite",
        className: "RangeBasedItemLevelRestoreCriteria",
        uberParent: "ItemLevelRestoreCriteria",
        polymorphicDiscriminator: ItemLevelRestoreCriteria.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ItemLevelRestoreCriteria.type.modelProperties), { minMatchingValue: {
                serializedName: "minMatchingValue",
                type: {
                    name: "String"
                }
            }, maxMatchingValue: {
                serializedName: "maxMatchingValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubernetesStorageClassRestoreCriteria = {
    serializedName: "KubernetesStorageClassRestoreCriteria",
    type: {
        name: "Composite",
        className: "KubernetesStorageClassRestoreCriteria",
        uberParent: "ItemLevelRestoreCriteria",
        polymorphicDiscriminator: ItemLevelRestoreCriteria.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ItemLevelRestoreCriteria.type.modelProperties), { selectedStorageClassName: {
                serializedName: "selectedStorageClassName",
                type: {
                    name: "String"
                }
            }, provisioner: {
                serializedName: "provisioner",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubernetesPVRestoreCriteria = {
    serializedName: "KubernetesPVRestoreCriteria",
    type: {
        name: "Composite",
        className: "KubernetesPVRestoreCriteria",
        uberParent: "ItemLevelRestoreCriteria",
        polymorphicDiscriminator: ItemLevelRestoreCriteria.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ItemLevelRestoreCriteria.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, storageClassName: {
                serializedName: "storageClassName",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubernetesClusterRestoreCriteria = {
    serializedName: "KubernetesClusterRestoreCriteria",
    type: {
        name: "Composite",
        className: "KubernetesClusterRestoreCriteria",
        uberParent: "ItemLevelRestoreCriteria",
        polymorphicDiscriminator: ItemLevelRestoreCriteria.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ItemLevelRestoreCriteria.type.modelProperties), { includeClusterScopeResources: {
                serializedName: "includeClusterScopeResources",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, includedNamespaces: {
                serializedName: "includedNamespaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, excludedNamespaces: {
                serializedName: "excludedNamespaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, includedResourceTypes: {
                serializedName: "includedResourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, excludedResourceTypes: {
                serializedName: "excludedResourceTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, labelSelectors: {
                serializedName: "labelSelectors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, persistentVolumeRestoreMode: {
                serializedName: "persistentVolumeRestoreMode",
                type: {
                    name: "String"
                }
            }, conflictPolicy: {
                serializedName: "conflictPolicy",
                type: {
                    name: "String"
                }
            }, namespaceMappings: {
                serializedName: "namespaceMappings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, restoreHookReferences: {
                serializedName: "restoreHookReferences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NamespacedNameResource"
                        }
                    }
                }
            } })
    }
};
const BackupVaultResource = {
    type: {
        name: "Composite",
        className: "BackupVaultResource",
        modelProperties: Object.assign(Object.assign({}, DppTrackedResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BackupVault"
                }
            } })
    }
};
const AzureBackupRestoreWithRehydrationRequest = {
    serializedName: "AzureBackupRestoreWithRehydrationRequest",
    type: {
        name: "Composite",
        className: "AzureBackupRestoreWithRehydrationRequest",
        uberParent: "AzureBackupRecoveryPointBasedRestoreRequest",
        polymorphicDiscriminator: AzureBackupRecoveryPointBasedRestoreRequest.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AzureBackupRecoveryPointBasedRestoreRequest.type.modelProperties), { rehydrationPriority: {
                serializedName: "rehydrationPriority",
                required: true,
                type: {
                    name: "String"
                }
            }, rehydrationRetentionDuration: {
                serializedName: "rehydrationRetentionDuration",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OperationResultGetHeaders = {
    type: {
        name: "Composite",
        className: "OperationResultGetHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupVaultOperationResultsGetHeaders = {
    type: {
        name: "Composite",
        className: "BackupVaultOperationResultsGetHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesCreateOrUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackupInstancesDeleteHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesAdhocBackupHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesAdhocBackupHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesValidateForBackupHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesValidateForBackupHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesTriggerRehydrateHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesTriggerRehydrateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesTriggerRestoreHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesTriggerRestoreHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesResumeBackupsHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesResumeBackupsHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesResumeProtectionHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesResumeProtectionHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesStopProtectionHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesStopProtectionHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesSuspendBackupsHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesSuspendBackupsHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesSyncBackupInstanceHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesSyncBackupInstanceHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupInstancesValidateForRestoreHeaders = {
    type: {
        name: "Composite",
        className: "BackupInstancesValidateForRestoreHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExportJobsTriggerHeaders = {
    type: {
        name: "Composite",
        className: "ExportJobsTriggerHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
let discriminators = {
    OperationExtendedInfo: OperationExtendedInfo,
    FeatureValidationRequestBase: FeatureValidationRequestBase,
    FeatureValidationResponseBase: FeatureValidationResponseBase,
    BaseBackupPolicy: BaseBackupPolicy,
    "BaseResourceProperties.BaseResourceProperties": BaseResourceProperties,
    DataStoreParameters: DataStoreParameters,
    BackupDatasourceParameters: BackupDatasourceParameters,
    AuthCredentials: AuthCredentials,
    AzureBackupRecoveryPoint: AzureBackupRecoveryPoint,
    AzureBackupRestoreRequest: AzureBackupRestoreRequest,
    RestoreTargetInfoBase: RestoreTargetInfoBase,
    DeleteOption: DeleteOption,
    TriggerContext: TriggerContext,
    BackupParameters: BackupParameters,
    BasePolicyRule: BasePolicyRule,
    CopyOption: CopyOption,
    BackupCriteria: BackupCriteria,
    ItemLevelRestoreCriteria: ItemLevelRestoreCriteria,
    "OperationExtendedInfo.OperationJobExtendedInfo": OperationJobExtendedInfo,
    "FeatureValidationRequestBase.FeatureValidationRequest": FeatureValidationRequest,
    "FeatureValidationResponseBase.FeatureValidationResponse": FeatureValidationResponse,
    "BaseBackupPolicy.BackupPolicy": BackupPolicy,
    "DataStoreParameters.AzureOperationalStoreParameters": AzureOperationalStoreParameters,
    "BackupDatasourceParameters.KubernetesClusterBackupDatasourceParameters": KubernetesClusterBackupDatasourceParameters,
    "BackupDatasourceParameters.BlobBackupDatasourceParameters": BlobBackupDatasourceParameters,
    "AuthCredentials.SecretStoreBasedAuthCredentials": SecretStoreBasedAuthCredentials,
    "AzureBackupRecoveryPoint.AzureBackupDiscreteRecoveryPoint": AzureBackupDiscreteRecoveryPoint,
    "AzureBackupRestoreRequest.AzureBackupRecoveryPointBasedRestoreRequest": AzureBackupRecoveryPointBasedRestoreRequest,
    "AzureBackupRestoreRequest.AzureBackupRecoveryTimeBasedRestoreRequest": AzureBackupRecoveryTimeBasedRestoreRequest,
    "RestoreTargetInfoBase.ItemLevelRestoreTargetInfo": ItemLevelRestoreTargetInfo,
    "RestoreTargetInfoBase.RestoreFilesTargetInfo": RestoreFilesTargetInfo,
    "RestoreTargetInfoBase.RestoreTargetInfo": RestoreTargetInfo,
    "DeleteOption.AbsoluteDeleteOption": AbsoluteDeleteOption,
    "TriggerContext.AdhocBasedTriggerContext": AdhocBasedTriggerContext,
    "TriggerContext.ScheduleBasedTriggerContext": ScheduleBasedTriggerContext,
    "BackupParameters.AzureBackupParams": AzureBackupParams,
    "BasePolicyRule.AzureBackupRule": AzureBackupRule,
    "BasePolicyRule.AzureRetentionRule": AzureRetentionRule,
    "CopyOption.CopyOnExpiryOption": CopyOnExpiryOption,
    "CopyOption.CustomCopyOption": CustomCopyOption,
    "CopyOption.ImmediateCopyOption": ImmediateCopyOption,
    "BackupCriteria.ScheduleBasedBackupCriteria": ScheduleBasedBackupCriteria,
    "ItemLevelRestoreCriteria.ItemPathBasedRestoreCriteria": ItemPathBasedRestoreCriteria,
    "ItemLevelRestoreCriteria.RangeBasedItemLevelRestoreCriteria": RangeBasedItemLevelRestoreCriteria,
    "ItemLevelRestoreCriteria.KubernetesStorageClassRestoreCriteria": KubernetesStorageClassRestoreCriteria,
    "ItemLevelRestoreCriteria.KubernetesPVRestoreCriteria": KubernetesPVRestoreCriteria,
    "ItemLevelRestoreCriteria.KubernetesClusterRestoreCriteria": KubernetesClusterRestoreCriteria,
    "AzureBackupRecoveryPointBasedRestoreRequest.AzureBackupRestoreWithRehydrationRequest": AzureBackupRestoreWithRehydrationRequest
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BackupVault: BackupVault,
    MonitoringSettings: MonitoringSettings,
    AzureMonitorAlertSettings: AzureMonitorAlertSettings,
    ResourceMoveDetails: ResourceMoveDetails,
    SecuritySettings: SecuritySettings,
    SoftDeleteSettings: SoftDeleteSettings,
    ImmutabilitySettings: ImmutabilitySettings,
    StorageSetting: StorageSetting,
    FeatureSettings: FeatureSettings,
    CrossSubscriptionRestoreSettings: CrossSubscriptionRestoreSettings,
    CrossRegionRestoreSettings: CrossRegionRestoreSettings,
    DppIdentityDetails: DppIdentityDetails,
    UserAssignedIdentity: UserAssignedIdentity,
    DppBaseTrackedResource: DppBaseTrackedResource,
    SystemData: SystemData,
    DppResourceList: DppResourceList,
    CloudError: CloudError,
    ErrorModel: ErrorModel,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    OperationExtendedInfo: OperationExtendedInfo,
    OperationResource: OperationResource,
    PatchResourceRequestInput: PatchResourceRequestInput,
    PatchBackupVaultInput: PatchBackupVaultInput,
    CheckNameAvailabilityRequest: CheckNameAvailabilityRequest,
    CheckNameAvailabilityResult: CheckNameAvailabilityResult,
    FeatureValidationRequestBase: FeatureValidationRequestBase,
    FeatureValidationResponseBase: FeatureValidationResponseBase,
    ClientDiscoveryResponse: ClientDiscoveryResponse,
    ClientDiscoveryValueForSingleApi: ClientDiscoveryValueForSingleApi,
    ClientDiscoveryDisplay: ClientDiscoveryDisplay,
    ClientDiscoveryForProperties: ClientDiscoveryForProperties,
    ClientDiscoveryForServiceSpecification: ClientDiscoveryForServiceSpecification,
    ClientDiscoveryForLogSpecification: ClientDiscoveryForLogSpecification,
    BaseBackupPolicy: BaseBackupPolicy,
    DppResource: DppResource,
    BackupInstance: BackupInstance,
    Datasource: Datasource,
    BaseResourceProperties: BaseResourceProperties,
    DatasourceSet: DatasourceSet,
    PolicyInfo: PolicyInfo,
    PolicyParameters: PolicyParameters,
    DataStoreParameters: DataStoreParameters,
    BackupDatasourceParameters: BackupDatasourceParameters,
    ProtectionStatusDetails: ProtectionStatusDetails,
    UserFacingError: UserFacingError,
    InnerError: InnerError,
    AuthCredentials: AuthCredentials,
    IdentityDetails: IdentityDetails,
    DppProxyResource: DppProxyResource,
    TriggerBackupRequest: TriggerBackupRequest,
    AdHocBackupRuleOptions: AdHocBackupRuleOptions,
    AdhocBackupTriggerOption: AdhocBackupTriggerOption,
    ValidateForBackupRequest: ValidateForBackupRequest,
    AzureBackupRecoveryPoint: AzureBackupRecoveryPoint,
    AzureBackupRehydrationRequest: AzureBackupRehydrationRequest,
    AzureBackupRestoreRequest: AzureBackupRestoreRequest,
    RestoreTargetInfoBase: RestoreTargetInfoBase,
    SyncBackupInstanceRequest: SyncBackupInstanceRequest,
    ValidateRestoreRequestObject: ValidateRestoreRequestObject,
    AzureBackupJob: AzureBackupJob,
    JobExtendedInfo: JobExtendedInfo,
    RestoreJobRecoveryPointDetails: RestoreJobRecoveryPointDetails,
    JobSubTask: JobSubTask,
    AzureBackupFindRestorableTimeRangesRequest: AzureBackupFindRestorableTimeRangesRequest,
    AzureBackupFindRestorableTimeRangesResponse: AzureBackupFindRestorableTimeRangesResponse,
    RestorableTimeRange: RestorableTimeRange,
    ExportJobsResult: ExportJobsResult,
    DeletionInfo: DeletionInfo,
    ResourceGuard: ResourceGuard,
    ResourceGuardOperation: ResourceGuardOperation,
    DppTrackedResourceList: DppTrackedResourceList,
    PatchResourceGuardInput: PatchResourceGuardInput,
    DppBaseResourceList: DppBaseResourceList,
    DppBaseResource: DppBaseResource,
    ResourceGuardProxyBase: ResourceGuardProxyBase,
    ResourceGuardOperationDetail: ResourceGuardOperationDetail,
    UnlockDeleteRequest: UnlockDeleteRequest,
    UnlockDeleteResponse: UnlockDeleteResponse,
    DeleteOption: DeleteOption,
    RecoveryPointsFilters: RecoveryPointsFilters,
    AdhocBasedTaggingCriteria: AdhocBasedTaggingCriteria,
    RetentionTag: RetentionTag,
    TriggerContext: TriggerContext,
    RecoveryPointDataStoreDetails: RecoveryPointDataStoreDetails,
    DppWorkerRequest: DppWorkerRequest,
    BackupParameters: BackupParameters,
    DataStoreInfoBase: DataStoreInfoBase,
    BasePolicyRule: BasePolicyRule,
    NamespacedNameResource: NamespacedNameResource,
    SourceLifeCycle: SourceLifeCycle,
    TargetCopySetting: TargetCopySetting,
    CopyOption: CopyOption,
    BackupCriteria: BackupCriteria,
    BackupSchedule: BackupSchedule,
    Day: Day,
    SupportedFeature: SupportedFeature,
    ItemLevelRestoreCriteria: ItemLevelRestoreCriteria,
    TargetDetails: TargetDetails,
    TaggingCriteria: TaggingCriteria,
    SecretStoreResource: SecretStoreResource,
    DppTrackedResource: DppTrackedResource,
    ResourceGuardResource: ResourceGuardResource,
    BackupVaultResourceList: BackupVaultResourceList,
    BaseBackupPolicyResourceList: BaseBackupPolicyResourceList,
    BackupInstanceResourceList: BackupInstanceResourceList,
    AzureBackupRecoveryPointResourceList: AzureBackupRecoveryPointResourceList,
    AzureBackupJobResourceList: AzureBackupJobResourceList,
    DeletedBackupInstanceResourceList: DeletedBackupInstanceResourceList,
    ResourceGuardProxyBaseResourceList: ResourceGuardProxyBaseResourceList,
    OperationJobExtendedInfo: OperationJobExtendedInfo,
    FeatureValidationRequest: FeatureValidationRequest,
    FeatureValidationResponse: FeatureValidationResponse,
    BackupPolicy: BackupPolicy,
    BaseBackupPolicyResource: BaseBackupPolicyResource,
    AzureBackupRecoveryPointResource: AzureBackupRecoveryPointResource,
    AzureBackupJobResource: AzureBackupJobResource,
    AzureBackupFindRestorableTimeRangesResponseResource: AzureBackupFindRestorableTimeRangesResponseResource,
    DeletedBackupInstanceResource: DeletedBackupInstanceResource,
    ResourceGuardProxyBaseResource: ResourceGuardProxyBaseResource,
    DeletedBackupInstance: DeletedBackupInstance,
    AzureOperationalStoreParameters: AzureOperationalStoreParameters,
    KubernetesClusterBackupDatasourceParameters: KubernetesClusterBackupDatasourceParameters,
    BlobBackupDatasourceParameters: BlobBackupDatasourceParameters,
    SecretStoreBasedAuthCredentials: SecretStoreBasedAuthCredentials,
    BackupInstanceResource: BackupInstanceResource,
    AzureBackupDiscreteRecoveryPoint: AzureBackupDiscreteRecoveryPoint,
    AzureBackupRecoveryPointBasedRestoreRequest: AzureBackupRecoveryPointBasedRestoreRequest,
    AzureBackupRecoveryTimeBasedRestoreRequest: AzureBackupRecoveryTimeBasedRestoreRequest,
    ItemLevelRestoreTargetInfo: ItemLevelRestoreTargetInfo,
    RestoreFilesTargetInfo: RestoreFilesTargetInfo,
    RestoreTargetInfo: RestoreTargetInfo,
    ResourceGuardResourceList: ResourceGuardResourceList,
    AbsoluteDeleteOption: AbsoluteDeleteOption,
    AdhocBasedTriggerContext: AdhocBasedTriggerContext,
    ScheduleBasedTriggerContext: ScheduleBasedTriggerContext,
    AzureBackupFindRestorableTimeRangesRequestResource: AzureBackupFindRestorableTimeRangesRequestResource,
    AzureBackupParams: AzureBackupParams,
    AzureBackupRule: AzureBackupRule,
    AzureRetentionRule: AzureRetentionRule,
    CopyOnExpiryOption: CopyOnExpiryOption,
    CustomCopyOption: CustomCopyOption,
    ImmediateCopyOption: ImmediateCopyOption,
    ScheduleBasedBackupCriteria: ScheduleBasedBackupCriteria,
    ItemPathBasedRestoreCriteria: ItemPathBasedRestoreCriteria,
    RangeBasedItemLevelRestoreCriteria: RangeBasedItemLevelRestoreCriteria,
    KubernetesStorageClassRestoreCriteria: KubernetesStorageClassRestoreCriteria,
    KubernetesPVRestoreCriteria: KubernetesPVRestoreCriteria,
    KubernetesClusterRestoreCriteria: KubernetesClusterRestoreCriteria,
    BackupVaultResource: BackupVaultResource,
    AzureBackupRestoreWithRehydrationRequest: AzureBackupRestoreWithRehydrationRequest,
    OperationResultGetHeaders: OperationResultGetHeaders,
    BackupVaultOperationResultsGetHeaders: BackupVaultOperationResultsGetHeaders,
    BackupInstancesCreateOrUpdateHeaders: BackupInstancesCreateOrUpdateHeaders,
    BackupInstancesDeleteHeaders: BackupInstancesDeleteHeaders,
    BackupInstancesAdhocBackupHeaders: BackupInstancesAdhocBackupHeaders,
    BackupInstancesValidateForBackupHeaders: BackupInstancesValidateForBackupHeaders,
    BackupInstancesTriggerRehydrateHeaders: BackupInstancesTriggerRehydrateHeaders,
    BackupInstancesTriggerRestoreHeaders: BackupInstancesTriggerRestoreHeaders,
    BackupInstancesResumeBackupsHeaders: BackupInstancesResumeBackupsHeaders,
    BackupInstancesResumeProtectionHeaders: BackupInstancesResumeProtectionHeaders,
    BackupInstancesStopProtectionHeaders: BackupInstancesStopProtectionHeaders,
    BackupInstancesSuspendBackupsHeaders: BackupInstancesSuspendBackupsHeaders,
    BackupInstancesSyncBackupInstanceHeaders: BackupInstancesSyncBackupInstanceHeaders,
    BackupInstancesValidateForRestoreHeaders: BackupInstancesValidateForRestoreHeaders,
    ExportJobsTriggerHeaders: ExportJobsTriggerHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vaultName = {
    parameterPath: "vaultName",
    mapper: {
        serializedName: "vaultName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: BackupVaultResource
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: PatchResourceRequestInput
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: CheckNameAvailabilityRequest
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: FeatureValidationRequestBase
};
const backupPolicyName = {
    parameterPath: "backupPolicyName",
    mapper: {
        serializedName: "backupPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: BaseBackupPolicyResource
};
const backupInstanceName = {
    parameterPath: "backupInstanceName",
    mapper: {
        serializedName: "backupInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: BackupInstanceResource
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: TriggerBackupRequest
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: ValidateForBackupRequest
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: AzureBackupRehydrationRequest
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: AzureBackupRestoreRequest
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: SyncBackupInstanceRequest
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: ValidateRestoreRequestObject
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const recoveryPointId = {
    parameterPath: "recoveryPointId",
    mapper: {
        serializedName: "recoveryPointId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jobId = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: AzureBackupFindRestorableTimeRangesRequest
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: ResourceGuardResource
};
const resourceGuardsName = {
    parameterPath: "resourceGuardsName",
    mapper: {
        serializedName: "resourceGuardsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: PatchResourceGuardInput
};
const requestName = {
    parameterPath: "requestName",
    mapper: {
        serializedName: "requestName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGuardProxyName = {
    parameterPath: "resourceGuardProxyName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[A-Za-z0-9]*$")
        },
        serializedName: "resourceGuardProxyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: ResourceGuardProxyBaseResource
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: UnlockDeleteRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BackupVaults operations. */
class BackupVaultsImpl {
    /**
     * Initialize a new instance of the class BackupVaults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns resource collection belonging to a subscription.
     * @param options The options parameters.
     */
    listInSubscription(options) {
        const iter = this.getInSubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getInSubscriptionPagingPage(options, settings);
            }
        };
    }
    getInSubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getInSubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getInSubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getInSubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getInSubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getInSubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getInSubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns resource collection belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listInResourceGroup(resourceGroupName, options) {
        const iter = this.getInResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getInResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    getInResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getInResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getInResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getInResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getInResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getInResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getInResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns resource collection belonging to a subscription.
     * @param options The options parameters.
     */
    _getInSubscription(options) {
        return this.client.sendOperationRequest({ options }, getInSubscriptionOperationSpec);
    }
    /**
     * Returns resource collection belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _getInResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, getInResourceGroupOperationSpec);
    }
    /**
     * Returns a resource belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, getOperationSpec$d);
    }
    /**
     * Creates or updates a BackupVault resource belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, parameters, options },
                spec: createOrUpdateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a BackupVault resource belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vaultName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a BackupVault resource from the resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vaultName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, options },
                spec: deleteOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a BackupVault resource from the resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vaultName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vaultName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a BackupVault resource belonging to a resource group. For example, updating tags for a
     * resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, parameters, options },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a BackupVault resource belonging to a resource group. For example, updating tags for a
     * resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vaultName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * API to check for resource name availability
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param location The location in which uniqueness will be verified.
     * @param parameters Check name availability request
     * @param options The options parameters.
     */
    checkNameAvailability(resourceGroupName, location, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, parameters, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * GetInSubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the GetInSubscription method.
     * @param options The options parameters.
     */
    _getInSubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getInSubscriptionNextOperationSpec);
    }
    /**
     * GetInResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the GetInResourceGroup method.
     * @param options The options parameters.
     */
    _getInResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, getInResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getInSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataProtection/backupVaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupVaultResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$h
};
const getInResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupVaultResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupVaultResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupVaultResource
        },
        201: {
            bodyMapper: BackupVaultResource
        },
        202: {
            bodyMapper: BackupVaultResource
        },
        204: {
            bodyMapper: BackupVaultResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BackupVaultResource
        },
        201: {
            bodyMapper: BackupVaultResource
        },
        202: {
            bodyMapper: BackupVaultResource
        },
        204: {
            bodyMapper: BackupVaultResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/locations/{location}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const getInSubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupVaultResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getInResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupVaultResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationResult operations. */
class OperationResultImpl {
    /**
     * Initialize a new instance of the class OperationResult class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the operation result for a resource
     * @param operationId
     * @param location
     * @param options The options parameters.
     */
    get(operationId, location, options) {
        return this.client.sendOperationRequest({ operationId, location, options }, getOperationSpec$c);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataProtection/locations/{location}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationJobExtendedInfo
        },
        202: {
            headersMapper: OperationResultGetHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationStatus operations. */
class OperationStatusImpl {
    /**
     * Initialize a new instance of the class OperationStatus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the operation status for a resource.
     * @param location
     * @param operationId
     * @param options The options parameters.
     */
    get(location, operationId, options) {
        return this.client.sendOperationRequest({ location, operationId, options }, getOperationSpec$b);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataProtection/locations/{location}/operationStatus/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationStatusBackupVaultContext operations. */
class OperationStatusBackupVaultContextImpl {
    /**
     * Initialize a new instance of the class OperationStatusBackupVaultContext class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the operation status for an operation over a BackupVault's context.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param operationId
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, operationId, options }, getOperationSpec$a);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/operationStatus/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationStatusResourceGroupContext operations. */
class OperationStatusResourceGroupContextImpl {
    /**
     * Initialize a new instance of the class OperationStatusResourceGroupContext class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the operation status for an operation over a ResourceGroup's context.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param operationId
     * @param options The options parameters.
     */
    get(resourceGroupName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, operationId, options }, getOperationSpec$9);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/operationStatus/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing BackupVaultOperationResults operations. */
class BackupVaultOperationResultsImpl {
    /**
     * Initialize a new instance of the class BackupVaultOperationResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param operationId
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, operationId, options }, getOperationSpec$8);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupVaultResource
        },
        202: {
            headersMapper: BackupVaultOperationResultsGetHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DataProtection operations. */
class DataProtectionImpl {
    /**
     * Initialize a new instance of the class DataProtection class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Validates if a feature is supported
     * @param location
     * @param parameters Feature support request object
     * @param options The options parameters.
     */
    checkFeatureSupport(location, parameters, options) {
        return this.client.sendOperationRequest({ location, parameters, options }, checkFeatureSupportOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkFeatureSupportOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataProtection/locations/{location}/checkFeatureSupport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FeatureValidationResponseBase
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataProtectionOperations operations. */
class DataProtectionOperationsImpl {
    /**
     * Initialize a new instance of the class DataProtectionOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of available operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns the list of available operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/providers/Microsoft.DataProtection/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClientDiscoveryResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClientDiscoveryResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BackupPolicies operations. */
class BackupPoliciesImpl {
    /**
     * Initialize a new instance of the class BackupPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of backup policies belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of backup policies belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec$5);
    }
    /**
     * Gets a backup policy belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupPolicyName
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, backupPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupPolicyName, options }, getOperationSpec$7);
    }
    /**
     * Creates or Updates a backup policy belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupPolicyName Name of the policy
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, vaultName, backupPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupPolicyName, parameters, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes a backup policy belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupPolicyName
     * @param options The options parameters.
     */
    delete(resourceGroupName, vaultName, backupPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupPolicyName, options }, deleteOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BaseBackupPolicyResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BaseBackupPolicyResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BaseBackupPolicyResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupPolicies/{backupPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BaseBackupPolicyResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BackupInstances operations. */
class BackupInstancesImpl {
    /**
     * Initialize a new instance of the class BackupInstances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a backup instances belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a backup instances belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec$4);
    }
    /**
     * Gets a backup instance with name in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, backupInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupInstanceName, options }, getOperationSpec$6);
    }
    /**
     * Create or update a backup instance in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    backupInstanceName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a backup instance in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vaultName, backupInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a backup instance in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, backupInstanceName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a backup instance in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vaultName, backupInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Trigger adhoc backup
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginAdhocBackup(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    backupInstanceName,
                    parameters,
                    options
                },
                spec: adhocBackupOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Trigger adhoc backup
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginAdhocBackupAndWait(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAdhocBackup(resourceGroupName, vaultName, backupInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validate whether adhoc backup will be successful or not
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginValidateForBackup(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, parameters, options },
                spec: validateForBackupOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validate whether adhoc backup will be successful or not
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginValidateForBackupAndWait(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateForBackup(resourceGroupName, vaultName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get result of backup instance creation operation
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param operationId
     * @param options The options parameters.
     */
    getBackupInstanceOperationResult(resourceGroupName, vaultName, backupInstanceName, operationId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vaultName,
            backupInstanceName,
            operationId,
            options
        }, getBackupInstanceOperationResultOperationSpec);
    }
    /**
     * rehydrate recovery point for restore for a BackupInstance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginTriggerRehydrate(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    backupInstanceName,
                    parameters,
                    options
                },
                spec: triggerRehydrateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * rehydrate recovery point for restore for a BackupInstance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginTriggerRehydrateAndWait(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTriggerRehydrate(resourceGroupName, vaultName, backupInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Triggers restore for a BackupInstance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginTriggerRestore(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    backupInstanceName,
                    parameters,
                    options
                },
                spec: triggerRestoreOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Triggers restore for a BackupInstance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginTriggerRestoreAndWait(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTriggerRestore(resourceGroupName, vaultName, backupInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation will resume backups for backup instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginResumeBackups(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, backupInstanceName, options },
                spec: resumeBackupsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation will resume backups for backup instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginResumeBackupsAndWait(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResumeBackups(resourceGroupName, vaultName, backupInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation will resume protection for a stopped backup instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginResumeProtection(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, backupInstanceName, options },
                spec: resumeProtectionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation will resume protection for a stopped backup instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginResumeProtectionAndWait(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResumeProtection(resourceGroupName, vaultName, backupInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation will stop protection of a backup instance and data will be held forever
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginStopProtection(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, backupInstanceName, options },
                spec: stopProtectionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation will stop protection of a backup instance and data will be held forever
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginStopProtectionAndWait(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopProtection(resourceGroupName, vaultName, backupInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation will stop backup for a backup instance and retains the backup data as per the policy
     * (except latest Recovery point, which will be retained forever)
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginSuspendBackups(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, backupInstanceName, options },
                spec: suspendBackupsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation will stop backup for a backup instance and retains the backup data as per the policy
     * (except latest Recovery point, which will be retained forever)
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    beginSuspendBackupsAndWait(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSuspendBackups(resourceGroupName, vaultName, backupInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Sync backup instance again in case of failure
     * This action will retry last failed operation and will bring backup instance to valid state
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginSyncBackupInstance(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    backupInstanceName,
                    parameters,
                    options
                },
                spec: syncBackupInstanceOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Sync backup instance again in case of failure
     * This action will retry last failed operation and will bring backup instance to valid state
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginSyncBackupInstanceAndWait(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSyncBackupInstance(resourceGroupName, vaultName, backupInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Validates if Restore can be triggered for a DataSource
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginValidateForRestore(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    backupInstanceName,
                    parameters,
                    options
                },
                spec: validateForRestoreOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Validates if Restore can be triggered for a DataSource
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    beginValidateForRestoreAndWait(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginValidateForRestore(resourceGroupName, vaultName, backupInstanceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupInstanceResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupInstanceResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupInstanceResource
        },
        201: {
            bodyMapper: BackupInstanceResource
        },
        202: {
            bodyMapper: BackupInstanceResource
        },
        204: {
            bodyMapper: BackupInstanceResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const adhocBackupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/backup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationJobExtendedInfo
        },
        201: {
            bodyMapper: OperationJobExtendedInfo
        },
        202: {
            bodyMapper: OperationJobExtendedInfo
        },
        204: {
            bodyMapper: OperationJobExtendedInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const validateForBackupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/validateForBackup",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationJobExtendedInfo
        },
        201: {
            bodyMapper: OperationJobExtendedInfo
        },
        202: {
            bodyMapper: OperationJobExtendedInfo
        },
        204: {
            bodyMapper: OperationJobExtendedInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const getBackupInstanceOperationResultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupInstanceResource
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        operationId,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const triggerRehydrateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/rehydrate",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: BackupInstancesTriggerRehydrateHeaders
        },
        201: {
            headersMapper: BackupInstancesTriggerRehydrateHeaders
        },
        202: {
            headersMapper: BackupInstancesTriggerRehydrateHeaders
        },
        204: {
            headersMapper: BackupInstancesTriggerRehydrateHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const triggerRestoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/restore",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationJobExtendedInfo
        },
        201: {
            bodyMapper: OperationJobExtendedInfo
        },
        202: {
            bodyMapper: OperationJobExtendedInfo
        },
        204: {
            bodyMapper: OperationJobExtendedInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const resumeBackupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/resumeBackups",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const resumeProtectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/resumeProtection",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const stopProtectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/stopProtection",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const suspendBackupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/suspendBackups",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const syncBackupInstanceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/sync",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const validateForRestoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/validateRestore",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: OperationJobExtendedInfo
        },
        201: {
            bodyMapper: OperationJobExtendedInfo
        },
        202: {
            bodyMapper: OperationJobExtendedInfo
        },
        204: {
            bodyMapper: OperationJobExtendedInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupInstanceResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RecoveryPoints operations. */
class RecoveryPointsImpl {
    /**
     * Initialize a new instance of the class RecoveryPoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of Recovery Points for a DataSource in a vault.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, backupInstanceName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, backupInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, backupInstanceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, backupInstanceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, backupInstanceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, backupInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, backupInstanceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of Recovery Points for a DataSource in a vault.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, backupInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupInstanceName, options }, listOperationSpec$3);
    }
    /**
     * Gets a Recovery Point using recoveryPointId for a Datasource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param recoveryPointId
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, backupInstanceName, recoveryPointId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vaultName,
            backupInstanceName,
            recoveryPointId,
            options
        }, getOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, backupInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupInstanceName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/recoveryPoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureBackupRecoveryPointResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/recoveryPoints/{recoveryPointId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureBackupRecoveryPointResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName,
        recoveryPointId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureBackupRecoveryPointResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Jobs operations. */
class JobsImpl {
    /**
     * Initialize a new instance of the class Jobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of jobs belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of jobs belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec$2);
    }
    /**
     * Gets a job with id in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param jobId The Job ID. This is a GUID-formatted string (e.g.
     *              00000000-0000-0000-0000-000000000000).
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, jobId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, jobId, options }, getOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupJobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureBackupJobResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupJobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureBackupJobResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        jobId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureBackupJobResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing RestorableTimeRanges operations. */
class RestorableTimeRangesImpl {
    /**
     * Initialize a new instance of the class RestorableTimeRanges class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the backup instance.
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    find(resourceGroupName, vaultName, backupInstanceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupInstanceName, parameters, options }, findOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const findOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}/findRestorableTimeRanges",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureBackupFindRestorableTimeRangesResponseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExportJobs operations. */
class ExportJobsImpl {
    /**
     * Initialize a new instance of the class ExportJobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Triggers export of jobs and returns an OperationID to track.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    beginTrigger(resourceGroupName, vaultName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, options },
                spec: triggerOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Triggers export of jobs and returns an OperationID to track.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    beginTriggerAndWait(resourceGroupName, vaultName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTrigger(resourceGroupName, vaultName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const triggerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/exportBackupJobs",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ExportJobsTriggerHeaders
        },
        201: {
            headersMapper: ExportJobsTriggerHeaders
        },
        202: {
            headersMapper: ExportJobsTriggerHeaders
        },
        204: {
            headersMapper: ExportJobsTriggerHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExportJobsOperationResult operations. */
class ExportJobsOperationResultImpl {
    /**
     * Initialize a new instance of the class ExportJobsOperationResult class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the operation result of operation triggered by Export Jobs API. If the operation is successful,
     * then it also contains URL of a Blob and a SAS key to access the same. The blob contains exported
     * jobs in JSON serialized format.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param operationId OperationID which represents the export job.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, operationId, options }, getOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupJobs/operations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExportJobsResult
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DeletedBackupInstances operations. */
class DeletedBackupInstancesImpl {
    /**
     * Initialize a new instance of the class DeletedBackupInstances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets deleted backup instances belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets deleted backup instances belonging to a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec$1);
    }
    /**
     * Gets a deleted backup instance with name in a backup vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the deleted backup instance
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, backupInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, backupInstanceName, options }, getOperationSpec$2);
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the deleted backup instance
     * @param options The options parameters.
     */
    beginUndelete(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, backupInstanceName, options },
                spec: undeleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param backupInstanceName The name of the deleted backup instance
     * @param options The options parameters.
     */
    beginUndeleteAndWait(resourceGroupName, vaultName, backupInstanceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUndelete(resourceGroupName, vaultName, backupInstanceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/deletedBackupInstances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedBackupInstanceResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/deletedBackupInstances/{backupInstanceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedBackupInstanceResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const undeleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/deletedBackupInstances/{backupInstanceName}/undelete",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        backupInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedBackupInstanceResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourceGuards operations. */
class ResourceGuardsImpl {
    /**
     * Initialize a new instance of the class ResourceGuards class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns ResourceGuards collection belonging to a subscription.
     * @param options The options parameters.
     */
    listResourcesInSubscription(options) {
        const iter = this.getResourcesInSubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getResourcesInSubscriptionPagingPage(options, settings);
            }
        };
    }
    getResourcesInSubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getResourcesInSubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getResourcesInSubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getResourcesInSubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getResourcesInSubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* getResourcesInSubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getResourcesInSubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns ResourceGuards collection belonging to a ResourceGroup.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listResourcesInResourceGroup(resourceGroupName, options) {
        const iter = this.getResourcesInResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getResourcesInResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    getResourcesInResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getResourcesInResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getResourcesInResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getResourcesInResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getResourcesInResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getResourcesInResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getResourcesInResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    listDisableSoftDeleteRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        const iter = this.getDisableSoftDeleteRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getDisableSoftDeleteRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings);
            }
        };
    }
    getDisableSoftDeleteRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getDisableSoftDeleteRequestsObjectsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getDisableSoftDeleteRequestsObjects(resourceGroupName, resourceGuardsName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getDisableSoftDeleteRequestsObjectsNext(resourceGroupName, resourceGuardsName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getDisableSoftDeleteRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getDisableSoftDeleteRequestsObjectsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getDisableSoftDeleteRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    listDeleteResourceGuardProxyRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        const iter = this.getDeleteResourceGuardProxyRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getDeleteResourceGuardProxyRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings);
            }
        };
    }
    getDeleteResourceGuardProxyRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getDeleteResourceGuardProxyRequestsObjectsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getDeleteResourceGuardProxyRequestsObjects(resourceGroupName, resourceGuardsName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getDeleteResourceGuardProxyRequestsObjectsNext(resourceGroupName, resourceGuardsName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getDeleteResourceGuardProxyRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getDeleteResourceGuardProxyRequestsObjectsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getDeleteResourceGuardProxyRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    listBackupSecurityPINRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        const iter = this.getBackupSecurityPINRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getBackupSecurityPINRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings);
            }
        };
    }
    getBackupSecurityPINRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getBackupSecurityPINRequestsObjectsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getBackupSecurityPINRequestsObjects(resourceGroupName, resourceGuardsName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getBackupSecurityPINRequestsObjectsNext(resourceGroupName, resourceGuardsName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getBackupSecurityPINRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getBackupSecurityPINRequestsObjectsPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getBackupSecurityPINRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    listDeleteProtectedItemRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        const iter = this.getDeleteProtectedItemRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getDeleteProtectedItemRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings);
            }
        };
    }
    getDeleteProtectedItemRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getDeleteProtectedItemRequestsObjectsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getDeleteProtectedItemRequestsObjects(resourceGroupName, resourceGuardsName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getDeleteProtectedItemRequestsObjectsNext(resourceGroupName, resourceGuardsName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getDeleteProtectedItemRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getDeleteProtectedItemRequestsObjectsPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getDeleteProtectedItemRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    listUpdateProtectionPolicyRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        const iter = this.getUpdateProtectionPolicyRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getUpdateProtectionPolicyRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings);
            }
        };
    }
    getUpdateProtectionPolicyRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getUpdateProtectionPolicyRequestsObjectsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getUpdateProtectionPolicyRequestsObjects(resourceGroupName, resourceGuardsName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getUpdateProtectionPolicyRequestsObjectsNext(resourceGroupName, resourceGuardsName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getUpdateProtectionPolicyRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUpdateProtectionPolicyRequestsObjectsPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getUpdateProtectionPolicyRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    listUpdateProtectedItemRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        const iter = this.getUpdateProtectedItemRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getUpdateProtectedItemRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings);
            }
        };
    }
    getUpdateProtectedItemRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getUpdateProtectedItemRequestsObjectsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getUpdateProtectedItemRequestsObjects(resourceGroupName, resourceGuardsName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getUpdateProtectedItemRequestsObjectsNext(resourceGroupName, resourceGuardsName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getUpdateProtectedItemRequestsObjectsPagingAll(resourceGroupName, resourceGuardsName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getUpdateProtectedItemRequestsObjectsPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getUpdateProtectedItemRequestsObjectsPagingPage(resourceGroupName, resourceGuardsName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Returns ResourceGuards collection belonging to a subscription.
     * @param options The options parameters.
     */
    _getResourcesInSubscription(options) {
        return this.client.sendOperationRequest({ options }, getResourcesInSubscriptionOperationSpec);
    }
    /**
     * Returns ResourceGuards collection belonging to a ResourceGroup.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _getResourcesInResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, getResourcesInResourceGroupOperationSpec);
    }
    /**
     * Creates or updates a ResourceGuard resource belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName The name of ResourceGuard
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    put(resourceGroupName, resourceGuardsName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, parameters, options }, putOperationSpec);
    }
    /**
     * Returns a ResourceGuard belonging to a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName The name of ResourceGuard
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getOperationSpec$1);
    }
    /**
     * Deletes a ResourceGuard resource from the resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName The name of ResourceGuard
     * @param options The options parameters.
     */
    delete(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, deleteOperationSpec$1);
    }
    /**
     * Updates a ResourceGuard resource belonging to a resource group. For example, updating tags for a
     * resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName The name of ResourceGuard
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    patch(resourceGroupName, resourceGuardsName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, parameters, options }, patchOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    _getDisableSoftDeleteRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getDisableSoftDeleteRequestsObjectsOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    _getDeleteResourceGuardProxyRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getDeleteResourceGuardProxyRequestsObjectsOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    _getBackupSecurityPINRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getBackupSecurityPINRequestsObjectsOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    _getDeleteProtectedItemRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getDeleteProtectedItemRequestsObjectsOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    _getUpdateProtectionPolicyRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getUpdateProtectionPolicyRequestsObjectsOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param options The options parameters.
     */
    _getUpdateProtectedItemRequestsObjects(resourceGroupName, resourceGuardsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, options }, getUpdateProtectedItemRequestsObjectsOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param requestName
     * @param options The options parameters.
     */
    getDefaultDisableSoftDeleteRequestsObject(resourceGroupName, resourceGuardsName, requestName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, requestName, options }, getDefaultDisableSoftDeleteRequestsObjectOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param requestName
     * @param options The options parameters.
     */
    getDefaultDeleteResourceGuardProxyRequestsObject(resourceGroupName, resourceGuardsName, requestName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, requestName, options }, getDefaultDeleteResourceGuardProxyRequestsObjectOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param requestName
     * @param options The options parameters.
     */
    getDefaultBackupSecurityPINRequestsObject(resourceGroupName, resourceGuardsName, requestName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, requestName, options }, getDefaultBackupSecurityPINRequestsObjectOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param requestName
     * @param options The options parameters.
     */
    getDefaultDeleteProtectedItemRequestsObject(resourceGroupName, resourceGuardsName, requestName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, requestName, options }, getDefaultDeleteProtectedItemRequestsObjectOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param requestName
     * @param options The options parameters.
     */
    getDefaultUpdateProtectionPolicyRequestsObject(resourceGroupName, resourceGuardsName, requestName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, requestName, options }, getDefaultUpdateProtectionPolicyRequestsObjectOperationSpec);
    }
    /**
     * Returns collection of operation request objects for a critical operation protected by the given
     * ResourceGuard resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param requestName
     * @param options The options parameters.
     */
    getDefaultUpdateProtectedItemRequestsObject(resourceGroupName, resourceGuardsName, requestName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, requestName, options }, getDefaultUpdateProtectedItemRequestsObjectOperationSpec);
    }
    /**
     * GetResourcesInSubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the GetResourcesInSubscription
     *                 method.
     * @param options The options parameters.
     */
    _getResourcesInSubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getResourcesInSubscriptionNextOperationSpec);
    }
    /**
     * GetResourcesInResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the GetResourcesInResourceGroup
     *                 method.
     * @param options The options parameters.
     */
    _getResourcesInResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, getResourcesInResourceGroupNextOperationSpec);
    }
    /**
     * GetDisableSoftDeleteRequestsObjectsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetDisableSoftDeleteRequestsObjects method.
     * @param options The options parameters.
     */
    _getDisableSoftDeleteRequestsObjectsNext(resourceGroupName, resourceGuardsName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, nextLink, options }, getDisableSoftDeleteRequestsObjectsNextOperationSpec);
    }
    /**
     * GetDeleteResourceGuardProxyRequestsObjectsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetDeleteResourceGuardProxyRequestsObjects method.
     * @param options The options parameters.
     */
    _getDeleteResourceGuardProxyRequestsObjectsNext(resourceGroupName, resourceGuardsName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, nextLink, options }, getDeleteResourceGuardProxyRequestsObjectsNextOperationSpec);
    }
    /**
     * GetBackupSecurityPINRequestsObjectsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetBackupSecurityPINRequestsObjects method.
     * @param options The options parameters.
     */
    _getBackupSecurityPINRequestsObjectsNext(resourceGroupName, resourceGuardsName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, nextLink, options }, getBackupSecurityPINRequestsObjectsNextOperationSpec);
    }
    /**
     * GetDeleteProtectedItemRequestsObjectsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetDeleteProtectedItemRequestsObjects method.
     * @param options The options parameters.
     */
    _getDeleteProtectedItemRequestsObjectsNext(resourceGroupName, resourceGuardsName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, nextLink, options }, getDeleteProtectedItemRequestsObjectsNextOperationSpec);
    }
    /**
     * GetUpdateProtectionPolicyRequestsObjectsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetUpdateProtectionPolicyRequestsObjects method.
     * @param options The options parameters.
     */
    _getUpdateProtectionPolicyRequestsObjectsNext(resourceGroupName, resourceGuardsName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, nextLink, options }, getUpdateProtectionPolicyRequestsObjectsNextOperationSpec);
    }
    /**
     * GetUpdateProtectedItemRequestsObjectsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceGuardsName
     * @param nextLink The nextLink from the previous successful call to the
     *                 GetUpdateProtectedItemRequestsObjects method.
     * @param options The options parameters.
     */
    _getUpdateProtectedItemRequestsObjectsNext(resourceGroupName, resourceGuardsName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceGuardsName, nextLink, options }, getUpdateProtectedItemRequestsObjectsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getResourcesInSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataProtection/resourceGuards",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const getResourcesInResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ResourceGuardResource
        },
        201: {
            bodyMapper: ResourceGuardResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const patchOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ResourceGuardResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getDisableSoftDeleteRequestsObjectsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/disableSoftDeleteRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDeleteResourceGuardProxyRequestsObjectsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/deleteResourceGuardProxyRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getBackupSecurityPINRequestsObjectsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/getBackupSecurityPINRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDeleteProtectedItemRequestsObjectsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/deleteProtectedItemRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getUpdateProtectionPolicyRequestsObjectsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/updateProtectionPolicyRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getUpdateProtectedItemRequestsObjectsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/updateProtectedItemRequests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDefaultDisableSoftDeleteRequestsObjectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/disableSoftDeleteRequests/{requestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName,
        requestName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDefaultDeleteResourceGuardProxyRequestsObjectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/deleteResourceGuardProxyRequests/{requestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName,
        requestName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDefaultBackupSecurityPINRequestsObjectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/getBackupSecurityPINRequests/{requestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName,
        requestName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDefaultDeleteProtectedItemRequestsObjectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/deleteProtectedItemRequests/{requestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName,
        requestName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDefaultUpdateProtectionPolicyRequestsObjectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/updateProtectionPolicyRequests/{requestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName,
        requestName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDefaultUpdateProtectedItemRequestsObjectOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/resourceGuards/{resourceGuardsName}/updateProtectedItemRequests/{requestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceGuardsName,
        requestName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getResourcesInSubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getResourcesInResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDisableSoftDeleteRequestsObjectsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDeleteResourceGuardProxyRequestsObjectsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getBackupSecurityPINRequestsObjectsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getDeleteProtectedItemRequestsObjectsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getUpdateProtectionPolicyRequestsObjectsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getUpdateProtectedItemRequestsObjectsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DppBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        resourceGuardsName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DppResourceGuardProxy operations. */
class DppResourceGuardProxyImpl {
    /**
     * Initialize a new instance of the class DppResourceGuardProxy class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of ResourceGuardProxies associated with the vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns the list of ResourceGuardProxies associated with the vault
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec);
    }
    /**
     * Returns the ResourceGuardProxy object associated with the vault, and that matches the name in the
     * request
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param resourceGuardProxyName name of the resource guard proxy
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, resourceGuardProxyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, resourceGuardProxyName, options }, getOperationSpec);
    }
    /**
     * Creates or Updates a ResourceGuardProxy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param resourceGuardProxyName name of the resource guard proxy
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, vaultName, resourceGuardProxyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vaultName,
            resourceGuardProxyName,
            parameters,
            options
        }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes the ResourceGuardProxy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param resourceGuardProxyName name of the resource guard proxy
     * @param options The options parameters.
     */
    delete(resourceGroupName, vaultName, resourceGuardProxyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, resourceGuardProxyName, options }, deleteOperationSpec);
    }
    /**
     * UnlockDelete call for ResourceGuardProxy, executed before one can delete it
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param resourceGuardProxyName name of the resource guard proxy
     * @param parameters Request body for operation
     * @param options The options parameters.
     */
    unlockDelete(resourceGroupName, vaultName, resourceGuardProxyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vaultName,
            resourceGuardProxyName,
            parameters,
            options
        }, unlockDeleteOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vaultName The name of the backup vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupResourceGuardProxies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardProxyBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardProxyBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        resourceGuardProxyName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ResourceGuardProxyBaseResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        resourceGuardProxyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        resourceGuardProxyName
    ],
    headerParameters: [accept],
    serializer
};
const unlockDeleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupResourceGuardProxies/{resourceGuardProxyName}/unlockDelete",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UnlockDeleteResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        resourceGuardProxyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceGuardProxyBaseResourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class DataProtectionClient extends coreClient__namespace.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-dataprotection/1.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-05-01";
        this.backupVaults = new BackupVaultsImpl(this);
        this.operationResult = new OperationResultImpl(this);
        this.operationStatus = new OperationStatusImpl(this);
        this.operationStatusBackupVaultContext = new OperationStatusBackupVaultContextImpl(this);
        this.operationStatusResourceGroupContext = new OperationStatusResourceGroupContextImpl(this);
        this.backupVaultOperationResults = new BackupVaultOperationResultsImpl(this);
        this.dataProtection = new DataProtectionImpl(this);
        this.dataProtectionOperations = new DataProtectionOperationsImpl(this);
        this.backupPolicies = new BackupPoliciesImpl(this);
        this.backupInstances = new BackupInstancesImpl(this);
        this.recoveryPoints = new RecoveryPointsImpl(this);
        this.jobs = new JobsImpl(this);
        this.restorableTimeRanges = new RestorableTimeRangesImpl(this);
        this.exportJobs = new ExportJobsImpl(this);
        this.exportJobsOperationResult = new ExportJobsOperationResultImpl(this);
        this.deletedBackupInstances = new DeletedBackupInstancesImpl(this);
        this.resourceGuards = new ResourceGuardsImpl(this);
        this.dppResourceGuardProxy = new DppResourceGuardProxyImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.DataProtectionClient = DataProtectionClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map

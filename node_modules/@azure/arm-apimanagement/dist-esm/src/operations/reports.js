/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import { setContinuationToken } from "../pagingHelper";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
/// <reference lib="esnext.asynciterable" />
/** Class containing Reports operations. */
export class ReportsImpl {
    /**
     * Initialize a new instance of the class Reports class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists report records by API.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter The filter to apply on the operation.
     * @param options The options parameters.
     */
    listByApi(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByApiPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByApiPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listByApiPagingPage(resourceGroupName, serviceName, filter, options, settings) {
        return __asyncGenerator(this, arguments, function* listByApiPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByApi(resourceGroupName, serviceName, filter, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByApiNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByApiPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listByApiPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByApiPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists report records by User.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| userId | select, filter | eq |
     *               | </br>| apiRegion | filter | eq |     | </br>| productId | filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter
     *               | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked |
     *               select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>|
     *               callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     |
     *               </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>|
     *               cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>|
     *               apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg |
     *               select |     |     | </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |
     *                 |     | </br>
     * @param options The options parameters.
     */
    listByUser(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByUserPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByUserPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listByUserPagingPage(resourceGroupName, serviceName, filter, options, settings) {
        return __asyncGenerator(this, arguments, function* listByUserPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByUser(resourceGroupName, serviceName, filter, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByUserNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByUserPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listByUserPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByUserPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists report records by API Operations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | select, filter | eq |
     *                | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked | select, orderBy
     *               |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>| callCountOther | select,
     *               orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     | </br>| bandwidth |
     *               select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>| apiTimeMin | select |
     *                  |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     |
     *               </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listByOperation(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByOperationPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByOperationPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listByOperationPagingPage(resourceGroupName, serviceName, filter, options, settings) {
        return __asyncGenerator(this, arguments, function* listByOperationPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByOperation(resourceGroupName, serviceName, filter, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByOperationNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByOperationPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listByOperationPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByOperationPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists report records by Product.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>|
     *               callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |
     *                | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |
     *                 |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |
     *                | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     |
     *               </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>|
     *               serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listByProduct(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByProductPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByProductPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listByProductPagingPage(resourceGroupName, serviceName, filter, options, settings) {
        return __asyncGenerator(this, arguments, function* listByProductPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByProduct(resourceGroupName, serviceName, filter, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByProductNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByProductPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listByProductPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByProductPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists report records by geography.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| country | select |     |     | </br>| region | select |     |     | </br>| zip |
     *               select |     |     | </br>| apiRegion | filter | eq |     | </br>| userId | filter | eq |     |
     *               </br>| productId | filter | eq |     | </br>| subscriptionId | filter | eq |     | </br>| apiId |
     *               filter | eq |     | </br>| operationId | filter | eq |     | </br>| callCountSuccess | select |
     *               |     | </br>| callCountBlocked | select |     |     | </br>| callCountFailed | select |     |     |
     *               </br>| callCountOther | select |     |     | </br>| bandwidth | select, orderBy |     |     | </br>|
     *               cacheHitsCount | select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg
     *               | select |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                 | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listByGeo(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByGeoPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByGeoPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listByGeoPagingPage(resourceGroupName, serviceName, filter, options, settings) {
        return __asyncGenerator(this, arguments, function* listByGeoPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByGeo(resourceGroupName, serviceName, filter, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByGeoNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByGeoPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listByGeoPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByGeoPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Lists report records by subscription.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | select, filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | select, filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     |
     *               </br>| callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |
     *                 |     | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select,
     *               orderBy |     |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount |
     *               select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select,
     *               orderBy |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    listBySubscription(resourceGroupName, serviceName, filter, options) {
        const iter = this.listBySubscriptionPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(resourceGroupName, serviceName, filter, options, settings) {
        return __asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listBySubscription(resourceGroupName, serviceName, filter, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listBySubscriptionNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listBySubscriptionPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listBySubscriptionPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Lists report records by Time.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter, select
     *               | ge, le |     | </br>| interval | select |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     |
     *               </br>| callCountSuccess | select |     |     | </br>| callCountBlocked | select |     |     | </br>|
     *               callCountFailed | select |     |     | </br>| callCountOther | select |     |     | </br>| bandwidth
     *               | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select |     |     | </br>| apiTimeMin | select |     |
     *               | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     | </br>|
     *               serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param interval By time interval. Interval must be multiple of 15 minutes and may not be zero. The
     *                 value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can
     *                 be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours,
     *                 minutes, seconds)).
     * @param options The options parameters.
     */
    listByTime(resourceGroupName, serviceName, filter, interval, options) {
        const iter = this.listByTimePagingAll(resourceGroupName, serviceName, filter, interval, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByTimePagingPage(resourceGroupName, serviceName, filter, interval, options, settings);
            }
        };
    }
    listByTimePagingPage(resourceGroupName, serviceName, filter, interval, options, settings) {
        return __asyncGenerator(this, arguments, function* listByTimePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listByTime(resourceGroupName, serviceName, filter, interval, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listByTimeNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listByTimePagingAll(resourceGroupName, serviceName, filter, interval, options) {
        return __asyncGenerator(this, arguments, function* listByTimePagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByTimePagingPage(resourceGroupName, serviceName, filter, interval, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Lists report records by Request.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     | </br>| productId
     *               | filter | eq |     | </br>| userId | filter | eq |     | </br>| apiRegion | filter | eq |     |
     *               </br>| subscriptionId | filter | eq |     | </br>
     * @param options The options parameters.
     */
    listByRequest(resourceGroupName, serviceName, filter, options) {
        const iter = this.listByRequestPagingAll(resourceGroupName, serviceName, filter, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByRequestPagingPage(resourceGroupName, serviceName, filter, options, settings);
            }
        };
    }
    listByRequestPagingPage(resourceGroupName, serviceName, filter, options, _settings) {
        return __asyncGenerator(this, arguments, function* listByRequestPagingPage_1() {
            let result;
            result = yield __await(this._listByRequest(resourceGroupName, serviceName, filter, options));
            yield yield __await(result.value || []);
        });
    }
    listByRequestPagingAll(resourceGroupName, serviceName, filter, options) {
        return __asyncGenerator(this, arguments, function* listByRequestPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listByRequestPagingPage(resourceGroupName, serviceName, filter, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * Lists report records by API.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter The filter to apply on the operation.
     * @param options The options parameters.
     */
    _listByApi(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByApiOperationSpec);
    }
    /**
     * Lists report records by User.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| userId | select, filter | eq |
     *               | </br>| apiRegion | filter | eq |     | </br>| productId | filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter
     *               | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked |
     *               select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>|
     *               callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     |
     *               </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>|
     *               cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>|
     *               apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg |
     *               select |     |     | </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |
     *                 |     | </br>
     * @param options The options parameters.
     */
    _listByUser(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByUserOperationSpec);
    }
    /**
     * Lists report records by API Operations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | select, filter | eq |
     *                | </br>| callCountSuccess | select, orderBy |     |     | </br>| callCountBlocked | select, orderBy
     *               |     |     | </br>| callCountFailed | select, orderBy |     |     | </br>| callCountOther | select,
     *               orderBy |     |     | </br>| callCountTotal | select, orderBy |     |     | </br>| bandwidth |
     *               select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select, orderBy |     |     | </br>| apiTimeMin | select |
     *                  |     | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     |
     *               </br>| serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listByOperation(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByOperationOperationSpec);
    }
    /**
     * Lists report records by Product.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     | </br>|
     *               callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |     |
     *                | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select, orderBy |
     *                 |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount | select |     |
     *                | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select, orderBy |     |     |
     *               </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |     | </br>|
     *               serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listByProduct(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByProductOperationSpec);
    }
    /**
     * Lists report records by geography.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| country | select |     |     | </br>| region | select |     |     | </br>| zip |
     *               select |     |     | </br>| apiRegion | filter | eq |     | </br>| userId | filter | eq |     |
     *               </br>| productId | filter | eq |     | </br>| subscriptionId | filter | eq |     | </br>| apiId |
     *               filter | eq |     | </br>| operationId | filter | eq |     | </br>| callCountSuccess | select |
     *               |     | </br>| callCountBlocked | select |     |     | </br>| callCountFailed | select |     |     |
     *               </br>| callCountOther | select |     |     | </br>| bandwidth | select, orderBy |     |     | </br>|
     *               cacheHitsCount | select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg
     *               | select |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                 | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listByGeo(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByGeoOperationSpec);
    }
    /**
     * Lists report records by subscription.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| displayName | select, orderBy |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | select, filter | eq |     | </br>| productId | select, filter | eq |     | </br>|
     *               subscriptionId | select, filter | eq |     | </br>| callCountSuccess | select, orderBy |     |     |
     *               </br>| callCountBlocked | select, orderBy |     |     | </br>| callCountFailed | select, orderBy |
     *                 |     | </br>| callCountOther | select, orderBy |     |     | </br>| callCountTotal | select,
     *               orderBy |     |     | </br>| bandwidth | select, orderBy |     |     | </br>| cacheHitsCount |
     *               select |     |     | </br>| cacheMissCount | select |     |     | </br>| apiTimeAvg | select,
     *               orderBy |     |     | </br>| apiTimeMin | select |     |     | </br>| apiTimeMax | select |     |
     *                | </br>| serviceTimeAvg | select |     |     | </br>| serviceTimeMin | select |     |     | </br>|
     *               serviceTimeMax | select |     |     | </br>
     * @param options The options parameters.
     */
    _listBySubscription(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listBySubscriptionOperationSpec);
    }
    /**
     * Lists report records by Time.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter, select
     *               | ge, le |     | </br>| interval | select |     |     | </br>| apiRegion | filter | eq |     |
     *               </br>| userId | filter | eq |     | </br>| productId | filter | eq |     | </br>| subscriptionId |
     *               filter | eq |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     |
     *               </br>| callCountSuccess | select |     |     | </br>| callCountBlocked | select |     |     | </br>|
     *               callCountFailed | select |     |     | </br>| callCountOther | select |     |     | </br>| bandwidth
     *               | select, orderBy |     |     | </br>| cacheHitsCount | select |     |     | </br>| cacheMissCount |
     *               select |     |     | </br>| apiTimeAvg | select |     |     | </br>| apiTimeMin | select |     |
     *               | </br>| apiTimeMax | select |     |     | </br>| serviceTimeAvg | select |     |     | </br>|
     *               serviceTimeMin | select |     |     | </br>| serviceTimeMax | select |     |     | </br>
     * @param interval By time interval. Interval must be multiple of 15 minutes and may not be zero. The
     *                 value should be in ISO  8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).This code can
     *                 be used to convert TimeSpan to a valid interval string: XmlConvert.ToString(new TimeSpan(hours,
     *                 minutes, seconds)).
     * @param options The options parameters.
     */
    _listByTime(resourceGroupName, serviceName, filter, interval, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, interval, options }, listByTimeOperationSpec);
    }
    /**
     * Lists report records by Request.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param filter |   Field     |     Usage     |     Supported operators     |     Supported functions
     *                  |</br>|-------------|-------------|-------------|-------------|</br>| timestamp | filter | ge, le
     *               |     | </br>| apiId | filter | eq |     | </br>| operationId | filter | eq |     | </br>| productId
     *               | filter | eq |     | </br>| userId | filter | eq |     | </br>| apiRegion | filter | eq |     |
     *               </br>| subscriptionId | filter | eq |     | </br>
     * @param options The options parameters.
     */
    _listByRequest(resourceGroupName, serviceName, filter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, filter, options }, listByRequestOperationSpec);
    }
    /**
     * ListByApiNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByApi method.
     * @param options The options parameters.
     */
    _listByApiNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByApiNextOperationSpec);
    }
    /**
     * ListByUserNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByUser method.
     * @param options The options parameters.
     */
    _listByUserNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByUserNextOperationSpec);
    }
    /**
     * ListByOperationNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByOperation method.
     * @param options The options parameters.
     */
    _listByOperationNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByOperationNextOperationSpec);
    }
    /**
     * ListByProductNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByProduct method.
     * @param options The options parameters.
     */
    _listByProductNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByProductNextOperationSpec);
    }
    /**
     * ListByGeoNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByGeo method.
     * @param options The options parameters.
     */
    _listByGeoNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByGeoNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByTimeNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param serviceName The name of the API Management service.
     * @param nextLink The nextLink from the previous successful call to the ListByTime method.
     * @param options The options parameters.
     */
    _listByTimeNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listByTimeNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByApiOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byApi",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.orderby,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byUser",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.orderby,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byOperation",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.orderby,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByProductOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byProduct",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.orderby,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByGeoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byGeo",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/bySubscription",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.orderby,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByTimeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byTime",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.orderby,
        Parameters.filter1,
        Parameters.interval
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByRequestOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/reports/byRequest",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.RequestReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [
        Parameters.top,
        Parameters.skip,
        Parameters.apiVersion,
        Parameters.filter1
    ],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByApiNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByUserNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByOperationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByProductNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByGeoNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listByTimeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ReportCollection
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.serviceName,
        Parameters.subscriptionId,
        Parameters.nextLink
    ],
    headerParameters: [Parameters.accept],
    serializer
};
//# sourceMappingURL=reports.js.map
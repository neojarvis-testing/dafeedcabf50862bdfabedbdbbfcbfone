'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link KubernetesSupportPlan} that the service accepts. */
exports.KnownKubernetesSupportPlan = void 0;
(function (KnownKubernetesSupportPlan) {
    /** Support for the version is the same as for the open source Kubernetes offering. Official Kubernetes open source community support versions for 1 year after release. */
    KnownKubernetesSupportPlan["KubernetesOfficial"] = "KubernetesOfficial";
    /** Support for the version extended past the KubernetesOfficial support of 1 year. AKS continues to patch CVEs for another 1 year, for a total of 2 years of support. */
    KnownKubernetesSupportPlan["AKSLongTermSupport"] = "AKSLongTermSupport";
})(exports.KnownKubernetesSupportPlan || (exports.KnownKubernetesSupportPlan = {}));
/** Known values of {@link ManagedClusterSKUName} that the service accepts. */
exports.KnownManagedClusterSKUName = void 0;
(function (KnownManagedClusterSKUName) {
    /** Base option for the AKS control plane. */
    KnownManagedClusterSKUName["Base"] = "Base";
})(exports.KnownManagedClusterSKUName || (exports.KnownManagedClusterSKUName = {}));
/** Known values of {@link ManagedClusterSKUTier} that the service accepts. */
exports.KnownManagedClusterSKUTier = void 0;
(function (KnownManagedClusterSKUTier) {
    /** Cluster has premium capabilities in addition to all of the capabilities included in 'Standard'. Premium enables selection of LongTermSupport (aka.ms\/aks\/lts) for certain Kubernetes versions. */
    KnownManagedClusterSKUTier["Premium"] = "Premium";
    /** Recommended for mission-critical and production workloads. Includes Kubernetes control plane autoscaling, workload-intensive testing, and up to 5,000 nodes per cluster. Guarantees 99.95% availability of the Kubernetes API server endpoint for clusters that use Availability Zones and 99.9% of availability for clusters that don't use Availability Zones. */
    KnownManagedClusterSKUTier["Standard"] = "Standard";
    /** The cluster management is free, but charged for VM, storage, and networking usage. Best for experimenting, learning, simple testing, or workloads with fewer than 10 nodes. Not recommended for production use cases. */
    KnownManagedClusterSKUTier["Free"] = "Free";
})(exports.KnownManagedClusterSKUTier || (exports.KnownManagedClusterSKUTier = {}));
/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
exports.KnownExtendedLocationTypes = void 0;
(function (KnownExtendedLocationTypes) {
    /** EdgeZone */
    KnownExtendedLocationTypes["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = {}));
/** Known values of {@link Code} that the service accepts. */
exports.KnownCode = void 0;
(function (KnownCode) {
    /** The cluster is running. */
    KnownCode["Running"] = "Running";
    /** The cluster is stopped. */
    KnownCode["Stopped"] = "Stopped";
})(exports.KnownCode || (exports.KnownCode = {}));
/** Known values of {@link OSDiskType} that the service accepts. */
exports.KnownOSDiskType = void 0;
(function (KnownOSDiskType) {
    /** Azure replicates the operating system disk for a virtual machine to Azure storage to avoid data loss should the VM need to be relocated to another host. Since containers aren't designed to have local state persisted, this behavior offers limited value while providing some drawbacks, including slower node provisioning and higher read\/write latency. */
    KnownOSDiskType["Managed"] = "Managed";
    /** Ephemeral OS disks are stored only on the host machine, just like a temporary disk. This provides lower read\/write latency, along with faster node scaling and cluster upgrades. */
    KnownOSDiskType["Ephemeral"] = "Ephemeral";
})(exports.KnownOSDiskType || (exports.KnownOSDiskType = {}));
/** Known values of {@link KubeletDiskType} that the service accepts. */
exports.KnownKubeletDiskType = void 0;
(function (KnownKubeletDiskType) {
    /** Kubelet will use the OS disk for its data. */
    KnownKubeletDiskType["OS"] = "OS";
    /** Kubelet will use the temporary disk for its data. */
    KnownKubeletDiskType["Temporary"] = "Temporary";
})(exports.KnownKubeletDiskType || (exports.KnownKubeletDiskType = {}));
/** Known values of {@link WorkloadRuntime} that the service accepts. */
exports.KnownWorkloadRuntime = void 0;
(function (KnownWorkloadRuntime) {
    /** Nodes will use Kubelet to run standard OCI container workloads. */
    KnownWorkloadRuntime["OCIContainer"] = "OCIContainer";
    /** Nodes will use Krustlet to run WASM workloads using the WASI provider (Preview). */
    KnownWorkloadRuntime["WasmWasi"] = "WasmWasi";
})(exports.KnownWorkloadRuntime || (exports.KnownWorkloadRuntime = {}));
/** Known values of {@link OSType} that the service accepts. */
exports.KnownOSType = void 0;
(function (KnownOSType) {
    /** Use Linux. */
    KnownOSType["Linux"] = "Linux";
    /** Use Windows. */
    KnownOSType["Windows"] = "Windows";
})(exports.KnownOSType || (exports.KnownOSType = {}));
/** Known values of {@link Ossku} that the service accepts. */
exports.KnownOssku = void 0;
(function (KnownOssku) {
    /** Use Ubuntu as the OS for node images. */
    KnownOssku["Ubuntu"] = "Ubuntu";
    /** Use AzureLinux as the OS for node images. Azure Linux is a container-optimized Linux distro built by Microsoft, visit https:\//aka.ms\/azurelinux for more information. */
    KnownOssku["AzureLinux"] = "AzureLinux";
    /** Deprecated OSSKU. Microsoft recommends that new deployments choose 'AzureLinux' instead. */
    KnownOssku["CBLMariner"] = "CBLMariner";
    /** Use Windows2019 as the OS for node images. Unsupported for system node pools. Windows2019 only supports Windows2019 containers; it cannot run Windows2022 containers and vice versa. */
    KnownOssku["Windows2019"] = "Windows2019";
    /** Use Windows2022 as the OS for node images. Unsupported for system node pools. Windows2022 only supports Windows2022 containers; it cannot run Windows2019 containers and vice versa. */
    KnownOssku["Windows2022"] = "Windows2022";
})(exports.KnownOssku || (exports.KnownOssku = {}));
/** Known values of {@link ScaleDownMode} that the service accepts. */
exports.KnownScaleDownMode = void 0;
(function (KnownScaleDownMode) {
    /** Create new instances during scale up and remove instances during scale down. */
    KnownScaleDownMode["Delete"] = "Delete";
    /** Attempt to start deallocated instances (if they exist) during scale up and deallocate instances during scale down. */
    KnownScaleDownMode["Deallocate"] = "Deallocate";
})(exports.KnownScaleDownMode || (exports.KnownScaleDownMode = {}));
/** Known values of {@link AgentPoolType} that the service accepts. */
exports.KnownAgentPoolType = void 0;
(function (KnownAgentPoolType) {
    /** Create an Agent Pool backed by a Virtual Machine Scale Set. */
    KnownAgentPoolType["VirtualMachineScaleSets"] = "VirtualMachineScaleSets";
    /** Use of this is strongly discouraged. */
    KnownAgentPoolType["AvailabilitySet"] = "AvailabilitySet";
})(exports.KnownAgentPoolType || (exports.KnownAgentPoolType = {}));
/** Known values of {@link AgentPoolMode} that the service accepts. */
exports.KnownAgentPoolMode = void 0;
(function (KnownAgentPoolMode) {
    /** System agent pools are primarily for hosting critical system pods such as CoreDNS and metrics-server. System agent pools osType must be Linux. System agent pools VM SKU must have at least 2vCPUs and 4GB of memory. */
    KnownAgentPoolMode["System"] = "System";
    /** User agent pools are primarily for hosting your application pods. */
    KnownAgentPoolMode["User"] = "User";
})(exports.KnownAgentPoolMode || (exports.KnownAgentPoolMode = {}));
/** Known values of {@link ScaleSetPriority} that the service accepts. */
exports.KnownScaleSetPriority = void 0;
(function (KnownScaleSetPriority) {
    /** Spot priority VMs will be used. There is no SLA for spot nodes. See [spot on AKS](https:\//docs.microsoft.com\/azure\/aks\/spot-node-pool) for more information. */
    KnownScaleSetPriority["Spot"] = "Spot";
    /** Regular VMs will be used. */
    KnownScaleSetPriority["Regular"] = "Regular";
})(exports.KnownScaleSetPriority || (exports.KnownScaleSetPriority = {}));
/** Known values of {@link ScaleSetEvictionPolicy} that the service accepts. */
exports.KnownScaleSetEvictionPolicy = void 0;
(function (KnownScaleSetEvictionPolicy) {
    /** Nodes in the underlying Scale Set of the node pool are deleted when they're evicted. */
    KnownScaleSetEvictionPolicy["Delete"] = "Delete";
    /** Nodes in the underlying Scale Set of the node pool are set to the stopped-deallocated state upon eviction. Nodes in the stopped-deallocated state count against your compute quota and can cause issues with cluster scaling or upgrading. */
    KnownScaleSetEvictionPolicy["Deallocate"] = "Deallocate";
})(exports.KnownScaleSetEvictionPolicy || (exports.KnownScaleSetEvictionPolicy = {}));
/** Known values of {@link GPUInstanceProfile} that the service accepts. */
exports.KnownGPUInstanceProfile = void 0;
(function (KnownGPUInstanceProfile) {
    /** MIG1G */
    KnownGPUInstanceProfile["MIG1G"] = "MIG1g";
    /** MIG2G */
    KnownGPUInstanceProfile["MIG2G"] = "MIG2g";
    /** MIG3G */
    KnownGPUInstanceProfile["MIG3G"] = "MIG3g";
    /** MIG4G */
    KnownGPUInstanceProfile["MIG4G"] = "MIG4g";
    /** MIG7G */
    KnownGPUInstanceProfile["MIG7G"] = "MIG7g";
})(exports.KnownGPUInstanceProfile || (exports.KnownGPUInstanceProfile = {}));
/** Known values of {@link Protocol} that the service accepts. */
exports.KnownProtocol = void 0;
(function (KnownProtocol) {
    /** TCP protocol. */
    KnownProtocol["TCP"] = "TCP";
    /** UDP protocol. */
    KnownProtocol["UDP"] = "UDP";
})(exports.KnownProtocol || (exports.KnownProtocol = {}));
/** Known values of {@link LicenseType} that the service accepts. */
exports.KnownLicenseType = void 0;
(function (KnownLicenseType) {
    /** No additional licensing is applied. */
    KnownLicenseType["None"] = "None";
    /** Enables Azure Hybrid User Benefits for Windows VMs. */
    KnownLicenseType["WindowsServer"] = "Windows_Server";
})(exports.KnownLicenseType || (exports.KnownLicenseType = {}));
/** Known values of {@link ManagedClusterPodIdentityProvisioningState} that the service accepts. */
exports.KnownManagedClusterPodIdentityProvisioningState = void 0;
(function (KnownManagedClusterPodIdentityProvisioningState) {
    /** Assigned */
    KnownManagedClusterPodIdentityProvisioningState["Assigned"] = "Assigned";
    /** Canceled */
    KnownManagedClusterPodIdentityProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownManagedClusterPodIdentityProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownManagedClusterPodIdentityProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownManagedClusterPodIdentityProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownManagedClusterPodIdentityProvisioningState["Updating"] = "Updating";
})(exports.KnownManagedClusterPodIdentityProvisioningState || (exports.KnownManagedClusterPodIdentityProvisioningState = {}));
/** Known values of {@link NetworkPlugin} that the service accepts. */
exports.KnownNetworkPlugin = void 0;
(function (KnownNetworkPlugin) {
    /** Use the Azure CNI network plugin. See [Azure CNI (advanced) networking](https:\//docs.microsoft.com\/azure\/aks\/concepts-network#azure-cni-advanced-networking) for more information. */
    KnownNetworkPlugin["Azure"] = "azure";
    /** Use the Kubenet network plugin. See [Kubenet (basic) networking](https:\//docs.microsoft.com\/azure\/aks\/concepts-network#kubenet-basic-networking) for more information. */
    KnownNetworkPlugin["Kubenet"] = "kubenet";
    /** No CNI plugin is pre-installed. See [BYO CNI](https:\//docs.microsoft.com\/en-us\/azure\/aks\/use-byo-cni) for more information. */
    KnownNetworkPlugin["None"] = "none";
})(exports.KnownNetworkPlugin || (exports.KnownNetworkPlugin = {}));
/** Known values of {@link NetworkPluginMode} that the service accepts. */
exports.KnownNetworkPluginMode = void 0;
(function (KnownNetworkPluginMode) {
    /** Used with networkPlugin=azure, pods are given IPs from the PodCIDR address space but use Azure Routing Domains rather than Kubenet's method of route tables. For more information visit https:\//aka.ms\/aks\/azure-cni-overlay. */
    KnownNetworkPluginMode["Overlay"] = "overlay";
})(exports.KnownNetworkPluginMode || (exports.KnownNetworkPluginMode = {}));
/** Known values of {@link NetworkPolicy} that the service accepts. */
exports.KnownNetworkPolicy = void 0;
(function (KnownNetworkPolicy) {
    /** Use Calico network policies. See [differences between Azure and Calico policies](https:\//docs.microsoft.com\/azure\/aks\/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities) for more information. */
    KnownNetworkPolicy["Calico"] = "calico";
    /** Use Azure network policies. See [differences between Azure and Calico policies](https:\//docs.microsoft.com\/azure\/aks\/use-network-policies#differences-between-azure-and-calico-policies-and-their-capabilities) for more information. */
    KnownNetworkPolicy["Azure"] = "azure";
    /** Use Cilium to enforce network policies. This requires networkDataplane to be 'cilium'. */
    KnownNetworkPolicy["Cilium"] = "cilium";
})(exports.KnownNetworkPolicy || (exports.KnownNetworkPolicy = {}));
/** Known values of {@link NetworkMode} that the service accepts. */
exports.KnownNetworkMode = void 0;
(function (KnownNetworkMode) {
    /** No bridge is created. Intra-VM Pod to Pod communication is through IP routes created by Azure CNI. See [Transparent Mode](https:\//docs.microsoft.com\/azure\/aks\/faq#transparent-mode) for more information. */
    KnownNetworkMode["Transparent"] = "transparent";
    /** This is no longer supported */
    KnownNetworkMode["Bridge"] = "bridge";
})(exports.KnownNetworkMode || (exports.KnownNetworkMode = {}));
/** Known values of {@link NetworkDataplane} that the service accepts. */
exports.KnownNetworkDataplane = void 0;
(function (KnownNetworkDataplane) {
    /** Use Azure network dataplane. */
    KnownNetworkDataplane["Azure"] = "azure";
    /** Use Cilium network dataplane. See [Azure CNI Powered by Cilium](https:\//learn.microsoft.com\/azure\/aks\/azure-cni-powered-by-cilium) for more information. */
    KnownNetworkDataplane["Cilium"] = "cilium";
})(exports.KnownNetworkDataplane || (exports.KnownNetworkDataplane = {}));
/** Known values of {@link OutboundType} that the service accepts. */
exports.KnownOutboundType = void 0;
(function (KnownOutboundType) {
    /** The load balancer is used for egress through an AKS assigned public IP. This supports Kubernetes services of type 'loadBalancer'. For more information see [outbound type loadbalancer](https:\//docs.microsoft.com\/azure\/aks\/egress-outboundtype#outbound-type-of-loadbalancer). */
    KnownOutboundType["LoadBalancer"] = "loadBalancer";
    /** Egress paths must be defined by the user. This is an advanced scenario and requires proper network configuration. For more information see [outbound type userDefinedRouting](https:\//docs.microsoft.com\/azure\/aks\/egress-outboundtype#outbound-type-of-userdefinedrouting). */
    KnownOutboundType["UserDefinedRouting"] = "userDefinedRouting";
    /** The AKS-managed NAT gateway is used for egress. */
    KnownOutboundType["ManagedNATGateway"] = "managedNATGateway";
    /** The user-assigned NAT gateway associated to the cluster subnet is used for egress. This is an advanced scenario and requires proper network configuration. */
    KnownOutboundType["UserAssignedNATGateway"] = "userAssignedNATGateway";
})(exports.KnownOutboundType || (exports.KnownOutboundType = {}));
/** Known values of {@link LoadBalancerSku} that the service accepts. */
exports.KnownLoadBalancerSku = void 0;
(function (KnownLoadBalancerSku) {
    /** Use a a standard Load Balancer. This is the recommended Load Balancer SKU. For more information about on working with the load balancer in the managed cluster, see the [standard Load Balancer](https:\//docs.microsoft.com\/azure\/aks\/load-balancer-standard) article. */
    KnownLoadBalancerSku["Standard"] = "standard";
    /** Use a basic Load Balancer with limited functionality. */
    KnownLoadBalancerSku["Basic"] = "basic";
})(exports.KnownLoadBalancerSku || (exports.KnownLoadBalancerSku = {}));
/** Known values of {@link BackendPoolType} that the service accepts. */
exports.KnownBackendPoolType = void 0;
(function (KnownBackendPoolType) {
    /** The type of the managed inbound Load Balancer BackendPool. https:\//cloud-provider-azure.sigs.k8s.io\/topics\/loadbalancer\/#configure-load-balancer-backend. */
    KnownBackendPoolType["NodeIPConfiguration"] = "NodeIPConfiguration";
    /** The type of the managed inbound Load Balancer BackendPool. https:\//cloud-provider-azure.sigs.k8s.io\/topics\/loadbalancer\/#configure-load-balancer-backend. */
    KnownBackendPoolType["NodeIP"] = "NodeIP";
})(exports.KnownBackendPoolType || (exports.KnownBackendPoolType = {}));
/** Known values of {@link IpFamily} that the service accepts. */
exports.KnownIpFamily = void 0;
(function (KnownIpFamily) {
    /** IPv4 */
    KnownIpFamily["IPv4"] = "IPv4";
    /** IPv6 */
    KnownIpFamily["IPv6"] = "IPv6";
})(exports.KnownIpFamily || (exports.KnownIpFamily = {}));
/** Known values of {@link UpgradeChannel} that the service accepts. */
exports.KnownUpgradeChannel = void 0;
(function (KnownUpgradeChannel) {
    /** Automatically upgrade the cluster to the latest supported patch release on the latest supported minor version. In cases where the cluster is at a version of Kubernetes that is at an N-2 minor version where N is the latest supported minor version, the cluster first upgrades to the latest supported patch version on N-1 minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster first is upgraded to 1.18.6, then is upgraded to 1.19.1. */
    KnownUpgradeChannel["Rapid"] = "rapid";
    /** Automatically upgrade the cluster to the latest supported patch release on minor version N-1, where N is the latest supported minor version. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.18.6. */
    KnownUpgradeChannel["Stable"] = "stable";
    /** Automatically upgrade the cluster to the latest supported patch version when it becomes available while keeping the minor version the same. For example, if a cluster is running version 1.17.7 and versions 1.17.9, 1.18.4, 1.18.6, and 1.19.1 are available, your cluster is upgraded to 1.17.9. */
    KnownUpgradeChannel["Patch"] = "patch";
    /** Automatically upgrade the node image to the latest version available. Consider using nodeOSUpgradeChannel instead as that allows you to configure node OS patching separate from Kubernetes version patching */
    KnownUpgradeChannel["NodeImage"] = "node-image";
    /** Disables auto-upgrades and keeps the cluster at its current version of Kubernetes. */
    KnownUpgradeChannel["None"] = "none";
})(exports.KnownUpgradeChannel || (exports.KnownUpgradeChannel = {}));
/** Known values of {@link NodeOSUpgradeChannel} that the service accepts. */
exports.KnownNodeOSUpgradeChannel = void 0;
(function (KnownNodeOSUpgradeChannel) {
    /** No attempt to update your machines OS will be made either by OS or by rolling VHDs. This means you are responsible for your security updates */
    KnownNodeOSUpgradeChannel["None"] = "None";
    /** OS updates will be applied automatically through the OS built-in patching infrastructure. Newly scaled in machines will be unpatched initially and will be patched at some point by the OS's infrastructure. Behavior of this option depends on the OS in question. Ubuntu and Mariner apply security patches through unattended upgrade roughly once a day around 06:00 UTC. Windows does not apply security patches automatically and so for them this option is equivalent to None till further notice */
    KnownNodeOSUpgradeChannel["Unmanaged"] = "Unmanaged";
    /** AKS will update the nodes with a newly patched VHD containing security fixes and bugfixes on a weekly cadence. With the VHD update machines will be rolling reimaged to that VHD following maintenance windows and surge settings. No extra VHD cost is incurred when choosing this option as AKS hosts the images. */
    KnownNodeOSUpgradeChannel["NodeImage"] = "NodeImage";
})(exports.KnownNodeOSUpgradeChannel || (exports.KnownNodeOSUpgradeChannel = {}));
/** Known values of {@link Expander} that the service accepts. */
exports.KnownExpander = void 0;
(function (KnownExpander) {
    /** Selects the node group that will have the least idle CPU (if tied, unused memory) after scale-up. This is useful when you have different classes of nodes, for example, high CPU or high memory nodes, and only want to expand those when there are pending pods that need a lot of those resources. */
    KnownExpander["LeastWaste"] = "least-waste";
    /** Selects the node group that would be able to schedule the most pods when scaling up. This is useful when you are using nodeSelector to make sure certain pods land on certain nodes. Note that this won't cause the autoscaler to select bigger nodes vs. smaller, as it can add multiple smaller nodes at once. */
    KnownExpander["MostPods"] = "most-pods";
    /** Selects the node group that has the highest priority assigned by the user. It's configuration is described in more details [here](https:\//github.com\/kubernetes\/autoscaler\/blob\/master\/cluster-autoscaler\/expander\/priority\/readme.md). */
    KnownExpander["Priority"] = "priority";
    /** Used when you don't have a particular need for the node groups to scale differently. */
    KnownExpander["Random"] = "random";
})(exports.KnownExpander || (exports.KnownExpander = {}));
/** Known values of {@link KeyVaultNetworkAccessTypes} that the service accepts. */
exports.KnownKeyVaultNetworkAccessTypes = void 0;
(function (KnownKeyVaultNetworkAccessTypes) {
    /** Public */
    KnownKeyVaultNetworkAccessTypes["Public"] = "Public";
    /** Private */
    KnownKeyVaultNetworkAccessTypes["Private"] = "Private";
})(exports.KnownKeyVaultNetworkAccessTypes || (exports.KnownKeyVaultNetworkAccessTypes = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link ServiceMeshMode} that the service accepts. */
exports.KnownServiceMeshMode = void 0;
(function (KnownServiceMeshMode) {
    /** Istio deployed as an AKS addon. */
    KnownServiceMeshMode["Istio"] = "Istio";
    /** Mesh is disabled. */
    KnownServiceMeshMode["Disabled"] = "Disabled";
})(exports.KnownServiceMeshMode || (exports.KnownServiceMeshMode = {}));
/** Known values of {@link IstioIngressGatewayMode} that the service accepts. */
exports.KnownIstioIngressGatewayMode = void 0;
(function (KnownIstioIngressGatewayMode) {
    /** The ingress gateway is assigned a public IP address and is publicly accessible. */
    KnownIstioIngressGatewayMode["External"] = "External";
    /** The ingress gateway is assigned an internal IP address and cannot is accessed publicly. */
    KnownIstioIngressGatewayMode["Internal"] = "Internal";
})(exports.KnownIstioIngressGatewayMode || (exports.KnownIstioIngressGatewayMode = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link Format} that the service accepts. */
exports.KnownFormat = void 0;
(function (KnownFormat) {
    /** Return azure auth-provider kubeconfig. This format is deprecated in v1.22 and will be fully removed in v1.26. See: https:\//aka.ms\/k8s\/changes-1-26. */
    KnownFormat["Azure"] = "azure";
    /** Return exec format kubeconfig. This format requires kubelogin binary in the path. */
    KnownFormat["Exec"] = "exec";
})(exports.KnownFormat || (exports.KnownFormat = {}));
/** Known values of {@link WeekDay} that the service accepts. */
exports.KnownWeekDay = void 0;
(function (KnownWeekDay) {
    /** Sunday */
    KnownWeekDay["Sunday"] = "Sunday";
    /** Monday */
    KnownWeekDay["Monday"] = "Monday";
    /** Tuesday */
    KnownWeekDay["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownWeekDay["Wednesday"] = "Wednesday";
    /** Thursday */
    KnownWeekDay["Thursday"] = "Thursday";
    /** Friday */
    KnownWeekDay["Friday"] = "Friday";
    /** Saturday */
    KnownWeekDay["Saturday"] = "Saturday";
})(exports.KnownWeekDay || (exports.KnownWeekDay = {}));
/** Known values of {@link Type} that the service accepts. */
exports.KnownType = void 0;
(function (KnownType) {
    /** First week of the month. */
    KnownType["First"] = "First";
    /** Second week of the month. */
    KnownType["Second"] = "Second";
    /** Third week of the month. */
    KnownType["Third"] = "Third";
    /** Fourth week of the month. */
    KnownType["Fourth"] = "Fourth";
    /** Last week of the month. */
    KnownType["Last"] = "Last";
})(exports.KnownType || (exports.KnownType = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Canceled */
    KnownPrivateEndpointConnectionProvisioningState["Canceled"] = "Canceled";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link ConnectionStatus} that the service accepts. */
exports.KnownConnectionStatus = void 0;
(function (KnownConnectionStatus) {
    /** Pending */
    KnownConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownConnectionStatus || (exports.KnownConnectionStatus = {}));
/** Known values of {@link SnapshotType} that the service accepts. */
exports.KnownSnapshotType = void 0;
(function (KnownSnapshotType) {
    /** The snapshot is a snapshot of a node pool. */
    KnownSnapshotType["NodePool"] = "NodePool";
})(exports.KnownSnapshotType || (exports.KnownSnapshotType = {}));
/** Known values of {@link TrustedAccessRoleBindingProvisioningState} that the service accepts. */
exports.KnownTrustedAccessRoleBindingProvisioningState = void 0;
(function (KnownTrustedAccessRoleBindingProvisioningState) {
    /** Canceled */
    KnownTrustedAccessRoleBindingProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownTrustedAccessRoleBindingProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownTrustedAccessRoleBindingProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownTrustedAccessRoleBindingProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownTrustedAccessRoleBindingProvisioningState["Updating"] = "Updating";
})(exports.KnownTrustedAccessRoleBindingProvisioningState || (exports.KnownTrustedAccessRoleBindingProvisioningState = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationValue",
                        },
                    },
                },
            },
        },
    },
};
const OperationValue = {
    type: {
        name: "Composite",
        className: "OperationValue",
        modelProperties: {
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            operation: {
                serializedName: "display.operation",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            resource: {
                serializedName: "display.resource",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "display.description",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            provider: {
                serializedName: "display.provider",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody",
                },
            },
        },
    },
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody",
                        },
                    },
                },
            },
        },
    },
};
const OSOptionProfile = {
    type: {
        name: "Composite",
        className: "OSOptionProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            osOptionPropertyList: {
                serializedName: "properties.osOptionPropertyList",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OSOptionProperty",
                        },
                    },
                },
            },
        },
    },
};
const OSOptionProperty = {
    type: {
        name: "Composite",
        className: "OSOptionProperty",
        modelProperties: {
            osType: {
                serializedName: "os-type",
                required: true,
                type: {
                    name: "String",
                },
            },
            enableFipsImage: {
                serializedName: "enable-fips-image",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const KubernetesVersionListResult = {
    type: {
        name: "Composite",
        className: "KubernetesVersionListResult",
        modelProperties: {
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KubernetesVersion",
                        },
                    },
                },
            },
        },
    },
};
const KubernetesVersion = {
    type: {
        name: "Composite",
        className: "KubernetesVersion",
        modelProperties: {
            version: {
                serializedName: "version",
                type: {
                    name: "String",
                },
            },
            capabilities: {
                serializedName: "capabilities",
                type: {
                    name: "Composite",
                    className: "KubernetesVersionCapabilities",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
            patchVersions: {
                serializedName: "patchVersions",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "KubernetesPatchVersion" },
                    },
                },
            },
        },
    },
};
const KubernetesVersionCapabilities = {
    type: {
        name: "Composite",
        className: "KubernetesVersionCapabilities",
        modelProperties: {
            supportPlan: {
                serializedName: "supportPlan",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const KubernetesPatchVersion = {
    type: {
        name: "Composite",
        className: "KubernetesPatchVersion",
        modelProperties: {
            upgrades: {
                serializedName: "upgrades",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterListResult = {
    type: {
        name: "Composite",
        className: "ManagedClusterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedCluster",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterSKU = {
    type: {
        name: "Composite",
        className: "ManagedClusterSKU",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterIdentity = {
    type: {
        name: "Composite",
        className: "ManagedClusterIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["SystemAssigned", "UserAssigned", "None"],
                },
            },
            delegatedResources: {
                serializedName: "delegatedResources",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "DelegatedResource" },
                    },
                },
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "ManagedServiceIdentityUserAssignedIdentitiesValue",
                        },
                    },
                },
            },
        },
    },
};
const DelegatedResource = {
    type: {
        name: "Composite",
        className: "DelegatedResource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String",
                },
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid",
                },
            },
            referralResource: {
                serializedName: "referralResource",
                type: {
                    name: "String",
                },
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedServiceIdentityUserAssignedIdentitiesValue = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentityUserAssignedIdentitiesValue",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PowerState = {
    type: {
        name: "Composite",
        className: "PowerState",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterAgentPoolProfileProperties = {
    type: {
        name: "Composite",
        className: "ManagedClusterAgentPoolProfileProperties",
        modelProperties: {
            count: {
                serializedName: "count",
                type: {
                    name: "Number",
                },
            },
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String",
                },
            },
            osDiskSizeGB: {
                constraints: {
                    InclusiveMaximum: 2048,
                    InclusiveMinimum: 0,
                },
                serializedName: "osDiskSizeGB",
                type: {
                    name: "Number",
                },
            },
            osDiskType: {
                serializedName: "osDiskType",
                type: {
                    name: "String",
                },
            },
            kubeletDiskType: {
                serializedName: "kubeletDiskType",
                type: {
                    name: "String",
                },
            },
            workloadRuntime: {
                serializedName: "workloadRuntime",
                type: {
                    name: "String",
                },
            },
            vnetSubnetID: {
                serializedName: "vnetSubnetID",
                type: {
                    name: "String",
                },
            },
            podSubnetID: {
                serializedName: "podSubnetID",
                type: {
                    name: "String",
                },
            },
            maxPods: {
                serializedName: "maxPods",
                type: {
                    name: "Number",
                },
            },
            osType: {
                defaultValue: "Linux",
                serializedName: "osType",
                type: {
                    name: "String",
                },
            },
            osSKU: {
                serializedName: "osSKU",
                type: {
                    name: "String",
                },
            },
            maxCount: {
                serializedName: "maxCount",
                type: {
                    name: "Number",
                },
            },
            minCount: {
                serializedName: "minCount",
                type: {
                    name: "Number",
                },
            },
            enableAutoScaling: {
                serializedName: "enableAutoScaling",
                type: {
                    name: "Boolean",
                },
            },
            scaleDownMode: {
                serializedName: "scaleDownMode",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String",
                },
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String",
                },
            },
            orchestratorVersion: {
                serializedName: "orchestratorVersion",
                type: {
                    name: "String",
                },
            },
            currentOrchestratorVersion: {
                serializedName: "currentOrchestratorVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            nodeImageVersion: {
                serializedName: "nodeImageVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            upgradeSettings: {
                serializedName: "upgradeSettings",
                type: {
                    name: "Composite",
                    className: "AgentPoolUpgradeSettings",
                },
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            powerState: {
                serializedName: "powerState",
                type: {
                    name: "Composite",
                    className: "PowerState",
                },
            },
            availabilityZones: {
                serializedName: "availabilityZones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            enableNodePublicIP: {
                serializedName: "enableNodePublicIP",
                type: {
                    name: "Boolean",
                },
            },
            nodePublicIPPrefixID: {
                serializedName: "nodePublicIPPrefixID",
                type: {
                    name: "String",
                },
            },
            scaleSetPriority: {
                defaultValue: "Regular",
                serializedName: "scaleSetPriority",
                type: {
                    name: "String",
                },
            },
            scaleSetEvictionPolicy: {
                defaultValue: "Delete",
                serializedName: "scaleSetEvictionPolicy",
                type: {
                    name: "String",
                },
            },
            spotMaxPrice: {
                defaultValue: -1,
                serializedName: "spotMaxPrice",
                type: {
                    name: "Number",
                },
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            nodeLabels: {
                serializedName: "nodeLabels",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            nodeTaints: {
                serializedName: "nodeTaints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            proximityPlacementGroupID: {
                serializedName: "proximityPlacementGroupID",
                type: {
                    name: "String",
                },
            },
            kubeletConfig: {
                serializedName: "kubeletConfig",
                type: {
                    name: "Composite",
                    className: "KubeletConfig",
                },
            },
            linuxOSConfig: {
                serializedName: "linuxOSConfig",
                type: {
                    name: "Composite",
                    className: "LinuxOSConfig",
                },
            },
            enableEncryptionAtHost: {
                serializedName: "enableEncryptionAtHost",
                type: {
                    name: "Boolean",
                },
            },
            enableUltraSSD: {
                serializedName: "enableUltraSSD",
                type: {
                    name: "Boolean",
                },
            },
            enableFips: {
                serializedName: "enableFIPS",
                type: {
                    name: "Boolean",
                },
            },
            gpuInstanceProfile: {
                serializedName: "gpuInstanceProfile",
                type: {
                    name: "String",
                },
            },
            creationData: {
                serializedName: "creationData",
                type: {
                    name: "Composite",
                    className: "CreationData",
                },
            },
            capacityReservationGroupID: {
                serializedName: "capacityReservationGroupID",
                type: {
                    name: "String",
                },
            },
            hostGroupID: {
                serializedName: "hostGroupID",
                type: {
                    name: "String",
                },
            },
            networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "AgentPoolNetworkProfile",
                },
            },
        },
    },
};
const AgentPoolUpgradeSettings = {
    type: {
        name: "Composite",
        className: "AgentPoolUpgradeSettings",
        modelProperties: {
            maxSurge: {
                serializedName: "maxSurge",
                type: {
                    name: "String",
                },
            },
            drainTimeoutInMinutes: {
                constraints: {
                    InclusiveMaximum: 1440,
                    InclusiveMinimum: 1,
                },
                serializedName: "drainTimeoutInMinutes",
                type: {
                    name: "Number",
                },
            },
            nodeSoakDurationInMinutes: {
                constraints: {
                    InclusiveMaximum: 30,
                    InclusiveMinimum: 0,
                },
                serializedName: "nodeSoakDurationInMinutes",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const KubeletConfig = {
    type: {
        name: "Composite",
        className: "KubeletConfig",
        modelProperties: {
            cpuManagerPolicy: {
                serializedName: "cpuManagerPolicy",
                type: {
                    name: "String",
                },
            },
            cpuCfsQuota: {
                serializedName: "cpuCfsQuota",
                type: {
                    name: "Boolean",
                },
            },
            cpuCfsQuotaPeriod: {
                serializedName: "cpuCfsQuotaPeriod",
                type: {
                    name: "String",
                },
            },
            imageGcHighThreshold: {
                serializedName: "imageGcHighThreshold",
                type: {
                    name: "Number",
                },
            },
            imageGcLowThreshold: {
                serializedName: "imageGcLowThreshold",
                type: {
                    name: "Number",
                },
            },
            topologyManagerPolicy: {
                serializedName: "topologyManagerPolicy",
                type: {
                    name: "String",
                },
            },
            allowedUnsafeSysctls: {
                serializedName: "allowedUnsafeSysctls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            failSwapOn: {
                serializedName: "failSwapOn",
                type: {
                    name: "Boolean",
                },
            },
            containerLogMaxSizeMB: {
                serializedName: "containerLogMaxSizeMB",
                type: {
                    name: "Number",
                },
            },
            containerLogMaxFiles: {
                constraints: {
                    InclusiveMinimum: 2,
                },
                serializedName: "containerLogMaxFiles",
                type: {
                    name: "Number",
                },
            },
            podMaxPids: {
                serializedName: "podMaxPids",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const LinuxOSConfig = {
    type: {
        name: "Composite",
        className: "LinuxOSConfig",
        modelProperties: {
            sysctls: {
                serializedName: "sysctls",
                type: {
                    name: "Composite",
                    className: "SysctlConfig",
                },
            },
            transparentHugePageEnabled: {
                serializedName: "transparentHugePageEnabled",
                type: {
                    name: "String",
                },
            },
            transparentHugePageDefrag: {
                serializedName: "transparentHugePageDefrag",
                type: {
                    name: "String",
                },
            },
            swapFileSizeMB: {
                serializedName: "swapFileSizeMB",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const SysctlConfig = {
    type: {
        name: "Composite",
        className: "SysctlConfig",
        modelProperties: {
            netCoreSomaxconn: {
                serializedName: "netCoreSomaxconn",
                type: {
                    name: "Number",
                },
            },
            netCoreNetdevMaxBacklog: {
                serializedName: "netCoreNetdevMaxBacklog",
                type: {
                    name: "Number",
                },
            },
            netCoreRmemDefault: {
                serializedName: "netCoreRmemDefault",
                type: {
                    name: "Number",
                },
            },
            netCoreRmemMax: {
                serializedName: "netCoreRmemMax",
                type: {
                    name: "Number",
                },
            },
            netCoreWmemDefault: {
                serializedName: "netCoreWmemDefault",
                type: {
                    name: "Number",
                },
            },
            netCoreWmemMax: {
                serializedName: "netCoreWmemMax",
                type: {
                    name: "Number",
                },
            },
            netCoreOptmemMax: {
                serializedName: "netCoreOptmemMax",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpMaxSynBacklog: {
                serializedName: "netIpv4TcpMaxSynBacklog",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpMaxTwBuckets: {
                serializedName: "netIpv4TcpMaxTwBuckets",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpFinTimeout: {
                serializedName: "netIpv4TcpFinTimeout",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpKeepaliveTime: {
                serializedName: "netIpv4TcpKeepaliveTime",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpKeepaliveProbes: {
                serializedName: "netIpv4TcpKeepaliveProbes",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpkeepaliveIntvl: {
                constraints: {
                    InclusiveMaximum: 90,
                    InclusiveMinimum: 10,
                },
                serializedName: "netIpv4TcpkeepaliveIntvl",
                type: {
                    name: "Number",
                },
            },
            netIpv4TcpTwReuse: {
                serializedName: "netIpv4TcpTwReuse",
                type: {
                    name: "Boolean",
                },
            },
            netIpv4IpLocalPortRange: {
                serializedName: "netIpv4IpLocalPortRange",
                type: {
                    name: "String",
                },
            },
            netIpv4NeighDefaultGcThresh1: {
                serializedName: "netIpv4NeighDefaultGcThresh1",
                type: {
                    name: "Number",
                },
            },
            netIpv4NeighDefaultGcThresh2: {
                serializedName: "netIpv4NeighDefaultGcThresh2",
                type: {
                    name: "Number",
                },
            },
            netIpv4NeighDefaultGcThresh3: {
                serializedName: "netIpv4NeighDefaultGcThresh3",
                type: {
                    name: "Number",
                },
            },
            netNetfilterNfConntrackMax: {
                constraints: {
                    InclusiveMaximum: 2097152,
                    InclusiveMinimum: 131072,
                },
                serializedName: "netNetfilterNfConntrackMax",
                type: {
                    name: "Number",
                },
            },
            netNetfilterNfConntrackBuckets: {
                constraints: {
                    InclusiveMaximum: 524288,
                    InclusiveMinimum: 65536,
                },
                serializedName: "netNetfilterNfConntrackBuckets",
                type: {
                    name: "Number",
                },
            },
            fsInotifyMaxUserWatches: {
                serializedName: "fsInotifyMaxUserWatches",
                type: {
                    name: "Number",
                },
            },
            fsFileMax: {
                serializedName: "fsFileMax",
                type: {
                    name: "Number",
                },
            },
            fsAioMaxNr: {
                serializedName: "fsAioMaxNr",
                type: {
                    name: "Number",
                },
            },
            fsNrOpen: {
                serializedName: "fsNrOpen",
                type: {
                    name: "Number",
                },
            },
            kernelThreadsMax: {
                serializedName: "kernelThreadsMax",
                type: {
                    name: "Number",
                },
            },
            vmMaxMapCount: {
                serializedName: "vmMaxMapCount",
                type: {
                    name: "Number",
                },
            },
            vmSwappiness: {
                serializedName: "vmSwappiness",
                type: {
                    name: "Number",
                },
            },
            vmVfsCachePressure: {
                serializedName: "vmVfsCachePressure",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const CreationData = {
    type: {
        name: "Composite",
        className: "CreationData",
        modelProperties: {
            sourceResourceId: {
                serializedName: "sourceResourceId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolNetworkProfile = {
    type: {
        name: "Composite",
        className: "AgentPoolNetworkProfile",
        modelProperties: {
            nodePublicIPTags: {
                serializedName: "nodePublicIPTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPTag",
                        },
                    },
                },
            },
            allowedHostPorts: {
                serializedName: "allowedHostPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PortRange",
                        },
                    },
                },
            },
            applicationSecurityGroups: {
                serializedName: "applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const IPTag = {
    type: {
        name: "Composite",
        className: "IPTag",
        modelProperties: {
            ipTagType: {
                serializedName: "ipTagType",
                type: {
                    name: "String",
                },
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PortRange = {
    type: {
        name: "Composite",
        className: "PortRange",
        modelProperties: {
            portStart: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1,
                },
                serializedName: "portStart",
                type: {
                    name: "Number",
                },
            },
            portEnd: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1,
                },
                serializedName: "portEnd",
                type: {
                    name: "Number",
                },
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ContainerServiceLinuxProfile = {
    type: {
        name: "Composite",
        className: "ContainerServiceLinuxProfile",
        modelProperties: {
            adminUsername: {
                constraints: {
                    Pattern: new RegExp("^[A-Za-z][-A-Za-z0-9_]*$"),
                },
                serializedName: "adminUsername",
                required: true,
                type: {
                    name: "String",
                },
            },
            ssh: {
                serializedName: "ssh",
                type: {
                    name: "Composite",
                    className: "ContainerServiceSshConfiguration",
                },
            },
        },
    },
};
const ContainerServiceSshConfiguration = {
    type: {
        name: "Composite",
        className: "ContainerServiceSshConfiguration",
        modelProperties: {
            publicKeys: {
                serializedName: "publicKeys",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerServiceSshPublicKey",
                        },
                    },
                },
            },
        },
    },
};
const ContainerServiceSshPublicKey = {
    type: {
        name: "Composite",
        className: "ContainerServiceSshPublicKey",
        modelProperties: {
            keyData: {
                serializedName: "keyData",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterWindowsProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterWindowsProfile",
        modelProperties: {
            adminUsername: {
                serializedName: "adminUsername",
                required: true,
                type: {
                    name: "String",
                },
            },
            adminPassword: {
                serializedName: "adminPassword",
                type: {
                    name: "String",
                },
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String",
                },
            },
            enableCSIProxy: {
                serializedName: "enableCSIProxy",
                type: {
                    name: "Boolean",
                },
            },
            gmsaProfile: {
                serializedName: "gmsaProfile",
                type: {
                    name: "Composite",
                    className: "WindowsGmsaProfile",
                },
            },
        },
    },
};
const WindowsGmsaProfile = {
    type: {
        name: "Composite",
        className: "WindowsGmsaProfile",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            dnsServer: {
                serializedName: "dnsServer",
                type: {
                    name: "String",
                },
            },
            rootDomainName: {
                serializedName: "rootDomainName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterServicePrincipalProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterServicePrincipalProfile",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                required: true,
                type: {
                    name: "String",
                },
            },
            secret: {
                serializedName: "secret",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterAddonProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAddonProfile",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
            config: {
                serializedName: "config",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAddonProfileIdentity",
                },
            },
        },
    },
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String",
                },
            },
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String",
                },
            },
            objectId: {
                serializedName: "objectId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterPodIdentityProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterPodIdentityProfile",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            allowNetworkPluginKubenet: {
                serializedName: "allowNetworkPluginKubenet",
                type: {
                    name: "Boolean",
                },
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterPodIdentity",
                        },
                    },
                },
            },
            userAssignedIdentityExceptions: {
                serializedName: "userAssignedIdentityExceptions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterPodIdentityException",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterPodIdentity = {
    type: {
        name: "Composite",
        className: "ManagedClusterPodIdentity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            },
            namespace: {
                serializedName: "namespace",
                required: true,
                type: {
                    name: "String",
                },
            },
            bindingSelector: {
                serializedName: "bindingSelector",
                type: {
                    name: "String",
                },
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "UserAssignedIdentity",
                },
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            provisioningInfo: {
                serializedName: "provisioningInfo",
                type: {
                    name: "Composite",
                    className: "ManagedClusterPodIdentityProvisioningInfo",
                },
            },
        },
    },
};
const ManagedClusterPodIdentityProvisioningInfo = {
    type: {
        name: "Composite",
        className: "ManagedClusterPodIdentityProvisioningInfo",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ManagedClusterPodIdentityProvisioningError",
                },
            },
        },
    },
};
const ManagedClusterPodIdentityProvisioningError = {
    type: {
        name: "Composite",
        className: "ManagedClusterPodIdentityProvisioningError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ManagedClusterPodIdentityProvisioningErrorBody",
                },
            },
        },
    },
};
const ManagedClusterPodIdentityProvisioningErrorBody = {
    type: {
        name: "Composite",
        className: "ManagedClusterPodIdentityProvisioningErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterPodIdentityProvisioningErrorBody",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterPodIdentityException = {
    type: {
        name: "Composite",
        className: "ManagedClusterPodIdentityException",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            },
            namespace: {
                serializedName: "namespace",
                required: true,
                type: {
                    name: "String",
                },
            },
            podLabels: {
                serializedName: "podLabels",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const ManagedClusterOidcIssuerProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterOidcIssuerProfile",
        modelProperties: {
            issuerURL: {
                serializedName: "issuerURL",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ContainerServiceNetworkProfile = {
    type: {
        name: "Composite",
        className: "ContainerServiceNetworkProfile",
        modelProperties: {
            networkPlugin: {
                defaultValue: "kubenet",
                serializedName: "networkPlugin",
                type: {
                    name: "String",
                },
            },
            networkPluginMode: {
                serializedName: "networkPluginMode",
                type: {
                    name: "String",
                },
            },
            networkPolicy: {
                serializedName: "networkPolicy",
                type: {
                    name: "String",
                },
            },
            networkMode: {
                serializedName: "networkMode",
                type: {
                    name: "String",
                },
            },
            networkDataplane: {
                serializedName: "networkDataplane",
                type: {
                    name: "String",
                },
            },
            podCidr: {
                defaultValue: "10.244.0.0/16",
                constraints: {
                    Pattern: new RegExp("^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"),
                },
                serializedName: "podCidr",
                type: {
                    name: "String",
                },
            },
            serviceCidr: {
                defaultValue: "10.0.0.0/16",
                constraints: {
                    Pattern: new RegExp("^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"),
                },
                serializedName: "serviceCidr",
                type: {
                    name: "String",
                },
            },
            dnsServiceIP: {
                defaultValue: "10.0.0.10",
                constraints: {
                    Pattern: new RegExp("^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"),
                },
                serializedName: "dnsServiceIP",
                type: {
                    name: "String",
                },
            },
            outboundType: {
                defaultValue: "loadBalancer",
                serializedName: "outboundType",
                type: {
                    name: "String",
                },
            },
            loadBalancerSku: {
                serializedName: "loadBalancerSku",
                type: {
                    name: "String",
                },
            },
            loadBalancerProfile: {
                serializedName: "loadBalancerProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterLoadBalancerProfile",
                },
            },
            natGatewayProfile: {
                serializedName: "natGatewayProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterNATGatewayProfile",
                },
            },
            podCidrs: {
                serializedName: "podCidrs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            serviceCidrs: {
                serializedName: "serviceCidrs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            ipFamilies: {
                serializedName: "ipFamilies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterLoadBalancerProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterLoadBalancerProfile",
        modelProperties: {
            managedOutboundIPs: {
                serializedName: "managedOutboundIPs",
                type: {
                    name: "Composite",
                    className: "ManagedClusterLoadBalancerProfileManagedOutboundIPs",
                },
            },
            outboundIPPrefixes: {
                serializedName: "outboundIPPrefixes",
                type: {
                    name: "Composite",
                    className: "ManagedClusterLoadBalancerProfileOutboundIPPrefixes",
                },
            },
            outboundIPs: {
                serializedName: "outboundIPs",
                type: {
                    name: "Composite",
                    className: "ManagedClusterLoadBalancerProfileOutboundIPs",
                },
            },
            effectiveOutboundIPs: {
                serializedName: "effectiveOutboundIPs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference",
                        },
                    },
                },
            },
            allocatedOutboundPorts: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0,
                },
                serializedName: "allocatedOutboundPorts",
                type: {
                    name: "Number",
                },
            },
            idleTimeoutInMinutes: {
                defaultValue: 30,
                constraints: {
                    InclusiveMaximum: 120,
                    InclusiveMinimum: 4,
                },
                serializedName: "idleTimeoutInMinutes",
                type: {
                    name: "Number",
                },
            },
            enableMultipleStandardLoadBalancers: {
                serializedName: "enableMultipleStandardLoadBalancers",
                type: {
                    name: "Boolean",
                },
            },
            backendPoolType: {
                defaultValue: "NodeIPConfiguration",
                serializedName: "backendPoolType",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterLoadBalancerProfileManagedOutboundIPs = {
    type: {
        name: "Composite",
        className: "ManagedClusterLoadBalancerProfileManagedOutboundIPs",
        modelProperties: {
            count: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1,
                },
                serializedName: "count",
                type: {
                    name: "Number",
                },
            },
            countIPv6: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0,
                },
                serializedName: "countIPv6",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ManagedClusterLoadBalancerProfileOutboundIPPrefixes = {
    type: {
        name: "Composite",
        className: "ManagedClusterLoadBalancerProfileOutboundIPPrefixes",
        modelProperties: {
            publicIPPrefixes: {
                serializedName: "publicIPPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference",
                        },
                    },
                },
            },
        },
    },
};
const ResourceReference = {
    type: {
        name: "Composite",
        className: "ResourceReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterLoadBalancerProfileOutboundIPs = {
    type: {
        name: "Composite",
        className: "ManagedClusterLoadBalancerProfileOutboundIPs",
        modelProperties: {
            publicIPs: {
                serializedName: "publicIPs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterNATGatewayProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterNATGatewayProfile",
        modelProperties: {
            managedOutboundIPProfile: {
                serializedName: "managedOutboundIPProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterManagedOutboundIPProfile",
                },
            },
            effectiveOutboundIPs: {
                serializedName: "effectiveOutboundIPs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceReference",
                        },
                    },
                },
            },
            idleTimeoutInMinutes: {
                defaultValue: 4,
                constraints: {
                    InclusiveMaximum: 120,
                    InclusiveMinimum: 4,
                },
                serializedName: "idleTimeoutInMinutes",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ManagedClusterManagedOutboundIPProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterManagedOutboundIPProfile",
        modelProperties: {
            count: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 16,
                    InclusiveMinimum: 1,
                },
                serializedName: "count",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ManagedClusterAADProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAADProfile",
        modelProperties: {
            managed: {
                serializedName: "managed",
                type: {
                    name: "Boolean",
                },
            },
            enableAzureRbac: {
                serializedName: "enableAzureRBAC",
                type: {
                    name: "Boolean",
                },
            },
            adminGroupObjectIDs: {
                serializedName: "adminGroupObjectIDs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            clientAppID: {
                serializedName: "clientAppID",
                type: {
                    name: "String",
                },
            },
            serverAppID: {
                serializedName: "serverAppID",
                type: {
                    name: "String",
                },
            },
            serverAppSecret: {
                serializedName: "serverAppSecret",
                type: {
                    name: "String",
                },
            },
            tenantID: {
                serializedName: "tenantID",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterAutoUpgradeProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAutoUpgradeProfile",
        modelProperties: {
            upgradeChannel: {
                serializedName: "upgradeChannel",
                type: {
                    name: "String",
                },
            },
            nodeOSUpgradeChannel: {
                serializedName: "nodeOSUpgradeChannel",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ClusterUpgradeSettings = {
    type: {
        name: "Composite",
        className: "ClusterUpgradeSettings",
        modelProperties: {
            overrideSettings: {
                serializedName: "overrideSettings",
                type: {
                    name: "Composite",
                    className: "UpgradeOverrideSettings",
                },
            },
        },
    },
};
const UpgradeOverrideSettings = {
    type: {
        name: "Composite",
        className: "UpgradeOverrideSettings",
        modelProperties: {
            forceUpgrade: {
                serializedName: "forceUpgrade",
                type: {
                    name: "Boolean",
                },
            },
            until: {
                serializedName: "until",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const ManagedClusterPropertiesAutoScalerProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterPropertiesAutoScalerProfile",
        modelProperties: {
            balanceSimilarNodeGroups: {
                serializedName: "balance-similar-node-groups",
                type: {
                    name: "String",
                },
            },
            expander: {
                serializedName: "expander",
                type: {
                    name: "String",
                },
            },
            maxEmptyBulkDelete: {
                serializedName: "max-empty-bulk-delete",
                type: {
                    name: "String",
                },
            },
            maxGracefulTerminationSec: {
                serializedName: "max-graceful-termination-sec",
                type: {
                    name: "String",
                },
            },
            maxNodeProvisionTime: {
                serializedName: "max-node-provision-time",
                type: {
                    name: "String",
                },
            },
            maxTotalUnreadyPercentage: {
                serializedName: "max-total-unready-percentage",
                type: {
                    name: "String",
                },
            },
            newPodScaleUpDelay: {
                serializedName: "new-pod-scale-up-delay",
                type: {
                    name: "String",
                },
            },
            okTotalUnreadyCount: {
                serializedName: "ok-total-unready-count",
                type: {
                    name: "String",
                },
            },
            scanInterval: {
                serializedName: "scan-interval",
                type: {
                    name: "String",
                },
            },
            scaleDownDelayAfterAdd: {
                serializedName: "scale-down-delay-after-add",
                type: {
                    name: "String",
                },
            },
            scaleDownDelayAfterDelete: {
                serializedName: "scale-down-delay-after-delete",
                type: {
                    name: "String",
                },
            },
            scaleDownDelayAfterFailure: {
                serializedName: "scale-down-delay-after-failure",
                type: {
                    name: "String",
                },
            },
            scaleDownUnneededTime: {
                serializedName: "scale-down-unneeded-time",
                type: {
                    name: "String",
                },
            },
            scaleDownUnreadyTime: {
                serializedName: "scale-down-unready-time",
                type: {
                    name: "String",
                },
            },
            scaleDownUtilizationThreshold: {
                serializedName: "scale-down-utilization-threshold",
                type: {
                    name: "String",
                },
            },
            skipNodesWithLocalStorage: {
                serializedName: "skip-nodes-with-local-storage",
                type: {
                    name: "String",
                },
            },
            skipNodesWithSystemPods: {
                serializedName: "skip-nodes-with-system-pods",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterAPIServerAccessProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAPIServerAccessProfile",
        modelProperties: {
            authorizedIPRanges: {
                serializedName: "authorizedIPRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            enablePrivateCluster: {
                serializedName: "enablePrivateCluster",
                type: {
                    name: "Boolean",
                },
            },
            privateDNSZone: {
                serializedName: "privateDNSZone",
                type: {
                    name: "String",
                },
            },
            enablePrivateClusterPublicFqdn: {
                serializedName: "enablePrivateClusterPublicFQDN",
                type: {
                    name: "Boolean",
                },
            },
            disableRunCommand: {
                serializedName: "disableRunCommand",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String",
                },
            },
            groupId: {
                serializedName: "groupId",
                type: {
                    name: "String",
                },
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            privateLinkServiceID: {
                serializedName: "privateLinkServiceID",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterHttpProxyConfig = {
    type: {
        name: "Composite",
        className: "ManagedClusterHttpProxyConfig",
        modelProperties: {
            httpProxy: {
                serializedName: "httpProxy",
                type: {
                    name: "String",
                },
            },
            httpsProxy: {
                serializedName: "httpsProxy",
                type: {
                    name: "String",
                },
            },
            noProxy: {
                serializedName: "noProxy",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            trustedCa: {
                serializedName: "trustedCa",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterSecurityProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterSecurityProfile",
        modelProperties: {
            defender: {
                serializedName: "defender",
                type: {
                    name: "Composite",
                    className: "ManagedClusterSecurityProfileDefender",
                },
            },
            azureKeyVaultKms: {
                serializedName: "azureKeyVaultKms",
                type: {
                    name: "Composite",
                    className: "AzureKeyVaultKms",
                },
            },
            workloadIdentity: {
                serializedName: "workloadIdentity",
                type: {
                    name: "Composite",
                    className: "ManagedClusterSecurityProfileWorkloadIdentity",
                },
            },
            imageCleaner: {
                serializedName: "imageCleaner",
                type: {
                    name: "Composite",
                    className: "ManagedClusterSecurityProfileImageCleaner",
                },
            },
        },
    },
};
const ManagedClusterSecurityProfileDefender = {
    type: {
        name: "Composite",
        className: "ManagedClusterSecurityProfileDefender",
        modelProperties: {
            logAnalyticsWorkspaceResourceId: {
                serializedName: "logAnalyticsWorkspaceResourceId",
                type: {
                    name: "String",
                },
            },
            securityMonitoring: {
                serializedName: "securityMonitoring",
                type: {
                    name: "Composite",
                    className: "ManagedClusterSecurityProfileDefenderSecurityMonitoring",
                },
            },
        },
    },
};
const ManagedClusterSecurityProfileDefenderSecurityMonitoring = {
    type: {
        name: "Composite",
        className: "ManagedClusterSecurityProfileDefenderSecurityMonitoring",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AzureKeyVaultKms = {
    type: {
        name: "Composite",
        className: "AzureKeyVaultKms",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            keyId: {
                serializedName: "keyId",
                type: {
                    name: "String",
                },
            },
            keyVaultNetworkAccess: {
                defaultValue: "Public",
                serializedName: "keyVaultNetworkAccess",
                type: {
                    name: "String",
                },
            },
            keyVaultResourceId: {
                serializedName: "keyVaultResourceId",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClusterSecurityProfileWorkloadIdentity = {
    type: {
        name: "Composite",
        className: "ManagedClusterSecurityProfileWorkloadIdentity",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterSecurityProfileImageCleaner = {
    type: {
        name: "Composite",
        className: "ManagedClusterSecurityProfileImageCleaner",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            intervalHours: {
                serializedName: "intervalHours",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const ManagedClusterStorageProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterStorageProfile",
        modelProperties: {
            diskCSIDriver: {
                serializedName: "diskCSIDriver",
                type: {
                    name: "Composite",
                    className: "ManagedClusterStorageProfileDiskCSIDriver",
                },
            },
            fileCSIDriver: {
                serializedName: "fileCSIDriver",
                type: {
                    name: "Composite",
                    className: "ManagedClusterStorageProfileFileCSIDriver",
                },
            },
            snapshotController: {
                serializedName: "snapshotController",
                type: {
                    name: "Composite",
                    className: "ManagedClusterStorageProfileSnapshotController",
                },
            },
            blobCSIDriver: {
                serializedName: "blobCSIDriver",
                type: {
                    name: "Composite",
                    className: "ManagedClusterStorageProfileBlobCSIDriver",
                },
            },
        },
    },
};
const ManagedClusterStorageProfileDiskCSIDriver = {
    type: {
        name: "Composite",
        className: "ManagedClusterStorageProfileDiskCSIDriver",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterStorageProfileFileCSIDriver = {
    type: {
        name: "Composite",
        className: "ManagedClusterStorageProfileFileCSIDriver",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterStorageProfileSnapshotController = {
    type: {
        name: "Composite",
        className: "ManagedClusterStorageProfileSnapshotController",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterStorageProfileBlobCSIDriver = {
    type: {
        name: "Composite",
        className: "ManagedClusterStorageProfileBlobCSIDriver",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterIngressProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterIngressProfile",
        modelProperties: {
            webAppRouting: {
                serializedName: "webAppRouting",
                type: {
                    name: "Composite",
                    className: "ManagedClusterIngressProfileWebAppRouting",
                },
            },
        },
    },
};
const ManagedClusterIngressProfileWebAppRouting = {
    type: {
        name: "Composite",
        className: "ManagedClusterIngressProfileWebAppRouting",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean",
                },
            },
            dnsZoneResourceIds: {
                constraints: {
                    MaxItems: 5,
                },
                serializedName: "dnsZoneResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "UserAssignedIdentity",
                },
            },
        },
    },
};
const ManagedClusterWorkloadAutoScalerProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterWorkloadAutoScalerProfile",
        modelProperties: {
            keda: {
                serializedName: "keda",
                type: {
                    name: "Composite",
                    className: "ManagedClusterWorkloadAutoScalerProfileKeda",
                },
            },
            verticalPodAutoscaler: {
                serializedName: "verticalPodAutoscaler",
                type: {
                    name: "Composite",
                    className: "ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler",
                },
            },
        },
    },
};
const ManagedClusterWorkloadAutoScalerProfileKeda = {
    type: {
        name: "Composite",
        className: "ManagedClusterWorkloadAutoScalerProfileKeda",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler = {
    type: {
        name: "Composite",
        className: "ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler",
        modelProperties: {
            enabled: {
                defaultValue: false,
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const ManagedClusterAzureMonitorProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAzureMonitorProfile",
        modelProperties: {
            metrics: {
                serializedName: "metrics",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAzureMonitorProfileMetrics",
                },
            },
        },
    },
};
const ManagedClusterAzureMonitorProfileMetrics = {
    type: {
        name: "Composite",
        className: "ManagedClusterAzureMonitorProfileMetrics",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
            kubeStateMetrics: {
                serializedName: "kubeStateMetrics",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAzureMonitorProfileKubeStateMetrics",
                },
            },
        },
    },
};
const ManagedClusterAzureMonitorProfileKubeStateMetrics = {
    type: {
        name: "Composite",
        className: "ManagedClusterAzureMonitorProfileKubeStateMetrics",
        modelProperties: {
            metricLabelsAllowlist: {
                serializedName: "metricLabelsAllowlist",
                type: {
                    name: "String",
                },
            },
            metricAnnotationsAllowList: {
                serializedName: "metricAnnotationsAllowList",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ServiceMeshProfile = {
    type: {
        name: "Composite",
        className: "ServiceMeshProfile",
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String",
                },
            },
            istio: {
                serializedName: "istio",
                type: {
                    name: "Composite",
                    className: "IstioServiceMesh",
                },
            },
        },
    },
};
const IstioServiceMesh = {
    type: {
        name: "Composite",
        className: "IstioServiceMesh",
        modelProperties: {
            components: {
                serializedName: "components",
                type: {
                    name: "Composite",
                    className: "IstioComponents",
                },
            },
            certificateAuthority: {
                serializedName: "certificateAuthority",
                type: {
                    name: "Composite",
                    className: "IstioCertificateAuthority",
                },
            },
            revisions: {
                constraints: {
                    MaxItems: 2,
                    UniqueItems: true,
                },
                serializedName: "revisions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const IstioComponents = {
    type: {
        name: "Composite",
        className: "IstioComponents",
        modelProperties: {
            ingressGateways: {
                serializedName: "ingressGateways",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IstioIngressGateway",
                        },
                    },
                },
            },
            egressGateways: {
                serializedName: "egressGateways",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IstioEgressGateway",
                        },
                    },
                },
            },
        },
    },
};
const IstioIngressGateway = {
    type: {
        name: "Composite",
        className: "IstioIngressGateway",
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String",
                },
            },
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const IstioEgressGateway = {
    type: {
        name: "Composite",
        className: "IstioEgressGateway",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean",
                },
            },
            nodeSelector: {
                serializedName: "nodeSelector",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const IstioCertificateAuthority = {
    type: {
        name: "Composite",
        className: "IstioCertificateAuthority",
        modelProperties: {
            plugin: {
                serializedName: "plugin",
                type: {
                    name: "Composite",
                    className: "IstioPluginCertificateAuthority",
                },
            },
        },
    },
};
const IstioPluginCertificateAuthority = {
    type: {
        name: "Composite",
        className: "IstioPluginCertificateAuthority",
        modelProperties: {
            keyVaultId: {
                serializedName: "keyVaultId",
                type: {
                    name: "String",
                },
            },
            certObjectName: {
                serializedName: "certObjectName",
                type: {
                    name: "String",
                },
            },
            keyObjectName: {
                serializedName: "keyObjectName",
                type: {
                    name: "String",
                },
            },
            rootCertObjectName: {
                serializedName: "rootCertObjectName",
                type: {
                    name: "String",
                },
            },
            certChainObjectName: {
                serializedName: "certChainObjectName",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData",
                },
            },
        },
    },
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String",
                },
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String",
                },
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime",
                },
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String",
                },
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String",
                },
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const ManagedClusterUpgradeProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterUpgradeProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            controlPlaneProfile: {
                serializedName: "properties.controlPlaneProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterPoolUpgradeProfile",
                },
            },
            agentPoolProfiles: {
                serializedName: "properties.agentPoolProfiles",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterPoolUpgradeProfile",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterPoolUpgradeProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterPoolUpgradeProfile",
        modelProperties: {
            kubernetesVersion: {
                serializedName: "kubernetesVersion",
                required: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            osType: {
                defaultValue: "Linux",
                serializedName: "osType",
                required: true,
                type: {
                    name: "String",
                },
            },
            upgrades: {
                serializedName: "upgrades",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterPoolUpgradeProfileUpgradesItem",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterPoolUpgradeProfileUpgradesItem = {
    type: {
        name: "Composite",
        className: "ManagedClusterPoolUpgradeProfileUpgradesItem",
        modelProperties: {
            kubernetesVersion: {
                serializedName: "kubernetesVersion",
                type: {
                    name: "String",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const CredentialResults = {
    type: {
        name: "Composite",
        className: "CredentialResults",
        modelProperties: {
            kubeconfigs: {
                serializedName: "kubeconfigs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CredentialResult",
                        },
                    },
                },
            },
        },
    },
};
const CredentialResult = {
    type: {
        name: "Composite",
        className: "CredentialResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "ByteArray",
                },
            },
        },
    },
};
const TagsObject = {
    type: {
        name: "Composite",
        className: "TagsObject",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
        },
    },
};
const MaintenanceConfigurationListResult = {
    type: {
        name: "Composite",
        className: "MaintenanceConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MaintenanceConfiguration",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TimeInWeek = {
    type: {
        name: "Composite",
        className: "TimeInWeek",
        modelProperties: {
            day: {
                serializedName: "day",
                type: {
                    name: "String",
                },
            },
            hourSlots: {
                serializedName: "hourSlots",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            InclusiveMaximum: 23,
                            InclusiveMinimum: 0,
                        },
                        type: {
                            name: "Number",
                        },
                    },
                },
            },
        },
    },
};
const TimeSpan = {
    type: {
        name: "Composite",
        className: "TimeSpan",
        modelProperties: {
            start: {
                serializedName: "start",
                type: {
                    name: "DateTime",
                },
            },
            end: {
                serializedName: "end",
                type: {
                    name: "DateTime",
                },
            },
        },
    },
};
const MaintenanceWindow = {
    type: {
        name: "Composite",
        className: "MaintenanceWindow",
        modelProperties: {
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "Schedule",
                },
            },
            durationHours: {
                defaultValue: 24,
                constraints: {
                    InclusiveMaximum: 24,
                    InclusiveMinimum: 4,
                },
                serializedName: "durationHours",
                required: true,
                type: {
                    name: "Number",
                },
            },
            utcOffset: {
                constraints: {
                    Pattern: new RegExp("^(-|\\+)[0-9]{2}:[0-9]{2}$"),
                },
                serializedName: "utcOffset",
                type: {
                    name: "String",
                },
            },
            startDate: {
                serializedName: "startDate",
                type: {
                    name: "Date",
                },
            },
            startTime: {
                constraints: {
                    Pattern: new RegExp("^\\d{2}:\\d{2}$"),
                },
                serializedName: "startTime",
                required: true,
                type: {
                    name: "String",
                },
            },
            notAllowedDates: {
                serializedName: "notAllowedDates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DateSpan",
                        },
                    },
                },
            },
        },
    },
};
const Schedule = {
    type: {
        name: "Composite",
        className: "Schedule",
        modelProperties: {
            daily: {
                serializedName: "daily",
                type: {
                    name: "Composite",
                    className: "DailySchedule",
                },
            },
            weekly: {
                serializedName: "weekly",
                type: {
                    name: "Composite",
                    className: "WeeklySchedule",
                },
            },
            absoluteMonthly: {
                serializedName: "absoluteMonthly",
                type: {
                    name: "Composite",
                    className: "AbsoluteMonthlySchedule",
                },
            },
            relativeMonthly: {
                serializedName: "relativeMonthly",
                type: {
                    name: "Composite",
                    className: "RelativeMonthlySchedule",
                },
            },
        },
    },
};
const DailySchedule = {
    type: {
        name: "Composite",
        className: "DailySchedule",
        modelProperties: {
            intervalDays: {
                constraints: {
                    InclusiveMaximum: 7,
                    InclusiveMinimum: 1,
                },
                serializedName: "intervalDays",
                required: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const WeeklySchedule = {
    type: {
        name: "Composite",
        className: "WeeklySchedule",
        modelProperties: {
            intervalWeeks: {
                constraints: {
                    InclusiveMaximum: 4,
                    InclusiveMinimum: 1,
                },
                serializedName: "intervalWeeks",
                required: true,
                type: {
                    name: "Number",
                },
            },
            dayOfWeek: {
                serializedName: "dayOfWeek",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AbsoluteMonthlySchedule = {
    type: {
        name: "Composite",
        className: "AbsoluteMonthlySchedule",
        modelProperties: {
            intervalMonths: {
                constraints: {
                    InclusiveMaximum: 6,
                    InclusiveMinimum: 1,
                },
                serializedName: "intervalMonths",
                required: true,
                type: {
                    name: "Number",
                },
            },
            dayOfMonth: {
                constraints: {
                    InclusiveMaximum: 31,
                    InclusiveMinimum: 1,
                },
                serializedName: "dayOfMonth",
                required: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const RelativeMonthlySchedule = {
    type: {
        name: "Composite",
        className: "RelativeMonthlySchedule",
        modelProperties: {
            intervalMonths: {
                constraints: {
                    InclusiveMaximum: 6,
                    InclusiveMinimum: 1,
                },
                serializedName: "intervalMonths",
                required: true,
                type: {
                    name: "Number",
                },
            },
            weekIndex: {
                serializedName: "weekIndex",
                required: true,
                type: {
                    name: "String",
                },
            },
            dayOfWeek: {
                serializedName: "dayOfWeek",
                required: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const DateSpan = {
    type: {
        name: "Composite",
        className: "DateSpan",
        modelProperties: {
            start: {
                serializedName: "start",
                required: true,
                type: {
                    name: "Date",
                },
            },
            end: {
                serializedName: "end",
                required: true,
                type: {
                    name: "Date",
                },
            },
        },
    },
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolListResult = {
    type: {
        name: "Composite",
        className: "AgentPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AgentPool",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolUpgradeProfile = {
    type: {
        name: "Composite",
        className: "AgentPoolUpgradeProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            kubernetesVersion: {
                serializedName: "properties.kubernetesVersion",
                required: true,
                type: {
                    name: "String",
                },
            },
            osType: {
                defaultValue: "Linux",
                serializedName: "properties.osType",
                required: true,
                type: {
                    name: "String",
                },
            },
            upgrades: {
                serializedName: "properties.upgrades",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AgentPoolUpgradeProfilePropertiesUpgradesItem",
                        },
                    },
                },
            },
            latestNodeImageVersion: {
                serializedName: "properties.latestNodeImageVersion",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolUpgradeProfilePropertiesUpgradesItem = {
    type: {
        name: "Composite",
        className: "AgentPoolUpgradeProfilePropertiesUpgradesItem",
        modelProperties: {
            kubernetesVersion: {
                serializedName: "kubernetesVersion",
                type: {
                    name: "String",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const AgentPoolAvailableVersions = {
    type: {
        name: "Composite",
        className: "AgentPoolAvailableVersions",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            agentPoolVersions: {
                serializedName: "properties.agentPoolVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem",
                        },
                    },
                },
            },
        },
    },
};
const AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem = {
    type: {
        name: "Composite",
        className: "AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem",
        modelProperties: {
            default: {
                serializedName: "default",
                type: {
                    name: "Boolean",
                },
            },
            kubernetesVersion: {
                serializedName: "kubernetesVersion",
                type: {
                    name: "String",
                },
            },
            isPreview: {
                serializedName: "isPreview",
                type: {
                    name: "Boolean",
                },
            },
        },
    },
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection",
                        },
                    },
                },
            },
        },
    },
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint",
                },
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState",
                },
            },
        },
    },
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const PrivateLinkResourcesListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource",
                        },
                    },
                },
            },
        },
    },
};
const RunCommandRequest = {
    type: {
        name: "Composite",
        className: "RunCommandRequest",
        modelProperties: {
            command: {
                serializedName: "command",
                required: true,
                type: {
                    name: "String",
                },
            },
            context: {
                serializedName: "context",
                type: {
                    name: "String",
                },
            },
            clusterToken: {
                serializedName: "clusterToken",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const RunCommandResult = {
    type: {
        name: "Composite",
        className: "RunCommandResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            exitCode: {
                serializedName: "properties.exitCode",
                readOnly: true,
                type: {
                    name: "Number",
                },
            },
            startedAt: {
                serializedName: "properties.startedAt",
                readOnly: true,
                type: {
                    name: "DateTime",
                },
            },
            finishedAt: {
                serializedName: "properties.finishedAt",
                readOnly: true,
                type: {
                    name: "DateTime",
                },
            },
            logs: {
                serializedName: "properties.logs",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            reason: {
                serializedName: "properties.reason",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OutboundEnvironmentEndpointCollection = {
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpointCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundEnvironmentEndpoint",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const OutboundEnvironmentEndpoint = {
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String",
                },
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDependency",
                        },
                    },
                },
            },
        },
    },
};
const EndpointDependency = {
    type: {
        name: "Composite",
        className: "EndpointDependency",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String",
                },
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDetail",
                        },
                    },
                },
            },
        },
    },
};
const EndpointDetail = {
    type: {
        name: "Composite",
        className: "EndpointDetail",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String",
                },
            },
            port: {
                serializedName: "port",
                type: {
                    name: "Number",
                },
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String",
                },
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const SnapshotListResult = {
    type: {
        name: "Composite",
        className: "SnapshotListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Snapshot",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MeshRevisionProfileList = {
    type: {
        name: "Composite",
        className: "MeshRevisionProfileList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MeshRevisionProfile",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MeshRevisionProfileProperties = {
    type: {
        name: "Composite",
        className: "MeshRevisionProfileProperties",
        modelProperties: {
            meshRevisions: {
                serializedName: "meshRevisions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MeshRevision",
                        },
                    },
                },
            },
        },
    },
};
const MeshRevision = {
    type: {
        name: "Composite",
        className: "MeshRevision",
        modelProperties: {
            revision: {
                serializedName: "revision",
                type: {
                    name: "String",
                },
            },
            upgrades: {
                serializedName: "upgrades",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            compatibleWith: {
                serializedName: "compatibleWith",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CompatibleVersions",
                        },
                    },
                },
            },
        },
    },
};
const CompatibleVersions = {
    type: {
        name: "Composite",
        className: "CompatibleVersions",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String",
                },
            },
            versions: {
                serializedName: "versions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const MeshUpgradeProfileList = {
    type: {
        name: "Composite",
        className: "MeshUpgradeProfileList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MeshUpgradeProfile",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TrustedAccessRoleBindingListResult = {
    type: {
        name: "Composite",
        className: "TrustedAccessRoleBindingListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrustedAccessRoleBinding",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail",
                },
            },
        },
    },
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail",
                        },
                    },
                },
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo",
                        },
                    },
                },
            },
        },
    },
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } },
                },
            },
        },
    },
};
const TrustedAccessRoleListResult = {
    type: {
        name: "Composite",
        className: "TrustedAccessRoleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrustedAccessRole",
                        },
                    },
                },
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TrustedAccessRole = {
    type: {
        name: "Composite",
        className: "TrustedAccessRole",
        modelProperties: {
            sourceResourceType: {
                serializedName: "sourceResourceType",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String",
                },
            },
            rules: {
                serializedName: "rules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrustedAccessRoleRule",
                        },
                    },
                },
            },
        },
    },
};
const TrustedAccessRoleRule = {
    type: {
        name: "Composite",
        className: "TrustedAccessRoleRule",
        modelProperties: {
            verbs: {
                serializedName: "verbs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            apiGroups: {
                serializedName: "apiGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            resources: {
                serializedName: "resources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            resourceNames: {
                serializedName: "resourceNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
            nonResourceURLs: {
                serializedName: "nonResourceURLs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            },
        },
    },
};
const ManagedClusterAgentPoolProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAgentPoolProfile",
        modelProperties: Object.assign(Object.assign({}, ManagedClusterAgentPoolProfileProperties.type.modelProperties), { name: {
                constraints: {
                    Pattern: new RegExp("^[a-z][a-z0-9]{0,11}$"),
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const ManagedClusterAddonProfileIdentity = {
    type: {
        name: "Composite",
        className: "ManagedClusterAddonProfileIdentity",
        modelProperties: Object.assign({}, UserAssignedIdentity.type.modelProperties),
    },
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties),
    },
};
const TrustedAccessRoleBinding = {
    type: {
        name: "Composite",
        className: "TrustedAccessRoleBinding",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, sourceResourceId: {
                serializedName: "properties.sourceResourceId",
                required: true,
                type: {
                    name: "String",
                },
            }, roles: {
                serializedName: "properties.roles",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            } }),
    },
};
const MaintenanceConfiguration = {
    type: {
        name: "Composite",
        className: "MaintenanceConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData",
                },
            }, timeInWeek: {
                serializedName: "properties.timeInWeek",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeInWeek",
                        },
                    },
                },
            }, notAllowedTime: {
                serializedName: "properties.notAllowedTime",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeSpan",
                        },
                    },
                },
            }, maintenanceWindow: {
                serializedName: "properties.maintenanceWindow",
                type: {
                    name: "Composite",
                    className: "MaintenanceWindow",
                },
            } }),
    },
};
const AgentPool = {
    type: {
        name: "Composite",
        className: "AgentPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { count: {
                serializedName: "properties.count",
                type: {
                    name: "Number",
                },
            }, vmSize: {
                serializedName: "properties.vmSize",
                type: {
                    name: "String",
                },
            }, osDiskSizeGB: {
                constraints: {
                    InclusiveMaximum: 2048,
                    InclusiveMinimum: 0,
                },
                serializedName: "properties.osDiskSizeGB",
                type: {
                    name: "Number",
                },
            }, osDiskType: {
                serializedName: "properties.osDiskType",
                type: {
                    name: "String",
                },
            }, kubeletDiskType: {
                serializedName: "properties.kubeletDiskType",
                type: {
                    name: "String",
                },
            }, workloadRuntime: {
                serializedName: "properties.workloadRuntime",
                type: {
                    name: "String",
                },
            }, vnetSubnetID: {
                serializedName: "properties.vnetSubnetID",
                type: {
                    name: "String",
                },
            }, podSubnetID: {
                serializedName: "properties.podSubnetID",
                type: {
                    name: "String",
                },
            }, maxPods: {
                serializedName: "properties.maxPods",
                type: {
                    name: "Number",
                },
            }, osType: {
                defaultValue: "Linux",
                serializedName: "properties.osType",
                type: {
                    name: "String",
                },
            }, osSKU: {
                serializedName: "properties.osSKU",
                type: {
                    name: "String",
                },
            }, maxCount: {
                serializedName: "properties.maxCount",
                type: {
                    name: "Number",
                },
            }, minCount: {
                serializedName: "properties.minCount",
                type: {
                    name: "Number",
                },
            }, enableAutoScaling: {
                serializedName: "properties.enableAutoScaling",
                type: {
                    name: "Boolean",
                },
            }, scaleDownMode: {
                serializedName: "properties.scaleDownMode",
                type: {
                    name: "String",
                },
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String",
                },
            }, mode: {
                serializedName: "properties.mode",
                type: {
                    name: "String",
                },
            }, orchestratorVersion: {
                serializedName: "properties.orchestratorVersion",
                type: {
                    name: "String",
                },
            }, currentOrchestratorVersion: {
                serializedName: "properties.currentOrchestratorVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, nodeImageVersion: {
                serializedName: "properties.nodeImageVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, upgradeSettings: {
                serializedName: "properties.upgradeSettings",
                type: {
                    name: "Composite",
                    className: "AgentPoolUpgradeSettings",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, powerState: {
                serializedName: "properties.powerState",
                type: {
                    name: "Composite",
                    className: "PowerState",
                },
            }, availabilityZones: {
                serializedName: "properties.availabilityZones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, enableNodePublicIP: {
                serializedName: "properties.enableNodePublicIP",
                type: {
                    name: "Boolean",
                },
            }, nodePublicIPPrefixID: {
                serializedName: "properties.nodePublicIPPrefixID",
                type: {
                    name: "String",
                },
            }, scaleSetPriority: {
                defaultValue: "Regular",
                serializedName: "properties.scaleSetPriority",
                type: {
                    name: "String",
                },
            }, scaleSetEvictionPolicy: {
                defaultValue: "Delete",
                serializedName: "properties.scaleSetEvictionPolicy",
                type: {
                    name: "String",
                },
            }, spotMaxPrice: {
                defaultValue: -1,
                serializedName: "properties.spotMaxPrice",
                type: {
                    name: "Number",
                },
            }, tags: {
                serializedName: "properties.tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            }, nodeLabels: {
                serializedName: "properties.nodeLabels",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            }, nodeTaints: {
                serializedName: "properties.nodeTaints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String",
                        },
                    },
                },
            }, proximityPlacementGroupID: {
                serializedName: "properties.proximityPlacementGroupID",
                type: {
                    name: "String",
                },
            }, kubeletConfig: {
                serializedName: "properties.kubeletConfig",
                type: {
                    name: "Composite",
                    className: "KubeletConfig",
                },
            }, linuxOSConfig: {
                serializedName: "properties.linuxOSConfig",
                type: {
                    name: "Composite",
                    className: "LinuxOSConfig",
                },
            }, enableEncryptionAtHost: {
                serializedName: "properties.enableEncryptionAtHost",
                type: {
                    name: "Boolean",
                },
            }, enableUltraSSD: {
                serializedName: "properties.enableUltraSSD",
                type: {
                    name: "Boolean",
                },
            }, enableFips: {
                serializedName: "properties.enableFIPS",
                type: {
                    name: "Boolean",
                },
            }, gpuInstanceProfile: {
                serializedName: "properties.gpuInstanceProfile",
                type: {
                    name: "String",
                },
            }, creationData: {
                serializedName: "properties.creationData",
                type: {
                    name: "Composite",
                    className: "CreationData",
                },
            }, capacityReservationGroupID: {
                serializedName: "properties.capacityReservationGroupID",
                type: {
                    name: "String",
                },
            }, hostGroupID: {
                serializedName: "properties.hostGroupID",
                type: {
                    name: "String",
                },
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "AgentPoolNetworkProfile",
                },
            } }),
    },
};
const MeshUpgradeProfileProperties = {
    type: {
        name: "Composite",
        className: "MeshUpgradeProfileProperties",
        modelProperties: Object.assign({}, MeshRevision.type.modelProperties),
    },
};
const ManagedCluster = {
    type: {
        name: "Composite",
        className: "ManagedCluster",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "ManagedClusterSKU",
                },
            }, extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation",
                },
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedClusterIdentity",
                },
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, powerState: {
                serializedName: "properties.powerState",
                type: {
                    name: "Composite",
                    className: "PowerState",
                },
            }, maxAgentPools: {
                serializedName: "properties.maxAgentPools",
                readOnly: true,
                type: {
                    name: "Number",
                },
            }, kubernetesVersion: {
                serializedName: "properties.kubernetesVersion",
                type: {
                    name: "String",
                },
            }, currentKubernetesVersion: {
                serializedName: "properties.currentKubernetesVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, dnsPrefix: {
                serializedName: "properties.dnsPrefix",
                type: {
                    name: "String",
                },
            }, fqdnSubdomain: {
                serializedName: "properties.fqdnSubdomain",
                type: {
                    name: "String",
                },
            }, fqdn: {
                serializedName: "properties.fqdn",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, privateFqdn: {
                serializedName: "properties.privateFQDN",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, azurePortalFqdn: {
                serializedName: "properties.azurePortalFQDN",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, agentPoolProfiles: {
                serializedName: "properties.agentPoolProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterAgentPoolProfile",
                        },
                    },
                },
            }, linuxProfile: {
                serializedName: "properties.linuxProfile",
                type: {
                    name: "Composite",
                    className: "ContainerServiceLinuxProfile",
                },
            }, windowsProfile: {
                serializedName: "properties.windowsProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterWindowsProfile",
                },
            }, servicePrincipalProfile: {
                serializedName: "properties.servicePrincipalProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterServicePrincipalProfile",
                },
            }, addonProfiles: {
                serializedName: "properties.addonProfiles",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "ManagedClusterAddonProfile",
                        },
                    },
                },
            }, podIdentityProfile: {
                serializedName: "properties.podIdentityProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterPodIdentityProfile",
                },
            }, oidcIssuerProfile: {
                serializedName: "properties.oidcIssuerProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterOidcIssuerProfile",
                },
            }, nodeResourceGroup: {
                serializedName: "properties.nodeResourceGroup",
                type: {
                    name: "String",
                },
            }, enableRbac: {
                serializedName: "properties.enableRBAC",
                type: {
                    name: "Boolean",
                },
            }, supportPlan: {
                serializedName: "properties.supportPlan",
                type: {
                    name: "String",
                },
            }, enablePodSecurityPolicy: {
                serializedName: "properties.enablePodSecurityPolicy",
                type: {
                    name: "Boolean",
                },
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "ContainerServiceNetworkProfile",
                },
            }, aadProfile: {
                serializedName: "properties.aadProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAADProfile",
                },
            }, autoUpgradeProfile: {
                serializedName: "properties.autoUpgradeProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAutoUpgradeProfile",
                },
            }, upgradeSettings: {
                serializedName: "properties.upgradeSettings",
                type: {
                    name: "Composite",
                    className: "ClusterUpgradeSettings",
                },
            }, autoScalerProfile: {
                serializedName: "properties.autoScalerProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterPropertiesAutoScalerProfile",
                },
            }, apiServerAccessProfile: {
                serializedName: "properties.apiServerAccessProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAPIServerAccessProfile",
                },
            }, diskEncryptionSetID: {
                serializedName: "properties.diskEncryptionSetID",
                type: {
                    name: "String",
                },
            }, identityProfile: {
                serializedName: "properties.identityProfile",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" },
                    },
                },
            }, privateLinkResources: {
                serializedName: "properties.privateLinkResources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource",
                        },
                    },
                },
            }, disableLocalAccounts: {
                serializedName: "properties.disableLocalAccounts",
                type: {
                    name: "Boolean",
                },
            }, httpProxyConfig: {
                serializedName: "properties.httpProxyConfig",
                type: {
                    name: "Composite",
                    className: "ManagedClusterHttpProxyConfig",
                },
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterSecurityProfile",
                },
            }, storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterStorageProfile",
                },
            }, ingressProfile: {
                serializedName: "properties.ingressProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterIngressProfile",
                },
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String",
                },
            }, workloadAutoScalerProfile: {
                serializedName: "properties.workloadAutoScalerProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterWorkloadAutoScalerProfile",
                },
            }, azureMonitorProfile: {
                serializedName: "properties.azureMonitorProfile",
                type: {
                    name: "Composite",
                    className: "ManagedClusterAzureMonitorProfile",
                },
            }, serviceMeshProfile: {
                serializedName: "properties.serviceMeshProfile",
                type: {
                    name: "Composite",
                    className: "ServiceMeshProfile",
                },
            }, resourceUID: {
                serializedName: "properties.resourceUID",
                readOnly: true,
                type: {
                    name: "String",
                },
            } }),
    },
};
const ManagedClusterAccessProfile = {
    type: {
        name: "Composite",
        className: "ManagedClusterAccessProfile",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { kubeConfig: {
                serializedName: "properties.kubeConfig",
                type: {
                    name: "ByteArray",
                },
            } }),
    },
};
const Snapshot = {
    type: {
        name: "Composite",
        className: "Snapshot",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { creationData: {
                serializedName: "properties.creationData",
                type: {
                    name: "Composite",
                    className: "CreationData",
                },
            }, snapshotType: {
                defaultValue: "NodePool",
                serializedName: "properties.snapshotType",
                type: {
                    name: "String",
                },
            }, kubernetesVersion: {
                serializedName: "properties.kubernetesVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, nodeImageVersion: {
                serializedName: "properties.nodeImageVersion",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, osType: {
                defaultValue: "Linux",
                serializedName: "properties.osType",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, osSku: {
                serializedName: "properties.osSku",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, vmSize: {
                serializedName: "properties.vmSize",
                readOnly: true,
                type: {
                    name: "String",
                },
            }, enableFips: {
                serializedName: "properties.enableFIPS",
                readOnly: true,
                type: {
                    name: "Boolean",
                },
            } }),
    },
};
const MeshRevisionProfile = {
    type: {
        name: "Composite",
        className: "MeshRevisionProfile",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MeshRevisionProfileProperties",
                },
            } }),
    },
};
const MeshUpgradeProfile = {
    type: {
        name: "Composite",
        className: "MeshUpgradeProfile",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MeshUpgradeProfileProperties",
                },
            } }),
    },
};
const ManagedClustersDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersResetServicePrincipalProfileHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersResetServicePrincipalProfileHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersResetAADProfileHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersResetAADProfileHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersRotateClusterCertificatesHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersRotateClusterCertificatesHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersAbortLatestOperationHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersAbortLatestOperationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersRotateServiceAccountSigningKeysHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersRotateServiceAccountSigningKeysHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersStopHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersStopHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersStartHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersStartHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersRunCommandHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersRunCommandHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const ManagedClustersGetCommandResultHeaders = {
    type: {
        name: "Composite",
        className: "ManagedClustersGetCommandResultHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolsAbortLatestOperationHeaders = {
    type: {
        name: "Composite",
        className: "AgentPoolsAbortLatestOperationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "AgentPoolsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const AgentPoolsUpgradeNodeImageVersionHeaders = {
    type: {
        name: "Composite",
        className: "AgentPoolsUpgradeNodeImageVersionHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const TrustedAccessRoleBindingsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "TrustedAccessRoleBindingsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String",
                },
            },
        },
    },
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbsoluteMonthlySchedule: AbsoluteMonthlySchedule,
    AgentPool: AgentPool,
    AgentPoolAvailableVersions: AgentPoolAvailableVersions,
    AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem: AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem,
    AgentPoolListResult: AgentPoolListResult,
    AgentPoolNetworkProfile: AgentPoolNetworkProfile,
    AgentPoolUpgradeProfile: AgentPoolUpgradeProfile,
    AgentPoolUpgradeProfilePropertiesUpgradesItem: AgentPoolUpgradeProfilePropertiesUpgradesItem,
    AgentPoolUpgradeSettings: AgentPoolUpgradeSettings,
    AgentPoolsAbortLatestOperationHeaders: AgentPoolsAbortLatestOperationHeaders,
    AgentPoolsDeleteHeaders: AgentPoolsDeleteHeaders,
    AgentPoolsUpgradeNodeImageVersionHeaders: AgentPoolsUpgradeNodeImageVersionHeaders,
    AzureKeyVaultKms: AzureKeyVaultKms,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    ClusterUpgradeSettings: ClusterUpgradeSettings,
    CompatibleVersions: CompatibleVersions,
    ContainerServiceLinuxProfile: ContainerServiceLinuxProfile,
    ContainerServiceNetworkProfile: ContainerServiceNetworkProfile,
    ContainerServiceSshConfiguration: ContainerServiceSshConfiguration,
    ContainerServiceSshPublicKey: ContainerServiceSshPublicKey,
    CreationData: CreationData,
    CredentialResult: CredentialResult,
    CredentialResults: CredentialResults,
    DailySchedule: DailySchedule,
    DateSpan: DateSpan,
    DelegatedResource: DelegatedResource,
    EndpointDependency: EndpointDependency,
    EndpointDetail: EndpointDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    ErrorDetail: ErrorDetail,
    ErrorResponse: ErrorResponse,
    ExtendedLocation: ExtendedLocation,
    IPTag: IPTag,
    IstioCertificateAuthority: IstioCertificateAuthority,
    IstioComponents: IstioComponents,
    IstioEgressGateway: IstioEgressGateway,
    IstioIngressGateway: IstioIngressGateway,
    IstioPluginCertificateAuthority: IstioPluginCertificateAuthority,
    IstioServiceMesh: IstioServiceMesh,
    KubeletConfig: KubeletConfig,
    KubernetesPatchVersion: KubernetesPatchVersion,
    KubernetesVersion: KubernetesVersion,
    KubernetesVersionCapabilities: KubernetesVersionCapabilities,
    KubernetesVersionListResult: KubernetesVersionListResult,
    LinuxOSConfig: LinuxOSConfig,
    MaintenanceConfiguration: MaintenanceConfiguration,
    MaintenanceConfigurationListResult: MaintenanceConfigurationListResult,
    MaintenanceWindow: MaintenanceWindow,
    ManagedCluster: ManagedCluster,
    ManagedClusterAADProfile: ManagedClusterAADProfile,
    ManagedClusterAPIServerAccessProfile: ManagedClusterAPIServerAccessProfile,
    ManagedClusterAccessProfile: ManagedClusterAccessProfile,
    ManagedClusterAddonProfile: ManagedClusterAddonProfile,
    ManagedClusterAddonProfileIdentity: ManagedClusterAddonProfileIdentity,
    ManagedClusterAgentPoolProfile: ManagedClusterAgentPoolProfile,
    ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties,
    ManagedClusterAutoUpgradeProfile: ManagedClusterAutoUpgradeProfile,
    ManagedClusterAzureMonitorProfile: ManagedClusterAzureMonitorProfile,
    ManagedClusterAzureMonitorProfileKubeStateMetrics: ManagedClusterAzureMonitorProfileKubeStateMetrics,
    ManagedClusterAzureMonitorProfileMetrics: ManagedClusterAzureMonitorProfileMetrics,
    ManagedClusterHttpProxyConfig: ManagedClusterHttpProxyConfig,
    ManagedClusterIdentity: ManagedClusterIdentity,
    ManagedClusterIngressProfile: ManagedClusterIngressProfile,
    ManagedClusterIngressProfileWebAppRouting: ManagedClusterIngressProfileWebAppRouting,
    ManagedClusterListResult: ManagedClusterListResult,
    ManagedClusterLoadBalancerProfile: ManagedClusterLoadBalancerProfile,
    ManagedClusterLoadBalancerProfileManagedOutboundIPs: ManagedClusterLoadBalancerProfileManagedOutboundIPs,
    ManagedClusterLoadBalancerProfileOutboundIPPrefixes: ManagedClusterLoadBalancerProfileOutboundIPPrefixes,
    ManagedClusterLoadBalancerProfileOutboundIPs: ManagedClusterLoadBalancerProfileOutboundIPs,
    ManagedClusterManagedOutboundIPProfile: ManagedClusterManagedOutboundIPProfile,
    ManagedClusterNATGatewayProfile: ManagedClusterNATGatewayProfile,
    ManagedClusterOidcIssuerProfile: ManagedClusterOidcIssuerProfile,
    ManagedClusterPodIdentity: ManagedClusterPodIdentity,
    ManagedClusterPodIdentityException: ManagedClusterPodIdentityException,
    ManagedClusterPodIdentityProfile: ManagedClusterPodIdentityProfile,
    ManagedClusterPodIdentityProvisioningError: ManagedClusterPodIdentityProvisioningError,
    ManagedClusterPodIdentityProvisioningErrorBody: ManagedClusterPodIdentityProvisioningErrorBody,
    ManagedClusterPodIdentityProvisioningInfo: ManagedClusterPodIdentityProvisioningInfo,
    ManagedClusterPoolUpgradeProfile: ManagedClusterPoolUpgradeProfile,
    ManagedClusterPoolUpgradeProfileUpgradesItem: ManagedClusterPoolUpgradeProfileUpgradesItem,
    ManagedClusterPropertiesAutoScalerProfile: ManagedClusterPropertiesAutoScalerProfile,
    ManagedClusterSKU: ManagedClusterSKU,
    ManagedClusterSecurityProfile: ManagedClusterSecurityProfile,
    ManagedClusterSecurityProfileDefender: ManagedClusterSecurityProfileDefender,
    ManagedClusterSecurityProfileDefenderSecurityMonitoring: ManagedClusterSecurityProfileDefenderSecurityMonitoring,
    ManagedClusterSecurityProfileImageCleaner: ManagedClusterSecurityProfileImageCleaner,
    ManagedClusterSecurityProfileWorkloadIdentity: ManagedClusterSecurityProfileWorkloadIdentity,
    ManagedClusterServicePrincipalProfile: ManagedClusterServicePrincipalProfile,
    ManagedClusterStorageProfile: ManagedClusterStorageProfile,
    ManagedClusterStorageProfileBlobCSIDriver: ManagedClusterStorageProfileBlobCSIDriver,
    ManagedClusterStorageProfileDiskCSIDriver: ManagedClusterStorageProfileDiskCSIDriver,
    ManagedClusterStorageProfileFileCSIDriver: ManagedClusterStorageProfileFileCSIDriver,
    ManagedClusterStorageProfileSnapshotController: ManagedClusterStorageProfileSnapshotController,
    ManagedClusterUpgradeProfile: ManagedClusterUpgradeProfile,
    ManagedClusterWindowsProfile: ManagedClusterWindowsProfile,
    ManagedClusterWorkloadAutoScalerProfile: ManagedClusterWorkloadAutoScalerProfile,
    ManagedClusterWorkloadAutoScalerProfileKeda: ManagedClusterWorkloadAutoScalerProfileKeda,
    ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler: ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler,
    ManagedClustersAbortLatestOperationHeaders: ManagedClustersAbortLatestOperationHeaders,
    ManagedClustersDeleteHeaders: ManagedClustersDeleteHeaders,
    ManagedClustersGetCommandResultHeaders: ManagedClustersGetCommandResultHeaders,
    ManagedClustersResetAADProfileHeaders: ManagedClustersResetAADProfileHeaders,
    ManagedClustersResetServicePrincipalProfileHeaders: ManagedClustersResetServicePrincipalProfileHeaders,
    ManagedClustersRotateClusterCertificatesHeaders: ManagedClustersRotateClusterCertificatesHeaders,
    ManagedClustersRotateServiceAccountSigningKeysHeaders: ManagedClustersRotateServiceAccountSigningKeysHeaders,
    ManagedClustersRunCommandHeaders: ManagedClustersRunCommandHeaders,
    ManagedClustersStartHeaders: ManagedClustersStartHeaders,
    ManagedClustersStopHeaders: ManagedClustersStopHeaders,
    ManagedServiceIdentityUserAssignedIdentitiesValue: ManagedServiceIdentityUserAssignedIdentitiesValue,
    MeshRevision: MeshRevision,
    MeshRevisionProfile: MeshRevisionProfile,
    MeshRevisionProfileList: MeshRevisionProfileList,
    MeshRevisionProfileProperties: MeshRevisionProfileProperties,
    MeshUpgradeProfile: MeshUpgradeProfile,
    MeshUpgradeProfileList: MeshUpgradeProfileList,
    MeshUpgradeProfileProperties: MeshUpgradeProfileProperties,
    OSOptionProfile: OSOptionProfile,
    OSOptionProperty: OSOptionProperty,
    OperationListResult: OperationListResult,
    OperationValue: OperationValue,
    OutboundEnvironmentEndpoint: OutboundEnvironmentEndpoint,
    OutboundEnvironmentEndpointCollection: OutboundEnvironmentEndpointCollection,
    PortRange: PortRange,
    PowerState: PowerState,
    PrivateEndpoint: PrivateEndpoint,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkResourcesListResult: PrivateLinkResourcesListResult,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    ProxyResource: ProxyResource,
    RelativeMonthlySchedule: RelativeMonthlySchedule,
    Resource: Resource,
    ResourceReference: ResourceReference,
    RunCommandRequest: RunCommandRequest,
    RunCommandResult: RunCommandResult,
    Schedule: Schedule,
    ServiceMeshProfile: ServiceMeshProfile,
    Snapshot: Snapshot,
    SnapshotListResult: SnapshotListResult,
    SubResource: SubResource,
    SysctlConfig: SysctlConfig,
    SystemData: SystemData,
    TagsObject: TagsObject,
    TimeInWeek: TimeInWeek,
    TimeSpan: TimeSpan,
    TrackedResource: TrackedResource,
    TrustedAccessRole: TrustedAccessRole,
    TrustedAccessRoleBinding: TrustedAccessRoleBinding,
    TrustedAccessRoleBindingListResult: TrustedAccessRoleBindingListResult,
    TrustedAccessRoleBindingsDeleteHeaders: TrustedAccessRoleBindingsDeleteHeaders,
    TrustedAccessRoleListResult: TrustedAccessRoleListResult,
    TrustedAccessRoleRule: TrustedAccessRoleRule,
    UpgradeOverrideSettings: UpgradeOverrideSettings,
    UserAssignedIdentity: UserAssignedIdentity,
    WeeklySchedule: WeeklySchedule,
    WindowsGmsaProfile: WindowsGmsaProfile
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2024-01-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String",
        },
    },
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "Uuid",
        },
    },
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1,
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String",
        },
    },
};
const resourceType = {
    parameterPath: ["options", "resourceType"],
    mapper: {
        serializedName: "resource-type",
        type: {
            name: "String",
        },
    },
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1,
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$"),
            MaxLength: 63,
            MinLength: 1,
        },
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const roleName = {
    parameterPath: "roleName",
    mapper: {
        serializedName: "roleName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const serverFqdn = {
    parameterPath: ["options", "serverFqdn"],
    mapper: {
        serializedName: "server-fqdn",
        type: {
            name: "String",
        },
    },
};
const format = {
    parameterPath: ["options", "format"],
    mapper: {
        serializedName: "format",
        type: {
            name: "String",
        },
    },
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const parameters = {
    parameterPath: "parameters",
    mapper: ManagedCluster,
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: TagsObject,
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ManagedClusterServicePrincipalProfile,
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ManagedClusterAADProfile,
};
const requestPayload = {
    parameterPath: "requestPayload",
    mapper: RunCommandRequest,
};
const commandId = {
    parameterPath: "commandId",
    mapper: {
        serializedName: "commandId",
        required: true,
        type: {
            name: "String",
        },
    },
};
const mode = {
    parameterPath: "mode",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$"),
            MaxLength: 24,
            MinLength: 1,
        },
        serializedName: "mode",
        required: true,
        type: {
            name: "String",
        },
    },
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};
const configName = {
    parameterPath: "configName",
    mapper: {
        serializedName: "configName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: MaintenanceConfiguration,
};
const agentPoolName = {
    parameterPath: "agentPoolName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-z][a-z0-9]{0,11}$"),
            MaxLength: 12,
            MinLength: 1,
        },
        serializedName: "agentPoolName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: AgentPool,
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection,
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: PrivateLinkResource,
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: Snapshot,
};
const trustedAccessRoleBindingName = {
    parameterPath: "trustedAccessRoleBindingName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^([A-Za-z0-9-])+$"),
            MaxLength: 24,
            MinLength: 1,
        },
        serializedName: "trustedAccessRoleBindingName",
        required: true,
        type: {
            name: "String",
        },
    },
};
const trustedAccessRoleBinding = {
    parameterPath: "trustedAccessRoleBinding",
    mapper: TrustedAccessRoleBinding,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$7);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/providers/Microsoft.ContainerService/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$9,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        },
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedClusters operations. */
class ManagedClustersImpl {
    /**
     * Initialize a new instance of the class ManagedClusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of managed clusters in the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists managed clusters in the specified subscription and resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of egress endpoints (network endpoints of all outbound dependencies) in the specified
     * managed cluster. The operation returns properties of each egress endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, resourceName, options) {
        const iter = this.listOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, resourceName, options, settings);
            },
        };
    }
    listOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listOutboundNetworkDependenciesEndpointsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listOutboundNetworkDependenciesEndpoints(resourceGroupName, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listOutboundNetworkDependenciesEndpointsNext(resourceGroupName, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOutboundNetworkDependenciesEndpointsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Contains extra metadata on each revision, including supported revisions, cluster compatibility and
     * available upgrades
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    listMeshRevisionProfiles(location, options) {
        const iter = this.listMeshRevisionProfilesPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMeshRevisionProfilesPagingPage(location, options, settings);
            },
        };
    }
    listMeshRevisionProfilesPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMeshRevisionProfilesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMeshRevisionProfiles(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMeshRevisionProfilesNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMeshRevisionProfilesPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMeshRevisionProfilesPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMeshRevisionProfilesPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Lists available upgrades for all service meshes in a specific cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    listMeshUpgradeProfiles(resourceGroupName, resourceName, options) {
        const iter = this.listMeshUpgradeProfilesPagingAll(resourceGroupName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listMeshUpgradeProfilesPagingPage(resourceGroupName, resourceName, options, settings);
            },
        };
    }
    listMeshUpgradeProfilesPagingPage(resourceGroupName, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listMeshUpgradeProfilesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listMeshUpgradeProfiles(resourceGroupName, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listMeshUpgradeProfilesNext(resourceGroupName, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listMeshUpgradeProfilesPagingAll(resourceGroupName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listMeshUpgradeProfilesPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listMeshUpgradeProfilesPagingPage(resourceGroupName, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets supported OS options in the specified subscription.
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    getOSOptions(location, options) {
        return this.client.sendOperationRequest({ location, options }, getOSOptionsOperationSpec);
    }
    /**
     * Contains extra metadata on the version, including supported patch versions, capabilities, available
     * upgrades, and details on preview status of the version
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    listKubernetesVersions(location, options) {
        return this.client.sendOperationRequest({ location, options }, listKubernetesVersionsOperationSpec);
    }
    /**
     * Gets a list of managed clusters in the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$6);
    }
    /**
     * Lists managed clusters in the specified subscription and resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Gets the upgrade profile of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    getUpgradeProfile(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, getUpgradeProfileOperationSpec$1);
    }
    /**
     * **WARNING**: This API will be deprecated. Instead use
     * [ListClusterUserCredentials](https://docs.microsoft.com/rest/api/aks/managedclusters/listclusterusercredentials)
     * or
     * [ListClusterAdminCredentials](https://docs.microsoft.com/rest/api/aks/managedclusters/listclusteradmincredentials)
     * .
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param roleName The name of the role for managed cluster accessProfile resource.
     * @param options The options parameters.
     */
    getAccessProfile(resourceGroupName, resourceName, roleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, roleName, options }, getAccessProfileOperationSpec);
    }
    /**
     * Lists the admin credentials of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    listClusterAdminCredentials(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listClusterAdminCredentialsOperationSpec);
    }
    /**
     * Lists the user credentials of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    listClusterUserCredentials(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listClusterUserCredentialsOperationSpec);
    }
    /**
     * Lists the cluster monitoring user credentials of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    listClusterMonitoringUserCredentials(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listClusterMonitoringUserCredentialsOperationSpec);
    }
    /**
     * Gets a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, getOperationSpec$5);
    }
    /**
     * Creates or updates a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The managed cluster to create or update.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, parameters, options },
                spec: createOrUpdateOperationSpec$4,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The managed cluster to create or update.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, resourceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags on a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters Parameters supplied to the Update Managed Cluster Tags operation.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, parameters, options },
                spec: updateTagsOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates tags on a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters Parameters supplied to the Update Managed Cluster Tags operation.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, resourceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, options },
                spec: deleteOperationSpec$5,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This action cannot be performed on a cluster that is not using a service principal
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The service principal profile to set on the managed cluster.
     * @param options The options parameters.
     */
    beginResetServicePrincipalProfile(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, parameters, options },
                spec: resetServicePrincipalProfileOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This action cannot be performed on a cluster that is not using a service principal
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The service principal profile to set on the managed cluster.
     * @param options The options parameters.
     */
    beginResetServicePrincipalProfileAndWait(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetServicePrincipalProfile(resourceGroupName, resourceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * **WARNING**: This API will be deprecated. Please see [AKS-managed Azure Active Directory
     * integration](https://aka.ms/aks-managed-aad) to update your cluster with AKS-managed Azure AD.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The AAD profile to set on the Managed Cluster
     * @param options The options parameters.
     */
    beginResetAADProfile(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, parameters, options },
                spec: resetAADProfileOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * **WARNING**: This API will be deprecated. Please see [AKS-managed Azure Active Directory
     * integration](https://aka.ms/aks-managed-aad) to update your cluster with AKS-managed Azure AD.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The AAD profile to set on the Managed Cluster
     * @param options The options parameters.
     */
    beginResetAADProfileAndWait(resourceGroupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetAADProfile(resourceGroupName, resourceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * See [Certificate rotation](https://docs.microsoft.com/azure/aks/certificate-rotation) for more
     * details about rotating managed cluster certificates.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginRotateClusterCertificates(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, options },
                spec: rotateClusterCertificatesOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * See [Certificate rotation](https://docs.microsoft.com/azure/aks/certificate-rotation) for more
     * details about rotating managed cluster certificates.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginRotateClusterCertificatesAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRotateClusterCertificates(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Aborts the currently running operation on the managed cluster. The Managed Cluster will be moved to
     * a Canceling state and eventually to a Canceled state when cancellation finishes. If the operation
     * completes before cancellation can take place, a 409 error code is returned.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginAbortLatestOperation(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, options },
                spec: abortLatestOperationOperationSpec$1,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Aborts the currently running operation on the managed cluster. The Managed Cluster will be moved to
     * a Canceling state and eventually to a Canceled state when cancellation finishes. If the operation
     * completes before cancellation can take place, a 409 error code is returned.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginAbortLatestOperationAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAbortLatestOperation(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Rotates the service account signing keys of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginRotateServiceAccountSigningKeys(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, options },
                spec: rotateServiceAccountSigningKeysOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Rotates the service account signing keys of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginRotateServiceAccountSigningKeysAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRotateServiceAccountSigningKeys(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This can only be performed on Azure Virtual Machine Scale set backed clusters. Stopping a cluster
     * stops the control plane and agent nodes entirely, while maintaining all object and cluster state. A
     * cluster does not accrue charges while it is stopped. See [stopping a
     * cluster](https://docs.microsoft.com/azure/aks/start-stop-cluster) for more details about stopping a
     * cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, options },
                spec: stopOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This can only be performed on Azure Virtual Machine Scale set backed clusters. Stopping a cluster
     * stops the control plane and agent nodes entirely, while maintaining all object and cluster state. A
     * cluster does not accrue charges while it is stopped. See [stopping a
     * cluster](https://docs.microsoft.com/azure/aks/start-stop-cluster) for more details about stopping a
     * cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * See [starting a cluster](https://docs.microsoft.com/azure/aks/start-stop-cluster) for more details
     * about starting a cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, options },
                spec: startOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * See [starting a cluster](https://docs.microsoft.com/azure/aks/start-stop-cluster) for more details
     * about starting a cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * AKS will create a pod to run the command. This is primarily useful for private clusters. For more
     * information see [AKS Run
     * Command](https://docs.microsoft.com/azure/aks/private-clusters#aks-run-command-preview).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param requestPayload The run command request
     * @param options The options parameters.
     */
    beginRunCommand(resourceGroupName, resourceName, requestPayload, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, requestPayload, options },
                spec: runCommandOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * AKS will create a pod to run the command. This is primarily useful for private clusters. For more
     * information see [AKS Run
     * Command](https://docs.microsoft.com/azure/aks/private-clusters#aks-run-command-preview).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param requestPayload The run command request
     * @param options The options parameters.
     */
    beginRunCommandAndWait(resourceGroupName, resourceName, requestPayload, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRunCommand(resourceGroupName, resourceName, requestPayload, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the results of a command which has been run on the Managed Cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param commandId Id of the command.
     * @param options The options parameters.
     */
    getCommandResult(resourceGroupName, resourceName, commandId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, commandId, options }, getCommandResultOperationSpec);
    }
    /**
     * Gets a list of egress endpoints (network endpoints of all outbound dependencies) in the specified
     * managed cluster. The operation returns properties of each egress endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    _listOutboundNetworkDependenciesEndpoints(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * Contains extra metadata on each revision, including supported revisions, cluster compatibility and
     * available upgrades
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    _listMeshRevisionProfiles(location, options) {
        return this.client.sendOperationRequest({ location, options }, listMeshRevisionProfilesOperationSpec);
    }
    /**
     * Contains extra metadata on the revision, including supported revisions, cluster compatibility and
     * available upgrades
     * @param location The name of the Azure region.
     * @param mode The mode of the mesh.
     * @param options The options parameters.
     */
    getMeshRevisionProfile(location, mode, options) {
        return this.client.sendOperationRequest({ location, mode, options }, getMeshRevisionProfileOperationSpec);
    }
    /**
     * Lists available upgrades for all service meshes in a specific cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    _listMeshUpgradeProfiles(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listMeshUpgradeProfilesOperationSpec);
    }
    /**
     * Gets available upgrades for a service mesh in a cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param mode The mode of the mesh.
     * @param options The options parameters.
     */
    getMeshUpgradeProfile(resourceGroupName, resourceName, mode, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, mode, options }, getMeshUpgradeProfileOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListOutboundNetworkDependenciesEndpointsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListOutboundNetworkDependenciesEndpoints method.
     * @param options The options parameters.
     */
    _listOutboundNetworkDependenciesEndpointsNext(resourceGroupName, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, nextLink, options }, listOutboundNetworkDependenciesEndpointsNextOperationSpec);
    }
    /**
     * ListMeshRevisionProfilesNext
     * @param location The name of the Azure region.
     * @param nextLink The nextLink from the previous successful call to the ListMeshRevisionProfiles
     *                 method.
     * @param options The options parameters.
     */
    _listMeshRevisionProfilesNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listMeshRevisionProfilesNextOperationSpec);
    }
    /**
     * ListMeshUpgradeProfilesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param nextLink The nextLink from the previous successful call to the ListMeshUpgradeProfiles
     *                 method.
     * @param options The options parameters.
     */
    _listMeshUpgradeProfilesNext(resourceGroupName, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, nextLink, options }, listMeshUpgradeProfilesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOSOptionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/locations/{location}/osOptions/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OSOptionProfile,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion, resourceType],
    urlParameters: [
        $host,
        subscriptionId,
        location,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listKubernetesVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/locations/{location}/kubernetesVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KubernetesVersionListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/managedClusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedClusterListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedClusterListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const getUpgradeProfileOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/upgradeProfiles/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedClusterUpgradeProfile,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const getAccessProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/accessProfiles/{roleName}/listCredential",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ManagedClusterAccessProfile,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        roleName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listClusterAdminCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/listClusterAdminCredential",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CredentialResults,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion, serverFqdn],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listClusterUserCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/listClusterUserCredential",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CredentialResults,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [
        apiVersion,
        serverFqdn,
        format,
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listClusterMonitoringUserCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/listClusterMonitoringUserCredential",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CredentialResults,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion, serverFqdn],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedCluster,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedCluster,
        },
        201: {
            bodyMapper: ManagedCluster,
        },
        202: {
            bodyMapper: ManagedCluster,
        },
        204: {
            bodyMapper: ManagedCluster,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8,
};
const updateTagsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedCluster,
        },
        201: {
            bodyMapper: ManagedCluster,
        },
        202: {
            bodyMapper: ManagedCluster,
        },
        204: {
            bodyMapper: ManagedCluster,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8,
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: ManagedClustersDeleteHeaders,
        },
        201: {
            headersMapper: ManagedClustersDeleteHeaders,
        },
        202: {
            headersMapper: ManagedClustersDeleteHeaders,
        },
        204: {
            headersMapper: ManagedClustersDeleteHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const resetServicePrincipalProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/resetServicePrincipalProfile",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8,
};
const resetAADProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/resetAADProfile",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8,
};
const rotateClusterCertificatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/rotateClusterCertificates",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ManagedClustersRotateClusterCertificatesHeaders,
        },
        201: {
            headersMapper: ManagedClustersRotateClusterCertificatesHeaders,
        },
        202: {
            headersMapper: ManagedClustersRotateClusterCertificatesHeaders,
        },
        204: {
            headersMapper: ManagedClustersRotateClusterCertificatesHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const abortLatestOperationOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedclusters/{resourceName}/abort",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ManagedClustersAbortLatestOperationHeaders,
        },
        201: {
            headersMapper: ManagedClustersAbortLatestOperationHeaders,
        },
        202: {
            headersMapper: ManagedClustersAbortLatestOperationHeaders,
        },
        204: {
            headersMapper: ManagedClustersAbortLatestOperationHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const rotateServiceAccountSigningKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/rotateServiceAccountSigningKeys",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ManagedClustersRotateServiceAccountSigningKeysHeaders,
        },
        201: {
            headersMapper: ManagedClustersRotateServiceAccountSigningKeysHeaders,
        },
        202: {
            headersMapper: ManagedClustersRotateServiceAccountSigningKeysHeaders,
        },
        204: {
            headersMapper: ManagedClustersRotateServiceAccountSigningKeysHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/stop",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ManagedClustersStopHeaders,
        },
        201: {
            headersMapper: ManagedClustersStopHeaders,
        },
        202: {
            headersMapper: ManagedClustersStopHeaders,
        },
        204: {
            headersMapper: ManagedClustersStopHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/start",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ManagedClustersStartHeaders,
        },
        201: {
            headersMapper: ManagedClustersStartHeaders,
        },
        202: {
            headersMapper: ManagedClustersStartHeaders,
        },
        204: {
            headersMapper: ManagedClustersStartHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const runCommandOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/runCommand",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RunCommandResult,
        },
        201: {
            bodyMapper: RunCommandResult,
        },
        202: {
            bodyMapper: RunCommandResult,
        },
        204: {
            bodyMapper: RunCommandResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: requestPayload,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8,
};
const getCommandResultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/commandResults/{commandId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RunCommandResult,
        },
        202: {
            headersMapper: ManagedClustersGetCommandResultHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        commandId,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listMeshRevisionProfilesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/locations/{location}/meshRevisionProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MeshRevisionProfileList,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const getMeshRevisionProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/locations/{location}/meshRevisionProfiles/{mode}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MeshRevisionProfile,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        mode,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listMeshUpgradeProfilesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/meshUpgradeProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MeshUpgradeProfileList,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const getMeshUpgradeProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/meshUpgradeProfiles/{mode}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MeshUpgradeProfile,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        mode,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedClusterListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedClusterListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listOutboundNetworkDependenciesEndpointsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listMeshRevisionProfilesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MeshRevisionProfileList,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        location,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};
const listMeshUpgradeProfilesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MeshUpgradeProfileList,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$8,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MaintenanceConfigurations operations. */
class MaintenanceConfigurationsImpl {
    /**
     * Initialize a new instance of the class MaintenanceConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of maintenance configurations in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    listByManagedCluster(resourceGroupName, resourceName, options) {
        const iter = this.listByManagedClusterPagingAll(resourceGroupName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByManagedClusterPagingPage(resourceGroupName, resourceName, options, settings);
            },
        };
    }
    listByManagedClusterPagingPage(resourceGroupName, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedClusterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByManagedCluster(resourceGroupName, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByManagedClusterNext(resourceGroupName, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByManagedClusterPagingAll(resourceGroupName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByManagedClusterPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByManagedClusterPagingPage(resourceGroupName, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of maintenance configurations in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    _listByManagedCluster(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listByManagedClusterOperationSpec);
    }
    /**
     * Gets the specified maintenance configuration of a managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param configName The name of the maintenance configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, configName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, configName, options }, getOperationSpec$4);
    }
    /**
     * Creates or updates a maintenance configuration in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param configName The name of the maintenance configuration.
     * @param parameters The maintenance configuration to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, resourceName, configName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, configName, parameters, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes a maintenance configuration.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param configName The name of the maintenance configuration.
     * @param options The options parameters.
     */
    delete(resourceGroupName, resourceName, configName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, configName, options }, deleteOperationSpec$4);
    }
    /**
     * ListByManagedClusterNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param nextLink The nextLink from the previous successful call to the ListByManagedCluster method.
     * @param options The options parameters.
     */
    _listByManagedClusterNext(resourceGroupName, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, nextLink, options }, listByManagedClusterNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByManagedClusterOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/maintenanceConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceConfigurationListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/maintenanceConfigurations/{configName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceConfiguration,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        configName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/maintenanceConfigurations/{configName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MaintenanceConfiguration,
        },
        201: {
            bodyMapper: MaintenanceConfiguration,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        configName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7,
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/maintenanceConfigurations/{configName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        configName,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};
const listByManagedClusterNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MaintenanceConfigurationListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$7,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AgentPools operations. */
class AgentPoolsImpl {
    /**
     * Initialize a new instance of the class AgentPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of agent pools in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, resourceName, options) {
        const iter = this.listPagingAll(resourceGroupName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, resourceName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Aborts the currently running operation on the agent pool. The Agent Pool will be moved to a
     * Canceling state and eventually to a Canceled state when cancellation finishes. If the operation
     * completes before cancellation can take place, a 409 error code is returned.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginAbortLatestOperation(resourceGroupName, resourceName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, agentPoolName, options },
                spec: abortLatestOperationOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Aborts the currently running operation on the agent pool. The Agent Pool will be moved to a
     * Canceling state and eventually to a Canceled state when cancellation finishes. If the operation
     * completes before cancellation can take place, a 409 error code is returned.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginAbortLatestOperationAndWait(resourceGroupName, resourceName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAbortLatestOperation(resourceGroupName, resourceName, agentPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of agent pools in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listOperationSpec$5);
    }
    /**
     * Gets the specified managed cluster agent pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, agentPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, agentPoolName, options }, getOperationSpec$3);
    }
    /**
     * Creates or updates an agent pool in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param parameters The agent pool to create or update.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, resourceName, agentPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceName,
                    agentPoolName,
                    parameters,
                    options,
                },
                spec: createOrUpdateOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an agent pool in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param parameters The agent pool to create or update.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, resourceName, agentPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, resourceName, agentPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes an agent pool in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, agentPoolName, options },
                spec: deleteOperationSpec$3,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an agent pool in the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceName, agentPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the upgrade profile for an agent pool.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    getUpgradeProfile(resourceGroupName, resourceName, agentPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, agentPoolName, options }, getUpgradeProfileOperationSpec);
    }
    /**
     * See [supported Kubernetes
     * versions](https://docs.microsoft.com/azure/aks/supported-kubernetes-versions) for more details about
     * the version lifecycle.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    getAvailableAgentPoolVersions(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, getAvailableAgentPoolVersionsOperationSpec);
    }
    /**
     * Upgrading the node image version of an agent pool applies the newest OS and runtime updates to the
     * nodes. AKS provides one new image per week with the latest updates. For more details on node image
     * versions, see: https://docs.microsoft.com/azure/aks/node-image-upgrade
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginUpgradeNodeImageVersion(resourceGroupName, resourceName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, resourceName, agentPoolName, options },
                spec: upgradeNodeImageVersionOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location",
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Upgrading the node image version of an agent pool applies the newest OS and runtime updates to the
     * nodes. AKS provides one new image per week with the latest updates. For more details on node image
     * versions, see: https://docs.microsoft.com/azure/aks/node-image-upgrade
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param agentPoolName The name of the agent pool.
     * @param options The options parameters.
     */
    beginUpgradeNodeImageVersionAndWait(resourceGroupName, resourceName, agentPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpgradeNodeImageVersion(resourceGroupName, resourceName, agentPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const abortLatestOperationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedclusters/{resourceName}/agentPools/{agentPoolName}/abort",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: AgentPoolsAbortLatestOperationHeaders,
        },
        201: {
            headersMapper: AgentPoolsAbortLatestOperationHeaders,
        },
        202: {
            headersMapper: AgentPoolsAbortLatestOperationHeaders,
        },
        204: {
            headersMapper: AgentPoolsAbortLatestOperationHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        agentPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPoolListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools/{agentPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPool,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        agentPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools/{agentPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AgentPool,
        },
        201: {
            bodyMapper: AgentPool,
        },
        202: {
            bodyMapper: AgentPool,
        },
        204: {
            bodyMapper: AgentPool,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        agentPoolName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6,
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools/{agentPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: AgentPoolsDeleteHeaders,
        },
        201: {
            headersMapper: AgentPoolsDeleteHeaders,
        },
        202: {
            headersMapper: AgentPoolsDeleteHeaders,
        },
        204: {
            headersMapper: AgentPoolsDeleteHeaders,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        agentPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const getUpgradeProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools/{agentPoolName}/upgradeProfiles/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPoolUpgradeProfile,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        agentPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const getAvailableAgentPoolVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/availableAgentPoolVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPoolAvailableVersions,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const upgradeNodeImageVersionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools/{agentPoolName}/upgradeNodeImageVersion",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        agentPoolName,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AgentPoolListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$6,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * To learn more about private clusters, see: https://docs.microsoft.com/azure/aks/private-clusters
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listOperationSpec$4);
    }
    /**
     * To learn more about private clusters, see: https://docs.microsoft.com/azure/aks/private-clusters
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceName,
            privateEndpointConnectionName,
            options,
        }, getOperationSpec$2);
    }
    /**
     * Updates a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters The updated private endpoint connection.
     * @param options The options parameters.
     */
    update(resourceGroupName, resourceName, privateEndpointConnectionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceName,
            privateEndpointConnectionName,
            parameters,
            options,
        }, updateOperationSpec);
    }
    /**
     * Deletes a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceName,
                    privateEndpointConnectionName,
                    options,
                },
                spec: deleteOperationSpec$2,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$5,
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$5,
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection,
        },
        201: {
            bodyMapper: PrivateEndpointConnection,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5,
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        privateEndpointConnectionName,
    ],
    headerParameters: [accept],
    serializer: serializer$5,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * To learn more about private clusters, see: https://docs.microsoft.com/azure/aks/private-clusters
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$4,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ResolvePrivateLinkServiceId operations. */
class ResolvePrivateLinkServiceIdImpl {
    /**
     * Initialize a new instance of the class ResolvePrivateLinkServiceId class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link service ID for the specified managed cluster.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters Parameters required in order to resolve a private link service ID.
     * @param options The options parameters.
     */
    post(resourceGroupName, resourceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, parameters, options }, postOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const postOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/resolvePrivateLinkServiceId",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Snapshots operations. */
class SnapshotsImpl {
    /**
     * Initialize a new instance of the class Snapshots class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of snapshots in the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            },
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists snapshots in the specified subscription and resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            },
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of snapshots in the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Lists snapshots in the specified subscription and resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets a snapshot.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, getOperationSpec$1);
    }
    /**
     * Creates or updates a snapshot.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters The snapshot to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, resourceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, parameters, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Updates tags on a snapshot.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param parameters Parameters supplied to the Update snapshot Tags operation.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, resourceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, parameters, options }, updateTagsOperationSpec);
    }
    /**
     * Deletes a snapshot.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    delete(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, deleteOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2,
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/snapshots/{resourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Snapshot,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/snapshots/{resourceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Snapshot,
        },
        201: {
            bodyMapper: Snapshot,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2,
};
const updateTagsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/snapshots/{resourceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Snapshot,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2,
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/snapshots/{resourceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$2,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TrustedAccessRoleBindings operations. */
class TrustedAccessRoleBindingsImpl {
    /**
     * Initialize a new instance of the class TrustedAccessRoleBindings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List trusted access role bindings.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, resourceName, options) {
        const iter = this.listPagingAll(resourceGroupName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, resourceName, options, settings);
            },
        };
    }
    listPagingPage(resourceGroupName, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, resourceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List trusted access role bindings.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, listOperationSpec$1);
    }
    /**
     * Get a trusted access role binding.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param trustedAccessRoleBindingName The name of trusted access role binding.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, trustedAccessRoleBindingName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            resourceName,
            trustedAccessRoleBindingName,
            options,
        }, getOperationSpec);
    }
    /**
     * Create or update a trusted access role binding
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param trustedAccessRoleBindingName The name of trusted access role binding.
     * @param trustedAccessRoleBinding A trusted access role binding
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, resourceName, trustedAccessRoleBindingName, trustedAccessRoleBinding, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceName,
                    trustedAccessRoleBindingName,
                    trustedAccessRoleBinding,
                    options,
                },
                spec: createOrUpdateOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a trusted access role binding
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param trustedAccessRoleBindingName The name of trusted access role binding.
     * @param trustedAccessRoleBinding A trusted access role binding
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, resourceName, trustedAccessRoleBindingName, trustedAccessRoleBinding, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, resourceName, trustedAccessRoleBindingName, trustedAccessRoleBinding, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a trusted access role binding.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param trustedAccessRoleBindingName The name of trusted access role binding.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceName, trustedAccessRoleBindingName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON(),
                    },
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    resourceName,
                    trustedAccessRoleBindingName,
                    options,
                },
                spec: deleteOperationSpec,
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a trusted access role binding.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param trustedAccessRoleBindingName The name of trusted access role binding.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceName, trustedAccessRoleBindingName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceName, trustedAccessRoleBindingName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param resourceName The name of the managed cluster resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/trustedAccessRoleBindings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TrustedAccessRoleBindingListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/trustedAccessRoleBindings/{trustedAccessRoleBindingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TrustedAccessRoleBinding,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        trustedAccessRoleBindingName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/trustedAccessRoleBindings/{trustedAccessRoleBindingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: TrustedAccessRoleBinding,
        },
        201: {
            bodyMapper: TrustedAccessRoleBinding,
        },
        202: {
            bodyMapper: TrustedAccessRoleBinding,
        },
        204: {
            bodyMapper: TrustedAccessRoleBinding,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    requestBody: trustedAccessRoleBinding,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        trustedAccessRoleBindingName,
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1,
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/trustedAccessRoleBindings/{trustedAccessRoleBindingName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: TrustedAccessRoleBindingsDeleteHeaders,
        },
        201: {
            headersMapper: TrustedAccessRoleBindingsDeleteHeaders,
        },
        202: {
            headersMapper: TrustedAccessRoleBindingsDeleteHeaders,
        },
        204: {
            headersMapper: TrustedAccessRoleBindingsDeleteHeaders,
        },
        default: {
            bodyMapper: ErrorResponse,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        trustedAccessRoleBindingName,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TrustedAccessRoleBindingListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName,
        nextLink,
    ],
    headerParameters: [accept],
    serializer: serializer$1,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TrustedAccessRoles operations. */
class TrustedAccessRolesImpl {
    /**
     * Initialize a new instance of the class TrustedAccessRoles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List supported trusted access roles.
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            },
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List supported trusted access roles.
     * @param location The name of the Azure region.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param location The name of the Azure region.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ContainerService/locations/{location}/trustedAccessRoles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TrustedAccessRoleListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
    ],
    headerParameters: [accept],
    serializer,
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TrustedAccessRoleListResult,
        },
        default: {
            bodyMapper: CloudError,
        },
    },
    urlParameters: [
        $host,
        subscriptionId,
        location,
        nextLink,
    ],
    headerParameters: [accept],
    serializer,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ContainerServiceClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ContainerServiceClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription. The value must be an UUID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials,
        };
        const packageDetails = `azsdk-js-arm-containerservice/19.8.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName,
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge,
                },
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2024-01-01";
        this.operations = new OperationsImpl(this);
        this.managedClusters = new ManagedClustersImpl(this);
        this.maintenanceConfigurations = new MaintenanceConfigurationsImpl(this);
        this.agentPools = new AgentPoolsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.resolvePrivateLinkServiceId = new ResolvePrivateLinkServiceIdImpl(this);
        this.snapshots = new SnapshotsImpl(this);
        this.trustedAccessRoleBindings = new TrustedAccessRoleBindingsImpl(this);
        this.trustedAccessRoles = new TrustedAccessRolesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            },
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.ContainerServiceClient = ContainerServiceClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map

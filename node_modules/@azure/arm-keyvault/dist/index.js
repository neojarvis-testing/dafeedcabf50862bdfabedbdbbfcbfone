'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DeletionRecoveryLevel} that the service accepts. */
exports.KnownDeletionRecoveryLevel = void 0;
(function (KnownDeletionRecoveryLevel) {
    /** Purgeable */
    KnownDeletionRecoveryLevel["Purgeable"] = "Purgeable";
    /** RecoverablePurgeable */
    KnownDeletionRecoveryLevel["RecoverablePurgeable"] = "Recoverable+Purgeable";
    /** Recoverable */
    KnownDeletionRecoveryLevel["Recoverable"] = "Recoverable";
    /** RecoverableProtectedSubscription */
    KnownDeletionRecoveryLevel["RecoverableProtectedSubscription"] = "Recoverable+ProtectedSubscription";
})(exports.KnownDeletionRecoveryLevel || (exports.KnownDeletionRecoveryLevel = {}));
/** Known values of {@link JsonWebKeyType} that the service accepts. */
exports.KnownJsonWebKeyType = void 0;
(function (KnownJsonWebKeyType) {
    /** EC */
    KnownJsonWebKeyType["EC"] = "EC";
    /** ECHSM */
    KnownJsonWebKeyType["ECHSM"] = "EC-HSM";
    /** RSA */
    KnownJsonWebKeyType["RSA"] = "RSA";
    /** RSAHSM */
    KnownJsonWebKeyType["RSAHSM"] = "RSA-HSM";
})(exports.KnownJsonWebKeyType || (exports.KnownJsonWebKeyType = {}));
/** Known values of {@link JsonWebKeyOperation} that the service accepts. */
exports.KnownJsonWebKeyOperation = void 0;
(function (KnownJsonWebKeyOperation) {
    /** Encrypt */
    KnownJsonWebKeyOperation["Encrypt"] = "encrypt";
    /** Decrypt */
    KnownJsonWebKeyOperation["Decrypt"] = "decrypt";
    /** Sign */
    KnownJsonWebKeyOperation["Sign"] = "sign";
    /** Verify */
    KnownJsonWebKeyOperation["Verify"] = "verify";
    /** WrapKey */
    KnownJsonWebKeyOperation["WrapKey"] = "wrapKey";
    /** UnwrapKey */
    KnownJsonWebKeyOperation["UnwrapKey"] = "unwrapKey";
    /** Import */
    KnownJsonWebKeyOperation["Import"] = "import";
    /** Release */
    KnownJsonWebKeyOperation["Release"] = "release";
})(exports.KnownJsonWebKeyOperation || (exports.KnownJsonWebKeyOperation = {}));
/** Known values of {@link JsonWebKeyCurveName} that the service accepts. */
exports.KnownJsonWebKeyCurveName = void 0;
(function (KnownJsonWebKeyCurveName) {
    /** P256 */
    KnownJsonWebKeyCurveName["P256"] = "P-256";
    /** P384 */
    KnownJsonWebKeyCurveName["P384"] = "P-384";
    /** P521 */
    KnownJsonWebKeyCurveName["P521"] = "P-521";
    /** P256K */
    KnownJsonWebKeyCurveName["P256K"] = "P-256K";
})(exports.KnownJsonWebKeyCurveName || (exports.KnownJsonWebKeyCurveName = {}));
/** Known values of {@link SkuFamily} that the service accepts. */
exports.KnownSkuFamily = void 0;
(function (KnownSkuFamily) {
    /** A */
    KnownSkuFamily["A"] = "A";
})(exports.KnownSkuFamily || (exports.KnownSkuFamily = {}));
/** Known values of {@link KeyPermissions} that the service accepts. */
exports.KnownKeyPermissions = void 0;
(function (KnownKeyPermissions) {
    /** All */
    KnownKeyPermissions["All"] = "all";
    /** Encrypt */
    KnownKeyPermissions["Encrypt"] = "encrypt";
    /** Decrypt */
    KnownKeyPermissions["Decrypt"] = "decrypt";
    /** WrapKey */
    KnownKeyPermissions["WrapKey"] = "wrapKey";
    /** UnwrapKey */
    KnownKeyPermissions["UnwrapKey"] = "unwrapKey";
    /** Sign */
    KnownKeyPermissions["Sign"] = "sign";
    /** Verify */
    KnownKeyPermissions["Verify"] = "verify";
    /** Get */
    KnownKeyPermissions["Get"] = "get";
    /** List */
    KnownKeyPermissions["List"] = "list";
    /** Create */
    KnownKeyPermissions["Create"] = "create";
    /** Update */
    KnownKeyPermissions["Update"] = "update";
    /** Import */
    KnownKeyPermissions["Import"] = "import";
    /** Delete */
    KnownKeyPermissions["Delete"] = "delete";
    /** Backup */
    KnownKeyPermissions["Backup"] = "backup";
    /** Restore */
    KnownKeyPermissions["Restore"] = "restore";
    /** Recover */
    KnownKeyPermissions["Recover"] = "recover";
    /** Purge */
    KnownKeyPermissions["Purge"] = "purge";
    /** Release */
    KnownKeyPermissions["Release"] = "release";
    /** Rotate */
    KnownKeyPermissions["Rotate"] = "rotate";
    /** Getrotationpolicy */
    KnownKeyPermissions["Getrotationpolicy"] = "getrotationpolicy";
    /** Setrotationpolicy */
    KnownKeyPermissions["Setrotationpolicy"] = "setrotationpolicy";
})(exports.KnownKeyPermissions || (exports.KnownKeyPermissions = {}));
/** Known values of {@link SecretPermissions} that the service accepts. */
exports.KnownSecretPermissions = void 0;
(function (KnownSecretPermissions) {
    /** All */
    KnownSecretPermissions["All"] = "all";
    /** Get */
    KnownSecretPermissions["Get"] = "get";
    /** List */
    KnownSecretPermissions["List"] = "list";
    /** Set */
    KnownSecretPermissions["Set"] = "set";
    /** Delete */
    KnownSecretPermissions["Delete"] = "delete";
    /** Backup */
    KnownSecretPermissions["Backup"] = "backup";
    /** Restore */
    KnownSecretPermissions["Restore"] = "restore";
    /** Recover */
    KnownSecretPermissions["Recover"] = "recover";
    /** Purge */
    KnownSecretPermissions["Purge"] = "purge";
})(exports.KnownSecretPermissions || (exports.KnownSecretPermissions = {}));
/** Known values of {@link CertificatePermissions} that the service accepts. */
exports.KnownCertificatePermissions = void 0;
(function (KnownCertificatePermissions) {
    /** All */
    KnownCertificatePermissions["All"] = "all";
    /** Get */
    KnownCertificatePermissions["Get"] = "get";
    /** List */
    KnownCertificatePermissions["List"] = "list";
    /** Delete */
    KnownCertificatePermissions["Delete"] = "delete";
    /** Create */
    KnownCertificatePermissions["Create"] = "create";
    /** Import */
    KnownCertificatePermissions["Import"] = "import";
    /** Update */
    KnownCertificatePermissions["Update"] = "update";
    /** Managecontacts */
    KnownCertificatePermissions["Managecontacts"] = "managecontacts";
    /** Getissuers */
    KnownCertificatePermissions["Getissuers"] = "getissuers";
    /** Listissuers */
    KnownCertificatePermissions["Listissuers"] = "listissuers";
    /** Setissuers */
    KnownCertificatePermissions["Setissuers"] = "setissuers";
    /** Deleteissuers */
    KnownCertificatePermissions["Deleteissuers"] = "deleteissuers";
    /** Manageissuers */
    KnownCertificatePermissions["Manageissuers"] = "manageissuers";
    /** Recover */
    KnownCertificatePermissions["Recover"] = "recover";
    /** Purge */
    KnownCertificatePermissions["Purge"] = "purge";
    /** Backup */
    KnownCertificatePermissions["Backup"] = "backup";
    /** Restore */
    KnownCertificatePermissions["Restore"] = "restore";
})(exports.KnownCertificatePermissions || (exports.KnownCertificatePermissions = {}));
/** Known values of {@link StoragePermissions} that the service accepts. */
exports.KnownStoragePermissions = void 0;
(function (KnownStoragePermissions) {
    /** All */
    KnownStoragePermissions["All"] = "all";
    /** Get */
    KnownStoragePermissions["Get"] = "get";
    /** List */
    KnownStoragePermissions["List"] = "list";
    /** Delete */
    KnownStoragePermissions["Delete"] = "delete";
    /** Set */
    KnownStoragePermissions["Set"] = "set";
    /** Update */
    KnownStoragePermissions["Update"] = "update";
    /** Regeneratekey */
    KnownStoragePermissions["Regeneratekey"] = "regeneratekey";
    /** Recover */
    KnownStoragePermissions["Recover"] = "recover";
    /** Purge */
    KnownStoragePermissions["Purge"] = "purge";
    /** Backup */
    KnownStoragePermissions["Backup"] = "backup";
    /** Restore */
    KnownStoragePermissions["Restore"] = "restore";
    /** Setsas */
    KnownStoragePermissions["Setsas"] = "setsas";
    /** Listsas */
    KnownStoragePermissions["Listsas"] = "listsas";
    /** Getsas */
    KnownStoragePermissions["Getsas"] = "getsas";
    /** Deletesas */
    KnownStoragePermissions["Deletesas"] = "deletesas";
})(exports.KnownStoragePermissions || (exports.KnownStoragePermissions = {}));
/** Known values of {@link NetworkRuleBypassOptions} that the service accepts. */
exports.KnownNetworkRuleBypassOptions = void 0;
(function (KnownNetworkRuleBypassOptions) {
    /** AzureServices */
    KnownNetworkRuleBypassOptions["AzureServices"] = "AzureServices";
    /** None */
    KnownNetworkRuleBypassOptions["None"] = "None";
})(exports.KnownNetworkRuleBypassOptions || (exports.KnownNetworkRuleBypassOptions = {}));
/** Known values of {@link NetworkRuleAction} that the service accepts. */
exports.KnownNetworkRuleAction = void 0;
(function (KnownNetworkRuleAction) {
    /** Allow */
    KnownNetworkRuleAction["Allow"] = "Allow";
    /** Deny */
    KnownNetworkRuleAction["Deny"] = "Deny";
})(exports.KnownNetworkRuleAction || (exports.KnownNetworkRuleAction = {}));
/** Known values of {@link VaultProvisioningState} that the service accepts. */
exports.KnownVaultProvisioningState = void 0;
(function (KnownVaultProvisioningState) {
    /** Succeeded */
    KnownVaultProvisioningState["Succeeded"] = "Succeeded";
    /** RegisteringDns */
    KnownVaultProvisioningState["RegisteringDns"] = "RegisteringDns";
})(exports.KnownVaultProvisioningState || (exports.KnownVaultProvisioningState = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateEndpointServiceConnectionStatus = void 0;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPrivateEndpointServiceConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link ActionsRequired} that the service accepts. */
exports.KnownActionsRequired = void 0;
(function (KnownActionsRequired) {
    /** None */
    KnownActionsRequired["None"] = "None";
})(exports.KnownActionsRequired || (exports.KnownActionsRequired = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownPrivateEndpointConnectionProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
    /** Disconnected */
    KnownPrivateEndpointConnectionProvisioningState["Disconnected"] = "Disconnected";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link IdentityType} that the service accepts. */
exports.KnownIdentityType = void 0;
(function (KnownIdentityType) {
    /** User */
    KnownIdentityType["User"] = "User";
    /** Application */
    KnownIdentityType["Application"] = "Application";
    /** ManagedIdentity */
    KnownIdentityType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownIdentityType["Key"] = "Key";
})(exports.KnownIdentityType || (exports.KnownIdentityType = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** The managed HSM Pool has been full provisioned. */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** The managed HSM Pool is currently being provisioned. */
    KnownProvisioningState["Provisioning"] = "Provisioning";
    /** Provisioning of the managed HSM Pool has failed. */
    KnownProvisioningState["Failed"] = "Failed";
    /** The managed HSM Pool is currently being updated. */
    KnownProvisioningState["Updating"] = "Updating";
    /** The managed HSM Pool is currently being deleted. */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** The managed HSM pool is ready for normal use. */
    KnownProvisioningState["Activated"] = "Activated";
    /** The managed HSM pool is waiting for a security domain restore action. */
    KnownProvisioningState["SecurityDomainRestore"] = "SecurityDomainRestore";
    /** The managed HSM pool is being restored from full HSM backup. */
    KnownProvisioningState["Restoring"] = "Restoring";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link GeoReplicationRegionProvisioningState} that the service accepts. */
exports.KnownGeoReplicationRegionProvisioningState = void 0;
(function (KnownGeoReplicationRegionProvisioningState) {
    /** Preprovisioning */
    KnownGeoReplicationRegionProvisioningState["Preprovisioning"] = "Preprovisioning";
    /** Provisioning */
    KnownGeoReplicationRegionProvisioningState["Provisioning"] = "Provisioning";
    /** Succeeded */
    KnownGeoReplicationRegionProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownGeoReplicationRegionProvisioningState["Failed"] = "Failed";
    /** Deleting */
    KnownGeoReplicationRegionProvisioningState["Deleting"] = "Deleting";
    /** Cleanup */
    KnownGeoReplicationRegionProvisioningState["Cleanup"] = "Cleanup";
})(exports.KnownGeoReplicationRegionProvisioningState || (exports.KnownGeoReplicationRegionProvisioningState = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link ActivationStatus} that the service accepts. */
exports.KnownActivationStatus = void 0;
(function (KnownActivationStatus) {
    /** The managed HSM Pool is active. */
    KnownActivationStatus["Active"] = "Active";
    /** The managed HSM Pool is not yet activated. */
    KnownActivationStatus["NotActivated"] = "NotActivated";
    /** An unknown error occurred while activating managed hsm. */
    KnownActivationStatus["Unknown"] = "Unknown";
    /** Failed to activate managed hsm. */
    KnownActivationStatus["Failed"] = "Failed";
})(exports.KnownActivationStatus || (exports.KnownActivationStatus = {}));
/** Known values of {@link ManagedHsmSkuFamily} that the service accepts. */
exports.KnownManagedHsmSkuFamily = void 0;
(function (KnownManagedHsmSkuFamily) {
    /** B */
    KnownManagedHsmSkuFamily["B"] = "B";
})(exports.KnownManagedHsmSkuFamily || (exports.KnownManagedHsmSkuFamily = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedServiceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const KeyCreateParameters = {
    type: {
        name: "Composite",
        className: "KeyCreateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "KeyProperties"
                }
            }
        }
    }
};
const KeyProperties = {
    type: {
        name: "Composite",
        className: "KeyProperties",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "keyOps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keySize: {
                serializedName: "keySize",
                type: {
                    name: "Number"
                }
            },
            curveName: {
                serializedName: "curveName",
                type: {
                    name: "String"
                }
            },
            keyUri: {
                serializedName: "keyUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyUriWithVersion: {
                serializedName: "keyUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rotationPolicy: {
                serializedName: "rotationPolicy",
                type: {
                    name: "Composite",
                    className: "RotationPolicy"
                }
            },
            releasePolicy: {
                serializedName: "release_policy",
                type: {
                    name: "Composite",
                    className: "KeyReleasePolicy"
                }
            }
        }
    }
};
const KeyAttributes = {
    type: {
        name: "Composite",
        className: "KeyAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "Number"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "Number"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            recoveryLevel: {
                serializedName: "recoveryLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            exportable: {
                defaultValue: false,
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RotationPolicy = {
    type: {
        name: "Composite",
        className: "RotationPolicy",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "KeyRotationPolicyAttributes"
                }
            },
            lifetimeActions: {
                serializedName: "lifetimeActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LifetimeAction"
                        }
                    }
                }
            }
        }
    }
};
const KeyRotationPolicyAttributes = {
    type: {
        name: "Composite",
        className: "KeyRotationPolicyAttributes",
        modelProperties: {
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LifetimeAction = {
    type: {
        name: "Composite",
        className: "LifetimeAction",
        modelProperties: {
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "Trigger"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "Action"
                }
            }
        }
    }
};
const Trigger = {
    type: {
        name: "Composite",
        className: "Trigger",
        modelProperties: {
            timeAfterCreate: {
                serializedName: "timeAfterCreate",
                type: {
                    name: "String"
                }
            },
            timeBeforeExpiry: {
                serializedName: "timeBeforeExpiry",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Action = {
    type: {
        name: "Composite",
        className: "Action",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["rotate", "notify"]
                }
            }
        }
    }
};
const KeyReleasePolicy = {
    type: {
        name: "Composite",
        className: "KeyReleasePolicy",
        modelProperties: {
            contentType: {
                defaultValue: "application/json; charset=utf-8",
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyListResult = {
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Key"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmKeyCreateParameters = {
    type: {
        name: "Composite",
        className: "ManagedHsmKeyCreateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedHsmKeyProperties"
                }
            }
        }
    }
};
const ManagedHsmKeyProperties = {
    type: {
        name: "Composite",
        className: "ManagedHsmKeyProperties",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "ManagedHsmKeyAttributes"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            keyOps: {
                serializedName: "keyOps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            keySize: {
                serializedName: "keySize",
                type: {
                    name: "Number"
                }
            },
            curveName: {
                serializedName: "curveName",
                type: {
                    name: "String"
                }
            },
            keyUri: {
                serializedName: "keyUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyUriWithVersion: {
                serializedName: "keyUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rotationPolicy: {
                serializedName: "rotationPolicy",
                type: {
                    name: "Composite",
                    className: "ManagedHsmRotationPolicy"
                }
            },
            releasePolicy: {
                serializedName: "release_policy",
                type: {
                    name: "Composite",
                    className: "ManagedHsmKeyReleasePolicy"
                }
            }
        }
    }
};
const ManagedHsmKeyAttributes = {
    type: {
        name: "Composite",
        className: "ManagedHsmKeyAttributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "Number"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "Number"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            recoveryLevel: {
                serializedName: "recoveryLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            exportable: {
                serializedName: "exportable",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ManagedHsmRotationPolicy = {
    type: {
        name: "Composite",
        className: "ManagedHsmRotationPolicy",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "ManagedHsmKeyRotationPolicyAttributes"
                }
            },
            lifetimeActions: {
                serializedName: "lifetimeActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedHsmLifetimeAction"
                        }
                    }
                }
            }
        }
    }
};
const ManagedHsmKeyRotationPolicyAttributes = {
    type: {
        name: "Composite",
        className: "ManagedHsmKeyRotationPolicyAttributes",
        modelProperties: {
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            expiryTime: {
                serializedName: "expiryTime",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmLifetimeAction = {
    type: {
        name: "Composite",
        className: "ManagedHsmLifetimeAction",
        modelProperties: {
            trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "ManagedHsmTrigger"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "ManagedHsmAction"
                }
            }
        }
    }
};
const ManagedHsmTrigger = {
    type: {
        name: "Composite",
        className: "ManagedHsmTrigger",
        modelProperties: {
            timeAfterCreate: {
                serializedName: "timeAfterCreate",
                type: {
                    name: "String"
                }
            },
            timeBeforeExpiry: {
                serializedName: "timeBeforeExpiry",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmAction = {
    type: {
        name: "Composite",
        className: "ManagedHsmAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["rotate", "notify"]
                }
            }
        }
    }
};
const ManagedHsmKeyReleasePolicy = {
    type: {
        name: "Composite",
        className: "ManagedHsmKeyReleasePolicy",
        modelProperties: {
            contentType: {
                defaultValue: "application/json; charset=utf-8",
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Base64Url"
                }
            }
        }
    }
};
const ProxyResourceWithoutSystemData = {
    type: {
        name: "Composite",
        className: "ProxyResourceWithoutSystemData",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ManagedHsmKeyListResult = {
    type: {
        name: "Composite",
        className: "ManagedHsmKeyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedHsmKey"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultCreateOrUpdateParameters = {
    type: {
        name: "Composite",
        className: "VaultCreateOrUpdateParameters",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultProperties"
                }
            }
        }
    }
};
const VaultProperties = {
    type: {
        name: "Composite",
        className: "VaultProperties",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            accessPolicies: {
                serializedName: "accessPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntry"
                        }
                    }
                }
            },
            vaultUri: {
                serializedName: "vaultUri",
                type: {
                    name: "String"
                }
            },
            hsmPoolResourceId: {
                serializedName: "hsmPoolResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            enabledForDeployment: {
                serializedName: "enabledForDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enabledForDiskEncryption: {
                serializedName: "enabledForDiskEncryption",
                type: {
                    name: "Boolean"
                }
            },
            enabledForTemplateDeployment: {
                serializedName: "enabledForTemplateDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enableSoftDelete: {
                defaultValue: true,
                serializedName: "enableSoftDelete",
                type: {
                    name: "Boolean"
                }
            },
            softDeleteRetentionInDays: {
                defaultValue: 90,
                serializedName: "softDeleteRetentionInDays",
                type: {
                    name: "Number"
                }
            },
            enableRbacAuthorization: {
                defaultValue: false,
                serializedName: "enableRbacAuthorization",
                type: {
                    name: "Boolean"
                }
            },
            createMode: {
                serializedName: "createMode",
                type: {
                    name: "Enum",
                    allowedValues: ["recover", "default"]
                }
            },
            enablePurgeProtection: {
                serializedName: "enablePurgeProtection",
                type: {
                    name: "Boolean"
                }
            },
            networkAcls: {
                serializedName: "networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            privateEndpointConnections: {
                serializedName: "privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnectionItem"
                        }
                    }
                }
            },
            publicNetworkAccess: {
                defaultValue: "enabled",
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            family: {
                serializedName: "family",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["standard", "premium"]
                }
            }
        }
    }
};
const AccessPolicyEntry = {
    type: {
        name: "Composite",
        className: "AccessPolicyEntry",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            objectId: {
                serializedName: "objectId",
                required: true,
                type: {
                    name: "String"
                }
            },
            applicationId: {
                serializedName: "applicationId",
                type: {
                    name: "Uuid"
                }
            },
            permissions: {
                serializedName: "permissions",
                type: {
                    name: "Composite",
                    className: "Permissions"
                }
            }
        }
    }
};
const Permissions = {
    type: {
        name: "Composite",
        className: "Permissions",
        modelProperties: {
            keys: {
                serializedName: "keys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            certificates: {
                serializedName: "certificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            storage: {
                serializedName: "storage",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const NetworkRuleSet = {
    type: {
        name: "Composite",
        className: "NetworkRuleSet",
        modelProperties: {
            bypass: {
                serializedName: "bypass",
                type: {
                    name: "String"
                }
            },
            defaultAction: {
                serializedName: "defaultAction",
                type: {
                    name: "String"
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPRule"
                        }
                    }
                }
            },
            virtualNetworkRules: {
                serializedName: "virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkRule"
                        }
                    }
                }
            }
        }
    }
};
const IPRule = {
    type: {
        name: "Composite",
        className: "IPRule",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkRule",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            ignoreMissingVnetServiceEndpoint: {
                serializedName: "ignoreMissingVnetServiceEndpoint",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PrivateEndpointConnectionItem = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Vault = {
    type: {
        name: "Composite",
        className: "Vault",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultProperties"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const VaultPatchParameters = {
    type: {
        name: "Composite",
        className: "VaultPatchParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultPatchProperties"
                }
            }
        }
    }
};
const VaultPatchProperties = {
    type: {
        name: "Composite",
        className: "VaultPatchProperties",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            accessPolicies: {
                serializedName: "accessPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntry"
                        }
                    }
                }
            },
            enabledForDeployment: {
                serializedName: "enabledForDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enabledForDiskEncryption: {
                serializedName: "enabledForDiskEncryption",
                type: {
                    name: "Boolean"
                }
            },
            enabledForTemplateDeployment: {
                serializedName: "enabledForTemplateDeployment",
                type: {
                    name: "Boolean"
                }
            },
            enableSoftDelete: {
                serializedName: "enableSoftDelete",
                type: {
                    name: "Boolean"
                }
            },
            enableRbacAuthorization: {
                serializedName: "enableRbacAuthorization",
                type: {
                    name: "Boolean"
                }
            },
            softDeleteRetentionInDays: {
                serializedName: "softDeleteRetentionInDays",
                type: {
                    name: "Number"
                }
            },
            createMode: {
                serializedName: "createMode",
                type: {
                    name: "Enum",
                    allowedValues: ["recover", "default"]
                }
            },
            enablePurgeProtection: {
                serializedName: "enablePurgeProtection",
                type: {
                    name: "Boolean"
                }
            },
            networkAcls: {
                serializedName: "networkAcls",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            },
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultAccessPolicyParameters = {
    type: {
        name: "Composite",
        className: "VaultAccessPolicyParameters",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VaultAccessPolicyProperties"
                }
            }
        }
    }
};
const VaultAccessPolicyProperties = {
    type: {
        name: "Composite",
        className: "VaultAccessPolicyProperties",
        modelProperties: {
            accessPolicies: {
                serializedName: "accessPolicies",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntry"
                        }
                    }
                }
            }
        }
    }
};
const VaultListResult = {
    type: {
        name: "Composite",
        className: "VaultListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Vault"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedVaultListResult = {
    type: {
        name: "Composite",
        className: "DeletedVaultListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedVault"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedVault = {
    type: {
        name: "Composite",
        className: "DeletedVault",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeletedVaultProperties"
                }
            }
        }
    }
};
const DeletedVaultProperties = {
    type: {
        name: "Composite",
        className: "DeletedVaultProperties",
        modelProperties: {
            vaultId: {
                serializedName: "vaultId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deletionDate: {
                serializedName: "deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            purgeProtectionEnabled: {
                serializedName: "purgeProtectionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResourceListResult = {
    type: {
        name: "Composite",
        className: "ResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Resource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VaultCheckNameAvailabilityParameters = {
    type: {
        name: "Composite",
        className: "VaultCheckNameAvailabilityParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.KeyVault/vaults",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["AccountNameInvalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ManagedHsmProperties = {
    type: {
        name: "Composite",
        className: "ManagedHsmProperties",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "Uuid"
                }
            },
            initialAdminObjectIds: {
                serializedName: "initialAdminObjectIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            hsmUri: {
                serializedName: "hsmUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            enableSoftDelete: {
                defaultValue: true,
                serializedName: "enableSoftDelete",
                type: {
                    name: "Boolean"
                }
            },
            softDeleteRetentionInDays: {
                defaultValue: 90,
                serializedName: "softDeleteRetentionInDays",
                type: {
                    name: "Number"
                }
            },
            enablePurgeProtection: {
                defaultValue: true,
                serializedName: "enablePurgeProtection",
                type: {
                    name: "Boolean"
                }
            },
            createMode: {
                serializedName: "createMode",
                type: {
                    name: "Enum",
                    allowedValues: ["recover", "default"]
                }
            },
            statusMessage: {
                serializedName: "statusMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            networkAcls: {
                serializedName: "networkAcls",
                type: {
                    name: "Composite",
                    className: "MhsmNetworkRuleSet"
                }
            },
            regions: {
                serializedName: "regions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmGeoReplicatedRegion"
                        }
                    }
                }
            },
            privateEndpointConnections: {
                serializedName: "privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmPrivateEndpointConnectionItem"
                        }
                    }
                }
            },
            publicNetworkAccess: {
                defaultValue: "Enabled",
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            securityDomainProperties: {
                serializedName: "securityDomainProperties",
                type: {
                    name: "Composite",
                    className: "ManagedHSMSecurityDomainProperties"
                }
            }
        }
    }
};
const MhsmNetworkRuleSet = {
    type: {
        name: "Composite",
        className: "MhsmNetworkRuleSet",
        modelProperties: {
            bypass: {
                serializedName: "bypass",
                type: {
                    name: "String"
                }
            },
            defaultAction: {
                serializedName: "defaultAction",
                type: {
                    name: "String"
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmipRule"
                        }
                    }
                }
            },
            virtualNetworkRules: {
                serializedName: "virtualNetworkRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmVirtualNetworkRule"
                        }
                    }
                }
            }
        }
    }
};
const MhsmipRule = {
    type: {
        name: "Composite",
        className: "MhsmipRule",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmVirtualNetworkRule = {
    type: {
        name: "Composite",
        className: "MhsmVirtualNetworkRule",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmGeoReplicatedRegion = {
    type: {
        name: "Composite",
        className: "MhsmGeoReplicatedRegion",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isPrimary: {
                serializedName: "isPrimary",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionItem = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpoint = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "MhsmPrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHSMSecurityDomainProperties = {
    type: {
        name: "Composite",
        className: "ManagedHSMSecurityDomainProperties",
        modelProperties: {
            activationStatus: {
                serializedName: "activationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            activationStatusMessage: {
                serializedName: "activationStatusMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmResource = {
    type: {
        name: "Composite",
        className: "ManagedHsmResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "ManagedHsmSku"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }
        }
    }
};
const ManagedHsmSku = {
    type: {
        name: "Composite",
        className: "ManagedHsmSku",
        modelProperties: {
            family: {
                serializedName: "family",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Standard_B1", "Custom_B32", "Custom_B6"]
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const ManagedHsmError = {
    type: {
        name: "Composite",
        className: "ManagedHsmError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const ManagedHsmListResult = {
    type: {
        name: "Composite",
        className: "ManagedHsmListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedHsm"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionsListResult = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmPrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedManagedHsmListResult = {
    type: {
        name: "Composite",
        className: "DeletedManagedHsmListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeletedManagedHsm"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeletedManagedHsm = {
    type: {
        name: "Composite",
        className: "DeletedManagedHsm",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DeletedManagedHsmProperties"
                }
            }
        }
    }
};
const DeletedManagedHsmProperties = {
    type: {
        name: "Composite",
        className: "DeletedManagedHsmProperties",
        modelProperties: {
            mhsmId: {
                serializedName: "mhsmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deletionDate: {
                serializedName: "deletionDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            scheduledPurgeDate: {
                serializedName: "scheduledPurgeDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            purgeProtectionEnabled: {
                serializedName: "purgeProtectionEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const MhsmPrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "MhsmPrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmPrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const MhsmRegionsListResult = {
    type: {
        name: "Composite",
        className: "MhsmRegionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MhsmGeoReplicatedRegion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckMhsmNameAvailabilityParameters = {
    type: {
        name: "Composite",
        className: "CheckMhsmNameAvailabilityParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckMhsmNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "CheckMhsmNameAvailabilityResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["AccountNameInvalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            },
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            lockAggregationType: {
                serializedName: "lockAggregationType",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DimensionProperties"
                        }
                    }
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            internalMetricName: {
                serializedName: "internalMetricName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DimensionProperties = {
    type: {
        name: "Composite",
        className: "DimensionProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SecretCreateOrUpdateParameters = {
    type: {
        name: "Composite",
        className: "SecretCreateOrUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            }
        }
    }
};
const SecretProperties = {
    type: {
        name: "Composite",
        className: "SecretProperties",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            },
            secretUri: {
                serializedName: "secretUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secretUriWithVersion: {
                serializedName: "secretUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Attributes = {
    type: {
        name: "Composite",
        className: "Attributes",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            notBefore: {
                serializedName: "nbf",
                type: {
                    name: "UnixTime"
                }
            },
            expires: {
                serializedName: "exp",
                type: {
                    name: "UnixTime"
                }
            },
            created: {
                serializedName: "created",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            },
            updated: {
                serializedName: "updated",
                readOnly: true,
                type: {
                    name: "UnixTime"
                }
            }
        }
    }
};
const SecretPatchParameters = {
    type: {
        name: "Composite",
        className: "SecretPatchParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SecretPatchProperties"
                }
            }
        }
    }
};
const SecretPatchProperties = {
    type: {
        name: "Composite",
        className: "SecretPatchProperties",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "contentType",
                type: {
                    name: "String"
                }
            },
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Composite",
                    className: "SecretAttributes"
                }
            }
        }
    }
};
const SecretListResult = {
    type: {
        name: "Composite",
        className: "SecretListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Key = {
    type: {
        name: "Composite",
        className: "Key",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { attributes: {
                serializedName: "properties.attributes",
                type: {
                    name: "Composite",
                    className: "KeyAttributes"
                }
            }, kty: {
                serializedName: "properties.kty",
                type: {
                    name: "String"
                }
            }, keyOps: {
                serializedName: "properties.keyOps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, keySize: {
                serializedName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, curveName: {
                serializedName: "properties.curveName",
                type: {
                    name: "String"
                }
            }, keyUri: {
                serializedName: "properties.keyUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, keyUriWithVersion: {
                serializedName: "properties.keyUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rotationPolicy: {
                serializedName: "properties.rotationPolicy",
                type: {
                    name: "Composite",
                    className: "RotationPolicy"
                }
            }, releasePolicy: {
                serializedName: "properties.release_policy",
                type: {
                    name: "Composite",
                    className: "KeyReleasePolicy"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Secret = {
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SecretProperties"
                }
            } })
    }
};
const ManagedHsmKey = {
    type: {
        name: "Composite",
        className: "ManagedHsmKey",
        modelProperties: Object.assign(Object.assign({}, ProxyResourceWithoutSystemData.type.modelProperties), { attributes: {
                serializedName: "properties.attributes",
                type: {
                    name: "Composite",
                    className: "ManagedHsmKeyAttributes"
                }
            }, kty: {
                serializedName: "properties.kty",
                type: {
                    name: "String"
                }
            }, keyOps: {
                serializedName: "properties.keyOps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, keySize: {
                serializedName: "properties.keySize",
                type: {
                    name: "Number"
                }
            }, curveName: {
                serializedName: "properties.curveName",
                type: {
                    name: "String"
                }
            }, keyUri: {
                serializedName: "properties.keyUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, keyUriWithVersion: {
                serializedName: "properties.keyUriWithVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rotationPolicy: {
                serializedName: "properties.rotationPolicy",
                type: {
                    name: "Composite",
                    className: "ManagedHsmRotationPolicy"
                }
            }, releasePolicy: {
                serializedName: "properties.release_policy",
                type: {
                    name: "Composite",
                    className: "ManagedHsmKeyReleasePolicy"
                }
            } })
    }
};
const ManagedHsm = {
    type: {
        name: "Composite",
        className: "ManagedHsm",
        modelProperties: Object.assign(Object.assign({}, ManagedHsmResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedHsmProperties"
                }
            } })
    }
};
const MhsmPrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ManagedHsmResource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "MhsmPrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const MhsmPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "MhsmPrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ManagedHsmResource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SecretAttributes = {
    type: {
        name: "Composite",
        className: "SecretAttributes",
        modelProperties: Object.assign({}, Attributes.type.modelProperties)
    }
};
const PrivateEndpointConnectionsPutHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionsPutHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionsDeleteHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "ManagedHsmsCreateOrUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "ManagedHsmsUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ManagedHsmsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedHsmsPurgeDeletedHeaders = {
    type: {
        name: "Composite",
        className: "ManagedHsmsPurgeDeletedHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionsPutHeaders = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionsPutHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MhsmPrivateEndpointConnectionsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "MhsmPrivateEndpointConnectionsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    KeyCreateParameters: KeyCreateParameters,
    KeyProperties: KeyProperties,
    KeyAttributes: KeyAttributes,
    RotationPolicy: RotationPolicy,
    KeyRotationPolicyAttributes: KeyRotationPolicyAttributes,
    LifetimeAction: LifetimeAction,
    Trigger: Trigger,
    Action: Action,
    KeyReleasePolicy: KeyReleasePolicy,
    Resource: Resource,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    KeyListResult: KeyListResult,
    ManagedHsmKeyCreateParameters: ManagedHsmKeyCreateParameters,
    ManagedHsmKeyProperties: ManagedHsmKeyProperties,
    ManagedHsmKeyAttributes: ManagedHsmKeyAttributes,
    ManagedHsmRotationPolicy: ManagedHsmRotationPolicy,
    ManagedHsmKeyRotationPolicyAttributes: ManagedHsmKeyRotationPolicyAttributes,
    ManagedHsmLifetimeAction: ManagedHsmLifetimeAction,
    ManagedHsmTrigger: ManagedHsmTrigger,
    ManagedHsmAction: ManagedHsmAction,
    ManagedHsmKeyReleasePolicy: ManagedHsmKeyReleasePolicy,
    ProxyResourceWithoutSystemData: ProxyResourceWithoutSystemData,
    ManagedHsmKeyListResult: ManagedHsmKeyListResult,
    VaultCreateOrUpdateParameters: VaultCreateOrUpdateParameters,
    VaultProperties: VaultProperties,
    Sku: Sku,
    AccessPolicyEntry: AccessPolicyEntry,
    Permissions: Permissions,
    NetworkRuleSet: NetworkRuleSet,
    IPRule: IPRule,
    VirtualNetworkRule: VirtualNetworkRule,
    PrivateEndpointConnectionItem: PrivateEndpointConnectionItem,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    Vault: Vault,
    SystemData: SystemData,
    VaultPatchParameters: VaultPatchParameters,
    VaultPatchProperties: VaultPatchProperties,
    VaultAccessPolicyParameters: VaultAccessPolicyParameters,
    VaultAccessPolicyProperties: VaultAccessPolicyProperties,
    VaultListResult: VaultListResult,
    DeletedVaultListResult: DeletedVaultListResult,
    DeletedVault: DeletedVault,
    DeletedVaultProperties: DeletedVaultProperties,
    ResourceListResult: ResourceListResult,
    VaultCheckNameAvailabilityParameters: VaultCheckNameAvailabilityParameters,
    CheckNameAvailabilityResult: CheckNameAvailabilityResult,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ManagedHsmProperties: ManagedHsmProperties,
    MhsmNetworkRuleSet: MhsmNetworkRuleSet,
    MhsmipRule: MhsmipRule,
    MhsmVirtualNetworkRule: MhsmVirtualNetworkRule,
    MhsmGeoReplicatedRegion: MhsmGeoReplicatedRegion,
    MhsmPrivateEndpointConnectionItem: MhsmPrivateEndpointConnectionItem,
    MhsmPrivateEndpoint: MhsmPrivateEndpoint,
    MhsmPrivateLinkServiceConnectionState: MhsmPrivateLinkServiceConnectionState,
    ManagedHSMSecurityDomainProperties: ManagedHSMSecurityDomainProperties,
    ManagedHsmResource: ManagedHsmResource,
    ManagedHsmSku: ManagedHsmSku,
    ManagedServiceIdentity: ManagedServiceIdentity,
    UserAssignedIdentity: UserAssignedIdentity,
    ManagedHsmError: ManagedHsmError,
    ErrorModel: ErrorModel,
    ManagedHsmListResult: ManagedHsmListResult,
    MhsmPrivateEndpointConnectionsListResult: MhsmPrivateEndpointConnectionsListResult,
    DeletedManagedHsmListResult: DeletedManagedHsmListResult,
    DeletedManagedHsm: DeletedManagedHsm,
    DeletedManagedHsmProperties: DeletedManagedHsmProperties,
    MhsmPrivateLinkResourceListResult: MhsmPrivateLinkResourceListResult,
    MhsmRegionsListResult: MhsmRegionsListResult,
    CheckMhsmNameAvailabilityParameters: CheckMhsmNameAvailabilityParameters,
    CheckMhsmNameAvailabilityResult: CheckMhsmNameAvailabilityResult,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ServiceSpecification: ServiceSpecification,
    LogSpecification: LogSpecification,
    MetricSpecification: MetricSpecification,
    DimensionProperties: DimensionProperties,
    SecretCreateOrUpdateParameters: SecretCreateOrUpdateParameters,
    SecretProperties: SecretProperties,
    Attributes: Attributes,
    SecretPatchParameters: SecretPatchParameters,
    SecretPatchProperties: SecretPatchProperties,
    SecretListResult: SecretListResult,
    Key: Key,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateLinkResource: PrivateLinkResource,
    Secret: Secret,
    ManagedHsmKey: ManagedHsmKey,
    ManagedHsm: ManagedHsm,
    MhsmPrivateEndpointConnection: MhsmPrivateEndpointConnection,
    MhsmPrivateLinkResource: MhsmPrivateLinkResource,
    SecretAttributes: SecretAttributes,
    PrivateEndpointConnectionsPutHeaders: PrivateEndpointConnectionsPutHeaders,
    PrivateEndpointConnectionsDeleteHeaders: PrivateEndpointConnectionsDeleteHeaders,
    ManagedHsmsCreateOrUpdateHeaders: ManagedHsmsCreateOrUpdateHeaders,
    ManagedHsmsUpdateHeaders: ManagedHsmsUpdateHeaders,
    ManagedHsmsDeleteHeaders: ManagedHsmsDeleteHeaders,
    ManagedHsmsPurgeDeletedHeaders: ManagedHsmsPurgeDeletedHeaders,
    MhsmPrivateEndpointConnectionsPutHeaders: MhsmPrivateEndpointConnectionsPutHeaders,
    MhsmPrivateEndpointConnectionsDeleteHeaders: MhsmPrivateEndpointConnectionsDeleteHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: KeyCreateParameters
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vaultName = {
    parameterPath: "vaultName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]{3,24}$")
        },
        serializedName: "vaultName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const keyName = {
    parameterPath: "keyName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]{1,127}$")
        },
        serializedName: "keyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-07-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const keyVersion = {
    parameterPath: "keyVersion",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-fA-F0-9]{32}$")
        },
        serializedName: "keyVersion",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ManagedHsmKeyCreateParameters
};
const resourceGroupName1 = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const name = {
    parameterPath: "name",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[A-Za-z]([A-Za-z0-9]|\\-[A-Za-z0-9])+$"),
            MaxLength: 24,
            MinLength: 3
        },
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: VaultCreateOrUpdateParameters
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: VaultPatchParameters
};
const vaultName1 = {
    parameterPath: "vaultName",
    mapper: {
        serializedName: "vaultName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: VaultAccessPolicyParameters
};
const operationKind = {
    parameterPath: "operationKind",
    mapper: {
        serializedName: "operationKind",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["add", "replace", "remove"]
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: "filter",
    mapper: {
        defaultValue: "resourceType eq 'Microsoft.KeyVault/vaults'",
        isConstant: true,
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2015-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const vaultName2 = {
    parameterPath: "vaultName",
    mapper: VaultCheckNameAvailabilityParameters
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: "properties",
    mapper: PrivateEndpointConnection
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: ManagedHsm
};
const name1 = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const mhsmName = {
    parameterPath: "mhsmName",
    mapper: CheckMhsmNameAvailabilityParameters
};
const properties1 = {
    parameterPath: "properties",
    mapper: MhsmPrivateEndpointConnection
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: SecretCreateOrUpdateParameters
};
const secretName = {
    parameterPath: "secretName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9-]{1,127}$")
        },
        serializedName: "secretName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: SecretPatchParameters
};
const secretName1 = {
    parameterPath: "secretName",
    mapper: {
        serializedName: "secretName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Keys operations. */
class KeysImpl {
    /**
     * Initialize a new instance of the class Keys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the keys in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the keys to be retrieved.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the versions of the specified key in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key versions to be retrieved.
     * @param keyName The name of the key versions to be retrieved.
     * @param options The options parameters.
     */
    listVersions(resourceGroupName, vaultName, keyName, options) {
        const iter = this.listVersionsPagingAll(resourceGroupName, vaultName, keyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVersionsPagingPage(resourceGroupName, vaultName, keyName, options, settings);
            }
        };
    }
    listVersionsPagingPage(resourceGroupName, vaultName, keyName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVersionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVersions(resourceGroupName, vaultName, keyName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVersionsNext(resourceGroupName, vaultName, keyName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVersionsPagingAll(resourceGroupName, vaultName, keyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVersionsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listVersionsPagingPage(resourceGroupName, vaultName, keyName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates the first version of a new key if it does not exist. If it already exists, then the existing
     * key is returned without any write operations being performed. This API does not create subsequent
     * versions, and does not update existing keys.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the key vault which contains the key to be created.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param parameters The parameters used to create the specified key.
     * @param options The options parameters.
     */
    createIfNotExist(resourceGroupName, vaultName, keyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, parameters, options }, createIfNotExistOperationSpec$1);
    }
    /**
     * Gets the current version of the specified key from the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key to be retrieved.
     * @param keyName The name of the key to be retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, options }, getOperationSpec$6);
    }
    /**
     * Lists the keys in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the keys to be retrieved.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec$4);
    }
    /**
     * Gets the specified version of the specified key in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key version to be retrieved.
     * @param keyName The name of the key version to be retrieved.
     * @param keyVersion The version of the key to be retrieved.
     * @param options The options parameters.
     */
    getVersion(resourceGroupName, vaultName, keyName, keyVersion, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, keyVersion, options }, getVersionOperationSpec$1);
    }
    /**
     * Lists the versions of the specified key in the specified key vault.
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key versions to be retrieved.
     * @param keyName The name of the key versions to be retrieved.
     * @param options The options parameters.
     */
    _listVersions(resourceGroupName, vaultName, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, options }, listVersionsOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the keys to be retrieved.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec$4);
    }
    /**
     * ListVersionsNext
     * @param resourceGroupName The name of the resource group which contains the specified key vault.
     * @param vaultName The name of the vault which contains the key versions to be retrieved.
     * @param keyName The name of the key versions to be retrieved.
     * @param nextLink The nextLink from the previous successful call to the ListVersions method.
     * @param options The options parameters.
     */
    _listVersionsNext(resourceGroupName, vaultName, keyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, keyName, nextLink, options }, listVersionsNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createIfNotExistOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getVersionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}/versions/{keyVersion}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Key
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName,
        keyVersion
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listVersionsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/keys/{keyName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listVersionsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        keyName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedHsmKeys operations. */
class ManagedHsmKeysImpl {
    /**
     * Initialize a new instance of the class ManagedHsmKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the keys in the specified managed HSM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, name, options) {
        const iter = this.listPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, name, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the versions of the specified key in the specified managed HSM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param options The options parameters.
     */
    listVersions(resourceGroupName, name, keyName, options) {
        const iter = this.listVersionsPagingAll(resourceGroupName, name, keyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVersionsPagingPage(resourceGroupName, name, keyName, options, settings);
            }
        };
    }
    listVersionsPagingPage(resourceGroupName, name, keyName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVersionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVersions(resourceGroupName, name, keyName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVersionsNext(resourceGroupName, name, keyName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVersionsPagingAll(resourceGroupName, name, keyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVersionsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listVersionsPagingPage(resourceGroupName, name, keyName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates the first version of a new key if it does not exist. If it already exists, then the existing
     * key is returned without any write operations being performed. This API does not create subsequent
     * versions, and does not update existing keys.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param parameters The parameters used to create the specified key.
     * @param options The options parameters.
     */
    createIfNotExist(resourceGroupName, name, keyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyName, parameters, options }, createIfNotExistOperationSpec);
    }
    /**
     * Gets the current version of the specified key from the specified managed HSM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyName, options }, getOperationSpec$5);
    }
    /**
     * Lists the keys in the specified managed HSM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listOperationSpec$3);
    }
    /**
     * Gets the specified version of the specified key in the specified managed HSM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param keyVersion The version of the key to be retrieved.
     * @param options The options parameters.
     */
    getVersion(resourceGroupName, name, keyName, keyVersion, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyName, keyVersion, options }, getVersionOperationSpec);
    }
    /**
     * Lists the versions of the specified key in the specified managed HSM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param options The options parameters.
     */
    _listVersions(resourceGroupName, name, keyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyName, options }, listVersionsOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listNextOperationSpec$3);
    }
    /**
     * ListVersionsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param name The name of the Managed HSM Pool within the specified resource group.
     * @param keyName The name of the key to be created. The value you provide may be copied globally for
     *                the purpose of running the service. The value provided should not include personally identifiable or
     *                sensitive information.
     * @param nextLink The nextLink from the previous successful call to the ListVersions method.
     * @param options The options parameters.
     */
    _listVersionsNext(resourceGroupName, name, keyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, keyName, nextLink, options }, listVersionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createIfNotExistOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/keys/{keyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedHsmKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        keyName,
        resourceGroupName1,
        name
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/keys/{keyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        keyName,
        resourceGroupName1,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmKeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName1,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getVersionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/keys/{keyName}/versions/{keyVersion}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        keyName,
        keyVersion,
        resourceGroupName1,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/keys/{keyName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmKeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        keyName,
        resourceGroupName1,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmKeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName1,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listVersionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmKeyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        keyName,
        nextLink,
        resourceGroupName1,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Vaults operations. */
class VaultsImpl {
    /**
     * Initialize a new instance of the class Vaults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the vaults associated with the subscription and within the
     * specified resource group.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets information about the deleted vaults in a subscription.
     * @param options The options parameters.
     */
    listDeleted(options) {
        const iter = this.listDeletedPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDeletedPagingPage(options, settings);
            }
        };
    }
    listDeletedPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDeleted(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDeletedNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDeletedPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDeletedPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Create or update a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the server belongs.
     * @param vaultName Name of the vault
     * @param parameters Parameters to create or update the vault
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vaultName, parameters, options },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the server belongs.
     * @param vaultName Name of the vault
     * @param parameters Parameters to create or update the vault
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vaultName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vaultName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the server belongs.
     * @param vaultName Name of the vault
     * @param parameters Parameters to patch the vault
     * @param options The options parameters.
     */
    update(resourceGroupName, vaultName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Deletes the specified Azure key vault.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault to delete
     * @param options The options parameters.
     */
    delete(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, deleteOperationSpec$3);
    }
    /**
     * Gets the specified Azure key vault.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, getOperationSpec$4);
    }
    /**
     * Update access policies in a key vault in the specified subscription.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName Name of the vault
     * @param operationKind Name of the operation
     * @param parameters Access policy to merge into the vault
     * @param options The options parameters.
     */
    updateAccessPolicy(resourceGroupName, vaultName, operationKind, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, operationKind, parameters, options }, updateAccessPolicyOperationSpec);
    }
    /**
     * The List operation gets information about the vaults associated with the subscription and within the
     * specified resource group.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Gets information about the deleted vaults in a subscription.
     * @param options The options parameters.
     */
    _listDeleted(options) {
        return this.client.sendOperationRequest({ options }, listDeletedOperationSpec$1);
    }
    /**
     * Gets the deleted Azure key vault.
     * @param vaultName The name of the vault.
     * @param location The location of the deleted vault.
     * @param options The options parameters.
     */
    getDeleted(vaultName, location, options) {
        return this.client.sendOperationRequest({ vaultName, location, options }, getDeletedOperationSpec$1);
    }
    /**
     * Permanently deletes the specified vault. aka Purges the deleted Azure key vault.
     * @param vaultName The name of the soft-deleted vault.
     * @param location The location of the soft-deleted vault.
     * @param options The options parameters.
     */
    beginPurgeDeleted(vaultName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { vaultName, location, options },
                spec: purgeDeletedOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Permanently deletes the specified vault. aka Purges the deleted Azure key vault.
     * @param vaultName The name of the soft-deleted vault.
     * @param location The location of the soft-deleted vault.
     * @param options The options parameters.
     */
    beginPurgeDeletedAndWait(vaultName, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeDeleted(vaultName, location, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The List operation gets information about the vaults associated with the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Checks that the vault name is valid and is not already in use.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    checkNameAvailability(vaultName, options) {
        return this.client.sendOperationRequest({ vaultName, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListDeletedNext
     * @param nextLink The nextLink from the previous successful call to the ListDeleted method.
     * @param options The options parameters.
     */
    _listDeletedNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listDeletedNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Vault
        },
        201: {
            bodyMapper: Vault
        },
        202: {
            bodyMapper: Vault
        },
        204: {
            bodyMapper: Vault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Vault
        },
        201: {
            bodyMapper: Vault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Vault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const updateAccessPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/accessPolicies/{operationKind}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VaultAccessPolicyParameters
        },
        201: {
            bodyMapper: VaultAccessPolicyParameters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        operationKind
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/vaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listDeletedOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/deletedVaults",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedVaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const getDeletedOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedVaults/{vaultName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedVault
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        vaultName1,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const purgeDeletedOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedVaults/{vaultName}/purge",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        vaultName1,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [top, filter, apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vaultName2,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listDeletedNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedVaultListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, vaultName, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourcePagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResource(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, privateEndpointConnectionName, options }, getOperationSpec$3);
    }
    /**
     * Updates the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param properties The intended state of private endpoint connection.
     * @param options The options parameters.
     */
    put(resourceGroupName, vaultName, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vaultName,
            privateEndpointConnectionName,
            properties,
            options
        }, putOperationSpec$1);
    }
    /**
     * Deletes the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vaultName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vaultName,
                    privateEndpointConnectionName,
                    options
                },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private endpoint connection associated with the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the key
     *                                      vault.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vaultName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vaultName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listByResourceOperationSpec$2);
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listByResourceNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const putOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection,
            headersMapper: PrivateEndpointConnectionsPutHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: properties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        privateEndpointConnectionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources supported for the key vault.
     * @param resourceGroupName Name of the resource group that contains the key vault.
     * @param vaultName The name of the key vault.
     * @param options The options parameters.
     */
    listByVault(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listByVaultOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByVaultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedHsms operations. */
class ManagedHsmsImpl {
    /**
     * Initialize a new instance of the class ManagedHsms class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription and
     * within the specified resource group.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * The List operation gets information about the deleted managed HSMs associated with the subscription.
     * @param options The options parameters.
     */
    listDeleted(options) {
        const iter = this.listDeletedPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDeletedPagingPage(options, settings);
            }
        };
    }
    listDeletedPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDeleted(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDeletedNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDeletedPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listDeletedPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDeletedPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Create or update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to create or update the managed HSM Pool
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, parameters, options },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to create or update the managed HSM Pool
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to patch the managed HSM Pool
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, parameters, options },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a managed HSM Pool in the specified subscription.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param parameters Parameters to patch the managed HSM Pool
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, name, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, name, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name The name of the managed HSM Pool to delete
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name The name of the managed HSM Pool to delete
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name The name of the managed HSM Pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$2);
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription and
     * within the specified resource group.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * The List operation gets information about the managed HSM Pools associated with the subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * The List operation gets information about the deleted managed HSMs associated with the subscription.
     * @param options The options parameters.
     */
    _listDeleted(options) {
        return this.client.sendOperationRequest({ options }, listDeletedOperationSpec);
    }
    /**
     * Gets the specified deleted managed HSM.
     * @param name The name of the deleted managed HSM.
     * @param location The location of the deleted managed HSM.
     * @param options The options parameters.
     */
    getDeleted(name, location, options) {
        return this.client.sendOperationRequest({ name, location, options }, getDeletedOperationSpec);
    }
    /**
     * Permanently deletes the specified managed HSM.
     * @param name The name of the soft-deleted managed HSM.
     * @param location The location of the soft-deleted managed HSM.
     * @param options The options parameters.
     */
    beginPurgeDeleted(name, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { name, location, options },
                spec: purgeDeletedOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Permanently deletes the specified managed HSM.
     * @param name The name of the soft-deleted managed HSM.
     * @param location The location of the soft-deleted managed HSM.
     * @param options The options parameters.
     */
    beginPurgeDeletedAndWait(name, location, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPurgeDeleted(name, location, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks that the managed hsm name is valid and is not already in use.
     * @param mhsmName The name of the managed hsm.
     * @param options The options parameters.
     */
    checkMhsmNameAvailability(mhsmName, options) {
        return this.client.sendOperationRequest({ mhsmName, options }, checkMhsmNameAvailabilityOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListDeletedNext
     * @param nextLink The nextLink from the previous successful call to the ListDeleted method.
     * @param options The options parameters.
     */
    _listDeletedNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listDeletedNextOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedHsm
        },
        201: {
            bodyMapper: ManagedHsm
        },
        202: {
            bodyMapper: ManagedHsm
        },
        204: {
            bodyMapper: ManagedHsm
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedHsm
        },
        201: {
            bodyMapper: ManagedHsm
        },
        202: {
            bodyMapper: ManagedHsm
        },
        204: {
            bodyMapper: ManagedHsm
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsm
        },
        204: {},
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/managedHSMs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listDeletedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/deletedManagedHSMs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const getDeletedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedManagedHSMs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedManagedHsm
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const purgeDeletedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/locations/{location}/deletedManagedHSMs/{name}/purge",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: ManagedHsmsPurgeDeletedHeaders
        },
        201: {
            headersMapper: ManagedHsmsPurgeDeletedHeaders
        },
        202: {
            headersMapper: ManagedHsmsPurgeDeletedHeaders
        },
        204: {
            headersMapper: ManagedHsmsPurgeDeletedHeaders
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const checkMhsmNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.KeyVault/checkMhsmNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckMhsmNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: mhsmName,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listDeletedNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DeletedManagedHsmListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MhsmPrivateEndpointConnections operations. */
class MhsmPrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class MhsmPrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, name, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourcePagingPage(resourceGroupName, name, options, settings);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResource(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the private endpoint connections associated with the
     * managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listByResourceOperationSpec$1);
    }
    /**
     * Gets the specified private endpoint connection associated with the managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, privateEndpointConnectionName, options }, getOperationSpec$1);
    }
    /**
     * Updates the specified private endpoint connection associated with the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param properties The intended state of private endpoint connection.
     * @param options The options parameters.
     */
    put(resourceGroupName, name, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            name,
            privateEndpointConnectionName,
            properties,
            options
        }, putOperationSpec);
    }
    /**
     * Deletes the specified private endpoint connection associated with the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, name, privateEndpointConnectionName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private endpoint connection associated with the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param privateEndpointConnectionName Name of the private endpoint connection associated with the
     *                                      managed hsm pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listByResourceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByResourceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnectionsListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnection,
            headersMapper: MhsmPrivateEndpointConnectionsPutHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: properties1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        name1
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        201: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        202: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        204: {
            bodyMapper: MhsmPrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateEndpointConnectionName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateEndpointConnectionsListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing MhsmPrivateLinkResources operations. */
class MhsmPrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class MhsmPrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources supported for the managed hsm pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    listByMhsmResource(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listByMhsmResourceOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByMhsmResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MhsmRegions operations. */
class MhsmRegionsImpl {
    /**
     * Initialize a new instance of the class MhsmRegions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the regions associated with the managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, name, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourcePagingPage(resourceGroupName, name, options, settings);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResource(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, name, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The List operation gets information about the regions associated with the managed HSM Pool.
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listByResourceOperationSpec);
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName Name of the resource group that contains the managed HSM pool.
     * @param name Name of the managed HSM Pool
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listByResourceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/managedHSMs/{name}/regions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmRegionsListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByResourceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MhsmRegionsListResult
        },
        default: {
            bodyMapper: ManagedHsmError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        name1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Key Vault Rest API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Key Vault Rest API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.KeyVault/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Secrets operations. */
class SecretsImpl {
    /**
     * Initialize a new instance of the class Secrets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List operation gets information about the secrets in a vault.  NOTE: This API is intended for
     * internal use in ARM deployments. Users should use the data-plane REST service for interaction with
     * vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    list(resourceGroupName, vaultName, options) {
        const iter = this.listPagingAll(resourceGroupName, vaultName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, vaultName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, vaultName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, vaultName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, vaultName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, vaultName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, vaultName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a secret in a key vault in the specified subscription.  NOTE: This API is intended
     * for internal use in ARM deployments. Users should use the data-plane REST service for interaction
     * with vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName Name of the vault
     * @param secretName Name of the secret. The value you provide may be copied globally for the purpose
     *                   of running the service. The value provided should not include personally identifiable or sensitive
     *                   information.
     * @param parameters Parameters to create or update the secret
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, vaultName, secretName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, secretName, parameters, options }, createOrUpdateOperationSpec);
    }
    /**
     * Update a secret in the specified subscription.  NOTE: This API is intended for internal use in ARM
     * deployments.  Users should use the data-plane REST service for interaction with vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName Name of the vault
     * @param secretName Name of the secret
     * @param parameters Parameters to patch the secret
     * @param options The options parameters.
     */
    update(resourceGroupName, vaultName, secretName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, secretName, parameters, options }, updateOperationSpec);
    }
    /**
     * Gets the specified secret.  NOTE: This API is intended for internal use in ARM deployments. Users
     * should use the data-plane REST service for interaction with vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param secretName The name of the secret.
     * @param options The options parameters.
     */
    get(resourceGroupName, vaultName, secretName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, secretName, options }, getOperationSpec);
    }
    /**
     * The List operation gets information about the secrets in a vault.  NOTE: This API is intended for
     * internal use in ARM deployments. Users should use the data-plane REST service for interaction with
     * vault secrets.
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param options The options parameters.
     */
    _list(resourceGroupName, vaultName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the Resource Group to which the vault belongs.
     * @param vaultName The name of the vault.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, vaultName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vaultName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets/{secretName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Secret
        },
        201: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        secretName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets/{secretName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Secret
        },
        201: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName,
        secretName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets/{secretName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1,
        secretName1
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}/secrets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vaultName1
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        vaultName1
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class KeyVaultManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the KeyVaultManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Subscription credentials which uniquely identify Microsoft Azure subscription.
     *                       The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-keyvault/3.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-07-01";
        this.keys = new KeysImpl(this);
        this.managedHsmKeys = new ManagedHsmKeysImpl(this);
        this.vaults = new VaultsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.managedHsms = new ManagedHsmsImpl(this);
        this.mhsmPrivateEndpointConnections = new MhsmPrivateEndpointConnectionsImpl(this);
        this.mhsmPrivateLinkResources = new MhsmPrivateLinkResourcesImpl(this);
        this.mhsmRegions = new MhsmRegionsImpl(this);
        this.operations = new OperationsImpl(this);
        this.secrets = new SecretsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.KeyVaultManagementClient = KeyVaultManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map

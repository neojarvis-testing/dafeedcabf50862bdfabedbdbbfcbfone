'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ChannelType} that the service accepts. */
exports.KnownChannelType = void 0;
(function (KnownChannelType) {
    /** PartnerTopic */
    KnownChannelType["PartnerTopic"] = "PartnerTopic";
})(exports.KnownChannelType || (exports.KnownChannelType = {}));
/** Known values of {@link EventDefinitionKind} that the service accepts. */
exports.KnownEventDefinitionKind = void 0;
(function (KnownEventDefinitionKind) {
    /** Inline */
    KnownEventDefinitionKind["Inline"] = "Inline";
})(exports.KnownEventDefinitionKind || (exports.KnownEventDefinitionKind = {}));
/** Known values of {@link ChannelProvisioningState} that the service accepts. */
exports.KnownChannelProvisioningState = void 0;
(function (KnownChannelProvisioningState) {
    /** Creating */
    KnownChannelProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownChannelProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownChannelProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownChannelProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownChannelProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownChannelProvisioningState["Failed"] = "Failed";
    /** IdleDueToMirroredPartnerTopicDeletion */
    KnownChannelProvisioningState["IdleDueToMirroredPartnerTopicDeletion"] = "IdleDueToMirroredPartnerTopicDeletion";
})(exports.KnownChannelProvisioningState || (exports.KnownChannelProvisioningState = {}));
/** Known values of {@link ReadinessState} that the service accepts. */
exports.KnownReadinessState = void 0;
(function (KnownReadinessState) {
    /** NeverActivated */
    KnownReadinessState["NeverActivated"] = "NeverActivated";
    /** Activated */
    KnownReadinessState["Activated"] = "Activated";
})(exports.KnownReadinessState || (exports.KnownReadinessState = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link PersistedConnectionStatus} that the service accepts. */
exports.KnownPersistedConnectionStatus = void 0;
(function (KnownPersistedConnectionStatus) {
    /** Pending */
    KnownPersistedConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPersistedConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPersistedConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPersistedConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownPersistedConnectionStatus || (exports.KnownPersistedConnectionStatus = {}));
/** Known values of {@link ResourceProvisioningState} that the service accepts. */
exports.KnownResourceProvisioningState = void 0;
(function (KnownResourceProvisioningState) {
    /** Creating */
    KnownResourceProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownResourceProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownResourceProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownResourceProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownResourceProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownResourceProvisioningState["Failed"] = "Failed";
})(exports.KnownResourceProvisioningState || (exports.KnownResourceProvisioningState = {}));
/** Known values of {@link DomainProvisioningState} that the service accepts. */
exports.KnownDomainProvisioningState = void 0;
(function (KnownDomainProvisioningState) {
    /** Creating */
    KnownDomainProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownDomainProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownDomainProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownDomainProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownDomainProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownDomainProvisioningState["Failed"] = "Failed";
})(exports.KnownDomainProvisioningState || (exports.KnownDomainProvisioningState = {}));
/** Known values of {@link InputSchema} that the service accepts. */
exports.KnownInputSchema = void 0;
(function (KnownInputSchema) {
    /** EventGridSchema */
    KnownInputSchema["EventGridSchema"] = "EventGridSchema";
    /** CustomEventSchema */
    KnownInputSchema["CustomEventSchema"] = "CustomEventSchema";
    /** CloudEventSchemaV10 */
    KnownInputSchema["CloudEventSchemaV10"] = "CloudEventSchemaV1_0";
})(exports.KnownInputSchema || (exports.KnownInputSchema = {}));
/** Known values of {@link InputSchemaMappingType} that the service accepts. */
exports.KnownInputSchemaMappingType = void 0;
(function (KnownInputSchemaMappingType) {
    /** Json */
    KnownInputSchemaMappingType["Json"] = "Json";
})(exports.KnownInputSchemaMappingType || (exports.KnownInputSchemaMappingType = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link IpActionType} that the service accepts. */
exports.KnownIpActionType = void 0;
(function (KnownIpActionType) {
    /** Allow */
    KnownIpActionType["Allow"] = "Allow";
})(exports.KnownIpActionType || (exports.KnownIpActionType = {}));
/** Known values of {@link DataResidencyBoundary} that the service accepts. */
exports.KnownDataResidencyBoundary = void 0;
(function (KnownDataResidencyBoundary) {
    /** WithinGeopair */
    KnownDataResidencyBoundary["WithinGeopair"] = "WithinGeopair";
    /** WithinRegion */
    KnownDataResidencyBoundary["WithinRegion"] = "WithinRegion";
})(exports.KnownDataResidencyBoundary || (exports.KnownDataResidencyBoundary = {}));
/** Known values of {@link IdentityType} that the service accepts. */
exports.KnownIdentityType = void 0;
(function (KnownIdentityType) {
    /** None */
    KnownIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned, UserAssigned";
})(exports.KnownIdentityType || (exports.KnownIdentityType = {}));
/** Known values of {@link DomainTopicProvisioningState} that the service accepts. */
exports.KnownDomainTopicProvisioningState = void 0;
(function (KnownDomainTopicProvisioningState) {
    /** Creating */
    KnownDomainTopicProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownDomainTopicProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownDomainTopicProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownDomainTopicProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownDomainTopicProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownDomainTopicProvisioningState["Failed"] = "Failed";
})(exports.KnownDomainTopicProvisioningState || (exports.KnownDomainTopicProvisioningState = {}));
/** Known values of {@link DeliveryAttributeMappingType} that the service accepts. */
exports.KnownDeliveryAttributeMappingType = void 0;
(function (KnownDeliveryAttributeMappingType) {
    /** Static */
    KnownDeliveryAttributeMappingType["Static"] = "Static";
    /** Dynamic */
    KnownDeliveryAttributeMappingType["Dynamic"] = "Dynamic";
})(exports.KnownDeliveryAttributeMappingType || (exports.KnownDeliveryAttributeMappingType = {}));
/** Known values of {@link EventSubscriptionProvisioningState} that the service accepts. */
exports.KnownEventSubscriptionProvisioningState = void 0;
(function (KnownEventSubscriptionProvisioningState) {
    /** Creating */
    KnownEventSubscriptionProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownEventSubscriptionProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownEventSubscriptionProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownEventSubscriptionProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownEventSubscriptionProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownEventSubscriptionProvisioningState["Failed"] = "Failed";
    /** AwaitingManualAction */
    KnownEventSubscriptionProvisioningState["AwaitingManualAction"] = "AwaitingManualAction";
})(exports.KnownEventSubscriptionProvisioningState || (exports.KnownEventSubscriptionProvisioningState = {}));
/** Known values of {@link EndpointType} that the service accepts. */
exports.KnownEndpointType = void 0;
(function (KnownEndpointType) {
    /** WebHook */
    KnownEndpointType["WebHook"] = "WebHook";
    /** EventHub */
    KnownEndpointType["EventHub"] = "EventHub";
    /** StorageQueue */
    KnownEndpointType["StorageQueue"] = "StorageQueue";
    /** HybridConnection */
    KnownEndpointType["HybridConnection"] = "HybridConnection";
    /** ServiceBusQueue */
    KnownEndpointType["ServiceBusQueue"] = "ServiceBusQueue";
    /** ServiceBusTopic */
    KnownEndpointType["ServiceBusTopic"] = "ServiceBusTopic";
    /** AzureFunction */
    KnownEndpointType["AzureFunction"] = "AzureFunction";
})(exports.KnownEndpointType || (exports.KnownEndpointType = {}));
/** Known values of {@link EventSubscriptionIdentityType} that the service accepts. */
exports.KnownEventSubscriptionIdentityType = void 0;
(function (KnownEventSubscriptionIdentityType) {
    /** SystemAssigned */
    KnownEventSubscriptionIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownEventSubscriptionIdentityType["UserAssigned"] = "UserAssigned";
})(exports.KnownEventSubscriptionIdentityType || (exports.KnownEventSubscriptionIdentityType = {}));
/** Known values of {@link AdvancedFilterOperatorType} that the service accepts. */
exports.KnownAdvancedFilterOperatorType = void 0;
(function (KnownAdvancedFilterOperatorType) {
    /** NumberIn */
    KnownAdvancedFilterOperatorType["NumberIn"] = "NumberIn";
    /** NumberNotIn */
    KnownAdvancedFilterOperatorType["NumberNotIn"] = "NumberNotIn";
    /** NumberLessThan */
    KnownAdvancedFilterOperatorType["NumberLessThan"] = "NumberLessThan";
    /** NumberGreaterThan */
    KnownAdvancedFilterOperatorType["NumberGreaterThan"] = "NumberGreaterThan";
    /** NumberLessThanOrEquals */
    KnownAdvancedFilterOperatorType["NumberLessThanOrEquals"] = "NumberLessThanOrEquals";
    /** NumberGreaterThanOrEquals */
    KnownAdvancedFilterOperatorType["NumberGreaterThanOrEquals"] = "NumberGreaterThanOrEquals";
    /** BoolEquals */
    KnownAdvancedFilterOperatorType["BoolEquals"] = "BoolEquals";
    /** StringIn */
    KnownAdvancedFilterOperatorType["StringIn"] = "StringIn";
    /** StringNotIn */
    KnownAdvancedFilterOperatorType["StringNotIn"] = "StringNotIn";
    /** StringBeginsWith */
    KnownAdvancedFilterOperatorType["StringBeginsWith"] = "StringBeginsWith";
    /** StringEndsWith */
    KnownAdvancedFilterOperatorType["StringEndsWith"] = "StringEndsWith";
    /** StringContains */
    KnownAdvancedFilterOperatorType["StringContains"] = "StringContains";
    /** NumberInRange */
    KnownAdvancedFilterOperatorType["NumberInRange"] = "NumberInRange";
    /** NumberNotInRange */
    KnownAdvancedFilterOperatorType["NumberNotInRange"] = "NumberNotInRange";
    /** StringNotBeginsWith */
    KnownAdvancedFilterOperatorType["StringNotBeginsWith"] = "StringNotBeginsWith";
    /** StringNotEndsWith */
    KnownAdvancedFilterOperatorType["StringNotEndsWith"] = "StringNotEndsWith";
    /** StringNotContains */
    KnownAdvancedFilterOperatorType["StringNotContains"] = "StringNotContains";
    /** IsNullOrUndefined */
    KnownAdvancedFilterOperatorType["IsNullOrUndefined"] = "IsNullOrUndefined";
    /** IsNotNull */
    KnownAdvancedFilterOperatorType["IsNotNull"] = "IsNotNull";
})(exports.KnownAdvancedFilterOperatorType || (exports.KnownAdvancedFilterOperatorType = {}));
/** Known values of {@link EventDeliverySchema} that the service accepts. */
exports.KnownEventDeliverySchema = void 0;
(function (KnownEventDeliverySchema) {
    /** EventGridSchema */
    KnownEventDeliverySchema["EventGridSchema"] = "EventGridSchema";
    /** CustomInputSchema */
    KnownEventDeliverySchema["CustomInputSchema"] = "CustomInputSchema";
    /** CloudEventSchemaV10 */
    KnownEventDeliverySchema["CloudEventSchemaV10"] = "CloudEventSchemaV1_0";
})(exports.KnownEventDeliverySchema || (exports.KnownEventDeliverySchema = {}));
/** Known values of {@link DeadLetterEndPointType} that the service accepts. */
exports.KnownDeadLetterEndPointType = void 0;
(function (KnownDeadLetterEndPointType) {
    /** StorageBlob */
    KnownDeadLetterEndPointType["StorageBlob"] = "StorageBlob";
})(exports.KnownDeadLetterEndPointType || (exports.KnownDeadLetterEndPointType = {}));
/** Known values of {@link TopicProvisioningState} that the service accepts. */
exports.KnownTopicProvisioningState = void 0;
(function (KnownTopicProvisioningState) {
    /** Creating */
    KnownTopicProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownTopicProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownTopicProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownTopicProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownTopicProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownTopicProvisioningState["Failed"] = "Failed";
})(exports.KnownTopicProvisioningState || (exports.KnownTopicProvisioningState = {}));
/** Known values of {@link PartnerConfigurationProvisioningState} that the service accepts. */
exports.KnownPartnerConfigurationProvisioningState = void 0;
(function (KnownPartnerConfigurationProvisioningState) {
    /** Creating */
    KnownPartnerConfigurationProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownPartnerConfigurationProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPartnerConfigurationProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownPartnerConfigurationProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownPartnerConfigurationProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownPartnerConfigurationProvisioningState["Failed"] = "Failed";
})(exports.KnownPartnerConfigurationProvisioningState || (exports.KnownPartnerConfigurationProvisioningState = {}));
/** Known values of {@link PartnerNamespaceProvisioningState} that the service accepts. */
exports.KnownPartnerNamespaceProvisioningState = void 0;
(function (KnownPartnerNamespaceProvisioningState) {
    /** Creating */
    KnownPartnerNamespaceProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownPartnerNamespaceProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPartnerNamespaceProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownPartnerNamespaceProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownPartnerNamespaceProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownPartnerNamespaceProvisioningState["Failed"] = "Failed";
})(exports.KnownPartnerNamespaceProvisioningState || (exports.KnownPartnerNamespaceProvisioningState = {}));
/** Known values of {@link PartnerTopicRoutingMode} that the service accepts. */
exports.KnownPartnerTopicRoutingMode = void 0;
(function (KnownPartnerTopicRoutingMode) {
    /** SourceEventAttribute */
    KnownPartnerTopicRoutingMode["SourceEventAttribute"] = "SourceEventAttribute";
    /** ChannelNameHeader */
    KnownPartnerTopicRoutingMode["ChannelNameHeader"] = "ChannelNameHeader";
})(exports.KnownPartnerTopicRoutingMode || (exports.KnownPartnerTopicRoutingMode = {}));
/** Known values of {@link PartnerRegistrationProvisioningState} that the service accepts. */
exports.KnownPartnerRegistrationProvisioningState = void 0;
(function (KnownPartnerRegistrationProvisioningState) {
    /** Creating */
    KnownPartnerRegistrationProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownPartnerRegistrationProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPartnerRegistrationProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownPartnerRegistrationProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownPartnerRegistrationProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownPartnerRegistrationProvisioningState["Failed"] = "Failed";
})(exports.KnownPartnerRegistrationProvisioningState || (exports.KnownPartnerRegistrationProvisioningState = {}));
/** Known values of {@link PartnerTopicProvisioningState} that the service accepts. */
exports.KnownPartnerTopicProvisioningState = void 0;
(function (KnownPartnerTopicProvisioningState) {
    /** Creating */
    KnownPartnerTopicProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownPartnerTopicProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPartnerTopicProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownPartnerTopicProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownPartnerTopicProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownPartnerTopicProvisioningState["Failed"] = "Failed";
    /** IdleDueToMirroredChannelResourceDeletion */
    KnownPartnerTopicProvisioningState["IdleDueToMirroredChannelResourceDeletion"] = "IdleDueToMirroredChannelResourceDeletion";
})(exports.KnownPartnerTopicProvisioningState || (exports.KnownPartnerTopicProvisioningState = {}));
/** Known values of {@link PartnerTopicActivationState} that the service accepts. */
exports.KnownPartnerTopicActivationState = void 0;
(function (KnownPartnerTopicActivationState) {
    /** NeverActivated */
    KnownPartnerTopicActivationState["NeverActivated"] = "NeverActivated";
    /** Activated */
    KnownPartnerTopicActivationState["Activated"] = "Activated";
    /** Deactivated */
    KnownPartnerTopicActivationState["Deactivated"] = "Deactivated";
})(exports.KnownPartnerTopicActivationState || (exports.KnownPartnerTopicActivationState = {}));
/** Known values of {@link PrivateEndpointConnectionsParentType} that the service accepts. */
exports.KnownPrivateEndpointConnectionsParentType = void 0;
(function (KnownPrivateEndpointConnectionsParentType) {
    /** Topics */
    KnownPrivateEndpointConnectionsParentType["Topics"] = "topics";
    /** Domains */
    KnownPrivateEndpointConnectionsParentType["Domains"] = "domains";
    /** PartnerNamespaces */
    KnownPrivateEndpointConnectionsParentType["PartnerNamespaces"] = "partnerNamespaces";
})(exports.KnownPrivateEndpointConnectionsParentType || (exports.KnownPrivateEndpointConnectionsParentType = {}));
/** Known values of {@link ResourceRegionType} that the service accepts. */
exports.KnownResourceRegionType = void 0;
(function (KnownResourceRegionType) {
    /** RegionalResource */
    KnownResourceRegionType["RegionalResource"] = "RegionalResource";
    /** GlobalResource */
    KnownResourceRegionType["GlobalResource"] = "GlobalResource";
})(exports.KnownResourceRegionType || (exports.KnownResourceRegionType = {}));
/** Known values of {@link TopicTypeProvisioningState} that the service accepts. */
exports.KnownTopicTypeProvisioningState = void 0;
(function (KnownTopicTypeProvisioningState) {
    /** Creating */
    KnownTopicTypeProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownTopicTypeProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownTopicTypeProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownTopicTypeProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownTopicTypeProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownTopicTypeProvisioningState["Failed"] = "Failed";
})(exports.KnownTopicTypeProvisioningState || (exports.KnownTopicTypeProvisioningState = {}));
/** Known values of {@link TopicTypeSourceScope} that the service accepts. */
exports.KnownTopicTypeSourceScope = void 0;
(function (KnownTopicTypeSourceScope) {
    /** Resource */
    KnownTopicTypeSourceScope["Resource"] = "Resource";
    /** ResourceGroup */
    KnownTopicTypeSourceScope["ResourceGroup"] = "ResourceGroup";
    /** AzureSubscription */
    KnownTopicTypeSourceScope["AzureSubscription"] = "AzureSubscription";
    /** ManagementGroup */
    KnownTopicTypeSourceScope["ManagementGroup"] = "ManagementGroup";
})(exports.KnownTopicTypeSourceScope || (exports.KnownTopicTypeSourceScope = {}));
/** Known values of {@link VerifiedPartnerProvisioningState} that the service accepts. */
exports.KnownVerifiedPartnerProvisioningState = void 0;
(function (KnownVerifiedPartnerProvisioningState) {
    /** Creating */
    KnownVerifiedPartnerProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownVerifiedPartnerProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownVerifiedPartnerProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownVerifiedPartnerProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownVerifiedPartnerProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownVerifiedPartnerProvisioningState["Failed"] = "Failed";
})(exports.KnownVerifiedPartnerProvisioningState || (exports.KnownVerifiedPartnerProvisioningState = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const PartnerTopicInfo = {
    type: {
        name: "Composite",
        className: "PartnerTopicInfo",
        modelProperties: {
            azureSubscriptionId: {
                serializedName: "azureSubscriptionId",
                type: {
                    name: "String"
                }
            },
            resourceGroupName: {
                serializedName: "resourceGroupName",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            eventTypeInfo: {
                serializedName: "eventTypeInfo",
                type: {
                    name: "Composite",
                    className: "EventTypeInfo"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventTypeInfo = {
    type: {
        name: "Composite",
        className: "EventTypeInfo",
        modelProperties: {
            kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            inlineEventTypes: {
                serializedName: "inlineEventTypes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "InlineEventProperties" }
                    }
                }
            }
        }
    }
};
const InlineEventProperties = {
    type: {
        name: "Composite",
        className: "InlineEventProperties",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            documentationUrl: {
                serializedName: "documentationUrl",
                type: {
                    name: "String"
                }
            },
            dataSchemaUrl: {
                serializedName: "dataSchemaUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChannelUpdateParameters = {
    type: {
        name: "Composite",
        className: "ChannelUpdateParameters",
        modelProperties: {
            expirationTimeIfNotActivatedUtc: {
                serializedName: "properties.expirationTimeIfNotActivatedUtc",
                type: {
                    name: "DateTime"
                }
            },
            partnerTopicInfo: {
                serializedName: "properties.partnerTopicInfo",
                type: {
                    name: "Composite",
                    className: "PartnerUpdateTopicInfo"
                }
            }
        }
    }
};
const PartnerUpdateTopicInfo = {
    type: {
        name: "Composite",
        className: "PartnerUpdateTopicInfo",
        modelProperties: {
            eventTypeInfo: {
                serializedName: "eventTypeInfo",
                type: {
                    name: "Composite",
                    className: "EventTypeInfo"
                }
            }
        }
    }
};
const ChannelsListResult = {
    type: {
        name: "Composite",
        className: "ChannelsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Channel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventSubscriptionFullUrl = {
    type: {
        name: "Composite",
        className: "EventSubscriptionFullUrl",
        modelProperties: {
            endpointUrl: {
                serializedName: "endpointUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionState = {
    type: {
        name: "Composite",
        className: "ConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InputSchemaMapping = {
    type: {
        name: "Composite",
        className: "InputSchemaMapping",
        uberParent: "InputSchemaMapping",
        polymorphicDiscriminator: {
            serializedName: "inputSchemaMappingType",
            clientName: "inputSchemaMappingType"
        },
        modelProperties: {
            inputSchemaMappingType: {
                serializedName: "inputSchemaMappingType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InboundIpRule = {
    type: {
        name: "Composite",
        className: "InboundIpRule",
        modelProperties: {
            ipMask: {
                serializedName: "ipMask",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityInfo = {
    type: {
        name: "Composite",
        className: "IdentityInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserIdentityProperties" }
                    }
                }
            }
        }
    }
};
const UserIdentityProperties = {
    type: {
        name: "Composite",
        className: "UserIdentityProperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainUpdateParameters = {
    type: {
        name: "Composite",
        className: "DomainUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            inboundIpRules: {
                serializedName: "properties.inboundIpRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundIpRule"
                        }
                    }
                }
            },
            disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            },
            autoCreateTopicWithFirstSubscription: {
                serializedName: "properties.autoCreateTopicWithFirstSubscription",
                type: {
                    name: "Boolean"
                }
            },
            autoDeleteTopicWithLastSubscription: {
                serializedName: "properties.autoDeleteTopicWithLastSubscription",
                type: {
                    name: "Boolean"
                }
            },
            dataResidencyBoundary: {
                serializedName: "properties.dataResidencyBoundary",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainsListResult = {
    type: {
        name: "Composite",
        className: "DomainsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Domain"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainSharedAccessKeys = {
    type: {
        name: "Composite",
        className: "DomainSharedAccessKeys",
        modelProperties: {
            key1: {
                serializedName: "key1",
                type: {
                    name: "String"
                }
            },
            key2: {
                serializedName: "key2",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainRegenerateKeyRequest = {
    type: {
        name: "Composite",
        className: "DomainRegenerateKeyRequest",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DomainTopicsListResult = {
    type: {
        name: "Composite",
        className: "DomainTopicsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DomainTopic"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeliveryAttributeListResult = {
    type: {
        name: "Composite",
        className: "DeliveryAttributeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            }
        }
    }
};
const DeliveryAttributeMapping = {
    type: {
        name: "Composite",
        className: "DeliveryAttributeMapping",
        uberParent: "DeliveryAttributeMapping",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventSubscriptionDestination = {
    type: {
        name: "Composite",
        className: "EventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: {
            serializedName: "endpointType",
            clientName: "endpointType"
        },
        modelProperties: {
            endpointType: {
                serializedName: "endpointType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeliveryWithResourceIdentity = {
    type: {
        name: "Composite",
        className: "DeliveryWithResourceIdentity",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionIdentity"
                }
            },
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionDestination"
                }
            }
        }
    }
};
const EventSubscriptionIdentity = {
    type: {
        name: "Composite",
        className: "EventSubscriptionIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            userAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventSubscriptionFilter = {
    type: {
        name: "Composite",
        className: "EventSubscriptionFilter",
        modelProperties: {
            subjectBeginsWith: {
                serializedName: "subjectBeginsWith",
                type: {
                    name: "String"
                }
            },
            subjectEndsWith: {
                serializedName: "subjectEndsWith",
                type: {
                    name: "String"
                }
            },
            includedEventTypes: {
                serializedName: "includedEventTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isSubjectCaseSensitive: {
                defaultValue: false,
                serializedName: "isSubjectCaseSensitive",
                type: {
                    name: "Boolean"
                }
            },
            enableAdvancedFilteringOnArrays: {
                serializedName: "enableAdvancedFilteringOnArrays",
                type: {
                    name: "Boolean"
                }
            },
            advancedFilters: {
                serializedName: "advancedFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdvancedFilter"
                        }
                    }
                }
            }
        }
    }
};
const AdvancedFilter = {
    type: {
        name: "Composite",
        className: "AdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: {
            serializedName: "operatorType",
            clientName: "operatorType"
        },
        modelProperties: {
            operatorType: {
                serializedName: "operatorType",
                required: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RetryPolicy = {
    type: {
        name: "Composite",
        className: "RetryPolicy",
        modelProperties: {
            maxDeliveryAttempts: {
                defaultValue: 30,
                serializedName: "maxDeliveryAttempts",
                type: {
                    name: "Number"
                }
            },
            eventTimeToLiveInMinutes: {
                defaultValue: 1440,
                serializedName: "eventTimeToLiveInMinutes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DeadLetterDestination = {
    type: {
        name: "Composite",
        className: "DeadLetterDestination",
        uberParent: "DeadLetterDestination",
        polymorphicDiscriminator: {
            serializedName: "endpointType",
            clientName: "endpointType"
        },
        modelProperties: {
            endpointType: {
                serializedName: "endpointType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeadLetterWithResourceIdentity = {
    type: {
        name: "Composite",
        className: "DeadLetterWithResourceIdentity",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionIdentity"
                }
            },
            deadLetterDestination: {
                serializedName: "deadLetterDestination",
                type: {
                    name: "Composite",
                    className: "DeadLetterDestination"
                }
            }
        }
    }
};
const EventSubscriptionUpdateParameters = {
    type: {
        name: "Composite",
        className: "EventSubscriptionUpdateParameters",
        modelProperties: {
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionDestination"
                }
            },
            deliveryWithResourceIdentity: {
                serializedName: "deliveryWithResourceIdentity",
                type: {
                    name: "Composite",
                    className: "DeliveryWithResourceIdentity"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionFilter"
                }
            },
            labels: {
                serializedName: "labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expirationTimeUtc: {
                serializedName: "expirationTimeUtc",
                type: {
                    name: "DateTime"
                }
            },
            eventDeliverySchema: {
                serializedName: "eventDeliverySchema",
                type: {
                    name: "String"
                }
            },
            retryPolicy: {
                serializedName: "retryPolicy",
                type: {
                    name: "Composite",
                    className: "RetryPolicy"
                }
            },
            deadLetterDestination: {
                serializedName: "deadLetterDestination",
                type: {
                    name: "Composite",
                    className: "DeadLetterDestination"
                }
            },
            deadLetterWithResourceIdentity: {
                serializedName: "deadLetterWithResourceIdentity",
                type: {
                    name: "Composite",
                    className: "DeadLetterWithResourceIdentity"
                }
            }
        }
    }
};
const EventSubscriptionsListResult = {
    type: {
        name: "Composite",
        className: "EventSubscriptionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EventSubscription"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationsListResult = {
    type: {
        name: "Composite",
        className: "OperationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationInfo"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const OperationInfo = {
    type: {
        name: "Composite",
        className: "OperationInfo",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopicUpdateParameters = {
    type: {
        name: "Composite",
        className: "TopicUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            inboundIpRules: {
                serializedName: "properties.inboundIpRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundIpRule"
                        }
                    }
                }
            },
            disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            },
            dataResidencyBoundary: {
                serializedName: "properties.dataResidencyBoundary",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopicsListResult = {
    type: {
        name: "Composite",
        className: "TopicsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Topic"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopicSharedAccessKeys = {
    type: {
        name: "Composite",
        className: "TopicSharedAccessKeys",
        modelProperties: {
            key1: {
                serializedName: "key1",
                type: {
                    name: "String"
                }
            },
            key2: {
                serializedName: "key2",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TopicRegenerateKeyRequest = {
    type: {
        name: "Composite",
        className: "TopicRegenerateKeyRequest",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerAuthorization = {
    type: {
        name: "Composite",
        className: "PartnerAuthorization",
        modelProperties: {
            defaultMaximumExpirationTimeInDays: {
                serializedName: "defaultMaximumExpirationTimeInDays",
                type: {
                    name: "Number"
                }
            },
            authorizedPartnersList: {
                serializedName: "authorizedPartnersList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Partner"
                        }
                    }
                }
            }
        }
    }
};
const Partner = {
    type: {
        name: "Composite",
        className: "Partner",
        modelProperties: {
            partnerRegistrationImmutableId: {
                serializedName: "partnerRegistrationImmutableId",
                type: {
                    name: "Uuid"
                }
            },
            partnerName: {
                serializedName: "partnerName",
                type: {
                    name: "String"
                }
            },
            authorizationExpirationTimeInUtc: {
                serializedName: "authorizationExpirationTimeInUtc",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const PartnerConfigurationUpdateParameters = {
    type: {
        name: "Composite",
        className: "PartnerConfigurationUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            defaultMaximumExpirationTimeInDays: {
                serializedName: "properties.defaultMaximumExpirationTimeInDays",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PartnerConfigurationsListResult = {
    type: {
        name: "Composite",
        className: "PartnerConfigurationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartnerConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerNamespaceUpdateParameters = {
    type: {
        name: "Composite",
        className: "PartnerNamespaceUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            inboundIpRules: {
                serializedName: "properties.inboundIpRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundIpRule"
                        }
                    }
                }
            },
            disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PartnerNamespacesListResult = {
    type: {
        name: "Composite",
        className: "PartnerNamespacesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartnerNamespace"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerNamespaceSharedAccessKeys = {
    type: {
        name: "Composite",
        className: "PartnerNamespaceSharedAccessKeys",
        modelProperties: {
            key1: {
                serializedName: "key1",
                type: {
                    name: "String"
                }
            },
            key2: {
                serializedName: "key2",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerNamespaceRegenerateKeyRequest = {
    type: {
        name: "Composite",
        className: "PartnerNamespaceRegenerateKeyRequest",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerRegistrationUpdateParameters = {
    type: {
        name: "Composite",
        className: "PartnerRegistrationUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PartnerRegistrationsListResult = {
    type: {
        name: "Composite",
        className: "PartnerRegistrationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartnerRegistration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerTopicUpdateParameters = {
    type: {
        name: "Composite",
        className: "PartnerTopicUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            }
        }
    }
};
const PartnerTopicsListResult = {
    type: {
        name: "Composite",
        className: "PartnerTopicsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PartnerTopic"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "properties.requiredMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourcesListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourcesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemTopicUpdateParameters = {
    type: {
        name: "Composite",
        className: "SystemTopicUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            }
        }
    }
};
const SystemTopicsListResult = {
    type: {
        name: "Composite",
        className: "SystemTopicsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SystemTopic"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventTypesListResult = {
    type: {
        name: "Composite",
        className: "EventTypesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EventType"
                        }
                    }
                }
            }
        }
    }
};
const TopicTypesListResult = {
    type: {
        name: "Composite",
        className: "TopicTypesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopicTypeInfo"
                        }
                    }
                }
            }
        }
    }
};
const PartnerDetails = {
    type: {
        name: "Composite",
        className: "PartnerDetails",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            longDescription: {
                serializedName: "longDescription",
                type: {
                    name: "String"
                }
            },
            setupUri: {
                serializedName: "setupUri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VerifiedPartnersListResult = {
    type: {
        name: "Composite",
        className: "VerifiedPartnersListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VerifiedPartner"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JsonField = {
    type: {
        name: "Composite",
        className: "JsonField",
        modelProperties: {
            sourceField: {
                serializedName: "sourceField",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JsonFieldWithDefault = {
    type: {
        name: "Composite",
        className: "JsonFieldWithDefault",
        modelProperties: {
            sourceField: {
                serializedName: "sourceField",
                type: {
                    name: "String"
                }
            },
            defaultValue: {
                serializedName: "defaultValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Channel = {
    type: {
        name: "Composite",
        className: "Channel",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, channelType: {
                serializedName: "properties.channelType",
                type: {
                    name: "String"
                }
            }, partnerTopicInfo: {
                serializedName: "properties.partnerTopicInfo",
                type: {
                    name: "Composite",
                    className: "PartnerTopicInfo"
                }
            }, messageForActivation: {
                serializedName: "properties.messageForActivation",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, readinessState: {
                serializedName: "properties.readinessState",
                type: {
                    name: "String"
                }
            }, expirationTimeIfNotActivatedUtc: {
                serializedName: "properties.expirationTimeIfNotActivatedUtc",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, groupIds: {
                serializedName: "properties.groupIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "ConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const DomainTopic = {
    type: {
        name: "Composite",
        className: "DomainTopic",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EventSubscription = {
    type: {
        name: "Composite",
        className: "EventSubscription",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, topic: {
                serializedName: "properties.topic",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, destination: {
                serializedName: "properties.destination",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionDestination"
                }
            }, deliveryWithResourceIdentity: {
                serializedName: "properties.deliveryWithResourceIdentity",
                type: {
                    name: "Composite",
                    className: "DeliveryWithResourceIdentity"
                }
            }, filter: {
                serializedName: "properties.filter",
                type: {
                    name: "Composite",
                    className: "EventSubscriptionFilter"
                }
            }, labels: {
                serializedName: "properties.labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, expirationTimeUtc: {
                serializedName: "properties.expirationTimeUtc",
                type: {
                    name: "DateTime"
                }
            }, eventDeliverySchema: {
                serializedName: "properties.eventDeliverySchema",
                type: {
                    name: "String"
                }
            }, retryPolicy: {
                serializedName: "properties.retryPolicy",
                type: {
                    name: "Composite",
                    className: "RetryPolicy"
                }
            }, deadLetterDestination: {
                serializedName: "properties.deadLetterDestination",
                type: {
                    name: "Composite",
                    className: "DeadLetterDestination"
                }
            }, deadLetterWithResourceIdentity: {
                serializedName: "properties.deadLetterWithResourceIdentity",
                type: {
                    name: "Composite",
                    className: "DeadLetterWithResourceIdentity"
                }
            } })
    }
};
const PartnerConfiguration = {
    type: {
        name: "Composite",
        className: "PartnerConfiguration",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, partnerAuthorization: {
                serializedName: "properties.partnerAuthorization",
                type: {
                    name: "Composite",
                    className: "PartnerAuthorization"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const EventType = {
    type: {
        name: "Composite",
        className: "EventType",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, schemaUrl: {
                serializedName: "properties.schemaUrl",
                type: {
                    name: "String"
                }
            }, isInDefaultSet: {
                serializedName: "properties.isInDefaultSet",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ExtensionTopic = {
    type: {
        name: "Composite",
        className: "ExtensionTopic",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, systemTopic: {
                serializedName: "properties.systemTopic",
                type: {
                    name: "String"
                }
            } })
    }
};
const TopicTypeInfo = {
    type: {
        name: "Composite",
        className: "TopicTypeInfo",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provider: {
                serializedName: "properties.provider",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, resourceRegionType: {
                serializedName: "properties.resourceRegionType",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }, supportedLocations: {
                serializedName: "properties.supportedLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceResourceFormat: {
                serializedName: "properties.sourceResourceFormat",
                type: {
                    name: "String"
                }
            }, supportedScopesForSource: {
                serializedName: "properties.supportedScopesForSource",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const VerifiedPartner = {
    type: {
        name: "Composite",
        className: "VerifiedPartner",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, partnerRegistrationImmutableId: {
                serializedName: "properties.partnerRegistrationImmutableId",
                type: {
                    name: "Uuid"
                }
            }, organizationName: {
                serializedName: "properties.organizationName",
                type: {
                    name: "String"
                }
            }, partnerDisplayName: {
                serializedName: "properties.partnerDisplayName",
                type: {
                    name: "String"
                }
            }, partnerTopicDetails: {
                serializedName: "properties.partnerTopicDetails",
                type: {
                    name: "Composite",
                    className: "PartnerDetails"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            } })
    }
};
const JsonInputSchemaMapping = {
    serializedName: "Json",
    type: {
        name: "Composite",
        className: "JsonInputSchemaMapping",
        uberParent: "InputSchemaMapping",
        polymorphicDiscriminator: InputSchemaMapping.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, InputSchemaMapping.type.modelProperties), { id: {
                serializedName: "properties.id",
                type: {
                    name: "Composite",
                    className: "JsonField"
                }
            }, topic: {
                serializedName: "properties.topic",
                type: {
                    name: "Composite",
                    className: "JsonField"
                }
            }, eventTime: {
                serializedName: "properties.eventTime",
                type: {
                    name: "Composite",
                    className: "JsonField"
                }
            }, eventType: {
                serializedName: "properties.eventType",
                type: {
                    name: "Composite",
                    className: "JsonFieldWithDefault"
                }
            }, subject: {
                serializedName: "properties.subject",
                type: {
                    name: "Composite",
                    className: "JsonFieldWithDefault"
                }
            }, dataVersion: {
                serializedName: "properties.dataVersion",
                type: {
                    name: "Composite",
                    className: "JsonFieldWithDefault"
                }
            } })
    }
};
const StaticDeliveryAttributeMapping = {
    serializedName: "Static",
    type: {
        name: "Composite",
        className: "StaticDeliveryAttributeMapping",
        uberParent: "DeliveryAttributeMapping",
        polymorphicDiscriminator: DeliveryAttributeMapping.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryAttributeMapping.type.modelProperties), { value: {
                serializedName: "properties.value",
                type: {
                    name: "String"
                }
            }, isSecret: {
                defaultValue: false,
                serializedName: "properties.isSecret",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DynamicDeliveryAttributeMapping = {
    serializedName: "Dynamic",
    type: {
        name: "Composite",
        className: "DynamicDeliveryAttributeMapping",
        uberParent: "DeliveryAttributeMapping",
        polymorphicDiscriminator: DeliveryAttributeMapping.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeliveryAttributeMapping.type.modelProperties), { sourceField: {
                serializedName: "properties.sourceField",
                type: {
                    name: "String"
                }
            } })
    }
};
const WebHookEventSubscriptionDestination = {
    serializedName: "WebHook",
    type: {
        name: "Composite",
        className: "WebHookEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { endpointUrl: {
                serializedName: "properties.endpointUrl",
                type: {
                    name: "String"
                }
            }, endpointBaseUrl: {
                serializedName: "properties.endpointBaseUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, maxEventsPerBatch: {
                defaultValue: 1,
                serializedName: "properties.maxEventsPerBatch",
                type: {
                    name: "Number"
                }
            }, preferredBatchSizeInKilobytes: {
                defaultValue: 64,
                serializedName: "properties.preferredBatchSizeInKilobytes",
                type: {
                    name: "Number"
                }
            }, azureActiveDirectoryTenantId: {
                serializedName: "properties.azureActiveDirectoryTenantId",
                type: {
                    name: "String"
                }
            }, azureActiveDirectoryApplicationIdOrUri: {
                serializedName: "properties.azureActiveDirectoryApplicationIdOrUri",
                type: {
                    name: "String"
                }
            }, deliveryAttributeMappings: {
                serializedName: "properties.deliveryAttributeMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            } })
    }
};
const EventHubEventSubscriptionDestination = {
    serializedName: "EventHub",
    type: {
        name: "Composite",
        className: "EventHubEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, deliveryAttributeMappings: {
                serializedName: "properties.deliveryAttributeMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            } })
    }
};
const StorageQueueEventSubscriptionDestination = {
    serializedName: "StorageQueue",
    type: {
        name: "Composite",
        className: "StorageQueueEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, queueName: {
                serializedName: "properties.queueName",
                type: {
                    name: "String"
                }
            }, queueMessageTimeToLiveInSeconds: {
                serializedName: "properties.queueMessageTimeToLiveInSeconds",
                type: {
                    name: "Number"
                }
            } })
    }
};
const HybridConnectionEventSubscriptionDestination = {
    serializedName: "HybridConnection",
    type: {
        name: "Composite",
        className: "HybridConnectionEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, deliveryAttributeMappings: {
                serializedName: "properties.deliveryAttributeMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            } })
    }
};
const ServiceBusQueueEventSubscriptionDestination = {
    serializedName: "ServiceBusQueue",
    type: {
        name: "Composite",
        className: "ServiceBusQueueEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, deliveryAttributeMappings: {
                serializedName: "properties.deliveryAttributeMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            } })
    }
};
const ServiceBusTopicEventSubscriptionDestination = {
    serializedName: "ServiceBusTopic",
    type: {
        name: "Composite",
        className: "ServiceBusTopicEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, deliveryAttributeMappings: {
                serializedName: "properties.deliveryAttributeMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            } })
    }
};
const AzureFunctionEventSubscriptionDestination = {
    serializedName: "AzureFunction",
    type: {
        name: "Composite",
        className: "AzureFunctionEventSubscriptionDestination",
        uberParent: "EventSubscriptionDestination",
        polymorphicDiscriminator: EventSubscriptionDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EventSubscriptionDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, maxEventsPerBatch: {
                defaultValue: 1,
                serializedName: "properties.maxEventsPerBatch",
                type: {
                    name: "Number"
                }
            }, preferredBatchSizeInKilobytes: {
                defaultValue: 64,
                serializedName: "properties.preferredBatchSizeInKilobytes",
                type: {
                    name: "Number"
                }
            }, deliveryAttributeMappings: {
                serializedName: "properties.deliveryAttributeMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeliveryAttributeMapping"
                        }
                    }
                }
            } })
    }
};
const NumberInAdvancedFilter = {
    serializedName: "NumberIn",
    type: {
        name: "Composite",
        className: "NumberInAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            } })
    }
};
const NumberNotInAdvancedFilter = {
    serializedName: "NumberNotIn",
    type: {
        name: "Composite",
        className: "NumberNotInAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            } })
    }
};
const NumberLessThanAdvancedFilter = {
    serializedName: "NumberLessThan",
    type: {
        name: "Composite",
        className: "NumberLessThanAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NumberGreaterThanAdvancedFilter = {
    serializedName: "NumberGreaterThan",
    type: {
        name: "Composite",
        className: "NumberGreaterThanAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NumberLessThanOrEqualsAdvancedFilter = {
    serializedName: "NumberLessThanOrEquals",
    type: {
        name: "Composite",
        className: "NumberLessThanOrEqualsAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NumberGreaterThanOrEqualsAdvancedFilter = {
    serializedName: "NumberGreaterThanOrEquals",
    type: {
        name: "Composite",
        className: "NumberGreaterThanOrEqualsAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            } })
    }
};
const BoolEqualsAdvancedFilter = {
    serializedName: "BoolEquals",
    type: {
        name: "Composite",
        className: "BoolEqualsAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const StringInAdvancedFilter = {
    serializedName: "StringIn",
    type: {
        name: "Composite",
        className: "StringInAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StringNotInAdvancedFilter = {
    serializedName: "StringNotIn",
    type: {
        name: "Composite",
        className: "StringNotInAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StringBeginsWithAdvancedFilter = {
    serializedName: "StringBeginsWith",
    type: {
        name: "Composite",
        className: "StringBeginsWithAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StringEndsWithAdvancedFilter = {
    serializedName: "StringEndsWith",
    type: {
        name: "Composite",
        className: "StringEndsWithAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StringContainsAdvancedFilter = {
    serializedName: "StringContains",
    type: {
        name: "Composite",
        className: "StringContainsAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const NumberInRangeAdvancedFilter = {
    serializedName: "NumberInRange",
    type: {
        name: "Composite",
        className: "NumberInRangeAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    }
                }
            } })
    }
};
const NumberNotInRangeAdvancedFilter = {
    serializedName: "NumberNotInRange",
    type: {
        name: "Composite",
        className: "NumberNotInRangeAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: {
                                    name: "Number"
                                }
                            }
                        }
                    }
                }
            } })
    }
};
const StringNotBeginsWithAdvancedFilter = {
    serializedName: "StringNotBeginsWith",
    type: {
        name: "Composite",
        className: "StringNotBeginsWithAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StringNotEndsWithAdvancedFilter = {
    serializedName: "StringNotEndsWith",
    type: {
        name: "Composite",
        className: "StringNotEndsWithAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const StringNotContainsAdvancedFilter = {
    serializedName: "StringNotContains",
    type: {
        name: "Composite",
        className: "StringNotContainsAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AdvancedFilter.type.modelProperties), { values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const IsNullOrUndefinedAdvancedFilter = {
    serializedName: "IsNullOrUndefined",
    type: {
        name: "Composite",
        className: "IsNullOrUndefinedAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AdvancedFilter.type.modelProperties)
    }
};
const IsNotNullAdvancedFilter = {
    serializedName: "IsNotNull",
    type: {
        name: "Composite",
        className: "IsNotNullAdvancedFilter",
        uberParent: "AdvancedFilter",
        polymorphicDiscriminator: AdvancedFilter.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AdvancedFilter.type.modelProperties)
    }
};
const StorageBlobDeadLetterDestination = {
    serializedName: "StorageBlob",
    type: {
        name: "Composite",
        className: "StorageBlobDeadLetterDestination",
        uberParent: "DeadLetterDestination",
        polymorphicDiscriminator: DeadLetterDestination.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DeadLetterDestination.type.modelProperties), { resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, blobContainerName: {
                serializedName: "properties.blobContainerName",
                type: {
                    name: "String"
                }
            } })
    }
};
const Domain = {
    type: {
        name: "Composite",
        className: "Domain",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "properties.endpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inputSchema: {
                serializedName: "properties.inputSchema",
                type: {
                    name: "String"
                }
            }, inputSchemaMapping: {
                serializedName: "properties.inputSchemaMapping",
                type: {
                    name: "Composite",
                    className: "InputSchemaMapping"
                }
            }, metricResourceId: {
                serializedName: "properties.metricResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, inboundIpRules: {
                serializedName: "properties.inboundIpRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundIpRule"
                        }
                    }
                }
            }, disableLocalAuth: {
                defaultValue: false,
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }, autoCreateTopicWithFirstSubscription: {
                defaultValue: true,
                serializedName: "properties.autoCreateTopicWithFirstSubscription",
                type: {
                    name: "Boolean"
                }
            }, autoDeleteTopicWithLastSubscription: {
                defaultValue: true,
                serializedName: "properties.autoDeleteTopicWithLastSubscription",
                type: {
                    name: "Boolean"
                }
            }, dataResidencyBoundary: {
                serializedName: "properties.dataResidencyBoundary",
                type: {
                    name: "String"
                }
            } })
    }
};
const Topic = {
    type: {
        name: "Composite",
        className: "Topic",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "properties.endpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inputSchema: {
                serializedName: "properties.inputSchema",
                type: {
                    name: "String"
                }
            }, inputSchemaMapping: {
                serializedName: "properties.inputSchemaMapping",
                type: {
                    name: "Composite",
                    className: "InputSchemaMapping"
                }
            }, metricResourceId: {
                serializedName: "properties.metricResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, inboundIpRules: {
                serializedName: "properties.inboundIpRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundIpRule"
                        }
                    }
                }
            }, disableLocalAuth: {
                defaultValue: false,
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }, dataResidencyBoundary: {
                serializedName: "properties.dataResidencyBoundary",
                type: {
                    name: "String"
                }
            } })
    }
};
const PartnerNamespace = {
    type: {
        name: "Composite",
        className: "PartnerNamespace",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerRegistrationFullyQualifiedId: {
                serializedName: "properties.partnerRegistrationFullyQualifiedId",
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "properties.endpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, inboundIpRules: {
                serializedName: "properties.inboundIpRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundIpRule"
                        }
                    }
                }
            }, disableLocalAuth: {
                defaultValue: false,
                serializedName: "properties.disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }, partnerTopicRoutingMode: {
                defaultValue: "SourceEventAttribute",
                serializedName: "properties.partnerTopicRoutingMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const PartnerRegistration = {
    type: {
        name: "Composite",
        className: "PartnerRegistration",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, partnerRegistrationImmutableId: {
                serializedName: "properties.partnerRegistrationImmutableId",
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const PartnerTopic = {
    type: {
        name: "Composite",
        className: "PartnerTopic",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            }, partnerRegistrationImmutableId: {
                serializedName: "properties.partnerRegistrationImmutableId",
                type: {
                    name: "Uuid"
                }
            }, source: {
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            }, eventTypeInfo: {
                serializedName: "properties.eventTypeInfo",
                type: {
                    name: "Composite",
                    className: "EventTypeInfo"
                }
            }, expirationTimeIfNotActivatedUtc: {
                serializedName: "properties.expirationTimeIfNotActivatedUtc",
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, activationState: {
                serializedName: "properties.activationState",
                type: {
                    name: "String"
                }
            }, partnerTopicFriendlyDescription: {
                serializedName: "properties.partnerTopicFriendlyDescription",
                type: {
                    name: "String"
                }
            }, messageForActivation: {
                serializedName: "properties.messageForActivation",
                type: {
                    name: "String"
                }
            } })
    }
};
const SystemTopic = {
    type: {
        name: "Composite",
        className: "SystemTopic",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityInfo"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, source: {
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            }, topicType: {
                serializedName: "properties.topicType",
                type: {
                    name: "String"
                }
            }, metricResourceId: {
                serializedName: "properties.metricResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
let discriminators = {
    InputSchemaMapping: InputSchemaMapping,
    DeliveryAttributeMapping: DeliveryAttributeMapping,
    EventSubscriptionDestination: EventSubscriptionDestination,
    AdvancedFilter: AdvancedFilter,
    DeadLetterDestination: DeadLetterDestination,
    "InputSchemaMapping.Json": JsonInputSchemaMapping,
    "DeliveryAttributeMapping.Static": StaticDeliveryAttributeMapping,
    "DeliveryAttributeMapping.Dynamic": DynamicDeliveryAttributeMapping,
    "EventSubscriptionDestination.WebHook": WebHookEventSubscriptionDestination,
    "EventSubscriptionDestination.EventHub": EventHubEventSubscriptionDestination,
    "EventSubscriptionDestination.StorageQueue": StorageQueueEventSubscriptionDestination,
    "EventSubscriptionDestination.HybridConnection": HybridConnectionEventSubscriptionDestination,
    "EventSubscriptionDestination.ServiceBusQueue": ServiceBusQueueEventSubscriptionDestination,
    "EventSubscriptionDestination.ServiceBusTopic": ServiceBusTopicEventSubscriptionDestination,
    "EventSubscriptionDestination.AzureFunction": AzureFunctionEventSubscriptionDestination,
    "AdvancedFilter.NumberIn": NumberInAdvancedFilter,
    "AdvancedFilter.NumberNotIn": NumberNotInAdvancedFilter,
    "AdvancedFilter.NumberLessThan": NumberLessThanAdvancedFilter,
    "AdvancedFilter.NumberGreaterThan": NumberGreaterThanAdvancedFilter,
    "AdvancedFilter.NumberLessThanOrEquals": NumberLessThanOrEqualsAdvancedFilter,
    "AdvancedFilter.NumberGreaterThanOrEquals": NumberGreaterThanOrEqualsAdvancedFilter,
    "AdvancedFilter.BoolEquals": BoolEqualsAdvancedFilter,
    "AdvancedFilter.StringIn": StringInAdvancedFilter,
    "AdvancedFilter.StringNotIn": StringNotInAdvancedFilter,
    "AdvancedFilter.StringBeginsWith": StringBeginsWithAdvancedFilter,
    "AdvancedFilter.StringEndsWith": StringEndsWithAdvancedFilter,
    "AdvancedFilter.StringContains": StringContainsAdvancedFilter,
    "AdvancedFilter.NumberInRange": NumberInRangeAdvancedFilter,
    "AdvancedFilter.NumberNotInRange": NumberNotInRangeAdvancedFilter,
    "AdvancedFilter.StringNotBeginsWith": StringNotBeginsWithAdvancedFilter,
    "AdvancedFilter.StringNotEndsWith": StringNotEndsWithAdvancedFilter,
    "AdvancedFilter.StringNotContains": StringNotContainsAdvancedFilter,
    "AdvancedFilter.IsNullOrUndefined": IsNullOrUndefinedAdvancedFilter,
    "AdvancedFilter.IsNotNull": IsNotNullAdvancedFilter,
    "DeadLetterDestination.StorageBlob": StorageBlobDeadLetterDestination
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    PartnerTopicInfo: PartnerTopicInfo,
    EventTypeInfo: EventTypeInfo,
    InlineEventProperties: InlineEventProperties,
    SystemData: SystemData,
    Resource: Resource,
    ChannelUpdateParameters: ChannelUpdateParameters,
    PartnerUpdateTopicInfo: PartnerUpdateTopicInfo,
    ChannelsListResult: ChannelsListResult,
    EventSubscriptionFullUrl: EventSubscriptionFullUrl,
    PrivateEndpoint: PrivateEndpoint,
    ConnectionState: ConnectionState,
    InputSchemaMapping: InputSchemaMapping,
    InboundIpRule: InboundIpRule,
    IdentityInfo: IdentityInfo,
    UserIdentityProperties: UserIdentityProperties,
    DomainUpdateParameters: DomainUpdateParameters,
    DomainsListResult: DomainsListResult,
    DomainSharedAccessKeys: DomainSharedAccessKeys,
    DomainRegenerateKeyRequest: DomainRegenerateKeyRequest,
    DomainTopicsListResult: DomainTopicsListResult,
    DeliveryAttributeListResult: DeliveryAttributeListResult,
    DeliveryAttributeMapping: DeliveryAttributeMapping,
    EventSubscriptionDestination: EventSubscriptionDestination,
    DeliveryWithResourceIdentity: DeliveryWithResourceIdentity,
    EventSubscriptionIdentity: EventSubscriptionIdentity,
    EventSubscriptionFilter: EventSubscriptionFilter,
    AdvancedFilter: AdvancedFilter,
    RetryPolicy: RetryPolicy,
    DeadLetterDestination: DeadLetterDestination,
    DeadLetterWithResourceIdentity: DeadLetterWithResourceIdentity,
    EventSubscriptionUpdateParameters: EventSubscriptionUpdateParameters,
    EventSubscriptionsListResult: EventSubscriptionsListResult,
    OperationsListResult: OperationsListResult,
    Operation: Operation,
    OperationInfo: OperationInfo,
    TopicUpdateParameters: TopicUpdateParameters,
    TopicsListResult: TopicsListResult,
    TopicSharedAccessKeys: TopicSharedAccessKeys,
    TopicRegenerateKeyRequest: TopicRegenerateKeyRequest,
    PartnerAuthorization: PartnerAuthorization,
    Partner: Partner,
    PartnerConfigurationUpdateParameters: PartnerConfigurationUpdateParameters,
    PartnerConfigurationsListResult: PartnerConfigurationsListResult,
    PartnerNamespaceUpdateParameters: PartnerNamespaceUpdateParameters,
    PartnerNamespacesListResult: PartnerNamespacesListResult,
    PartnerNamespaceSharedAccessKeys: PartnerNamespaceSharedAccessKeys,
    PartnerNamespaceRegenerateKeyRequest: PartnerNamespaceRegenerateKeyRequest,
    PartnerRegistrationUpdateParameters: PartnerRegistrationUpdateParameters,
    PartnerRegistrationsListResult: PartnerRegistrationsListResult,
    PartnerTopicUpdateParameters: PartnerTopicUpdateParameters,
    PartnerTopicsListResult: PartnerTopicsListResult,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkResourcesListResult: PrivateLinkResourcesListResult,
    SystemTopicUpdateParameters: SystemTopicUpdateParameters,
    SystemTopicsListResult: SystemTopicsListResult,
    EventTypesListResult: EventTypesListResult,
    TopicTypesListResult: TopicTypesListResult,
    PartnerDetails: PartnerDetails,
    VerifiedPartnersListResult: VerifiedPartnersListResult,
    JsonField: JsonField,
    JsonFieldWithDefault: JsonFieldWithDefault,
    Channel: Channel,
    PrivateEndpointConnection: PrivateEndpointConnection,
    TrackedResource: TrackedResource,
    DomainTopic: DomainTopic,
    EventSubscription: EventSubscription,
    PartnerConfiguration: PartnerConfiguration,
    EventType: EventType,
    ExtensionTopic: ExtensionTopic,
    TopicTypeInfo: TopicTypeInfo,
    VerifiedPartner: VerifiedPartner,
    JsonInputSchemaMapping: JsonInputSchemaMapping,
    StaticDeliveryAttributeMapping: StaticDeliveryAttributeMapping,
    DynamicDeliveryAttributeMapping: DynamicDeliveryAttributeMapping,
    WebHookEventSubscriptionDestination: WebHookEventSubscriptionDestination,
    EventHubEventSubscriptionDestination: EventHubEventSubscriptionDestination,
    StorageQueueEventSubscriptionDestination: StorageQueueEventSubscriptionDestination,
    HybridConnectionEventSubscriptionDestination: HybridConnectionEventSubscriptionDestination,
    ServiceBusQueueEventSubscriptionDestination: ServiceBusQueueEventSubscriptionDestination,
    ServiceBusTopicEventSubscriptionDestination: ServiceBusTopicEventSubscriptionDestination,
    AzureFunctionEventSubscriptionDestination: AzureFunctionEventSubscriptionDestination,
    NumberInAdvancedFilter: NumberInAdvancedFilter,
    NumberNotInAdvancedFilter: NumberNotInAdvancedFilter,
    NumberLessThanAdvancedFilter: NumberLessThanAdvancedFilter,
    NumberGreaterThanAdvancedFilter: NumberGreaterThanAdvancedFilter,
    NumberLessThanOrEqualsAdvancedFilter: NumberLessThanOrEqualsAdvancedFilter,
    NumberGreaterThanOrEqualsAdvancedFilter: NumberGreaterThanOrEqualsAdvancedFilter,
    BoolEqualsAdvancedFilter: BoolEqualsAdvancedFilter,
    StringInAdvancedFilter: StringInAdvancedFilter,
    StringNotInAdvancedFilter: StringNotInAdvancedFilter,
    StringBeginsWithAdvancedFilter: StringBeginsWithAdvancedFilter,
    StringEndsWithAdvancedFilter: StringEndsWithAdvancedFilter,
    StringContainsAdvancedFilter: StringContainsAdvancedFilter,
    NumberInRangeAdvancedFilter: NumberInRangeAdvancedFilter,
    NumberNotInRangeAdvancedFilter: NumberNotInRangeAdvancedFilter,
    StringNotBeginsWithAdvancedFilter: StringNotBeginsWithAdvancedFilter,
    StringNotEndsWithAdvancedFilter: StringNotEndsWithAdvancedFilter,
    StringNotContainsAdvancedFilter: StringNotContainsAdvancedFilter,
    IsNullOrUndefinedAdvancedFilter: IsNullOrUndefinedAdvancedFilter,
    IsNotNullAdvancedFilter: IsNotNullAdvancedFilter,
    StorageBlobDeadLetterDestination: StorageBlobDeadLetterDestination,
    Domain: Domain,
    Topic: Topic,
    PartnerNamespace: PartnerNamespace,
    PartnerRegistration: PartnerRegistration,
    PartnerTopic: PartnerTopic,
    SystemTopic: SystemTopic,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const partnerNamespaceName = {
    parameterPath: "partnerNamespaceName",
    mapper: {
        serializedName: "partnerNamespaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const channelName = {
    parameterPath: "channelName",
    mapper: {
        serializedName: "channelName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-06-15",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const channelInfo = {
    parameterPath: "channelInfo",
    mapper: Channel
};
const channelUpdateParameters = {
    parameterPath: "channelUpdateParameters",
    mapper: ChannelUpdateParameters
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const domainName = {
    parameterPath: "domainName",
    mapper: {
        serializedName: "domainName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const domainInfo = {
    parameterPath: "domainInfo",
    mapper: Domain
};
const domainUpdateParameters = {
    parameterPath: "domainUpdateParameters",
    mapper: DomainUpdateParameters
};
const regenerateKeyRequest = {
    parameterPath: "regenerateKeyRequest",
    mapper: DomainRegenerateKeyRequest
};
const domainTopicName = {
    parameterPath: "domainTopicName",
    mapper: {
        serializedName: "domainTopicName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const topicName = {
    parameterPath: "topicName",
    mapper: {
        serializedName: "topicName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const eventSubscriptionName = {
    parameterPath: "eventSubscriptionName",
    mapper: {
        serializedName: "eventSubscriptionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const eventSubscriptionInfo = {
    parameterPath: "eventSubscriptionInfo",
    mapper: EventSubscription
};
const eventSubscriptionUpdateParameters = {
    parameterPath: "eventSubscriptionUpdateParameters",
    mapper: EventSubscriptionUpdateParameters
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const topicTypeName = {
    parameterPath: "topicTypeName",
    mapper: {
        serializedName: "topicTypeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const providerNamespace = {
    parameterPath: "providerNamespace",
    mapper: {
        serializedName: "providerNamespace",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceTypeName = {
    parameterPath: "resourceTypeName",
    mapper: {
        serializedName: "resourceTypeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const systemTopicName = {
    parameterPath: "systemTopicName",
    mapper: {
        serializedName: "systemTopicName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const partnerTopicName = {
    parameterPath: "partnerTopicName",
    mapper: {
        serializedName: "partnerTopicName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const topicInfo = {
    parameterPath: "topicInfo",
    mapper: Topic
};
const topicUpdateParameters = {
    parameterPath: "topicUpdateParameters",
    mapper: TopicUpdateParameters
};
const regenerateKeyRequest1 = {
    parameterPath: "regenerateKeyRequest",
    mapper: TopicRegenerateKeyRequest
};
const partnerConfigurationInfo = {
    parameterPath: "partnerConfigurationInfo",
    mapper: PartnerConfiguration
};
const partnerConfigurationUpdateParameters = {
    parameterPath: "partnerConfigurationUpdateParameters",
    mapper: PartnerConfigurationUpdateParameters
};
const partnerInfo = {
    parameterPath: "partnerInfo",
    mapper: Partner
};
const partnerNamespaceInfo = {
    parameterPath: "partnerNamespaceInfo",
    mapper: PartnerNamespace
};
const partnerNamespaceUpdateParameters = {
    parameterPath: "partnerNamespaceUpdateParameters",
    mapper: PartnerNamespaceUpdateParameters
};
const regenerateKeyRequest2 = {
    parameterPath: "regenerateKeyRequest",
    mapper: PartnerNamespaceRegenerateKeyRequest
};
const partnerRegistrationName = {
    parameterPath: "partnerRegistrationName",
    mapper: {
        serializedName: "partnerRegistrationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const partnerRegistrationInfo = {
    parameterPath: "partnerRegistrationInfo",
    mapper: PartnerRegistration
};
const partnerRegistrationUpdateParameters = {
    parameterPath: "partnerRegistrationUpdateParameters",
    mapper: PartnerRegistrationUpdateParameters
};
const partnerTopicInfo = {
    parameterPath: "partnerTopicInfo",
    mapper: PartnerTopic
};
const partnerTopicUpdateParameters = {
    parameterPath: "partnerTopicUpdateParameters",
    mapper: PartnerTopicUpdateParameters
};
const parentType = {
    parameterPath: "parentType",
    mapper: {
        serializedName: "parentType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parentName = {
    parameterPath: "parentName",
    mapper: {
        serializedName: "parentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnection = {
    parameterPath: "privateEndpointConnection",
    mapper: PrivateEndpointConnection
};
const parentType1 = {
    parameterPath: "parentType",
    mapper: {
        serializedName: "parentType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateLinkResourceName = {
    parameterPath: "privateLinkResourceName",
    mapper: {
        serializedName: "privateLinkResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const systemTopicInfo = {
    parameterPath: "systemTopicInfo",
    mapper: SystemTopic
};
const systemTopicUpdateParameters = {
    parameterPath: "systemTopicUpdateParameters",
    mapper: SystemTopicUpdateParameters
};
const scope1 = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    }
};
const verifiedPartnerName = {
    parameterPath: "verifiedPartnerName",
    mapper: {
        serializedName: "verifiedPartnerName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Channels operations. */
class ChannelsImpl {
    /**
     * Initialize a new instance of the class Channels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the channels in a partner namespace.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param options The options parameters.
     */
    listByPartnerNamespace(resourceGroupName, partnerNamespaceName, options) {
        const iter = this.listByPartnerNamespacePagingAll(resourceGroupName, partnerNamespaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPartnerNamespacePagingPage(resourceGroupName, partnerNamespaceName, options, settings);
            }
        };
    }
    listByPartnerNamespacePagingPage(resourceGroupName, partnerNamespaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPartnerNamespacePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPartnerNamespace(resourceGroupName, partnerNamespaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPartnerNamespaceNext(resourceGroupName, partnerNamespaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPartnerNamespacePagingAll(resourceGroupName, partnerNamespaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPartnerNamespacePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPartnerNamespacePagingPage(resourceGroupName, partnerNamespaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get properties of a channel.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param channelName Name of the channel.
     * @param options The options parameters.
     */
    get(resourceGroupName, partnerNamespaceName, channelName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerNamespaceName, channelName, options }, getOperationSpec$j);
    }
    /**
     * Synchronously creates or updates a new channel with the specified parameters.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param channelName Name of the channel.
     * @param channelInfo Channel information.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, partnerNamespaceName, channelName, channelInfo, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            partnerNamespaceName,
            channelName,
            channelInfo,
            options
        }, createOrUpdateOperationSpec$e);
    }
    /**
     * Delete an existing channel.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param channelName Name of the channel.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, partnerNamespaceName, channelName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerNamespaceName, channelName, options }, deleteOperationSpec$f);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an existing channel.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param channelName Name of the channel.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, partnerNamespaceName, channelName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, partnerNamespaceName, channelName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Synchronously updates a channel with the specified parameters.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param channelName Name of the channel.
     * @param channelUpdateParameters Channel update information.
     * @param options The options parameters.
     */
    update(resourceGroupName, partnerNamespaceName, channelName, channelUpdateParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            partnerNamespaceName,
            channelName,
            channelUpdateParameters,
            options
        }, updateOperationSpec$e);
    }
    /**
     * List all the channels in a partner namespace.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param options The options parameters.
     */
    _listByPartnerNamespace(resourceGroupName, partnerNamespaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerNamespaceName, options }, listByPartnerNamespaceOperationSpec);
    }
    /**
     * Get the full endpoint URL of a partner destination channel.
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param channelName Name of the Channel.
     * @param options The options parameters.
     */
    getFullUrl(resourceGroupName, partnerNamespaceName, channelName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerNamespaceName, channelName, options }, getFullUrlOperationSpec$6);
    }
    /**
     * ListByPartnerNamespaceNext
     * @param resourceGroupName The name of the resource group within the partners subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param nextLink The nextLink from the previous successful call to the ListByPartnerNamespace method.
     * @param options The options parameters.
     */
    _listByPartnerNamespaceNext(resourceGroupName, partnerNamespaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerNamespaceName, nextLink, options }, listByPartnerNamespaceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/channels/{channelName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Channel
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName,
        channelName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/channels/{channelName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Channel
        },
        201: {
            bodyMapper: Channel
        },
        default: {}
    },
    requestBody: channelInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName,
        channelName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/channels/{channelName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName,
        channelName
    ],
    serializer: serializer$k
};
const updateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/channels/{channelName}",
    httpMethod: "PATCH",
    responses: { 200: {}, default: {} },
    requestBody: channelUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName,
        channelName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$k
};
const listByPartnerNamespaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/channels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChannelsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getFullUrlOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/channels/{channelName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName,
        channelName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByPartnerNamespaceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChannelsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Domains operations. */
class DomainsImpl {
    /**
     * Initialize a new instance of the class Domains class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the domains under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the domains under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get properties of a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    get(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, getOperationSpec$i);
    }
    /**
     * Asynchronously creates or updates a new domain with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainInfo Domain information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, domainName, domainInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, domainInfo, options }, createOrUpdateOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates or updates a new domain with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainInfo Domain information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, domainName, domainInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, domainName, domainInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete existing domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, domainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, options }, deleteOperationSpec$e);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, domainName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, domainName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Asynchronously updates a domain with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainUpdateParameters Domain update information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, domainName, domainUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, domainUpdateParameters, options }, updateOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously updates a domain with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainUpdateParameters Domain update information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, domainName, domainUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, domainName, domainUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the domains under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$6);
    }
    /**
     * List all the domains under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * List the two keys used to publish to a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    listSharedAccessKeys(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, listSharedAccessKeysOperationSpec$2);
    }
    /**
     * Regenerate a shared access key for a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param regenerateKeyRequest Request body to regenerate key.
     * @param options The options parameters.
     */
    regenerateKey(resourceGroupName, domainName, regenerateKeyRequest, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, regenerateKeyRequest, options }, regenerateKeyOperationSpec$2);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$6);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Domain
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Domain
        },
        201: {
            bodyMapper: Domain
        },
        202: {
            bodyMapper: Domain
        },
        204: {
            bodyMapper: Domain
        },
        default: {}
    },
    requestBody: domainInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    serializer: serializer$j
};
const updateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}",
    httpMethod: "PATCH",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: domainUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listBySubscriptionOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/domains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listSharedAccessKeysOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DomainSharedAccessKeys
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const regenerateKeyOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/regenerateKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DomainSharedAccessKeys
        },
        default: {}
    },
    requestBody: regenerateKeyRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listBySubscriptionNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DomainTopics operations. */
class DomainTopicsImpl {
    /**
     * Initialize a new instance of the class DomainTopics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the topics in a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Domain name.
     * @param options The options parameters.
     */
    listByDomain(resourceGroupName, domainName, options) {
        const iter = this.listByDomainPagingAll(resourceGroupName, domainName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDomainPagingPage(resourceGroupName, domainName, options, settings);
            }
        };
    }
    listByDomainPagingPage(resourceGroupName, domainName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDomainPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDomain(resourceGroupName, domainName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDomainNext(resourceGroupName, domainName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDomainPagingAll(resourceGroupName, domainName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDomainPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDomainPagingPage(resourceGroupName, domainName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get properties of a domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainTopicName Name of the topic.
     * @param options The options parameters.
     */
    get(resourceGroupName, domainName, domainTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, domainTopicName, options }, getOperationSpec$h);
    }
    /**
     * Asynchronously creates or updates a new domain topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainTopicName Name of the domain topic.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, domainName, domainTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, domainTopicName, options }, createOrUpdateOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates or updates a new domain topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainTopicName Name of the domain topic.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, domainName, domainTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, domainName, domainTopicName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete existing domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainTopicName Name of the domain topic.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, domainName, domainTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, domainTopicName, options }, deleteOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param domainTopicName Name of the domain topic.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, domainName, domainTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, domainName, domainTopicName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the topics in a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Domain name.
     * @param options The options parameters.
     */
    _listByDomain(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, listByDomainOperationSpec);
    }
    /**
     * ListByDomainNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Domain name.
     * @param nextLink The nextLink from the previous successful call to the ListByDomain method.
     * @param options The options parameters.
     */
    _listByDomainNext(resourceGroupName, domainName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, nextLink, options }, listByDomainNextOperationSpec);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{domainTopicName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        domainTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{domainTopicName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DomainTopic
        },
        201: {
            bodyMapper: DomainTopic
        },
        202: {
            bodyMapper: DomainTopic
        },
        204: {
            bodyMapper: DomainTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        domainTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{domainTopicName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        domainTopicName
    ],
    serializer: serializer$i
};
const listByDomainOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainTopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listByDomainNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DomainTopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TopicEventSubscriptions operations. */
class TopicEventSubscriptionsImpl {
    /**
     * Initialize a new instance of the class TopicEventSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all event subscriptions that have been created for a specific topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param options The options parameters.
     */
    list(resourceGroupName, topicName, options) {
        const iter = this.listPagingAll(resourceGroupName, topicName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, topicName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, topicName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, topicName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, topicName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, topicName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, topicName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all delivery attributes for an event subscription for topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getDeliveryAttributes(resourceGroupName, topicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, eventSubscriptionName, options }, getDeliveryAttributesOperationSpec$5);
    }
    /**
     * Get properties of an event subscription of a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be found. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    get(resourceGroupName, topicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, eventSubscriptionName, options }, getOperationSpec$g);
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, topicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                topicName,
                eventSubscriptionName,
                eventSubscriptionInfo,
                options
            }, createOrUpdateOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, topicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, topicName, eventSubscriptionName, eventSubscriptionInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an existing event subscription for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param eventSubscriptionName Name of the event subscription to be deleted. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, topicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, topicName, eventSubscriptionName, options }, deleteOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an existing event subscription for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param eventSubscriptionName Name of the event subscription to be deleted. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, topicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, topicName, eventSubscriptionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an existing event subscription for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the domain.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, topicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                topicName,
                eventSubscriptionName,
                eventSubscriptionUpdateParameters,
                options
            }, updateOperationSpec$c);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an existing event subscription for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the domain.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, topicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, topicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the full endpoint URL for an event subscription for topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getFullUrl(resourceGroupName, topicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, eventSubscriptionName, options }, getFullUrlOperationSpec$5);
    }
    /**
     * List all event subscriptions that have been created for a specific topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param options The options parameters.
     */
    _list(resourceGroupName, topicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, options }, listOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, topicName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getDeliveryAttributesOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}/getDeliveryAttributes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeliveryAttributeListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName,
        eventSubscriptionName
    ],
    serializer: serializer$h
};
const updateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const getFullUrlOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DomainEventSubscriptions operations. */
class DomainEventSubscriptionsImpl {
    /**
     * Initialize a new instance of the class DomainEventSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all event subscriptions that have been created for a specific topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    list(resourceGroupName, domainName, options) {
        const iter = this.listPagingAll(resourceGroupName, domainName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, domainName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, domainName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, domainName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, domainName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, domainName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, domainName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all delivery attributes for an event subscription for domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getDeliveryAttributes(resourceGroupName, domainName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, eventSubscriptionName, options }, getDeliveryAttributesOperationSpec$4);
    }
    /**
     * Get properties of an event subscription of a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be found. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    get(resourceGroupName, domainName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, eventSubscriptionName, options }, getOperationSpec$f);
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, domainName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                domainName,
                eventSubscriptionName,
                eventSubscriptionInfo,
                options
            }, createOrUpdateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, domainName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, domainName, eventSubscriptionName, eventSubscriptionInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an existing event subscription for a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param eventSubscriptionName Name of the event subscription to be deleted. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, domainName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, domainName, eventSubscriptionName, options }, deleteOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an existing event subscription for a domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param eventSubscriptionName Name of the event subscription to be deleted. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, domainName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, domainName, eventSubscriptionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an existing event subscription for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, domainName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                domainName,
                eventSubscriptionName,
                eventSubscriptionUpdateParameters,
                options
            }, updateOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an existing event subscription for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, domainName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, domainName, eventSubscriptionName, eventSubscriptionUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the full endpoint URL for an event subscription for domain.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getFullUrl(resourceGroupName, domainName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, eventSubscriptionName, options }, getFullUrlOperationSpec$4);
    }
    /**
     * List all event subscriptions that have been created for a specific topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param options The options parameters.
     */
    _list(resourceGroupName, domainName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, domainName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getDeliveryAttributesOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions/{eventSubscriptionName}/getDeliveryAttributes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeliveryAttributeListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        eventSubscriptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        eventSubscriptionName
    ],
    serializer: serializer$g
};
const updateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        eventSubscriptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const getFullUrlOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions/{eventSubscriptionName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        domainName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EventSubscriptions operations. */
class EventSubscriptionsImpl {
    /**
     * Initialize a new instance of the class EventSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all aggregated global event subscriptions under a specific Azure subscription.
     * @param options The options parameters.
     */
    listGlobalBySubscription(options) {
        const iter = this.listGlobalBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGlobalBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listGlobalBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listGlobalBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listGlobalBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listGlobalBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listGlobalBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all global event subscriptions under an Azure subscription for a topic type.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    listGlobalBySubscriptionForTopicType(topicTypeName, options) {
        const iter = this.listGlobalBySubscriptionForTopicTypePagingAll(topicTypeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGlobalBySubscriptionForTopicTypePagingPage(topicTypeName, options, settings);
            }
        };
    }
    listGlobalBySubscriptionForTopicTypePagingPage(topicTypeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalBySubscriptionForTopicTypePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listGlobalBySubscriptionForTopicType(topicTypeName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listGlobalBySubscriptionForTopicTypeNext(topicTypeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listGlobalBySubscriptionForTopicTypePagingAll(topicTypeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalBySubscriptionForTopicTypePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listGlobalBySubscriptionForTopicTypePagingPage(topicTypeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all global event subscriptions under a specific Azure subscription and resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listGlobalByResourceGroup(resourceGroupName, options) {
        const iter = this.listGlobalByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGlobalByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listGlobalByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listGlobalByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listGlobalByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listGlobalByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalByResourceGroupPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listGlobalByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * List all global event subscriptions under a resource group for a specific topic type.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    listGlobalByResourceGroupForTopicType(resourceGroupName, topicTypeName, options) {
        const iter = this.listGlobalByResourceGroupForTopicTypePagingAll(resourceGroupName, topicTypeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGlobalByResourceGroupForTopicTypePagingPage(resourceGroupName, topicTypeName, options, settings);
            }
        };
    }
    listGlobalByResourceGroupForTopicTypePagingPage(resourceGroupName, topicTypeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalByResourceGroupForTopicTypePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listGlobalByResourceGroupForTopicType(resourceGroupName, topicTypeName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listGlobalByResourceGroupForTopicTypeNext(resourceGroupName, topicTypeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listGlobalByResourceGroupForTopicTypePagingAll(resourceGroupName, topicTypeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listGlobalByResourceGroupForTopicTypePagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listGlobalByResourceGroupForTopicTypePagingPage(resourceGroupName, topicTypeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription.
     * @param location Name of the location.
     * @param options The options parameters.
     */
    listRegionalBySubscription(location, options) {
        const iter = this.listRegionalBySubscriptionPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRegionalBySubscriptionPagingPage(location, options, settings);
            }
        };
    }
    listRegionalBySubscriptionPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRegionalBySubscription(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRegionalBySubscriptionNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRegionalBySubscriptionPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalBySubscriptionPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRegionalBySubscriptionPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription and
     * resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param location Name of the location.
     * @param options The options parameters.
     */
    listRegionalByResourceGroup(resourceGroupName, location, options) {
        const iter = this.listRegionalByResourceGroupPagingAll(resourceGroupName, location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRegionalByResourceGroupPagingPage(resourceGroupName, location, options, settings);
            }
        };
    }
    listRegionalByResourceGroupPagingPage(resourceGroupName, location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRegionalByResourceGroup(resourceGroupName, location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRegionalByResourceGroupNext(resourceGroupName, location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRegionalByResourceGroupPagingAll(resourceGroupName, location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalByResourceGroupPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRegionalByResourceGroupPagingPage(resourceGroupName, location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription and topic
     * type.
     * @param location Name of the location.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    listRegionalBySubscriptionForTopicType(location, topicTypeName, options) {
        const iter = this.listRegionalBySubscriptionForTopicTypePagingAll(location, topicTypeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRegionalBySubscriptionForTopicTypePagingPage(location, topicTypeName, options, settings);
            }
        };
    }
    listRegionalBySubscriptionForTopicTypePagingPage(location, topicTypeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalBySubscriptionForTopicTypePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRegionalBySubscriptionForTopicType(location, topicTypeName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRegionalBySubscriptionForTopicTypeNext(location, topicTypeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRegionalBySubscriptionForTopicTypePagingAll(location, topicTypeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalBySubscriptionForTopicTypePagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRegionalBySubscriptionForTopicTypePagingPage(location, topicTypeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription and
     * resource group and topic type.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param location Name of the location.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    listRegionalByResourceGroupForTopicType(resourceGroupName, location, topicTypeName, options) {
        const iter = this.listRegionalByResourceGroupForTopicTypePagingAll(resourceGroupName, location, topicTypeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRegionalByResourceGroupForTopicTypePagingPage(resourceGroupName, location, topicTypeName, options, settings);
            }
        };
    }
    listRegionalByResourceGroupForTopicTypePagingPage(resourceGroupName, location, topicTypeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalByResourceGroupForTopicTypePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRegionalByResourceGroupForTopicType(resourceGroupName, location, topicTypeName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRegionalByResourceGroupForTopicTypeNext(resourceGroupName, location, topicTypeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRegionalByResourceGroupForTopicTypePagingAll(resourceGroupName, location, topicTypeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRegionalByResourceGroupForTopicTypePagingAll_1() {
            var e_8, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRegionalByResourceGroupForTopicTypePagingPage(resourceGroupName, location, topicTypeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * List all event subscriptions that have been created for a specific resource.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param providerNamespace Namespace of the provider of the topic.
     * @param resourceTypeName Name of the resource type.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourcePagingPage(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options, settings);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResource(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, providerNamespace, resourceTypeName, resourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var e_9, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * List all event subscriptions that have been created for a specific domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param options The options parameters.
     */
    listByDomainTopic(resourceGroupName, domainName, topicName, options) {
        const iter = this.listByDomainTopicPagingAll(resourceGroupName, domainName, topicName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDomainTopicPagingPage(resourceGroupName, domainName, topicName, options, settings);
            }
        };
    }
    listByDomainTopicPagingPage(resourceGroupName, domainName, topicName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDomainTopicPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDomainTopic(resourceGroupName, domainName, topicName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDomainTopicNext(resourceGroupName, domainName, topicName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDomainTopicPagingAll(resourceGroupName, domainName, topicName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDomainTopicPagingAll_1() {
            var e_10, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDomainTopicPagingPage(resourceGroupName, domainName, topicName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Get properties of an event subscription.
     * @param scope The scope of the event subscription. The scope can be a subscription, or a resource
     *              group, or a top level resource belonging to a resource provider namespace, or an EventGrid topic.
     *              For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    get(scope, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ scope, eventSubscriptionName, options }, getOperationSpec$e);
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription based on
     * the specified scope.
     * @param scope The identifier of the resource to which the event subscription needs to be created or
     *              updated. The scope can be a subscription, or a resource group, or a top level resource belonging to
     *              a resource provider namespace, or an EventGrid topic. For example, use
     *              '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription. Event subscription names must be
     *                              between 3 and 64 characters in length and should use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(scope, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { scope, eventSubscriptionName, eventSubscriptionInfo, options }, createOrUpdateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription based on
     * the specified scope.
     * @param scope The identifier of the resource to which the event subscription needs to be created or
     *              updated. The scope can be a subscription, or a resource group, or a top level resource belonging to
     *              a resource provider namespace, or an EventGrid topic. For example, use
     *              '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription. Event subscription names must be
     *                              between 3 and 64 characters in length and should use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(scope, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(scope, eventSubscriptionName, eventSubscriptionInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an existing event subscription.
     * @param scope The scope of the event subscription. The scope can be a subscription, or a resource
     *              group, or a top level resource belonging to a resource provider namespace, or an EventGrid topic.
     *              For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    beginDelete(scope, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { scope, eventSubscriptionName, options }, deleteOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an existing event subscription.
     * @param scope The scope of the event subscription. The scope can be a subscription, or a resource
     *              group, or a top level resource belonging to a resource provider namespace, or an EventGrid topic.
     *              For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    beginDeleteAndWait(scope, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(scope, eventSubscriptionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Asynchronously updates an existing event subscription.
     * @param scope The scope of existing event subscription. The scope can be a subscription, or a
     *              resource group, or a top level resource belonging to a resource provider namespace, or an EventGrid
     *              topic. For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdate(scope, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                scope,
                eventSubscriptionName,
                eventSubscriptionUpdateParameters,
                options
            }, updateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously updates an existing event subscription.
     * @param scope The scope of existing event subscription. The scope can be a subscription, or a
     *              resource group, or a top level resource belonging to a resource provider namespace, or an EventGrid
     *              topic. For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(scope, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(scope, eventSubscriptionName, eventSubscriptionUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the full endpoint URL for an event subscription.
     * @param scope The scope of the event subscription. The scope can be a subscription, or a resource
     *              group, or a top level resource belonging to a resource provider namespace, or an EventGrid topic.
     *              For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getFullUrl(scope, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ scope, eventSubscriptionName, options }, getFullUrlOperationSpec$3);
    }
    /**
     * List all aggregated global event subscriptions under a specific Azure subscription.
     * @param options The options parameters.
     */
    _listGlobalBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listGlobalBySubscriptionOperationSpec);
    }
    /**
     * List all global event subscriptions under an Azure subscription for a topic type.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    _listGlobalBySubscriptionForTopicType(topicTypeName, options) {
        return this.client.sendOperationRequest({ topicTypeName, options }, listGlobalBySubscriptionForTopicTypeOperationSpec);
    }
    /**
     * List all global event subscriptions under a specific Azure subscription and resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listGlobalByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listGlobalByResourceGroupOperationSpec);
    }
    /**
     * List all global event subscriptions under a resource group for a specific topic type.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    _listGlobalByResourceGroupForTopicType(resourceGroupName, topicTypeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicTypeName, options }, listGlobalByResourceGroupForTopicTypeOperationSpec);
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription.
     * @param location Name of the location.
     * @param options The options parameters.
     */
    _listRegionalBySubscription(location, options) {
        return this.client.sendOperationRequest({ location, options }, listRegionalBySubscriptionOperationSpec);
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription and
     * resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param location Name of the location.
     * @param options The options parameters.
     */
    _listRegionalByResourceGroup(resourceGroupName, location, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, options }, listRegionalByResourceGroupOperationSpec);
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription and topic
     * type.
     * @param location Name of the location.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    _listRegionalBySubscriptionForTopicType(location, topicTypeName, options) {
        return this.client.sendOperationRequest({ location, topicTypeName, options }, listRegionalBySubscriptionForTopicTypeOperationSpec);
    }
    /**
     * List all event subscriptions from the given location under a specific Azure subscription and
     * resource group and topic type.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param location Name of the location.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    _listRegionalByResourceGroupForTopicType(resourceGroupName, location, topicTypeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, topicTypeName, options }, listRegionalByResourceGroupForTopicTypeOperationSpec);
    }
    /**
     * List all event subscriptions that have been created for a specific resource.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param providerNamespace Namespace of the provider of the topic.
     * @param resourceTypeName Name of the resource type.
     * @param resourceName Name of the resource.
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            providerNamespace,
            resourceTypeName,
            resourceName,
            options
        }, listByResourceOperationSpec$2);
    }
    /**
     * List all event subscriptions that have been created for a specific domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param options The options parameters.
     */
    _listByDomainTopic(resourceGroupName, domainName, topicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, topicName, options }, listByDomainTopicOperationSpec);
    }
    /**
     * Get all delivery attributes for an event subscription.
     * @param scope The scope of the event subscription. The scope can be a subscription, or a resource
     *              group, or a top level resource belonging to a resource provider namespace, or an EventGrid topic.
     *              For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for a resource, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}'
     *              for an EventGrid topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getDeliveryAttributes(scope, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ scope, eventSubscriptionName, options }, getDeliveryAttributesOperationSpec$3);
    }
    /**
     * ListGlobalBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListGlobalBySubscription
     *                 method.
     * @param options The options parameters.
     */
    _listGlobalBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listGlobalBySubscriptionNextOperationSpec);
    }
    /**
     * ListGlobalBySubscriptionForTopicTypeNext
     * @param topicTypeName Name of the topic type.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListGlobalBySubscriptionForTopicType method.
     * @param options The options parameters.
     */
    _listGlobalBySubscriptionForTopicTypeNext(topicTypeName, nextLink, options) {
        return this.client.sendOperationRequest({ topicTypeName, nextLink, options }, listGlobalBySubscriptionForTopicTypeNextOperationSpec);
    }
    /**
     * ListGlobalByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListGlobalByResourceGroup
     *                 method.
     * @param options The options parameters.
     */
    _listGlobalByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listGlobalByResourceGroupNextOperationSpec);
    }
    /**
     * ListGlobalByResourceGroupForTopicTypeNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicTypeName Name of the topic type.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListGlobalByResourceGroupForTopicType method.
     * @param options The options parameters.
     */
    _listGlobalByResourceGroupForTopicTypeNext(resourceGroupName, topicTypeName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicTypeName, nextLink, options }, listGlobalByResourceGroupForTopicTypeNextOperationSpec);
    }
    /**
     * ListRegionalBySubscriptionNext
     * @param location Name of the location.
     * @param nextLink The nextLink from the previous successful call to the ListRegionalBySubscription
     *                 method.
     * @param options The options parameters.
     */
    _listRegionalBySubscriptionNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listRegionalBySubscriptionNextOperationSpec);
    }
    /**
     * ListRegionalByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param location Name of the location.
     * @param nextLink The nextLink from the previous successful call to the ListRegionalByResourceGroup
     *                 method.
     * @param options The options parameters.
     */
    _listRegionalByResourceGroupNext(resourceGroupName, location, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, nextLink, options }, listRegionalByResourceGroupNextOperationSpec);
    }
    /**
     * ListRegionalBySubscriptionForTopicTypeNext
     * @param location Name of the location.
     * @param topicTypeName Name of the topic type.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListRegionalBySubscriptionForTopicType method.
     * @param options The options parameters.
     */
    _listRegionalBySubscriptionForTopicTypeNext(location, topicTypeName, nextLink, options) {
        return this.client.sendOperationRequest({ location, topicTypeName, nextLink, options }, listRegionalBySubscriptionForTopicTypeNextOperationSpec);
    }
    /**
     * ListRegionalByResourceGroupForTopicTypeNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param location Name of the location.
     * @param topicTypeName Name of the topic type.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListRegionalByResourceGroupForTopicType method.
     * @param options The options parameters.
     */
    _listRegionalByResourceGroupForTopicTypeNext(resourceGroupName, location, topicTypeName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, topicTypeName, nextLink, options }, listRegionalByResourceGroupForTopicTypeNextOperationSpec);
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param providerNamespace Namespace of the provider of the topic.
     * @param resourceTypeName Name of the resource type.
     * @param resourceName Name of the resource.
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, providerNamespace, resourceTypeName, resourceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            providerNamespace,
            resourceTypeName,
            resourceName,
            nextLink,
            options
        }, listByResourceNextOperationSpec$2);
    }
    /**
     * ListByDomainTopicNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param nextLink The nextLink from the previous successful call to the ListByDomainTopic method.
     * @param options The options parameters.
     */
    _listByDomainTopicNext(resourceGroupName, domainName, topicName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, topicName, nextLink, options }, listByDomainTopicNextOperationSpec);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$e = {
    path: "/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        eventSubscriptionName,
        scope
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$9 = {
    path: "/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        eventSubscriptionName,
        scope
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$a = {
    path: "/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        eventSubscriptionName,
        scope
    ],
    serializer: serializer$f
};
const updateOperationSpec$a = {
    path: "/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        eventSubscriptionName,
        scope
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const getFullUrlOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        eventSubscriptionName,
        scope
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalBySubscriptionForTopicTypeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/topicTypes/{topicTypeName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        topicTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalByResourceGroupForTopicTypeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topicTypes/{topicTypeName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/locations/{location}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/locations/{location}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalBySubscriptionForTopicTypeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/locations/{location}/topicTypes/{topicTypeName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        topicTypeName,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalByResourceGroupForTopicTypeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/locations/{location}/topicTypes/{topicTypeName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicTypeName,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{providerNamespace}/{resourceTypeName}/{resourceName}/providers/Microsoft.EventGrid/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        providerNamespace,
        resourceTypeName,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByDomainTopicOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/providers/Microsoft.EventGrid/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getDeliveryAttributesOperationSpec$3 = {
    path: "/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}/getDeliveryAttributes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeliveryAttributeListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        eventSubscriptionName,
        scope
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalBySubscriptionForTopicTypeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        topicTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listGlobalByResourceGroupForTopicTypeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        topicTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalBySubscriptionForTopicTypeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        topicTypeName,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRegionalByResourceGroupForTopicTypeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        topicTypeName,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        providerNamespace,
        resourceTypeName,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByDomainTopicNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        domainName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DomainTopicEventSubscriptions operations. */
class DomainTopicEventSubscriptionsImpl {
    /**
     * Initialize a new instance of the class DomainTopicEventSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all event subscriptions that have been created for a specific domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param options The options parameters.
     */
    list(resourceGroupName, domainName, topicName, options) {
        const iter = this.listPagingAll(resourceGroupName, domainName, topicName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, domainName, topicName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, domainName, topicName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, domainName, topicName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, domainName, topicName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, domainName, topicName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, domainName, topicName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get properties of a nested event subscription for a domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    get(resourceGroupName, domainName, topicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            topicName,
            eventSubscriptionName,
            options
        }, getOperationSpec$d);
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, domainName, topicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                domainName,
                topicName,
                eventSubscriptionName,
                eventSubscriptionInfo,
                options
            }, createOrUpdateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new event subscription or updates an existing event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, domainName, topicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, domainName, topicName, eventSubscriptionName, eventSubscriptionInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a nested existing event subscription for a domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be deleted. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, domainName, topicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                domainName,
                topicName,
                eventSubscriptionName,
                options
            }, deleteOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a nested existing event subscription for a domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription to be deleted. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, domainName, topicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, domainName, topicName, eventSubscriptionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an existing event subscription for a domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param topicName Name of the topic.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, domainName, topicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                domainName,
                topicName,
                eventSubscriptionName,
                eventSubscriptionUpdateParameters,
                options
            }, updateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an existing event subscription for a domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the domain.
     * @param topicName Name of the topic.
     * @param eventSubscriptionName Name of the event subscription to be updated.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, domainName, topicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, domainName, topicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the full endpoint URL for a nested event subscription for domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getFullUrl(resourceGroupName, domainName, topicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            topicName,
            eventSubscriptionName,
            options
        }, getFullUrlOperationSpec$2);
    }
    /**
     * List all event subscriptions that have been created for a specific domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param options The options parameters.
     */
    _list(resourceGroupName, domainName, topicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, topicName, options }, listOperationSpec$3);
    }
    /**
     * Get all delivery attributes for an event subscription for domain topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param eventSubscriptionName Name of the event subscription.
     * @param options The options parameters.
     */
    getDeliveryAttributes(resourceGroupName, domainName, topicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            domainName,
            topicName,
            eventSubscriptionName,
            options
        }, getDeliveryAttributesOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param domainName Name of the top level domain.
     * @param topicName Name of the domain topic.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, domainName, topicName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, domainName, topicName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName,
        eventSubscriptionName
    ],
    serializer: serializer$e
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const getFullUrlOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getDeliveryAttributesOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/domains/{domainName}/topics/{topicName}/eventSubscriptions/{eventSubscriptionName}/getDeliveryAttributes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeliveryAttributeListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        domainName,
        topicName,
        eventSubscriptionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        domainName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SystemTopicEventSubscriptions operations. */
class SystemTopicEventSubscriptionsImpl {
    /**
     * Initialize a new instance of the class SystemTopicEventSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List event subscriptions that belong to a specific system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param options The options parameters.
     */
    listBySystemTopic(resourceGroupName, systemTopicName, options) {
        const iter = this.listBySystemTopicPagingAll(resourceGroupName, systemTopicName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySystemTopicPagingPage(resourceGroupName, systemTopicName, options, settings);
            }
        };
    }
    listBySystemTopicPagingPage(resourceGroupName, systemTopicName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySystemTopicPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySystemTopic(resourceGroupName, systemTopicName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySystemTopicNext(resourceGroupName, systemTopicName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySystemTopicPagingAll(resourceGroupName, systemTopicName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySystemTopicPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySystemTopicPagingPage(resourceGroupName, systemTopicName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get an event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    get(resourceGroupName, systemTopicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, systemTopicName, eventSubscriptionName, options }, getOperationSpec$c);
    }
    /**
     * Asynchronously creates or updates an event subscription with the specified parameters. Existing
     * event subscriptions will be updated with this API.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, systemTopicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                systemTopicName,
                eventSubscriptionName,
                eventSubscriptionInfo,
                options
            }, createOrUpdateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates or updates an event subscription with the specified parameters. Existing
     * event subscriptions will be updated with this API.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, systemTopicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, systemTopicName, eventSubscriptionName, eventSubscriptionInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an existing event subscription of a system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, systemTopicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, systemTopicName, eventSubscriptionName, options }, deleteOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an existing event subscription of a system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, systemTopicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, systemTopicName, eventSubscriptionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an existing event subscription of a system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, systemTopicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                systemTopicName,
                eventSubscriptionName,
                eventSubscriptionUpdateParameters,
                options
            }, updateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an existing event subscription of a system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, systemTopicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, systemTopicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the full endpoint URL for an event subscription of a system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    getFullUrl(resourceGroupName, systemTopicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, systemTopicName, eventSubscriptionName, options }, getFullUrlOperationSpec$1);
    }
    /**
     * List event subscriptions that belong to a specific system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param options The options parameters.
     */
    _listBySystemTopic(resourceGroupName, systemTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, systemTopicName, options }, listBySystemTopicOperationSpec);
    }
    /**
     * Get all delivery attributes for an event subscription.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    getDeliveryAttributes(resourceGroupName, systemTopicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, systemTopicName, eventSubscriptionName, options }, getDeliveryAttributesOperationSpec$1);
    }
    /**
     * ListBySystemTopicNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param nextLink The nextLink from the previous successful call to the ListBySystemTopic method.
     * @param options The options parameters.
     */
    _listBySystemTopicNext(resourceGroupName, systemTopicName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, systemTopicName, nextLink, options }, listBySystemTopicNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        systemTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        systemTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        systemTopicName
    ],
    serializer: serializer$d
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        systemTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const getFullUrlOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions/{eventSubscriptionName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        systemTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listBySystemTopicOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        systemTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getDeliveryAttributesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}/eventSubscriptions/{eventSubscriptionName}/getDeliveryAttributes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeliveryAttributeListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        systemTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listBySystemTopicNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        systemTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartnerTopicEventSubscriptions operations. */
class PartnerTopicEventSubscriptionsImpl {
    /**
     * Initialize a new instance of the class PartnerTopicEventSubscriptions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List event subscriptions that belong to a specific partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    listByPartnerTopic(resourceGroupName, partnerTopicName, options) {
        const iter = this.listByPartnerTopicPagingAll(resourceGroupName, partnerTopicName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPartnerTopicPagingPage(resourceGroupName, partnerTopicName, options, settings);
            }
        };
    }
    listByPartnerTopicPagingPage(resourceGroupName, partnerTopicName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPartnerTopicPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPartnerTopic(resourceGroupName, partnerTopicName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPartnerTopicNext(resourceGroupName, partnerTopicName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPartnerTopicPagingAll(resourceGroupName, partnerTopicName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPartnerTopicPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPartnerTopicPagingPage(resourceGroupName, partnerTopicName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get properties of an event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be found. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    get(resourceGroupName, partnerTopicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, eventSubscriptionName, options }, getOperationSpec$b);
    }
    /**
     * Asynchronously creates or updates an event subscription of a partner topic with the specified
     * parameters. Existing event subscriptions will be updated with this API.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, partnerTopicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                partnerTopicName,
                eventSubscriptionName,
                eventSubscriptionInfo,
                options
            }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates or updates an event subscription of a partner topic with the specified
     * parameters. Existing event subscriptions will be updated with this API.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionInfo Event subscription properties containing the destination and filter
     *                              information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, partnerTopicName, eventSubscriptionName, eventSubscriptionInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, partnerTopicName, eventSubscriptionName, eventSubscriptionInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an existing event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, partnerTopicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerTopicName, eventSubscriptionName, options }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an existing event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, partnerTopicName, eventSubscriptionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, partnerTopicName, eventSubscriptionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an existing event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, partnerTopicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                partnerTopicName,
                eventSubscriptionName,
                eventSubscriptionUpdateParameters,
                options
            }, updateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an existing event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param eventSubscriptionUpdateParameters Updated event subscription information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, partnerTopicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, partnerTopicName, eventSubscriptionName, eventSubscriptionUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the full endpoint URL for an event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    getFullUrl(resourceGroupName, partnerTopicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, eventSubscriptionName, options }, getFullUrlOperationSpec);
    }
    /**
     * List event subscriptions that belong to a specific partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    _listByPartnerTopic(resourceGroupName, partnerTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, options }, listByPartnerTopicOperationSpec);
    }
    /**
     * Get all delivery attributes for an event subscription of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param eventSubscriptionName Name of the event subscription to be created. Event subscription names
     *                              must be between 3 and 100 characters in length and use alphanumeric letters only.
     * @param options The options parameters.
     */
    getDeliveryAttributes(resourceGroupName, partnerTopicName, eventSubscriptionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, eventSubscriptionName, options }, getDeliveryAttributesOperationSpec);
    }
    /**
     * ListByPartnerTopicNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param nextLink The nextLink from the previous successful call to the ListByPartnerTopic method.
     * @param options The options parameters.
     */
    _listByPartnerTopicNext(resourceGroupName, partnerTopicName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, nextLink, options }, listByPartnerTopicNextOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        partnerTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        partnerTopicName
    ],
    serializer: serializer$c
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions/{eventSubscriptionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: EventSubscription
        },
        201: {
            bodyMapper: EventSubscription
        },
        202: {
            bodyMapper: EventSubscription
        },
        204: {
            bodyMapper: EventSubscription
        },
        default: {}
    },
    requestBody: eventSubscriptionUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        partnerTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const getFullUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions/{eventSubscriptionName}/getFullUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EventSubscriptionFullUrl
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByPartnerTopicOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getDeliveryAttributesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/eventSubscriptions/{eventSubscriptionName}/getDeliveryAttributes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeliveryAttributeListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        eventSubscriptionName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByPartnerTopicNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventSubscriptionsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List the available operations supported by the Microsoft.EventGrid resource provider.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List the available operations supported by the Microsoft.EventGrid resource provider.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/providers/Microsoft.EventGrid/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Topics operations. */
class TopicsImpl {
    /**
     * Initialize a new instance of the class Topics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the topics under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the topics under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List event types for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param providerNamespace Namespace of the provider of the topic.
     * @param resourceTypeName Name of the topic type.
     * @param resourceName Name of the topic.
     * @param options The options parameters.
     */
    listEventTypes(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options) {
        const iter = this.listEventTypesPagingAll(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listEventTypesPagingPage(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options, settings);
            }
        };
    }
    listEventTypesPagingPage(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listEventTypesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listEventTypes(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listEventTypesPagingAll(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listEventTypesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listEventTypesPagingPage(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get properties of a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param options The options parameters.
     */
    get(resourceGroupName, topicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, options }, getOperationSpec$a);
    }
    /**
     * Asynchronously creates a new topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param topicInfo Topic information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, topicName, topicInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, topicName, topicInfo, options }, createOrUpdateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param topicInfo Topic information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, topicName, topicInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, topicName, topicInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete existing topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, topicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, topicName, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, topicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, topicName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Asynchronously updates a topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param topicUpdateParameters Topic update information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, topicName, topicUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, topicName, topicUpdateParameters, options }, updateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously updates a topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param topicUpdateParameters Topic update information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, topicName, topicUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, topicName, topicUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the topics under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$5);
    }
    /**
     * List all the topics under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * List the two keys used to publish to a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param options The options parameters.
     */
    listSharedAccessKeys(resourceGroupName, topicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, topicName, options }, listSharedAccessKeysOperationSpec$1);
    }
    /**
     * Regenerate a shared access key for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param regenerateKeyRequest Request body to regenerate key.
     * @param options The options parameters.
     */
    beginRegenerateKey(resourceGroupName, topicName, regenerateKeyRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, topicName, regenerateKeyRequest, options }, regenerateKeyOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Regenerate a shared access key for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param topicName Name of the topic.
     * @param regenerateKeyRequest Request body to regenerate key.
     * @param options The options parameters.
     */
    beginRegenerateKeyAndWait(resourceGroupName, topicName, regenerateKeyRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegenerateKey(resourceGroupName, topicName, regenerateKeyRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List event types for a topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param providerNamespace Namespace of the provider of the topic.
     * @param resourceTypeName Name of the topic type.
     * @param resourceName Name of the topic.
     * @param options The options parameters.
     */
    _listEventTypes(resourceGroupName, providerNamespace, resourceTypeName, resourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            providerNamespace,
            resourceTypeName,
            resourceName,
            options
        }, listEventTypesOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Topic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Topic
        },
        201: {
            bodyMapper: Topic
        },
        202: {
            bodyMapper: Topic
        },
        204: {
            bodyMapper: Topic
        },
        default: {}
    },
    requestBody: topicInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    serializer: serializer$a
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}",
    httpMethod: "PATCH",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: topicUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listBySubscriptionOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/topics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listSharedAccessKeysOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TopicSharedAccessKeys
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const regenerateKeyOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/topics/{topicName}/regenerateKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TopicSharedAccessKeys
        },
        201: {
            bodyMapper: TopicSharedAccessKeys
        },
        202: {
            bodyMapper: TopicSharedAccessKeys
        },
        204: {
            bodyMapper: TopicSharedAccessKeys
        },
        default: {}
    },
    requestBody: regenerateKeyRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        topicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listEventTypesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{providerNamespace}/{resourceTypeName}/{resourceName}/providers/Microsoft.EventGrid/eventTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventTypesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        providerNamespace,
        resourceTypeName,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listBySubscriptionNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartnerConfigurations operations. */
class PartnerConfigurationsImpl {
    /**
     * Initialize a new instance of the class PartnerConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the partner configurations under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the partner configurations under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get properties of a partner configuration.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    get(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, getOperationSpec$9);
    }
    /**
     * Synchronously creates or updates a partner configuration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerConfigurationInfo Partner configuration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, partnerConfigurationInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerConfigurationInfo, options }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Synchronously creates or updates a partner configuration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerConfigurationInfo Partner configuration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, partnerConfigurationInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, partnerConfigurationInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete existing partner configuration.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing partner configuration.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Synchronously updates a partner configuration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerConfigurationUpdateParameters Partner configuration update information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, partnerConfigurationUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerConfigurationUpdateParameters, options }, updateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Synchronously updates a partner configuration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerConfigurationUpdateParameters Partner configuration update information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, partnerConfigurationUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, partnerConfigurationUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the partner configurations under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * List all the partner configurations under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$4);
    }
    /**
     * Authorize a single partner either by partner registration immutable Id or by partner name.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerInfo The information of the partner to be authorized.
     * @param options The options parameters.
     */
    authorizePartner(resourceGroupName, partnerInfo, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerInfo, options }, authorizePartnerOperationSpec);
    }
    /**
     * Unauthorize a single partner either by partner registration immutable Id or by partner name.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerInfo The information of the partner to be unauthorized.
     * @param options The options parameters.
     */
    unauthorizePartner(resourceGroupName, partnerInfo, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerInfo, options }, unauthorizePartnerOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerConfiguration
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PartnerConfiguration
        },
        201: {
            bodyMapper: PartnerConfiguration
        },
        202: {
            bodyMapper: PartnerConfiguration
        },
        204: {
            bodyMapper: PartnerConfiguration
        },
        default: {}
    },
    requestBody: partnerConfigurationInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations/default",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    serializer: serializer$9
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations/default",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PartnerConfiguration
        },
        201: {
            bodyMapper: PartnerConfiguration
        },
        202: {
            bodyMapper: PartnerConfiguration
        },
        204: {
            bodyMapper: PartnerConfiguration
        },
        default: {}
    },
    requestBody: partnerConfigurationUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerConfigurationsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listBySubscriptionOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/partnerConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerConfigurationsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const authorizePartnerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations/default/authorizePartner",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PartnerConfiguration
        },
        default: {}
    },
    requestBody: partnerInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const unauthorizePartnerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerConfigurations/default/unauthorizePartner",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PartnerConfiguration
        },
        default: {}
    },
    requestBody: partnerInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listBySubscriptionNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerConfigurationsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartnerNamespaces operations. */
class PartnerNamespacesImpl {
    /**
     * Initialize a new instance of the class PartnerNamespaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the partner namespaces under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the partner namespaces under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get properties of a partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param options The options parameters.
     */
    get(resourceGroupName, partnerNamespaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerNamespaceName, options }, getOperationSpec$8);
    }
    /**
     * Asynchronously creates a new partner namespace with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param partnerNamespaceInfo PartnerNamespace information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, partnerNamespaceName, partnerNamespaceInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                partnerNamespaceName,
                partnerNamespaceInfo,
                options
            }, createOrUpdateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new partner namespace with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param partnerNamespaceInfo PartnerNamespace information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, partnerNamespaceName, partnerNamespaceInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, partnerNamespaceName, partnerNamespaceInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete existing partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, partnerNamespaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerNamespaceName, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, partnerNamespaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, partnerNamespaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Asynchronously updates a partner namespace with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param partnerNamespaceUpdateParameters Partner namespace update information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, partnerNamespaceName, partnerNamespaceUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                partnerNamespaceName,
                partnerNamespaceUpdateParameters,
                options
            }, updateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously updates a partner namespace with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param partnerNamespaceUpdateParameters Partner namespace update information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, partnerNamespaceName, partnerNamespaceUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, partnerNamespaceName, partnerNamespaceUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the partner namespaces under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * List all the partner namespaces under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * List the two keys used to publish to a partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param options The options parameters.
     */
    listSharedAccessKeys(resourceGroupName, partnerNamespaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerNamespaceName, options }, listSharedAccessKeysOperationSpec);
    }
    /**
     * Regenerate a shared access key for a partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerNamespaceName Name of the partner namespace.
     * @param regenerateKeyRequest Request body to regenerate key.
     * @param options The options parameters.
     */
    regenerateKey(resourceGroupName, partnerNamespaceName, regenerateKeyRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            partnerNamespaceName,
            regenerateKeyRequest,
            options
        }, regenerateKeyOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerNamespace
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PartnerNamespace
        },
        201: {
            bodyMapper: PartnerNamespace
        },
        202: {
            bodyMapper: PartnerNamespace
        },
        204: {
            bodyMapper: PartnerNamespace
        },
        default: {}
    },
    requestBody: partnerNamespaceInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    serializer: serializer$8
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}",
    httpMethod: "PATCH",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: partnerNamespaceUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/partnerNamespaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerNamespacesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerNamespacesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listSharedAccessKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PartnerNamespaceSharedAccessKeys
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const regenerateKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerNamespaces/{partnerNamespaceName}/regenerateKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PartnerNamespaceSharedAccessKeys
        },
        default: {}
    },
    requestBody: regenerateKeyRequest2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerNamespaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerNamespacesListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerNamespacesListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartnerRegistrations operations. */
class PartnerRegistrationsImpl {
    /**
     * Initialize a new instance of the class PartnerRegistrations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the partner registrations under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the partner registrations under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param options The options parameters.
     */
    get(resourceGroupName, partnerRegistrationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerRegistrationName, options }, getOperationSpec$7);
    }
    /**
     * Creates a new partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param partnerRegistrationInfo PartnerRegistration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, partnerRegistrationName, partnerRegistrationInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                partnerRegistrationName,
                partnerRegistrationInfo,
                options
            }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param partnerRegistrationInfo PartnerRegistration information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, partnerRegistrationName, partnerRegistrationInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, partnerRegistrationName, partnerRegistrationInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, partnerRegistrationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerRegistrationName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, partnerRegistrationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, partnerRegistrationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param partnerRegistrationUpdateParameters Partner registration update information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, partnerRegistrationName, partnerRegistrationUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                partnerRegistrationName,
                partnerRegistrationUpdateParameters,
                options
            }, updateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a partner registration with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerRegistrationName Name of the partner registration.
     * @param partnerRegistrationUpdateParameters Partner registration update information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, partnerRegistrationName, partnerRegistrationUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, partnerRegistrationName, partnerRegistrationUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the partner registrations under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * List all the partner registrations under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerRegistrations/{partnerRegistrationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerRegistration
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerRegistrationName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerRegistrations/{partnerRegistrationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PartnerRegistration
        },
        201: {
            bodyMapper: PartnerRegistration
        },
        202: {
            bodyMapper: PartnerRegistration
        },
        204: {
            bodyMapper: PartnerRegistration
        },
        default: {}
    },
    requestBody: partnerRegistrationInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerRegistrationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerRegistrations/{partnerRegistrationName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerRegistrationName
    ],
    serializer: serializer$7
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerRegistrations/{partnerRegistrationName}",
    httpMethod: "PATCH",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: partnerRegistrationUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerRegistrationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/partnerRegistrations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerRegistrationsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerRegistrations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerRegistrationsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerRegistrationsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerRegistrationsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PartnerTopics operations. */
class PartnerTopicsImpl {
    /**
     * Initialize a new instance of the class PartnerTopics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the partner topics under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the partner topics under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get properties of a partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    get(resourceGroupName, partnerTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, options }, getOperationSpec$6);
    }
    /**
     * Asynchronously creates a new partner topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param partnerTopicInfo Partner Topic information.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, partnerTopicName, partnerTopicInfo, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, partnerTopicInfo, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Delete existing partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, partnerTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, partnerTopicName, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, partnerTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, partnerTopicName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Asynchronously updates a partner topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param partnerTopicUpdateParameters PartnerTopic update information.
     * @param options The options parameters.
     */
    update(resourceGroupName, partnerTopicName, partnerTopicUpdateParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            partnerTopicName,
            partnerTopicUpdateParameters,
            options
        }, updateOperationSpec$2);
    }
    /**
     * List all the partner topics under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * List all the partner topics under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Activate a newly created partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    activate(resourceGroupName, partnerTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, options }, activateOperationSpec);
    }
    /**
     * Deactivate specific partner topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param partnerTopicName Name of the partner topic.
     * @param options The options parameters.
     */
    deactivate(resourceGroupName, partnerTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, partnerTopicName, options }, deactivateOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PartnerTopic
        },
        201: {
            bodyMapper: PartnerTopic
        },
        default: {}
    },
    requestBody: partnerTopicInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    serializer: serializer$6
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}",
    httpMethod: "PATCH",
    responses: {
        200: {},
        201: {
            bodyMapper: PartnerTopic
        },
        default: {}
    },
    requestBody: partnerTopicUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/partnerTopics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerTopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerTopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const activateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/activate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PartnerTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const deactivateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/partnerTopics/{partnerTopicName}/deactivate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PartnerTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        partnerTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerTopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PartnerTopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all private endpoint connections under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, parentType, parentName, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, parentType, parentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourcePagingPage(resourceGroupName, parentType, parentName, options, settings);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, parentType, parentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResource(resourceGroupName, parentType, parentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, parentType, parentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, parentType, parentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, parentType, parentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a specific private endpoint connection under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param privateEndpointConnectionName The name of the private endpoint connection connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, parentType, parentName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            parentType,
            parentName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$5);
    }
    /**
     * Update a specific private endpoint connection under a topic, domain or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param privateEndpointConnectionName The name of the private endpoint connection connection.
     * @param privateEndpointConnection The private endpoint connection object to update.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, parentType, parentName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                parentType,
                parentName,
                privateEndpointConnectionName,
                privateEndpointConnection,
                options
            }, updateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a specific private endpoint connection under a topic, domain or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param privateEndpointConnectionName The name of the private endpoint connection connection.
     * @param privateEndpointConnection The private endpoint connection object to update.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, parentType, parentName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, parentType, parentName, privateEndpointConnectionName, privateEndpointConnection, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a specific private endpoint connection under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param privateEndpointConnectionName The name of the private endpoint connection connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, parentType, parentName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                parentType,
                parentName,
                privateEndpointConnectionName,
                options
            }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a specific private endpoint connection under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param privateEndpointConnectionName The name of the private endpoint connection connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, parentType, parentName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, parentType, parentName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get all private endpoint connections under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, parentType, parentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, parentType, parentName, options }, listByResourceOperationSpec$1);
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, parentType, parentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, parentType, parentName, nextLink, options }, listByResourceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/{parentType}/{parentName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        parentType,
        parentName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/{parentType}/{parentName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {}
    },
    requestBody: privateEndpointConnection,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        parentType,
        parentName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/{parentType}/{parentName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        parentType,
        parentName,
        privateEndpointConnectionName
    ],
    serializer: serializer$5
};
const listByResourceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/{parentType}/{parentName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        parentType,
        parentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByResourceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        parentType,
        parentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the private link resources under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param options The options parameters.
     */
    listByResource(resourceGroupName, parentType, parentName, options) {
        const iter = this.listByResourcePagingAll(resourceGroupName, parentType, parentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourcePagingPage(resourceGroupName, parentType, parentName, options, settings);
            }
        };
    }
    listByResourcePagingPage(resourceGroupName, parentType, parentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResource(resourceGroupName, parentType, parentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceNext(resourceGroupName, parentType, parentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourcePagingAll(resourceGroupName, parentType, parentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourcePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourcePagingPage(resourceGroupName, parentType, parentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get properties of a private link resource.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param privateLinkResourceName The name of private link resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, parentType, parentName, privateLinkResourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            parentType,
            parentName,
            privateLinkResourceName,
            options
        }, getOperationSpec$4);
    }
    /**
     * List all the private link resources under a topic, domain, or partner namespace.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param options The options parameters.
     */
    _listByResource(resourceGroupName, parentType, parentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, parentType, parentName, options }, listByResourceOperationSpec);
    }
    /**
     * ListByResourceNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param parentType The type of the parent resource. This can be either \'topics\', \'domains\', or
     *                   \'partnerNamespaces\'.
     * @param parentName The name of the parent resource (namely, either, the topic name, domain name, or
     *                   partner namespace name).
     * @param nextLink The nextLink from the previous successful call to the ListByResource method.
     * @param options The options parameters.
     */
    _listByResourceNext(resourceGroupName, parentType, parentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, parentType, parentName, nextLink, options }, listByResourceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/{parentType}/{parentName}/privateLinkResources/{privateLinkResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        parentName,
        parentType1,
        privateLinkResourceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/{parentType}/{parentName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        parentName,
        parentType1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        parentName,
        parentType1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SystemTopics operations. */
class SystemTopicsImpl {
    /**
     * Initialize a new instance of the class SystemTopics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the system topics under an Azure subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the system topics under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get properties of a system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param options The options parameters.
     */
    get(resourceGroupName, systemTopicName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, systemTopicName, options }, getOperationSpec$3);
    }
    /**
     * Asynchronously creates a new system topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param systemTopicInfo System Topic information.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, systemTopicName, systemTopicInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, systemTopicName, systemTopicInfo, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously creates a new system topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param systemTopicInfo System Topic information.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, systemTopicName, systemTopicInfo, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, systemTopicName, systemTopicInfo, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete existing system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, systemTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, systemTopicName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete existing system topic.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, systemTopicName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, systemTopicName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Asynchronously updates a system topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param systemTopicUpdateParameters SystemTopic update information.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, systemTopicName, systemTopicUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                systemTopicName,
                systemTopicUpdateParameters,
                options
            }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Asynchronously updates a system topic with the specified parameters.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param systemTopicName Name of the system topic.
     * @param systemTopicUpdateParameters SystemTopic update information.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, systemTopicName, systemTopicUpdateParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, systemTopicName, systemTopicUpdateParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all the system topics under an Azure subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * List all the system topics under a resource group.
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the user's subscription.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SystemTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        systemTopicName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SystemTopic
        },
        201: {
            bodyMapper: SystemTopic
        },
        202: {
            bodyMapper: SystemTopic
        },
        204: {
            bodyMapper: SystemTopic
        },
        default: {}
    },
    requestBody: systemTopicInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        systemTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        systemTopicName
    ],
    serializer: serializer$3
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics/{systemTopicName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SystemTopic
        },
        201: {
            bodyMapper: SystemTopic
        },
        202: {
            bodyMapper: SystemTopic
        },
        204: {
            bodyMapper: SystemTopic
        },
        default: {}
    },
    requestBody: systemTopicUpdateParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        systemTopicName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.EventGrid/systemTopics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SystemTopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.EventGrid/systemTopics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SystemTopicsListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SystemTopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SystemTopicsListResult
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExtensionTopics operations. */
class ExtensionTopicsImpl {
    /**
     * Initialize a new instance of the class ExtensionTopics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the properties of an extension topic.
     * @param scope The identifier of the resource to which extension topic is queried. The scope can be a
     *              subscription, or a resource group, or a top level resource belonging to a resource provider
     *              namespace. For example, use '/subscriptions/{subscriptionId}/' for a subscription,
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for a resource group, and
     *              '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}'
     *              for Azure resource.
     * @param options The options parameters.
     */
    get(scope, options) {
        return this.client.sendOperationRequest({ scope, options }, getOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/{scope}/providers/Microsoft.EventGrid/extensionTopics/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExtensionTopic
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, scope1],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing TopicTypes operations. */
class TopicTypesImpl {
    /**
     * Initialize a new instance of the class TopicTypes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all registered topic types.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List event types for a topic type.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    listEventTypes(topicTypeName, options) {
        const iter = this.listEventTypesPagingAll(topicTypeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listEventTypesPagingPage(topicTypeName, options, settings);
            }
        };
    }
    listEventTypesPagingPage(topicTypeName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listEventTypesPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listEventTypes(topicTypeName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listEventTypesPagingAll(topicTypeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listEventTypesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listEventTypesPagingPage(topicTypeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all registered topic types.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * Get information about a topic type.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    get(topicTypeName, options) {
        return this.client.sendOperationRequest({ topicTypeName, options }, getOperationSpec$1);
    }
    /**
     * List event types for a topic type.
     * @param topicTypeName Name of the topic type.
     * @param options The options parameters.
     */
    _listEventTypes(topicTypeName, options) {
        return this.client.sendOperationRequest({ topicTypeName, options }, listEventTypesOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.EventGrid/topicTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopicTypesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/providers/Microsoft.EventGrid/topicTypes/{topicTypeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TopicTypeInfo
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, topicTypeName],
    headerParameters: [accept],
    serializer: serializer$1
};
const listEventTypesOperationSpec = {
    path: "/providers/Microsoft.EventGrid/topicTypes/{topicTypeName}/eventTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EventTypesListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, topicTypeName],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VerifiedPartners operations. */
class VerifiedPartnersImpl {
    /**
     * Initialize a new instance of the class VerifiedPartners class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a list of all verified partners.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get properties of a verified partner.
     * @param verifiedPartnerName Name of the verified partner.
     * @param options The options parameters.
     */
    get(verifiedPartnerName, options) {
        return this.client.sendOperationRequest({ verifiedPartnerName, options }, getOperationSpec);
    }
    /**
     * Get a list of all verified partners.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/providers/Microsoft.EventGrid/verifiedPartners/{verifiedPartnerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VerifiedPartner
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, verifiedPartnerName],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/providers/Microsoft.EventGrid/verifiedPartners",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VerifiedPartnersListResult
        },
        default: {}
    },
    queryParameters: [apiVersion, filter, top],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VerifiedPartnersListResult
        },
        default: {}
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class EventGridManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the EventGridManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Subscription credentials that uniquely identify a Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-eventgrid/14.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2022-06-15";
        this.channels = new ChannelsImpl(this);
        this.domains = new DomainsImpl(this);
        this.domainTopics = new DomainTopicsImpl(this);
        this.topicEventSubscriptions = new TopicEventSubscriptionsImpl(this);
        this.domainEventSubscriptions = new DomainEventSubscriptionsImpl(this);
        this.eventSubscriptions = new EventSubscriptionsImpl(this);
        this.domainTopicEventSubscriptions = new DomainTopicEventSubscriptionsImpl(this);
        this.systemTopicEventSubscriptions = new SystemTopicEventSubscriptionsImpl(this);
        this.partnerTopicEventSubscriptions = new PartnerTopicEventSubscriptionsImpl(this);
        this.operations = new OperationsImpl(this);
        this.topics = new TopicsImpl(this);
        this.partnerConfigurations = new PartnerConfigurationsImpl(this);
        this.partnerNamespaces = new PartnerNamespacesImpl(this);
        this.partnerRegistrations = new PartnerRegistrationsImpl(this);
        this.partnerTopics = new PartnerTopicsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.systemTopics = new SystemTopicsImpl(this);
        this.extensionTopics = new ExtensionTopicsImpl(this);
        this.topicTypes = new TopicTypesImpl(this);
        this.verifiedPartners = new VerifiedPartnersImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.EventGridManagementClient = EventGridManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CreatedByType} that the service accepts. */
export var KnownCreatedByType;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(KnownCreatedByType || (KnownCreatedByType = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
export var KnownPublicNetworkAccess;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(KnownPublicNetworkAccess || (KnownPublicNetworkAccess = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
export var KnownPrivateEndpointServiceConnectionStatus;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
})(KnownPrivateEndpointServiceConnectionStatus || (KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
export var KnownPrivateEndpointConnectionProvisioningState;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(KnownPrivateEndpointConnectionProvisioningState || (KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link ScalingHostPoolType} that the service accepts. */
export var KnownScalingHostPoolType;
(function (KnownScalingHostPoolType) {
    /** Users get a new (random) SessionHost every time it connects to the HostPool. */
    KnownScalingHostPoolType["Pooled"] = "Pooled";
})(KnownScalingHostPoolType || (KnownScalingHostPoolType = {}));
/** Known values of {@link ScalingScheduleDaysOfWeekItem} that the service accepts. */
export var KnownScalingScheduleDaysOfWeekItem;
(function (KnownScalingScheduleDaysOfWeekItem) {
    /** Sunday */
    KnownScalingScheduleDaysOfWeekItem["Sunday"] = "Sunday";
    /** Monday */
    KnownScalingScheduleDaysOfWeekItem["Monday"] = "Monday";
    /** Tuesday */
    KnownScalingScheduleDaysOfWeekItem["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownScalingScheduleDaysOfWeekItem["Wednesday"] = "Wednesday";
    /** Thursday */
    KnownScalingScheduleDaysOfWeekItem["Thursday"] = "Thursday";
    /** Friday */
    KnownScalingScheduleDaysOfWeekItem["Friday"] = "Friday";
    /** Saturday */
    KnownScalingScheduleDaysOfWeekItem["Saturday"] = "Saturday";
})(KnownScalingScheduleDaysOfWeekItem || (KnownScalingScheduleDaysOfWeekItem = {}));
/** Known values of {@link SessionHostLoadBalancingAlgorithm} that the service accepts. */
export var KnownSessionHostLoadBalancingAlgorithm;
(function (KnownSessionHostLoadBalancingAlgorithm) {
    /** BreadthFirst */
    KnownSessionHostLoadBalancingAlgorithm["BreadthFirst"] = "BreadthFirst";
    /** DepthFirst */
    KnownSessionHostLoadBalancingAlgorithm["DepthFirst"] = "DepthFirst";
})(KnownSessionHostLoadBalancingAlgorithm || (KnownSessionHostLoadBalancingAlgorithm = {}));
/** Known values of {@link StopHostsWhen} that the service accepts. */
export var KnownStopHostsWhen;
(function (KnownStopHostsWhen) {
    /** ZeroSessions */
    KnownStopHostsWhen["ZeroSessions"] = "ZeroSessions";
    /** ZeroActiveSessions */
    KnownStopHostsWhen["ZeroActiveSessions"] = "ZeroActiveSessions";
})(KnownStopHostsWhen || (KnownStopHostsWhen = {}));
/** Known values of {@link StartupBehavior} that the service accepts. */
export var KnownStartupBehavior;
(function (KnownStartupBehavior) {
    /** Session hosts will not be started by the service. This setting depends on Start VM on Connect to be enabled to start the session hosts. */
    KnownStartupBehavior["None"] = "None";
    /** Session hosts with an assigned user will be started during Ramp Up */
    KnownStartupBehavior["WithAssignedUser"] = "WithAssignedUser";
    /** All personal session hosts in the hostpool will be started during ramp up. */
    KnownStartupBehavior["All"] = "All";
})(KnownStartupBehavior || (KnownStartupBehavior = {}));
/** Known values of {@link SetStartVMOnConnect} that the service accepts. */
export var KnownSetStartVMOnConnect;
(function (KnownSetStartVMOnConnect) {
    /** Enable */
    KnownSetStartVMOnConnect["Enable"] = "Enable";
    /** Disable */
    KnownSetStartVMOnConnect["Disable"] = "Disable";
})(KnownSetStartVMOnConnect || (KnownSetStartVMOnConnect = {}));
/** Known values of {@link SessionHandlingOperation} that the service accepts. */
export var KnownSessionHandlingOperation;
(function (KnownSessionHandlingOperation) {
    /** None */
    KnownSessionHandlingOperation["None"] = "None";
    /** Deallocate */
    KnownSessionHandlingOperation["Deallocate"] = "Deallocate";
    /** Hibernate */
    KnownSessionHandlingOperation["Hibernate"] = "Hibernate";
})(KnownSessionHandlingOperation || (KnownSessionHandlingOperation = {}));
/** Known values of {@link ApplicationGroupType} that the service accepts. */
export var KnownApplicationGroupType;
(function (KnownApplicationGroupType) {
    /** RemoteApp */
    KnownApplicationGroupType["RemoteApp"] = "RemoteApp";
    /** Desktop */
    KnownApplicationGroupType["Desktop"] = "Desktop";
})(KnownApplicationGroupType || (KnownApplicationGroupType = {}));
/** Known values of {@link RemoteApplicationType} that the service accepts. */
export var KnownRemoteApplicationType;
(function (KnownRemoteApplicationType) {
    /** InBuilt */
    KnownRemoteApplicationType["InBuilt"] = "InBuilt";
    /** MsixApplication */
    KnownRemoteApplicationType["MsixApplication"] = "MsixApplication";
})(KnownRemoteApplicationType || (KnownRemoteApplicationType = {}));
/** Known values of {@link CommandLineSetting} that the service accepts. */
export var KnownCommandLineSetting;
(function (KnownCommandLineSetting) {
    /** DoNotAllow */
    KnownCommandLineSetting["DoNotAllow"] = "DoNotAllow";
    /** Allow */
    KnownCommandLineSetting["Allow"] = "Allow";
    /** Require */
    KnownCommandLineSetting["Require"] = "Require";
})(KnownCommandLineSetting || (KnownCommandLineSetting = {}));
/** Known values of {@link HostPoolType} that the service accepts. */
export var KnownHostPoolType;
(function (KnownHostPoolType) {
    /** Users will be assigned a SessionHost either by administrators (PersonalDesktopAssignmentType = Direct) or upon connecting to the pool (PersonalDesktopAssignmentType = Automatic). They will always be redirected to their assigned SessionHost. */
    KnownHostPoolType["Personal"] = "Personal";
    /** Users get a new (random) SessionHost every time it connects to the HostPool. */
    KnownHostPoolType["Pooled"] = "Pooled";
    /** Users assign their own machines, load balancing logic remains the same as Personal. PersonalDesktopAssignmentType must be Direct. */
    KnownHostPoolType["BYODesktop"] = "BYODesktop";
})(KnownHostPoolType || (KnownHostPoolType = {}));
/** Known values of {@link PersonalDesktopAssignmentType} that the service accepts. */
export var KnownPersonalDesktopAssignmentType;
(function (KnownPersonalDesktopAssignmentType) {
    /** Automatic */
    KnownPersonalDesktopAssignmentType["Automatic"] = "Automatic";
    /** Direct */
    KnownPersonalDesktopAssignmentType["Direct"] = "Direct";
})(KnownPersonalDesktopAssignmentType || (KnownPersonalDesktopAssignmentType = {}));
/** Known values of {@link LoadBalancerType} that the service accepts. */
export var KnownLoadBalancerType;
(function (KnownLoadBalancerType) {
    /** BreadthFirst */
    KnownLoadBalancerType["BreadthFirst"] = "BreadthFirst";
    /** DepthFirst */
    KnownLoadBalancerType["DepthFirst"] = "DepthFirst";
    /** Persistent */
    KnownLoadBalancerType["Persistent"] = "Persistent";
})(KnownLoadBalancerType || (KnownLoadBalancerType = {}));
/** Known values of {@link RegistrationTokenOperation} that the service accepts. */
export var KnownRegistrationTokenOperation;
(function (KnownRegistrationTokenOperation) {
    /** Delete */
    KnownRegistrationTokenOperation["Delete"] = "Delete";
    /** None */
    KnownRegistrationTokenOperation["None"] = "None";
    /** Update */
    KnownRegistrationTokenOperation["Update"] = "Update";
})(KnownRegistrationTokenOperation || (KnownRegistrationTokenOperation = {}));
/** Known values of {@link SSOSecretType} that the service accepts. */
export var KnownSSOSecretType;
(function (KnownSSOSecretType) {
    /** SharedKey */
    KnownSSOSecretType["SharedKey"] = "SharedKey";
    /** Certificate */
    KnownSSOSecretType["Certificate"] = "Certificate";
    /** SharedKeyInKeyVault */
    KnownSSOSecretType["SharedKeyInKeyVault"] = "SharedKeyInKeyVault";
    /** CertificateInKeyVault */
    KnownSSOSecretType["CertificateInKeyVault"] = "CertificateInKeyVault";
})(KnownSSOSecretType || (KnownSSOSecretType = {}));
/** Known values of {@link PreferredAppGroupType} that the service accepts. */
export var KnownPreferredAppGroupType;
(function (KnownPreferredAppGroupType) {
    /** None */
    KnownPreferredAppGroupType["None"] = "None";
    /** Desktop */
    KnownPreferredAppGroupType["Desktop"] = "Desktop";
    /** RailApplications */
    KnownPreferredAppGroupType["RailApplications"] = "RailApplications";
})(KnownPreferredAppGroupType || (KnownPreferredAppGroupType = {}));
/** Known values of {@link HostpoolPublicNetworkAccess} that the service accepts. */
export var KnownHostpoolPublicNetworkAccess;
(function (KnownHostpoolPublicNetworkAccess) {
    /** Enabled */
    KnownHostpoolPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownHostpoolPublicNetworkAccess["Disabled"] = "Disabled";
    /** EnabledForSessionHostsOnly */
    KnownHostpoolPublicNetworkAccess["EnabledForSessionHostsOnly"] = "EnabledForSessionHostsOnly";
    /** EnabledForClientsOnly */
    KnownHostpoolPublicNetworkAccess["EnabledForClientsOnly"] = "EnabledForClientsOnly";
})(KnownHostpoolPublicNetworkAccess || (KnownHostpoolPublicNetworkAccess = {}));
/** Known values of {@link SessionHostComponentUpdateType} that the service accepts. */
export var KnownSessionHostComponentUpdateType;
(function (KnownSessionHostComponentUpdateType) {
    /** Agent and other agent side components are delivery schedule is controlled by WVD Infra. */
    KnownSessionHostComponentUpdateType["Default"] = "Default";
    /** TenantAdmin have opted in for Scheduled Component Update feature. */
    KnownSessionHostComponentUpdateType["Scheduled"] = "Scheduled";
})(KnownSessionHostComponentUpdateType || (KnownSessionHostComponentUpdateType = {}));
/** Known values of {@link ApplicationType} that the service accepts. */
export var KnownApplicationType;
(function (KnownApplicationType) {
    /** RemoteApp */
    KnownApplicationType["RemoteApp"] = "RemoteApp";
    /** Desktop */
    KnownApplicationType["Desktop"] = "Desktop";
})(KnownApplicationType || (KnownApplicationType = {}));
/** Known values of {@link SessionState} that the service accepts. */
export var KnownSessionState;
(function (KnownSessionState) {
    /** Unknown */
    KnownSessionState["Unknown"] = "Unknown";
    /** Active */
    KnownSessionState["Active"] = "Active";
    /** Disconnected */
    KnownSessionState["Disconnected"] = "Disconnected";
    /** Pending */
    KnownSessionState["Pending"] = "Pending";
    /** LogOff */
    KnownSessionState["LogOff"] = "LogOff";
    /** UserProfileDiskMounted */
    KnownSessionState["UserProfileDiskMounted"] = "UserProfileDiskMounted";
})(KnownSessionState || (KnownSessionState = {}));
/** Known values of {@link Status} that the service accepts. */
export var KnownStatus;
(function (KnownStatus) {
    /** Session Host has passed all the health checks and is available to handle connections. */
    KnownStatus["Available"] = "Available";
    /** Session Host is either turned off or has failed critical health checks which is causing service not to be able to route connections to this session host. Note this replaces previous 'NoHeartBeat' status. */
    KnownStatus["Unavailable"] = "Unavailable";
    /** Session Host is shutdown - RD Agent reported session host to be stopped or deallocated. */
    KnownStatus["Shutdown"] = "Shutdown";
    /** The Session Host is unavailable because it is currently disconnected. */
    KnownStatus["Disconnected"] = "Disconnected";
    /** Session Host is unavailable because currently an upgrade of RDAgent\/side-by-side stack is in progress. Note: this state will be removed once the upgrade completes and the host is able to accept connections. */
    KnownStatus["Upgrading"] = "Upgrading";
    /** Session Host is unavailable because the critical component upgrade (agent, side-by-side stack, etc.) failed. */
    KnownStatus["UpgradeFailed"] = "UpgradeFailed";
    /** The Session Host is not heart beating. */
    KnownStatus["NoHeartbeat"] = "NoHeartbeat";
    /** SessionHost is not joined to domain. */
    KnownStatus["NotJoinedToDomain"] = "NotJoinedToDomain";
    /** SessionHost's domain trust relationship lost */
    KnownStatus["DomainTrustRelationshipLost"] = "DomainTrustRelationshipLost";
    /** SxS stack installed on the SessionHost is not ready to receive connections. */
    KnownStatus["SxSStackListenerNotReady"] = "SxSStackListenerNotReady";
    /** FSLogix is in an unhealthy state on the session host. */
    KnownStatus["FSLogixNotHealthy"] = "FSLogixNotHealthy";
    /** New status to inform admins that the health on their endpoint needs to be fixed. The connections might not fail, as these issues are not fatal. */
    KnownStatus["NeedsAssistance"] = "NeedsAssistance";
})(KnownStatus || (KnownStatus = {}));
/** Known values of {@link UpdateState} that the service accepts. */
export var KnownUpdateState;
(function (KnownUpdateState) {
    /** Initial */
    KnownUpdateState["Initial"] = "Initial";
    /** Pending */
    KnownUpdateState["Pending"] = "Pending";
    /** Started */
    KnownUpdateState["Started"] = "Started";
    /** Succeeded */
    KnownUpdateState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownUpdateState["Failed"] = "Failed";
})(KnownUpdateState || (KnownUpdateState = {}));
/** Known values of {@link HealthCheckName} that the service accepts. */
export var KnownHealthCheckName;
(function (KnownHealthCheckName) {
    /** Verifies the SessionHost is joined to a domain. If this check fails is classified as fatal as no connection can succeed if the SessionHost is not joined to the domain. (Currently Enabled) */
    KnownHealthCheckName["DomainJoinedCheck"] = "DomainJoinedCheck";
    /** Verifies the SessionHost is not experiencing domain trust issues that will prevent authentication on SessionHost at connection time when session is created. If this check fails is classified as fatal as no connection can succeed if we cannot reach the domain for authentication on the SessionHost. (Currently Enabled) */
    KnownHealthCheckName["DomainTrustCheck"] = "DomainTrustCheck";
    /** Verifies the FSLogix service is up and running to make sure users' profiles are loaded in the session. If this check fails is classified as fatal as even if the connection can succeed, user experience is bad as the user profile cannot be loaded and user will get a temporary profile in the session. (Currently Disabled) */
    KnownHealthCheckName["FSLogixHealthCheck"] = "FSLogixHealthCheck";
    /** Verifies that the SxS stack is up and running so connections can succeed. If this check fails is classified as fatal as no connection can succeed if the SxS stack is not ready. (Currently Enabled) */
    KnownHealthCheckName["SxSStackListenerCheck"] = "SxSStackListenerCheck";
    /** Verifies that the required WVD service and Geneva URLs are reachable from the SessionHost. These URLs are: RdTokenUri, RdBrokerURI, RdDiagnosticsUri and storage blob URLs for agent monitoring (geneva). If this check fails, it is non fatal and the machine still can service connections, main issue may be that monitoring agent is unable to store warm path data (logs, operations ...). (Currently Disabled) */
    KnownHealthCheckName["UrlsAccessibleCheck"] = "UrlsAccessibleCheck";
    /** Verifies that the required Geneva agent is running. If this check fails, it is non fatal and the machine still can service connections, main issue may be that monitoring agent is missing or running (possibly) older version. (Currently Enabled) */
    KnownHealthCheckName["MonitoringAgentCheck"] = "MonitoringAgentCheck";
    /** Verifies the domain the SessionHost is joined to is still reachable. If this check fails is classified as fatal as no connection can succeed if the domain the SessionHost is joined is not reachable at the time of connection. (Currently Disabled) */
    KnownHealthCheckName["DomainReachable"] = "DomainReachable";
    /** Verifies whether the WebRTCRedirector component is healthy. The WebRTCRedirector component is used to optimize video and audio performance in Microsoft Teams. This checks whether the component is still running, and whether there is a higher version available. If this check fails, it is non fatal and the machine still can service connections, main issue may be the WebRTCRedirector component has to be restarted or updated. (Currently Disabled) */
    KnownHealthCheckName["WebRTCRedirectorCheck"] = "WebRTCRedirectorCheck";
    /** Verifies the value of SecurityLayer registration key. If the value is 0 (SecurityLayer.RDP) this check fails with Error code = NativeMethodErrorCode.E_FAIL and is fatal. If the value is 1 (SecurityLayer.Negotiate) this check fails with Error code = NativeMethodErrorCode.ERROR_SUCCESS and is non fatal. (Currently Disabled) */
    KnownHealthCheckName["SupportedEncryptionCheck"] = "SupportedEncryptionCheck";
    /** Verifies the metadata service is accessible and return compute properties. (Currently Enabled) */
    KnownHealthCheckName["MetaDataServiceCheck"] = "MetaDataServiceCheck";
    /** Verifies that the AppAttachService is healthy (there were no issues during package staging). The AppAttachService is used to enable the staging\/registration (and eventual deregistration\/destaging) of MSIX apps that have been set up by the tenant admin. This checks whether the component had any failures during package staging. Failures in staging will prevent some MSIX apps from working properly for the end user. If this check fails, it is non fatal and the machine still can service connections, main issue may be certain apps will not work for end-users. (Currently Enabled) */
    KnownHealthCheckName["AppAttachHealthCheck"] = "AppAttachHealthCheck";
})(KnownHealthCheckName || (KnownHealthCheckName = {}));
/** Known values of {@link HealthCheckResult} that the service accepts. */
export var KnownHealthCheckResult;
(function (KnownHealthCheckResult) {
    /** Health check result is not currently known. */
    KnownHealthCheckResult["Unknown"] = "Unknown";
    /** Health check passed. */
    KnownHealthCheckResult["HealthCheckSucceeded"] = "HealthCheckSucceeded";
    /** Health check failed. */
    KnownHealthCheckResult["HealthCheckFailed"] = "HealthCheckFailed";
    /** We received a Shutdown notification. */
    KnownHealthCheckResult["SessionHostShutdown"] = "SessionHostShutdown";
})(KnownHealthCheckResult || (KnownHealthCheckResult = {}));
//# sourceMappingURL=index.js.map
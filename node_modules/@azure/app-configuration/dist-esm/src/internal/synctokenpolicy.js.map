{"version":3,"file":"synctokenpolicy.js","sourceRoot":"","sources":["../../../src/internal/synctokenpolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { logger } from \"../logger\";\n\n/**\n * The sync token header, as described here:\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n * @internal\n */\nexport const SyncTokenHeaderName = \"sync-token\";\n\n/**\n * A policy factory for injecting sync tokens properly into outgoing requests.\n * @param syncTokens - the sync tokens store to be used across requests.\n * @internal\n */\nexport function syncTokenPolicy(syncTokens: SyncTokens): PipelinePolicy {\n  return {\n    name: \"Sync Token Policy\",\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const syncTokenHeaderValue = syncTokens.getSyncTokenHeaderValue();\n\n      if (syncTokenHeaderValue) {\n        logger.info(\n          \"[syncTokenPolicy] Setting headers with ${SyncTokenHeaderName} and ${syncTokenHeaderValue}\",\n        );\n        request.headers.set(SyncTokenHeaderName, syncTokenHeaderValue);\n      }\n      const response = await next(request);\n      syncTokens.addSyncTokenFromHeaderValue(response.headers.get(SyncTokenHeaderName));\n      return response;\n    },\n  };\n}\n\n/**\n * Sync token tracker (allows for real-time consistency, even in the face of\n * caching and load balancing within App Configuration).\n *\n * (protocol and format described here)\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n *\n * @internal\n */\nexport class SyncTokens {\n  private _currentSyncTokens = new Map<string, SyncToken>();\n\n  /**\n   * Takes the value from the header named after the constant `SyncTokenHeaderName`\n   * and adds it to our list of accumulated sync tokens.\n   *\n   * If given an empty value (or undefined) it clears the current list of sync tokens.\n   * (indicates the service has properly absorbed values into the cluster).\n   *\n   * @param syncTokenHeaderValue - The full value of the sync token header.\n   */\n  addSyncTokenFromHeaderValue(syncTokenHeaderValue: string | undefined): void {\n    if (syncTokenHeaderValue == null || syncTokenHeaderValue === \"\") {\n      // eventually everything gets synced up and we don't have to track\n      // these headers anymore\n      this._currentSyncTokens.clear();\n      return;\n    }\n\n    const newTokens = syncTokenHeaderValue.split(\",\").map(parseSyncToken);\n\n    for (const newToken of newTokens) {\n      const existingToken = this._currentSyncTokens.get(newToken.id);\n\n      if (!existingToken || existingToken.sequenceNumber < newToken.sequenceNumber) {\n        this._currentSyncTokens.set(newToken.id, newToken);\n        continue;\n      }\n    }\n  }\n\n  /**\n   * Gets a properly formatted SyncToken header value.\n   */\n  getSyncTokenHeaderValue(): string | undefined {\n    if (this._currentSyncTokens.size === 0) {\n      return undefined;\n    }\n\n    const syncTokenStrings = [];\n\n    for (const syncToken of this._currentSyncTokens.values()) {\n      // note that you don't include the 'sn' field here - that's only\n      // used for internal tracking of the 'version' for the token itself\n      syncTokenStrings.push(`${syncToken.id}=${syncToken.value}`);\n    }\n\n    return syncTokenStrings.join(\",\");\n  }\n}\n\n// An example sync token (from their documentation):\n//\n// jtqGc1I4=MDoyOA==;sn=28\n//\n// Which breaks down to:\n// id: jtqGc1I4\n// value: MDoyOA==\n// sequence number: 28\nconst syncTokenRegex = /^([^=]+)=([^;]+);sn=(\\d+)$/;\n\ninterface SyncToken {\n  id: string;\n  value: string;\n  sequenceNumber: number;\n}\n\n/**\n * Parses a single sync token into it's constituent parts.\n *\n * @param syncToken - A single sync token.\n *\n * @internal\n */\nexport function parseSyncToken(syncToken: string): SyncToken {\n  const matches = syncToken.match(syncTokenRegex);\n\n  if (matches == null) {\n    throw new Error(\n      `Failed to parse sync token '${syncToken}' with regex ${syncTokenRegex.source}`,\n    );\n  }\n\n  const sequenceNumber = parseInt(matches[3], 10);\n\n  if (isNaN(sequenceNumber)) {\n    // this should be impossible since our regex restricts to just digits\n    // but there's nothing wrong with being thorough.\n    throw new Error(`${syncToken}: The sequence number value '${matches[3]}' wasn't a number`);\n  }\n\n  return {\n    id: matches[1],\n    value: matches[2],\n    sequenceNumber,\n  };\n}\n"]}
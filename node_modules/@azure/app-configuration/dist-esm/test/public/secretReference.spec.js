// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { isSecretReference, parseSecretReference, secretReferenceContentType, } from "../../src";
import { createAppConfigurationClientForTests, startRecorder } from "./utils/testHelpers";
import { assert } from "chai";
describe("AppConfigurationClient - SecretReference", () => {
    let client;
    let recorder;
    beforeEach(async function () {
        recorder = await startRecorder(this);
        client = createAppConfigurationClientForTests(recorder.configureClientOptions({}));
    });
    afterEach(async function () {
        await recorder.stop();
    });
    describe("SecretReference configuration setting", () => {
        const getBaseSetting = () => {
            return {
                value: {
                    secretId: `https://vault_name.vault.azure.net/secrets/${recorder.variable("name-2", `name-2${Math.floor(Math.random() * 1000)}`)}`,
                },
                isReadOnly: false,
                key: recorder.variable("name-3", `name-3${Math.floor(Math.random() * 1000)}`),
                label: "label-s",
                contentType: secretReferenceContentType,
            };
        };
        function assertSecretReferenceProps(actual, expected) {
            assert.equal(isSecretReference(actual), true, "Expected to get the SecretReference");
            const actualSecretReference = parseSecretReference(actual);
            if (isSecretReference(actual)) {
                assert.equal(actual.key, expected.key, "Key from the response from get request is not as expected");
                assert.equal(actualSecretReference.value.secretId, expected.value.secretId);
                assert.equal(actual.isReadOnly, expected.isReadOnly);
                assert.equal(actual.label, expected.label);
                assert.equal(actual.contentType, expected.contentType);
            }
        }
        let addResponse;
        let baseSetting;
        beforeEach(async () => {
            baseSetting = getBaseSetting();
            addResponse = await client.addConfigurationSetting(baseSetting);
        });
        afterEach(async () => {
            await client.setReadOnly({
                key: baseSetting.key,
                label: baseSetting.label,
            }, false);
            await client.deleteConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
        });
        it("can add and get SecretReference", async () => {
            assertSecretReferenceProps(addResponse, baseSetting);
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            assertSecretReferenceProps(getResponse, baseSetting);
        });
        it("can add and update SecretReference", async () => {
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            const newSecretId = `https://vault_name.vault.azure.net/secrets/${recorder.variable("name-4", `name-4${Math.floor(Math.random() * 1000)}`)}`;
            assertSecretReferenceProps(getResponse, baseSetting);
            const secretReference = parseSecretReference(getResponse);
            secretReference.value.secretId = newSecretId;
            const setResponse = await client.setConfigurationSetting(secretReference);
            assertSecretReferenceProps(setResponse, Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
            const getResponseAfterUpdate = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            assertSecretReferenceProps(getResponseAfterUpdate, Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
        });
        it("can add, list and update multiple SecretReferences", async () => {
            var _a, e_1, _b, _c, _d, e_2, _e, _f;
            const secondSetting = Object.assign(Object.assign({}, baseSetting), { key: `${baseSetting.key}-2` });
            const newSecretId = `https://vault_name.vault.azure.net/secrets/${recorder.variable("name-5", `name-5${Math.floor(Math.random() * 1000)}`)}`;
            await client.addConfigurationSetting(secondSetting);
            let numberOFSecretReferencesReceived = 0;
            try {
                for (var _g = true, _h = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`,
                })), _j; _j = await _h.next(), _a = _j.done, !_a; _g = true) {
                    _c = _j.value;
                    _g = false;
                    const setting = _c;
                    numberOFSecretReferencesReceived++;
                    if (setting.key === baseSetting.key) {
                        assertSecretReferenceProps(setting, baseSetting);
                        await client.setConfigurationSetting(Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
                    }
                    else {
                        assertSecretReferenceProps(setting, secondSetting);
                        await client.setReadOnly({ key: setting.key, label: setting.label }, !secondSetting.isReadOnly);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_g && !_a && (_b = _h.return)) await _b.call(_h);
                }
                finally { if (e_1) throw e_1.error; }
            }
            assert.equal(numberOFSecretReferencesReceived, 2, "Unexpected number of FeatureFlags seen");
            try {
                for (var _k = true, _l = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`,
                })), _m; _m = await _l.next(), _d = _m.done, !_d; _k = true) {
                    _f = _m.value;
                    _k = false;
                    const setting = _f;
                    numberOFSecretReferencesReceived--;
                    if (setting.key === baseSetting.key) {
                        assertSecretReferenceProps(setting, Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
                    }
                    else {
                        assertSecretReferenceProps(setting, Object.assign(Object.assign({}, secondSetting), { isReadOnly: !secondSetting.isReadOnly }));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_k && !_d && (_e = _l.return)) await _e.call(_l);
                }
                finally { if (e_2) throw e_2.error; }
            }
            assert.equal(numberOFSecretReferencesReceived, 0, "Unexpected number of SecretReferences seen after updating");
            await client.setReadOnly({ key: secondSetting.key, label: secondSetting.label }, false);
            await client.deleteConfigurationSetting({
                key: secondSetting.key,
                label: secondSetting.label,
            });
        });
    });
    describe("serializeAsConfigurationSettingParam", () => {
        [`[]`, "Hello World"].forEach((value) => {
            it(`Unexpected value ${value} as secret reference value`, async () => {
                const setting = {
                    contentType: secretReferenceContentType,
                    key: recorder.variable("name-1", `name-1${Math.floor(Math.random() * 1000)}`),
                    isReadOnly: false,
                    value: { secretId: "id" },
                };
                setting.value = value;
                await client.addConfigurationSetting(setting);
                assert.equal((await client.getConfigurationSetting({ key: setting.key })).value, value, "message");
                await client.deleteConfigurationSetting({ key: setting.key });
            });
        });
    });
});
//# sourceMappingURL=secretReference.spec.js.map
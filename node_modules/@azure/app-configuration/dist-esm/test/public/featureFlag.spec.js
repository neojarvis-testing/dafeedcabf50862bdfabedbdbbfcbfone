// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { featureFlagContentType, featureFlagPrefix, } from "../../src";
import { isFeatureFlag, parseFeatureFlag } from "../../src/featureFlag";
import { createAppConfigurationClientForTests, startRecorder } from "./utils/testHelpers";
import { assert } from "chai";
describe("AppConfigurationClient - FeatureFlag", () => {
    describe("FeatureFlag configuration setting", () => {
        let client;
        let recorder;
        let baseSetting;
        let addResponse;
        beforeEach(async function () {
            recorder = await startRecorder(this);
            client = createAppConfigurationClientForTests(recorder.configureClientOptions({}));
            baseSetting = {
                value: {
                    conditions: {
                        clientFilters: [
                            {
                                name: "Microsoft.TimeWindow",
                                parameters: {
                                    Start: "Wed, 01 May 2019 13:59:59 GMT",
                                    End: "Mon, 01 July 2019 00:00:00 GMT",
                                },
                            },
                            { name: "FilterX" },
                            {
                                name: "Microsoft.Targeting",
                                parameters: {
                                    Audience: {
                                        Groups: [
                                            { Name: "group-1", RolloutPercentage: 25 },
                                            { Name: "group-2", RolloutPercentage: 45 },
                                        ],
                                        Users: ["userA", "userB"],
                                        DefaultRolloutPercentage: 40,
                                    },
                                },
                            },
                            { name: "Microsoft.Percentage", parameters: { Value: 25 } },
                        ],
                    },
                    enabled: false,
                    description: "I'm a description",
                    displayName: "for display",
                },
                isReadOnly: false,
                key: `${featureFlagPrefix +
                    recorder.variable("name-1", `name-1${Math.floor(Math.random() * 1000)}`)}`,
                contentType: featureFlagContentType,
                label: "label-1",
            };
            addResponse = await client.addConfigurationSetting(baseSetting);
        });
        afterEach(async function () {
            await client.deleteConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            await recorder.stop();
        });
        function assertFeatureFlagProps(actual, expected) {
            assert.equal(isFeatureFlag(actual), true, "Expected to get the feature flag");
            assert.isDefined(actual.value, "Expected the value to be defined");
            const featureFlagValue = parseFeatureFlag(actual).value;
            assert.equal(actual.key, expected.key, "Key from the response from get request is not as expected");
            assert.deepEqual(featureFlagValue.conditions, expected.value.conditions, "conditions from the response from get request is not as expected");
            assert.equal(featureFlagValue.description, expected.value.description);
            assert.equal(featureFlagValue.enabled, expected.value.enabled);
            assert.equal(actual.isReadOnly, expected.isReadOnly);
            assert.equal(actual.label, expected.label);
            assert.equal(actual.contentType, expected.contentType);
        }
        it("can add and get FeatureFlag", async () => {
            assertFeatureFlagProps(addResponse, baseSetting);
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            assertFeatureFlagProps(getResponse, baseSetting);
        });
        it("can add and update FeatureFlag", async () => {
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            assertFeatureFlagProps(getResponse, baseSetting);
            const featureFlag = parseFeatureFlag(getResponse);
            featureFlag.value.enabled = !baseSetting.value.enabled;
            const setResponse = await client.setConfigurationSetting(featureFlag);
            assertFeatureFlagProps(setResponse, Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
            const getResponseAfterUpdate = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label,
            });
            assertFeatureFlagProps(getResponseAfterUpdate, Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
        });
        it("can add, list and update multiple FeatureFlags", async () => {
            var _a, e_1, _b, _c, _d, e_2, _e, _f;
            const secondSetting = Object.assign(Object.assign({}, baseSetting), { key: `${baseSetting.key}-2` });
            await client.addConfigurationSetting(secondSetting);
            let numberOFFeatureFlagsReceived = 0;
            try {
                for (var _g = true, _h = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`,
                })), _j; _j = await _h.next(), _a = _j.done, !_a; _g = true) {
                    _c = _j.value;
                    _g = false;
                    const setting = _c;
                    numberOFFeatureFlagsReceived++;
                    if (setting.key === baseSetting.key) {
                        assertFeatureFlagProps(setting, baseSetting);
                        await client.setConfigurationSetting(Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
                    }
                    else {
                        assertFeatureFlagProps(setting, secondSetting);
                        const parsedSetting = parseFeatureFlag(setting);
                        await client.setConfigurationSetting(Object.assign(Object.assign({}, parsedSetting), { value: Object.assign(Object.assign({}, parsedSetting.value), { description: "I'm new description" }) }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_g && !_a && (_b = _h.return)) await _b.call(_h);
                }
                finally { if (e_1) throw e_1.error; }
            }
            assert.equal(numberOFFeatureFlagsReceived, 2, "Unexpected number of FeatureFlags seen");
            try {
                for (var _k = true, _l = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`,
                })), _m; _m = await _l.next(), _d = _m.done, !_d; _k = true) {
                    _f = _m.value;
                    _k = false;
                    const setting = _f;
                    numberOFFeatureFlagsReceived--;
                    if (setting.key === baseSetting.key) {
                        assertFeatureFlagProps(setting, Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
                    }
                    else {
                        assertFeatureFlagProps(setting, Object.assign(Object.assign({}, secondSetting), { value: Object.assign(Object.assign({}, secondSetting.value), { description: "I'm new description" }) }));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_k && !_d && (_e = _l.return)) await _e.call(_l);
                }
                finally { if (e_2) throw e_2.error; }
            }
            assert.equal(numberOFFeatureFlagsReceived, 0, "Unexpected number of FeatureFlags seen after updating");
            await client.deleteConfigurationSetting({ key: secondSetting.key });
        });
    });
    describe("serializeAsConfigurationSettingParam", () => {
        let client;
        let recorder;
        let featureFlag;
        beforeEach(async function () {
            recorder = await startRecorder(this);
            client = createAppConfigurationClientForTests(recorder.configureClientOptions({}));
            featureFlag = {
                contentType: featureFlagContentType,
                key: `${featureFlagPrefix}${recorder.variable("name-1", `name-1${Math.floor(Math.random() * 1000)}`)}`,
                isReadOnly: false,
                value: { conditions: { clientFilters: [] }, enabled: true },
            };
        });
        afterEach(async function () {
            await client.deleteConfigurationSetting({ key: featureFlag.key });
            await recorder.stop();
        });
        [`[]`, "Hello World"].forEach((value) => {
            it(`Unexpected value ${value} as feature flag value`, async () => {
                featureFlag.value = value;
                await client.addConfigurationSetting(featureFlag);
                assert.equal((await client.getConfigurationSetting({ key: featureFlag.key })).value, value, "message");
            });
        });
    });
});
//# sourceMappingURL=featureFlag.spec.js.map
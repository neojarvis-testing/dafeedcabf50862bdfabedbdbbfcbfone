// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { AppConfigurationClient, } from "../../../src";
import { Recorder, env, isPlaybackMode } from "@azure-tools/test-recorder";
import { assert } from "chai";
import { createTestCredential } from "@azure-tools/test-credential";
let connectionStringNotPresentWarning = false;
let tokenCredentialsNotPresentWarning = false;
export async function startRecorder(that) {
    const recorderStartOptions = {
        envSetupForPlayback: {
            APPCONFIG_CONNECTION_STRING: "Endpoint=https://myappconfig.azconfig.io;Id=123456;Secret=123456",
            AZ_CONFIG_ENDPOINT: "https://myappconfig.azconfig.io",
            AZURE_CLIENT_ID: "azure_client_id",
            AZURE_CLIENT_SECRET: "azure_client_secret",
            AZURE_TENANT_ID: "azuretenantid",
        },
        sanitizerOptions: {
            connectionStringSanitizers: [
                {
                    fakeConnString: "Endpoint=https://myappconfig.azconfig.io;Id=123456;Secret=123456",
                    actualConnString: env.APPCONFIG_CONNECTION_STRING,
                },
            ],
        },
    };
    const recorder = new Recorder(that.currentTest);
    await recorder.start(recorderStartOptions);
    return recorder;
}
export function getTokenAuthenticationCredential() {
    const requiredEnvironmentVariables = [
        "AZ_CONFIG_ENDPOINT",
        "AZURE_CLIENT_ID",
        "AZURE_TENANT_ID",
        "AZURE_CLIENT_SECRET",
    ];
    for (const name of requiredEnvironmentVariables) {
        const value = env[name];
        if (value == null) {
            if (tokenCredentialsNotPresentWarning) {
                tokenCredentialsNotPresentWarning = true;
            }
            throw new Error("Invalid value for requiredEnvironmentVariables");
        }
    }
    return {
        credential: createTestCredential(),
        endpoint: env["AZ_CONFIG_ENDPOINT"],
    };
}
export function createAppConfigurationClientForTests(options) {
    const connectionString = env["APPCONFIG_CONNECTION_STRING"];
    if (connectionString == null) {
        if (!connectionStringNotPresentWarning) {
            connectionStringNotPresentWarning = true;
        }
        throw new Error("Invalid value for APPCONFIG_CONNECTION_STRING");
    }
    return new AppConfigurationClient(connectionString, options);
}
export async function deleteKeyCompletely(keys, client) {
    var _a, e_1, _b, _c;
    const settingsIterator = client.listConfigurationSettings({
        keyFilter: keys.join(","),
    });
    try {
        for (var _d = true, settingsIterator_1 = __asyncValues(settingsIterator), settingsIterator_1_1; settingsIterator_1_1 = await settingsIterator_1.next(), _a = settingsIterator_1_1.done, !_a; _d = true) {
            _c = settingsIterator_1_1.value;
            _d = false;
            const setting = _c;
            if (setting.isReadOnly) {
                await client.setReadOnly(setting, false);
            }
            await client.deleteConfigurationSetting({ key: setting.key, label: setting.label });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (!_d && !_a && (_b = settingsIterator_1.return)) await _b.call(settingsIterator_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
export async function deleteEverySetting() {
    var _a, e_2, _b, _c;
    const client = createAppConfigurationClientForTests();
    const settingsList = client.listConfigurationSettings({});
    try {
        for (var _d = true, settingsList_1 = __asyncValues(settingsList), settingsList_1_1; settingsList_1_1 = await settingsList_1.next(), _a = settingsList_1_1.done, !_a; _d = true) {
            _c = settingsList_1_1.value;
            _d = false;
            const setting = _c;
            await client.setReadOnly({ key: setting.key, label: setting.label }, false);
            await client.deleteConfigurationSetting({ key: setting.key, label: setting.label });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (!_d && !_a && (_b = settingsList_1.return)) await _b.call(settingsList_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
export async function toSortedArray(pagedIterator, compareFn) {
    var _a, e_3, _b, _c, _d, e_4, _e, _f;
    const settings = [];
    try {
        for (var _g = true, pagedIterator_1 = __asyncValues(pagedIterator), pagedIterator_1_1; pagedIterator_1_1 = await pagedIterator_1.next(), _a = pagedIterator_1_1.done, !_a; _g = true) {
            _c = pagedIterator_1_1.value;
            _g = false;
            const setting = _c;
            settings.push(setting);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (!_g && !_a && (_b = pagedIterator_1.return)) await _b.call(pagedIterator_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    let settingsViaPageIterator = [];
    try {
        for (var _h = true, _j = __asyncValues(pagedIterator.byPage()), _k; _k = await _j.next(), _d = _k.done, !_d; _h = true) {
            _f = _k.value;
            _h = false;
            const page = _f;
            settingsViaPageIterator = settingsViaPageIterator.concat(page.items);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (!_h && !_d && (_e = _j.return)) await _e.call(_j);
        }
        finally { if (e_4) throw e_4.error; }
    }
    // just a sanity-check
    assert.deepEqual(settings, settingsViaPageIterator);
    settings.sort((a, b) => compareFn
        ? compareFn(a, b)
        : `${a.key}-${a.label}-${a.value}`.localeCompare(`${b.key}-${b.label}-${b.value}`));
    return settings;
}
export async function toSortedSnapshotArray(pagedIterator, compareFn) {
    var _a, e_5, _b, _c, _d, e_6, _e, _f;
    const snapshots = [];
    try {
        for (var _g = true, pagedIterator_2 = __asyncValues(pagedIterator), pagedIterator_2_1; pagedIterator_2_1 = await pagedIterator_2.next(), _a = pagedIterator_2_1.done, !_a; _g = true) {
            _c = pagedIterator_2_1.value;
            _g = false;
            const snapshot = _c;
            snapshots.push(snapshot);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (!_g && !_a && (_b = pagedIterator_2.return)) await _b.call(pagedIterator_2);
        }
        finally { if (e_5) throw e_5.error; }
    }
    let snapshotsViaPageIterator = [];
    try {
        for (var _h = true, _j = __asyncValues(pagedIterator.byPage()), _k; _k = await _j.next(), _d = _k.done, !_d; _h = true) {
            _f = _k.value;
            _h = false;
            const page = _f;
            snapshotsViaPageIterator = snapshotsViaPageIterator.concat(page.items);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (!_h && !_d && (_e = _j.return)) await _e.call(_j);
        }
        finally { if (e_6) throw e_6.error; }
    }
    // just a sanity-check
    assert.deepEqual(snapshots, snapshotsViaPageIterator);
    snapshots.sort((a, b) => compareFn
        ? compareFn(a, b)
        : `${a.name}-${a.itemCount}-${a.status}`.localeCompare(`${b.name}-${b.itemCount}-${b.status}`));
    return snapshots;
}
export function assertEqualSettings(expected, actual) {
    actual = actual.map((setting) => {
        return {
            key: setting.key,
            label: setting.label || undefined,
            value: setting.value,
            isReadOnly: setting.isReadOnly,
        };
    });
    assert.deepEqual(expected, actual);
}
export async function assertThrowsRestError(testFunction, expectedStatusCode, message = "") {
    try {
        await testFunction();
        assert.fail(`${message}: No error thrown`);
    }
    catch (err) {
        if (!(err instanceof Error)) {
            throw new Error("Error is not recognized");
        }
        if (err.name === "RestError") {
            const restError = err;
            assert.equal(expectedStatusCode, restError.statusCode, message);
            return err;
        }
        assert.fail(`${message}: Caught error but wasn't a RestError: ${err}`);
    }
    return new Error("We won't reach this - both cases above throw because of assert.fail()");
}
export async function assertThrowsAbortError(testFunction, message = "") {
    try {
        await testFunction();
        assert.fail(`${message}: No error thrown`);
    }
    catch (e) {
        if (!(e instanceof Error)) {
            throw new Error("Error is not recognized");
        }
        if (isPlaybackMode() && (e.name === "FetchError" || e.name === "AbortError")) {
            return e;
        }
        else {
            assert.equal(e.name, "AbortError");
            return e;
        }
    }
}
/**
 * Assert 2 snapshots with name, retentionPeriod and filters are equal
 */
export function assertEqualSnapshot(snapshot1, snapshot2) {
    assert.equal(snapshot1.name, snapshot2.name, "Unexpected name in result from getSnapshot().");
    assert.equal(snapshot1.retentionPeriodInSeconds, snapshot2.retentionPeriodInSeconds, "Unexpected retentionPeriod in result from getSnapshot().");
    assert.deepEqual(snapshot1.filters, snapshot2.filters, "Unexpected filters in result from getSnapshot().");
}
//# sourceMappingURL=testHelpers.js.map
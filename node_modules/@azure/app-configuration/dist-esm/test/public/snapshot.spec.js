import { __asyncValues } from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { isPlaybackMode, testPollingOptions } from "@azure-tools/test-recorder";
import { assert } from "chai";
import { assertEqualSnapshot, assertThrowsAbortError, createAppConfigurationClientForTests, startRecorder, } from "./utils/testHelpers";
describe("AppConfigurationClient snapshot", () => {
    let client;
    let recorder;
    let key1;
    let key2;
    let configSetting1;
    let configSetting2;
    let snapshot1;
    let filter1;
    let filter2;
    let newSnapshot;
    beforeEach(async function () {
        recorder = await startRecorder(this);
        client = createAppConfigurationClientForTests(recorder.configureClientOptions({}));
        key1 = recorder.variable("key1", `key1-${new Date().getTime()}`);
        key2 = recorder.variable("key2", `key2-${new Date().getTime()}`);
        const label1 = "label1";
        const label2 = "label2";
        configSetting1 = {
            key: key1,
            label: label1,
        };
        configSetting2 = {
            key: key2,
            label: label2,
        };
        filter1 = {
            keyFilter: key1,
            labelFilter: label1,
        };
        filter2 = {
            keyFilter: key2,
            labelFilter: label2,
        };
        snapshot1 = {
            name: recorder.variable("snapshot1", `snapshot-${new Date().getTime()}`),
            retentionPeriodInSeconds: 2592000,
            filters: [filter1],
        };
        await client.addConfigurationSetting(Object.assign(Object.assign({}, configSetting1), { value: "value1" }));
        await client.addConfigurationSetting(Object.assign(Object.assign({}, configSetting2), { value: "value2" }));
    });
    afterEach(async function () {
        await client.deleteConfigurationSetting(Object.assign({}, configSetting1));
        await client.deleteConfigurationSetting(Object.assign({}, configSetting2));
        await recorder.stop();
    });
    describe("createSnapshot", () => {
        it("create a snapshot", async () => {
            const poller = await client.beginCreateSnapshot(snapshot1, testPollingOptions);
            newSnapshot = await poller.pollUntilDone();
            assertEqualSnapshot(newSnapshot, snapshot1);
            await client.archiveSnapshot(newSnapshot.name);
        });
        it("service throws error when tried to create a snapshot with same name", async () => {
            newSnapshot = await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
            assertEqualSnapshot(newSnapshot, snapshot1);
            const errorExpected = {
                type: "https://azconfig.io/errors/already-exists",
                title: "The resource already exists.",
                status: 409,
                detail: "",
            };
            // attempt to add the same snapshot
            try {
                await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
                throw new Error("Test failure");
            }
            catch (err) {
                assert.equal(err.message, JSON.stringify(errorExpected));
                assert.notEqual(err.message, "Test failure");
            }
            await client.archiveSnapshot(newSnapshot.name);
        });
        // Skipping all "accepts operation options flaky tests" https://github.com/Azure/azure-sdk-for-js/issues/26447
        it.skip("accepts  operation options", async function () {
            if (isPlaybackMode())
                this.skip();
            await assertThrowsAbortError(async () => {
                await client.beginCreateSnapshotAndWait(snapshot1, {
                    requestOptions: {
                        timeout: 1,
                    },
                    updateIntervalInMs: testPollingOptions.updateIntervalInMs,
                });
            });
        });
    });
    describe("listConfigurationSettings of a Snapshot", () => {
        it("list configuration settings", async () => {
            var _a, e_1, _b, _c;
            newSnapshot = await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
            await client.setConfigurationSetting(Object.assign(Object.assign({}, configSetting1), { value: "value2" }));
            const snapshotConfigurationSettings = client.listConfigurationSettingsForSnapshot(newSnapshot.name);
            try {
                for (var _d = true, snapshotConfigurationSettings_1 = __asyncValues(snapshotConfigurationSettings), snapshotConfigurationSettings_1_1; snapshotConfigurationSettings_1_1 = await snapshotConfigurationSettings_1.next(), _a = snapshotConfigurationSettings_1_1.done, !_a; _d = true) {
                    _c = snapshotConfigurationSettings_1_1.value;
                    _d = false;
                    const setting = _c;
                    assert.equal(setting.key, key1);
                    assert.equal(setting.label, "label1");
                    assert.equal(setting.value, "value1", "Should not get the updated value of the setting");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = snapshotConfigurationSettings_1.return)) await _b.call(snapshotConfigurationSettings_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            await client.archiveSnapshot(newSnapshot.name);
        });
    });
    describe("archiveSnapshot", () => {
        it("archive a snapshot", async () => {
            newSnapshot = await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
            const archivedSnapshot = await client.archiveSnapshot(newSnapshot.name);
            assert.equal(archivedSnapshot.status, "archived", "Unexpected status in result from archiveSnapshot().");
        });
        it.skip("accepts operation options", async function () {
            if (isPlaybackMode())
                this.skip();
            await assertThrowsAbortError(async () => {
                await client.archiveSnapshot(newSnapshot.name, {
                    requestOptions: {
                        timeout: 1,
                    },
                });
            });
        });
    });
    describe("recoverSnapshot", () => {
        it("recover a snapshot", async () => {
            newSnapshot = await client.beginCreateSnapshotAndWait(snapshot1);
            const archivedSnapshot = await client.archiveSnapshot(newSnapshot.name);
            const unarchivedSnapshot = await client.recoverSnapshot(archivedSnapshot.name);
            assert.equal(unarchivedSnapshot.status, "ready", "Unexpected status in result from archiveSnapshot().");
            await client.archiveSnapshot(newSnapshot.name);
        });
        it.skip("accepts operation options", async function () {
            if (isPlaybackMode())
                this.skip();
            await assertThrowsAbortError(async () => {
                await client.recoverSnapshot(newSnapshot.name, {
                    requestOptions: {
                        timeout: 1,
                    },
                });
            });
        });
    });
    describe("getSnapshot", () => {
        it("get a snapshot", async () => {
            newSnapshot = await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
            const snapshot = await client.getSnapshot(newSnapshot.name);
            assertEqualSnapshot(snapshot, newSnapshot);
            await client.archiveSnapshot(newSnapshot.name);
        });
        // Check issue https://github.com/Azure/azure-sdk-for-js/issues/26447
        it.skip("accepts operation options", async function () {
            if (isPlaybackMode())
                this.skip();
            newSnapshot = await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
            await assertThrowsAbortError(async () => {
                await client.getSnapshot(newSnapshot.name, {
                    requestOptions: {
                        timeout: 1,
                    },
                });
            });
            await client.archiveSnapshot(newSnapshot.name);
        });
    });
    describe("listSnapshots", () => {
        it("list all snapshots with ready filter", async function () {
            var _a, e_2, _b, _c, _d, e_3, _e, _f, _g, e_4, _h, _j;
            const list = client.listSnapshots();
            try {
                for (var _k = true, list_1 = __asyncValues(list), list_1_1; list_1_1 = await list_1.next(), _a = list_1_1.done, !_a; _k = true) {
                    _c = list_1_1.value;
                    _k = false;
                    const snapshot = _c;
                    await client.archiveSnapshot(snapshot.name);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_k && !_a && (_b = list_1.return)) await _b.call(list_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            const readyList = client.listSnapshots({ statusFilter: ["ready"] });
            let num = 0;
            try {
                for (var _l = true, readyList_1 = __asyncValues(readyList), readyList_1_1; readyList_1_1 = await readyList_1.next(), _d = readyList_1_1.done, !_d; _l = true) {
                    _f = readyList_1_1.value;
                    _l = false;
                    const snapshot = _f;
                    assert.equal(snapshot, undefined, "There should be no snapshot in ready status");
                    num++;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_l && !_d && (_e = readyList_1.return)) await _e.call(readyList_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            assert.equal(num, 0, "There should be no snapshot in ready status");
            await client.beginCreateSnapshotAndWait(snapshot1, testPollingOptions);
            const snapshot2 = {
                name: recorder.variable("snapshot2", `snapshot-${new Date().getTime()}`),
                filters: [filter1, filter2],
            };
            await client.beginCreateSnapshotAndWait(snapshot2, testPollingOptions);
            const listAfter = await client.listSnapshots({ statusFilter: ["ready"] });
            let total = 0;
            try {
                for (var _m = true, listAfter_1 = __asyncValues(listAfter), listAfter_1_1; listAfter_1_1 = await listAfter_1.next(), _g = listAfter_1_1.done, !_g; _m = true) {
                    _j = listAfter_1_1.value;
                    _m = false;
                    const snapshot = _j;
                    await client.archiveSnapshot(snapshot.name);
                    total++;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_m && !_g && (_h = listAfter_1.return)) await _h.call(listAfter_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            assert.equal(total, 2, "Unexpected number of snapshots in result from listSnapshots().");
        });
    });
});
//# sourceMappingURL=snapshot.spec.js.map
const MiB = 1048576;
export class TreeHash {
    constructor(Sha256, fromUtf8) {
        this.Sha256 = Sha256;
        this.fromUtf8 = fromUtf8;
        this.collectedHashDigests = [];
    }
    hashBuffer() {
        if (!this.buffer) {
            return;
        }
        let remainingSize = this.buffer.byteLength;
        while (remainingSize >= MiB) {
            const hash = new this.Sha256();
            hash.update(this.buffer.subarray(0, MiB));
            this.collectedHashDigests.push(hash.digest());
            this.buffer = this.buffer.subarray(MiB);
            remainingSize = this.buffer.byteLength;
        }
    }
    update(data) {
        const chunk = this.convertToBuffer(data);
        if (!this.buffer) {
            this.buffer = chunk;
        }
        else {
            const totalSize = this.buffer.byteLength + chunk.byteLength;
            const tempBuffer = new Uint8Array(totalSize);
            tempBuffer.set(this.buffer);
            tempBuffer.set(chunk, this.buffer.byteLength);
            this.buffer = tempBuffer;
        }
        this.hashBuffer();
    }
    async digest() {
        let collectedHashDigests = this.collectedHashDigests;
        this.collectedHashDigests = [];
        if (this.buffer && this.buffer.byteLength > 0) {
            const smallHash = new this.Sha256();
            smallHash.update(this.buffer);
            collectedHashDigests.push(smallHash.digest());
            this.buffer = void 0;
        }
        while (collectedHashDigests.length > 1) {
            const higherLevelHashDigests = [];
            for (let i = 0; i < collectedHashDigests.length; i += 2) {
                if (i + 1 < collectedHashDigests.length) {
                    const [digest1, digest2] = await Promise.all([collectedHashDigests[i], collectedHashDigests[i + 1]]);
                    const chunk = new Uint8Array(digest1.byteLength + digest2.byteLength);
                    chunk.set(digest1);
                    chunk.set(digest2, digest1.byteLength);
                    const hash = new this.Sha256();
                    hash.update(chunk);
                    higherLevelHashDigests.push(hash.digest());
                }
                else {
                    higherLevelHashDigests.push(collectedHashDigests[i]);
                }
            }
            collectedHashDigests = higherLevelHashDigests;
        }
        return collectedHashDigests[0];
    }
    convertToBuffer(data) {
        if (typeof data === "string") {
            return this.fromUtf8(data);
        }
        if (ArrayBuffer.isView(data)) {
            return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
        }
        return new Uint8Array(data);
    }
    reset() {
        this.buffer = undefined;
        this.collectedHashDigests = [];
    }
}

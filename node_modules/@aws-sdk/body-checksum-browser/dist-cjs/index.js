"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  bodyChecksumGenerator: () => bodyChecksumGenerator
});
module.exports = __toCommonJS(src_exports);
var import_sha256_tree_hash = require("@aws-sdk/sha256-tree-hash");
var import_chunked_blob_reader = require("@smithy/chunked-blob-reader");
var import_util_hex_encoding = require("@smithy/util-hex-encoding");
var import_util_utf8 = require("@smithy/util-utf8");
var MiB = 1024 * 1024;
async function bodyChecksumGenerator(request, options) {
  const contentHash = new options.sha256();
  const treeHash = new import_sha256_tree_hash.TreeHash(options.sha256, options.utf8Decoder);
  const { body } = request;
  if (typeof body === "string") {
    contentHash.update((0, import_util_utf8.toUint8Array)(body));
    treeHash.update(body);
  } else {
    if (Boolean(body) && Object.prototype.toString.call(body) === "[object Blob]") {
      await (0, import_chunked_blob_reader.blobReader)(
        body,
        (chunk) => {
          treeHash == null ? void 0 : treeHash.update(chunk);
          contentHash == null ? void 0 : contentHash.update(chunk);
        },
        MiB
      );
    } else {
      throw new Error("Unable to calculate checksums for non-blob streams.");
    }
  }
  return [(0, import_util_hex_encoding.toHex)(await contentHash.digest()), (0, import_util_hex_encoding.toHex)(await treeHash.digest())];
}
__name(bodyChecksumGenerator, "bodyChecksumGenerator");
// Annotate the CommonJS export names for ESM import in node:

0 && (module.exports = {
  bodyChecksumGenerator
});


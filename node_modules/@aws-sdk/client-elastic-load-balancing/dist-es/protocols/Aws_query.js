import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { ElasticLoadBalancingServiceException as __BaseException } from "../models/ElasticLoadBalancingServiceException";
import { AccessPointNotFoundException, CertificateNotFoundException, DependencyThrottleException, DuplicateAccessPointNameException, DuplicateListenerException, DuplicatePolicyNameException, DuplicateTagKeysException, InvalidConfigurationRequestException, InvalidEndPointException, InvalidSchemeException, InvalidSecurityGroupException, InvalidSubnetException, ListenerNotFoundException, LoadBalancerAttributeNotFoundException, OperationNotPermittedException, PolicyNotFoundException, PolicyTypeNotFoundException, SubnetNotFoundException, TooManyAccessPointsException, TooManyPoliciesException, TooManyTagsException, UnsupportedProtocolException, } from "../models/models_0";
export const se_AddTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddTagsInput(input, context),
        [_A]: _AT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ApplySecurityGroupsToLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ApplySecurityGroupsToLoadBalancerInput(input, context),
        [_A]: _ASGTLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachLoadBalancerToSubnetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachLoadBalancerToSubnetsInput(input, context),
        [_A]: _ALBTS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ConfigureHealthCheckCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ConfigureHealthCheckInput(input, context),
        [_A]: _CHC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAppCookieStickinessPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAppCookieStickinessPolicyInput(input, context),
        [_A]: _CACSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLBCookieStickinessPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLBCookieStickinessPolicyInput(input, context),
        [_A]: _CLBCSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccessPointInput(input, context),
        [_A]: _CLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLoadBalancerListenersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoadBalancerListenerInput(input, context),
        [_A]: _CLBL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLoadBalancerPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoadBalancerPolicyInput(input, context),
        [_A]: _CLBP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccessPointInput(input, context),
        [_A]: _DLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLoadBalancerListenersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoadBalancerListenerInput(input, context),
        [_A]: _DLBL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLoadBalancerPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoadBalancerPolicyInput(input, context),
        [_A]: _DLBP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeregisterInstancesFromLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterEndPointsInput(input, context),
        [_A]: _DIFLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAccountLimitsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAccountLimitsInput(input, context),
        [_A]: _DAL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInstanceHealthCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEndPointStateInput(input, context),
        [_A]: _DIH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerAttributesInput(input, context),
        [_A]: _DLBA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancerPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerPoliciesInput(input, context),
        [_A]: _DLBPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancerPolicyTypesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerPolicyTypesInput(input, context),
        [_A]: _DLBPT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAccessPointsInput(input, context),
        [_A]: _DLBe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsInput(input, context),
        [_A]: _DT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachLoadBalancerFromSubnetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachLoadBalancerFromSubnetsInput(input, context),
        [_A]: _DLBFS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableAvailabilityZonesForLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveAvailabilityZonesInput(input, context),
        [_A]: _DAZFLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableAvailabilityZonesForLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddAvailabilityZonesInput(input, context),
        [_A]: _EAZFLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyLoadBalancerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyLoadBalancerAttributesInput(input, context),
        [_A]: _MLBA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RegisterInstancesWithLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterEndPointsInput(input, context),
        [_A]: _RIWLB,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveTagsInput(input, context),
        [_A]: _RT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetLoadBalancerListenerSSLCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetLoadBalancerListenerSSLCertificateInput(input, context),
        [_A]: _SLBLSSLC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetLoadBalancerPoliciesForBackendServerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetLoadBalancerPoliciesForBackendServerInput(input, context),
        [_A]: _SLBPFBS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetLoadBalancerPoliciesOfListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetLoadBalancerPoliciesOfListenerInput(input, context),
        [_A]: _SLBPOL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddTagsOutput(data.AddTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ApplySecurityGroupsToLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ApplySecurityGroupsToLoadBalancerOutput(data.ApplySecurityGroupsToLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AttachLoadBalancerToSubnetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AttachLoadBalancerToSubnetsOutput(data.AttachLoadBalancerToSubnetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ConfigureHealthCheckCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ConfigureHealthCheckOutput(data.ConfigureHealthCheckResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateAppCookieStickinessPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAppCookieStickinessPolicyOutput(data.CreateAppCookieStickinessPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLBCookieStickinessPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLBCookieStickinessPolicyOutput(data.CreateLBCookieStickinessPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAccessPointOutput(data.CreateLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLoadBalancerListenersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoadBalancerListenerOutput(data.CreateLoadBalancerListenersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateLoadBalancerPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoadBalancerPolicyOutput(data.CreateLoadBalancerPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAccessPointOutput(data.DeleteLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLoadBalancerListenersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLoadBalancerListenerOutput(data.DeleteLoadBalancerListenersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteLoadBalancerPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLoadBalancerPolicyOutput(data.DeleteLoadBalancerPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeregisterInstancesFromLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterEndPointsOutput(data.DeregisterInstancesFromLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAccountLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccountLimitsOutput(data.DescribeAccountLimitsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInstanceHealthCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEndPointStateOutput(data.DescribeInstanceHealthResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerAttributesOutput(data.DescribeLoadBalancerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancerPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerPoliciesOutput(data.DescribeLoadBalancerPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancerPolicyTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerPolicyTypesOutput(data.DescribeLoadBalancerPolicyTypesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccessPointsOutput(data.DescribeLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTagsOutput(data.DescribeTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DetachLoadBalancerFromSubnetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DetachLoadBalancerFromSubnetsOutput(data.DetachLoadBalancerFromSubnetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableAvailabilityZonesForLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveAvailabilityZonesOutput(data.DisableAvailabilityZonesForLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableAvailabilityZonesForLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddAvailabilityZonesOutput(data.EnableAvailabilityZonesForLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyLoadBalancerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyLoadBalancerAttributesOutput(data.ModifyLoadBalancerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RegisterInstancesWithLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterEndPointsOutput(data.RegisterInstancesWithLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RemoveTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveTagsOutput(data.RemoveTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetLoadBalancerListenerSSLCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetLoadBalancerListenerSSLCertificateOutput(data.SetLoadBalancerListenerSSLCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetLoadBalancerPoliciesForBackendServerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetLoadBalancerPoliciesForBackendServerOutput(data.SetLoadBalancerPoliciesForBackendServerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetLoadBalancerPoliciesOfListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetLoadBalancerPoliciesOfListenerOutput(data.SetLoadBalancerPoliciesOfListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateTagKeys":
        case "com.amazonaws.elasticloadbalancing#DuplicateTagKeysException":
            throw await de_DuplicateTagKeysExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancing#AccessPointNotFoundException":
            throw await de_AccessPointNotFoundExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancing#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancing#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidSecurityGroup":
        case "com.amazonaws.elasticloadbalancing#InvalidSecurityGroupException":
            throw await de_InvalidSecurityGroupExceptionRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.elasticloadbalancing#InvalidSubnetException":
            throw await de_InvalidSubnetExceptionRes(parsedOutput, context);
        case "SubnetNotFound":
        case "com.amazonaws.elasticloadbalancing#SubnetNotFoundException":
            throw await de_SubnetNotFoundExceptionRes(parsedOutput, context);
        case "DuplicatePolicyName":
        case "com.amazonaws.elasticloadbalancing#DuplicatePolicyNameException":
            throw await de_DuplicatePolicyNameExceptionRes(parsedOutput, context);
        case "TooManyPolicies":
        case "com.amazonaws.elasticloadbalancing#TooManyPoliciesException":
            throw await de_TooManyPoliciesExceptionRes(parsedOutput, context);
        case "CertificateNotFound":
        case "com.amazonaws.elasticloadbalancing#CertificateNotFoundException":
            throw await de_CertificateNotFoundExceptionRes(parsedOutput, context);
        case "DuplicateLoadBalancerName":
        case "com.amazonaws.elasticloadbalancing#DuplicateAccessPointNameException":
            throw await de_DuplicateAccessPointNameExceptionRes(parsedOutput, context);
        case "InvalidScheme":
        case "com.amazonaws.elasticloadbalancing#InvalidSchemeException":
            throw await de_InvalidSchemeExceptionRes(parsedOutput, context);
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancing#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "TooManyLoadBalancers":
        case "com.amazonaws.elasticloadbalancing#TooManyAccessPointsException":
            throw await de_TooManyAccessPointsExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancing#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        case "DuplicateListener":
        case "com.amazonaws.elasticloadbalancing#DuplicateListenerException":
            throw await de_DuplicateListenerExceptionRes(parsedOutput, context);
        case "PolicyTypeNotFound":
        case "com.amazonaws.elasticloadbalancing#PolicyTypeNotFoundException":
            throw await de_PolicyTypeNotFoundExceptionRes(parsedOutput, context);
        case "InvalidInstance":
        case "com.amazonaws.elasticloadbalancing#InvalidEndPointException":
            throw await de_InvalidEndPointExceptionRes(parsedOutput, context);
        case "LoadBalancerAttributeNotFound":
        case "com.amazonaws.elasticloadbalancing#LoadBalancerAttributeNotFoundException":
            throw await de_LoadBalancerAttributeNotFoundExceptionRes(parsedOutput, context);
        case "PolicyNotFound":
        case "com.amazonaws.elasticloadbalancing#PolicyNotFoundException":
            throw await de_PolicyNotFoundExceptionRes(parsedOutput, context);
        case "DependencyThrottle":
        case "com.amazonaws.elasticloadbalancing#DependencyThrottleException":
            throw await de_DependencyThrottleExceptionRes(parsedOutput, context);
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancing#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AccessPointNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AccessPointNotFoundException(body.Error, context);
    const exception = new AccessPointNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CertificateNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CertificateNotFoundException(body.Error, context);
    const exception = new CertificateNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DependencyThrottleExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DependencyThrottleException(body.Error, context);
    const exception = new DependencyThrottleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateAccessPointNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateAccessPointNameException(body.Error, context);
    const exception = new DuplicateAccessPointNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateListenerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateListenerException(body.Error, context);
    const exception = new DuplicateListenerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicatePolicyNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicatePolicyNameException(body.Error, context);
    const exception = new DuplicatePolicyNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateTagKeysExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateTagKeysException(body.Error, context);
    const exception = new DuplicateTagKeysException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidConfigurationRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidConfigurationRequestException(body.Error, context);
    const exception = new InvalidConfigurationRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidEndPointExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidEndPointException(body.Error, context);
    const exception = new InvalidEndPointException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSchemeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSchemeException(body.Error, context);
    const exception = new InvalidSchemeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSecurityGroupExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSecurityGroupException(body.Error, context);
    const exception = new InvalidSecurityGroupException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubnetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubnetException(body.Error, context);
    const exception = new InvalidSubnetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ListenerNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ListenerNotFoundException(body.Error, context);
    const exception = new ListenerNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LoadBalancerAttributeNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LoadBalancerAttributeNotFoundException(body.Error, context);
    const exception = new LoadBalancerAttributeNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_OperationNotPermittedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OperationNotPermittedException(body.Error, context);
    const exception = new OperationNotPermittedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PolicyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyNotFoundException(body.Error, context);
    const exception = new PolicyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PolicyTypeNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyTypeNotFoundException(body.Error, context);
    const exception = new PolicyTypeNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetNotFoundException(body.Error, context);
    const exception = new SubnetNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyAccessPointsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyAccessPointsException(body.Error, context);
    const exception = new TooManyAccessPointsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyPoliciesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyPoliciesException(body.Error, context);
    const exception = new TooManyPoliciesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTagsException(body.Error, context);
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedProtocolExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedProtocolException(body.Error, context);
    const exception = new UnsupportedProtocolException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AccessLog = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_SBN] != null) {
        entries[_SBN] = input[_SBN];
    }
    if (input[_EI] != null) {
        entries[_EI] = input[_EI];
    }
    if (input[_SBP] != null) {
        entries[_SBP] = input[_SBP];
    }
    return entries;
};
const se_AddAvailabilityZonesInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AdditionalAttribute = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_AdditionalAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AdditionalAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AddTagsInput = (input, context) => {
    const entries = {};
    if (input[_LBNo] != null) {
        const memberEntries = se_LoadBalancerNames(input[_LBNo], context);
        if (input[_LBNo]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ApplySecurityGroupsToLoadBalancerInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroups(input[_SG], context);
        if (input[_SG]?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AttachLoadBalancerToSubnetsInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_S] != null) {
        const memberEntries = se_Subnets(input[_S], context);
        if (input[_S]?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AvailabilityZones = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ConfigureHealthCheckInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_HC] != null) {
        const memberEntries = se_HealthCheck(input[_HC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HealthCheck.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ConnectionDraining = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_Ti] != null) {
        entries[_Ti] = input[_Ti];
    }
    return entries;
};
const se_ConnectionSettings = (input, context) => {
    const entries = {};
    if (input[_IT] != null) {
        entries[_IT] = input[_IT];
    }
    return entries;
};
const se_CreateAccessPointInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_L] != null) {
        const memberEntries = se_Listeners(input[_L], context);
        if (input[_L]?.length === 0) {
            entries.Listeners = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Listeners.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        const memberEntries = se_Subnets(input[_S], context);
        if (input[_S]?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SG] != null) {
        const memberEntries = se_SecurityGroups(input[_SG], context);
        if (input[_SG]?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateAppCookieStickinessPolicyInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_CN] != null) {
        entries[_CN] = input[_CN];
    }
    return entries;
};
const se_CreateLBCookieStickinessPolicyInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_CEP] != null) {
        entries[_CEP] = input[_CEP];
    }
    return entries;
};
const se_CreateLoadBalancerListenerInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_L] != null) {
        const memberEntries = se_Listeners(input[_L], context);
        if (input[_L]?.length === 0) {
            entries.Listeners = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Listeners.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLoadBalancerPolicyInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_PTN] != null) {
        entries[_PTN] = input[_PTN];
    }
    if (input[_PA] != null) {
        const memberEntries = se_PolicyAttributes(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyAttributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyAttributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CrossZoneLoadBalancing = (input, context) => {
    const entries = {};
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    return entries;
};
const se_DeleteAccessPointInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    return entries;
};
const se_DeleteLoadBalancerListenerInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_LBP] != null) {
        const memberEntries = se_Ports(input[_LBP], context);
        if (input[_LBP]?.length === 0) {
            entries.LoadBalancerPorts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerPorts.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteLoadBalancerPolicyInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_DeregisterEndPointsInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_I] != null) {
        const memberEntries = se_Instances(input[_I], context);
        if (input[_I]?.length === 0) {
            entries.Instances = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Instances.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAccessPointsInput = (input, context) => {
    const entries = {};
    if (input[_LBNo] != null) {
        const memberEntries = se_LoadBalancerNames(input[_LBNo], context);
        if (input[_LBNo]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeAccountLimitsInput = (input, context) => {
    const entries = {};
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_PS] != null) {
        entries[_PS] = input[_PS];
    }
    return entries;
};
const se_DescribeEndPointStateInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_I] != null) {
        const memberEntries = se_Instances(input[_I], context);
        if (input[_I]?.length === 0) {
            entries.Instances = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Instances.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeLoadBalancerAttributesInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    return entries;
};
const se_DescribeLoadBalancerPoliciesInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_PNo] != null) {
        const memberEntries = se_PolicyNames(input[_PNo], context);
        if (input[_PNo]?.length === 0) {
            entries.PolicyNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeLoadBalancerPolicyTypesInput = (input, context) => {
    const entries = {};
    if (input[_PTNo] != null) {
        const memberEntries = se_PolicyTypeNames(input[_PTNo], context);
        if (input[_PTNo]?.length === 0) {
            entries.PolicyTypeNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyTypeNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeTagsInput = (input, context) => {
    const entries = {};
    if (input[_LBNo] != null) {
        const memberEntries = se_LoadBalancerNamesMax20(input[_LBNo], context);
        if (input[_LBNo]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DetachLoadBalancerFromSubnetsInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_S] != null) {
        const memberEntries = se_Subnets(input[_S], context);
        if (input[_S]?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_HealthCheck = (input, context) => {
    const entries = {};
    if (input[_Ta] != null) {
        entries[_Ta] = input[_Ta];
    }
    if (input[_In] != null) {
        entries[_In] = input[_In];
    }
    if (input[_Ti] != null) {
        entries[_Ti] = input[_Ti];
    }
    if (input[_UT] != null) {
        entries[_UT] = input[_UT];
    }
    if (input[_HT] != null) {
        entries[_HT] = input[_HT];
    }
    return entries;
};
const se_Instance = (input, context) => {
    const entries = {};
    if (input[_II] != null) {
        entries[_II] = input[_II];
    }
    return entries;
};
const se_Instances = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Instance(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Listener = (input, context) => {
    const entries = {};
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_LBPo] != null) {
        entries[_LBPo] = input[_LBPo];
    }
    if (input[_IP] != null) {
        entries[_IP] = input[_IP];
    }
    if (input[_IPn] != null) {
        entries[_IPn] = input[_IPn];
    }
    if (input[_SSLCI] != null) {
        entries[_SSLCI] = input[_SSLCI];
    }
    return entries;
};
const se_Listeners = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Listener(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LoadBalancerAttributes = (input, context) => {
    const entries = {};
    if (input[_CZLB] != null) {
        const memberEntries = se_CrossZoneLoadBalancing(input[_CZLB], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `CrossZoneLoadBalancing.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AL] != null) {
        const memberEntries = se_AccessLog(input[_AL], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AccessLog.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CD] != null) {
        const memberEntries = se_ConnectionDraining(input[_CD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionDraining.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CS] != null) {
        const memberEntries = se_ConnectionSettings(input[_CS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ConnectionSettings.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AA] != null) {
        const memberEntries = se_AdditionalAttributes(input[_AA], context);
        if (input[_AA]?.length === 0) {
            entries.AdditionalAttributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AdditionalAttributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_LoadBalancerNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LoadBalancerNamesMax20 = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ModifyLoadBalancerAttributesInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_LBA] != null) {
        const memberEntries = se_LoadBalancerAttributes(input[_LBA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerAttributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PolicyAttribute = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        entries[_AN] = input[_AN];
    }
    if (input[_AV] != null) {
        entries[_AV] = input[_AV];
    }
    return entries;
};
const se_PolicyAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PolicyAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_PolicyTypeNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Ports = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RegisterEndPointsInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_I] != null) {
        const memberEntries = se_Instances(input[_I], context);
        if (input[_I]?.length === 0) {
            entries.Instances = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Instances.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveAvailabilityZonesInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_AZ] != null) {
        const memberEntries = se_AvailabilityZones(input[_AZ], context);
        if (input[_AZ]?.length === 0) {
            entries.AvailabilityZones = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AvailabilityZones.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveTagsInput = (input, context) => {
    const entries = {};
    if (input[_LBNo] != null) {
        const memberEntries = se_LoadBalancerNames(input[_LBNo], context);
        if (input[_LBNo]?.length === 0) {
            entries.LoadBalancerNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagKeyList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetLoadBalancerListenerSSLCertificateInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_LBPo] != null) {
        entries[_LBPo] = input[_LBPo];
    }
    if (input[_SSLCI] != null) {
        entries[_SSLCI] = input[_SSLCI];
    }
    return entries;
};
const se_SetLoadBalancerPoliciesForBackendServerInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_IPn] != null) {
        entries[_IPn] = input[_IPn];
    }
    if (input[_PNo] != null) {
        const memberEntries = se_PolicyNames(input[_PNo], context);
        if (input[_PNo]?.length === 0) {
            entries.PolicyNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SetLoadBalancerPoliciesOfListenerInput = (input, context) => {
    const entries = {};
    if (input[_LBN] != null) {
        entries[_LBN] = input[_LBN];
    }
    if (input[_LBPo] != null) {
        entries[_LBPo] = input[_LBPo];
    }
    if (input[_PNo] != null) {
        const memberEntries = se_PolicyNames(input[_PNo], context);
        if (input[_PNo]?.length === 0) {
            entries.PolicyNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Subnets = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_TagKeyList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TagKeyOnly(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagKeyOnly = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const de_AccessLog = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __parseBoolean(output[_E]);
    }
    if (output[_SBN] != null) {
        contents[_SBN] = __expectString(output[_SBN]);
    }
    if (output[_EI] != null) {
        contents[_EI] = __strictParseInt32(output[_EI]);
    }
    if (output[_SBP] != null) {
        contents[_SBP] = __expectString(output[_SBP]);
    }
    return contents;
};
const de_AccessPointNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_AddAvailabilityZonesOutput = (output, context) => {
    const contents = {};
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_m] != null) {
        contents[_AZ] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZ][_m]), context);
    }
    return contents;
};
const de_AdditionalAttribute = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Va] != null) {
        contents[_Va] = __expectString(output[_Va]);
    }
    return contents;
};
const de_AdditionalAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdditionalAttribute(entry, context);
    });
};
const de_AddTagsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_AppCookieStickinessPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AppCookieStickinessPolicy(entry, context);
    });
};
const de_AppCookieStickinessPolicy = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_CN] != null) {
        contents[_CN] = __expectString(output[_CN]);
    }
    return contents;
};
const de_ApplySecurityGroupsToLoadBalancerOutput = (output, context) => {
    const contents = {};
    if (output.SecurityGroups === "") {
        contents[_SG] = [];
    }
    else if (output[_SG] != null && output[_SG][_m] != null) {
        contents[_SG] = de_SecurityGroups(__getArrayIfSingleItem(output[_SG][_m]), context);
    }
    return contents;
};
const de_AttachLoadBalancerToSubnetsOutput = (output, context) => {
    const contents = {};
    if (output.Subnets === "") {
        contents[_S] = [];
    }
    else if (output[_S] != null && output[_S][_m] != null) {
        contents[_S] = de_Subnets(__getArrayIfSingleItem(output[_S][_m]), context);
    }
    return contents;
};
const de_AvailabilityZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_BackendServerDescription = (output, context) => {
    const contents = {};
    if (output[_IPn] != null) {
        contents[_IPn] = __strictParseInt32(output[_IPn]);
    }
    if (output.PolicyNames === "") {
        contents[_PNo] = [];
    }
    else if (output[_PNo] != null && output[_PNo][_m] != null) {
        contents[_PNo] = de_PolicyNames(__getArrayIfSingleItem(output[_PNo][_m]), context);
    }
    return contents;
};
const de_BackendServerDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BackendServerDescription(entry, context);
    });
};
const de_CertificateNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_ConfigureHealthCheckOutput = (output, context) => {
    const contents = {};
    if (output[_HC] != null) {
        contents[_HC] = de_HealthCheck(output[_HC], context);
    }
    return contents;
};
const de_ConnectionDraining = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __parseBoolean(output[_E]);
    }
    if (output[_Ti] != null) {
        contents[_Ti] = __strictParseInt32(output[_Ti]);
    }
    return contents;
};
const de_ConnectionSettings = (output, context) => {
    const contents = {};
    if (output[_IT] != null) {
        contents[_IT] = __strictParseInt32(output[_IT]);
    }
    return contents;
};
const de_CreateAccessPointOutput = (output, context) => {
    const contents = {};
    if (output[_DNSN] != null) {
        contents[_DNSN] = __expectString(output[_DNSN]);
    }
    return contents;
};
const de_CreateAppCookieStickinessPolicyOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_CreateLBCookieStickinessPolicyOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_CreateLoadBalancerListenerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_CreateLoadBalancerPolicyOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_CrossZoneLoadBalancing = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = __parseBoolean(output[_E]);
    }
    return contents;
};
const de_DeleteAccessPointOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteLoadBalancerListenerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteLoadBalancerPolicyOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DependencyThrottleException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DeregisterEndPointsOutput = (output, context) => {
    const contents = {};
    if (output.Instances === "") {
        contents[_I] = [];
    }
    else if (output[_I] != null && output[_I][_m] != null) {
        contents[_I] = de_Instances(__getArrayIfSingleItem(output[_I][_m]), context);
    }
    return contents;
};
const de_DescribeAccessPointsOutput = (output, context) => {
    const contents = {};
    if (output.LoadBalancerDescriptions === "") {
        contents[_LBD] = [];
    }
    else if (output[_LBD] != null && output[_LBD][_m] != null) {
        contents[_LBD] = de_LoadBalancerDescriptions(__getArrayIfSingleItem(output[_LBD][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeAccountLimitsOutput = (output, context) => {
    const contents = {};
    if (output.Limits === "") {
        contents[_Li] = [];
    }
    else if (output[_Li] != null && output[_Li][_m] != null) {
        contents[_Li] = de_Limits(__getArrayIfSingleItem(output[_Li][_m]), context);
    }
    if (output[_NM] != null) {
        contents[_NM] = __expectString(output[_NM]);
    }
    return contents;
};
const de_DescribeEndPointStateOutput = (output, context) => {
    const contents = {};
    if (output.InstanceStates === "") {
        contents[_IS] = [];
    }
    else if (output[_IS] != null && output[_IS][_m] != null) {
        contents[_IS] = de_InstanceStates(__getArrayIfSingleItem(output[_IS][_m]), context);
    }
    return contents;
};
const de_DescribeLoadBalancerAttributesOutput = (output, context) => {
    const contents = {};
    if (output[_LBA] != null) {
        contents[_LBA] = de_LoadBalancerAttributes(output[_LBA], context);
    }
    return contents;
};
const de_DescribeLoadBalancerPoliciesOutput = (output, context) => {
    const contents = {};
    if (output.PolicyDescriptions === "") {
        contents[_PD] = [];
    }
    else if (output[_PD] != null && output[_PD][_m] != null) {
        contents[_PD] = de_PolicyDescriptions(__getArrayIfSingleItem(output[_PD][_m]), context);
    }
    return contents;
};
const de_DescribeLoadBalancerPolicyTypesOutput = (output, context) => {
    const contents = {};
    if (output.PolicyTypeDescriptions === "") {
        contents[_PTD] = [];
    }
    else if (output[_PTD] != null && output[_PTD][_m] != null) {
        contents[_PTD] = de_PolicyTypeDescriptions(__getArrayIfSingleItem(output[_PTD][_m]), context);
    }
    return contents;
};
const de_DescribeTagsOutput = (output, context) => {
    const contents = {};
    if (output.TagDescriptions === "") {
        contents[_TD] = [];
    }
    else if (output[_TD] != null && output[_TD][_m] != null) {
        contents[_TD] = de_TagDescriptions(__getArrayIfSingleItem(output[_TD][_m]), context);
    }
    return contents;
};
const de_DetachLoadBalancerFromSubnetsOutput = (output, context) => {
    const contents = {};
    if (output.Subnets === "") {
        contents[_S] = [];
    }
    else if (output[_S] != null && output[_S][_m] != null) {
        contents[_S] = de_Subnets(__getArrayIfSingleItem(output[_S][_m]), context);
    }
    return contents;
};
const de_DuplicateAccessPointNameException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicateListenerException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicatePolicyNameException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_DuplicateTagKeysException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_HealthCheck = (output, context) => {
    const contents = {};
    if (output[_Ta] != null) {
        contents[_Ta] = __expectString(output[_Ta]);
    }
    if (output[_In] != null) {
        contents[_In] = __strictParseInt32(output[_In]);
    }
    if (output[_Ti] != null) {
        contents[_Ti] = __strictParseInt32(output[_Ti]);
    }
    if (output[_UT] != null) {
        contents[_UT] = __strictParseInt32(output[_UT]);
    }
    if (output[_HT] != null) {
        contents[_HT] = __strictParseInt32(output[_HT]);
    }
    return contents;
};
const de_Instance = (output, context) => {
    const contents = {};
    if (output[_II] != null) {
        contents[_II] = __expectString(output[_II]);
    }
    return contents;
};
const de_Instances = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Instance(entry, context);
    });
};
const de_InstanceState = (output, context) => {
    const contents = {};
    if (output[_II] != null) {
        contents[_II] = __expectString(output[_II]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_RC] != null) {
        contents[_RC] = __expectString(output[_RC]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    return contents;
};
const de_InstanceStates = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceState(entry, context);
    });
};
const de_InvalidConfigurationRequestException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidEndPointException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidSchemeException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidSecurityGroupException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_InvalidSubnetException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_LBCookieStickinessPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LBCookieStickinessPolicy(entry, context);
    });
};
const de_LBCookieStickinessPolicy = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_CEP] != null) {
        contents[_CEP] = __strictParseLong(output[_CEP]);
    }
    return contents;
};
const de_Limit = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __expectString(output[_Ma]);
    }
    return contents;
};
const de_Limits = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Limit(entry, context);
    });
};
const de_Listener = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = __expectString(output[_P]);
    }
    if (output[_LBPo] != null) {
        contents[_LBPo] = __strictParseInt32(output[_LBPo]);
    }
    if (output[_IP] != null) {
        contents[_IP] = __expectString(output[_IP]);
    }
    if (output[_IPn] != null) {
        contents[_IPn] = __strictParseInt32(output[_IPn]);
    }
    if (output[_SSLCI] != null) {
        contents[_SSLCI] = __expectString(output[_SSLCI]);
    }
    return contents;
};
const de_ListenerDescription = (output, context) => {
    const contents = {};
    if (output[_Lis] != null) {
        contents[_Lis] = de_Listener(output[_Lis], context);
    }
    if (output.PolicyNames === "") {
        contents[_PNo] = [];
    }
    else if (output[_PNo] != null && output[_PNo][_m] != null) {
        contents[_PNo] = de_PolicyNames(__getArrayIfSingleItem(output[_PNo][_m]), context);
    }
    return contents;
};
const de_ListenerDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListenerDescription(entry, context);
    });
};
const de_ListenerNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_LoadBalancerAttributeNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_LoadBalancerAttributes = (output, context) => {
    const contents = {};
    if (output[_CZLB] != null) {
        contents[_CZLB] = de_CrossZoneLoadBalancing(output[_CZLB], context);
    }
    if (output[_AL] != null) {
        contents[_AL] = de_AccessLog(output[_AL], context);
    }
    if (output[_CD] != null) {
        contents[_CD] = de_ConnectionDraining(output[_CD], context);
    }
    if (output[_CS] != null) {
        contents[_CS] = de_ConnectionSettings(output[_CS], context);
    }
    if (output.AdditionalAttributes === "") {
        contents[_AA] = [];
    }
    else if (output[_AA] != null && output[_AA][_m] != null) {
        contents[_AA] = de_AdditionalAttributes(__getArrayIfSingleItem(output[_AA][_m]), context);
    }
    return contents;
};
const de_LoadBalancerDescription = (output, context) => {
    const contents = {};
    if (output[_LBN] != null) {
        contents[_LBN] = __expectString(output[_LBN]);
    }
    if (output[_DNSN] != null) {
        contents[_DNSN] = __expectString(output[_DNSN]);
    }
    if (output[_CHZN] != null) {
        contents[_CHZN] = __expectString(output[_CHZN]);
    }
    if (output[_CHZNID] != null) {
        contents[_CHZNID] = __expectString(output[_CHZNID]);
    }
    if (output.ListenerDescriptions === "") {
        contents[_LD] = [];
    }
    else if (output[_LD] != null && output[_LD][_m] != null) {
        contents[_LD] = de_ListenerDescriptions(__getArrayIfSingleItem(output[_LD][_m]), context);
    }
    if (output[_Po] != null) {
        contents[_Po] = de_Policies(output[_Po], context);
    }
    if (output.BackendServerDescriptions === "") {
        contents[_BSD] = [];
    }
    else if (output[_BSD] != null && output[_BSD][_m] != null) {
        contents[_BSD] = de_BackendServerDescriptions(__getArrayIfSingleItem(output[_BSD][_m]), context);
    }
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_m] != null) {
        contents[_AZ] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZ][_m]), context);
    }
    if (output.Subnets === "") {
        contents[_S] = [];
    }
    else if (output[_S] != null && output[_S][_m] != null) {
        contents[_S] = de_Subnets(__getArrayIfSingleItem(output[_S][_m]), context);
    }
    if (output[_VPCI] != null) {
        contents[_VPCI] = __expectString(output[_VPCI]);
    }
    if (output.Instances === "") {
        contents[_I] = [];
    }
    else if (output[_I] != null && output[_I][_m] != null) {
        contents[_I] = de_Instances(__getArrayIfSingleItem(output[_I][_m]), context);
    }
    if (output[_HC] != null) {
        contents[_HC] = de_HealthCheck(output[_HC], context);
    }
    if (output[_SSG] != null) {
        contents[_SSG] = de_SourceSecurityGroup(output[_SSG], context);
    }
    if (output.SecurityGroups === "") {
        contents[_SG] = [];
    }
    else if (output[_SG] != null && output[_SG][_m] != null) {
        contents[_SG] = de_SecurityGroups(__getArrayIfSingleItem(output[_SG][_m]), context);
    }
    if (output[_CT] != null) {
        contents[_CT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CT]));
    }
    if (output[_Sc] != null) {
        contents[_Sc] = __expectString(output[_Sc]);
    }
    return contents;
};
const de_LoadBalancerDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerDescription(entry, context);
    });
};
const de_ModifyLoadBalancerAttributesOutput = (output, context) => {
    const contents = {};
    if (output[_LBN] != null) {
        contents[_LBN] = __expectString(output[_LBN]);
    }
    if (output[_LBA] != null) {
        contents[_LBA] = de_LoadBalancerAttributes(output[_LBA], context);
    }
    return contents;
};
const de_OperationNotPermittedException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Policies = (output, context) => {
    const contents = {};
    if (output.AppCookieStickinessPolicies === "") {
        contents[_ACSP] = [];
    }
    else if (output[_ACSP] != null && output[_ACSP][_m] != null) {
        contents[_ACSP] = de_AppCookieStickinessPolicies(__getArrayIfSingleItem(output[_ACSP][_m]), context);
    }
    if (output.LBCookieStickinessPolicies === "") {
        contents[_LBCSP] = [];
    }
    else if (output[_LBCSP] != null && output[_LBCSP][_m] != null) {
        contents[_LBCSP] = de_LBCookieStickinessPolicies(__getArrayIfSingleItem(output[_LBCSP][_m]), context);
    }
    if (output.OtherPolicies === "") {
        contents[_OP] = [];
    }
    else if (output[_OP] != null && output[_OP][_m] != null) {
        contents[_OP] = de_PolicyNames(__getArrayIfSingleItem(output[_OP][_m]), context);
    }
    return contents;
};
const de_PolicyAttributeDescription = (output, context) => {
    const contents = {};
    if (output[_AN] != null) {
        contents[_AN] = __expectString(output[_AN]);
    }
    if (output[_AV] != null) {
        contents[_AV] = __expectString(output[_AV]);
    }
    return contents;
};
const de_PolicyAttributeDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyAttributeDescription(entry, context);
    });
};
const de_PolicyAttributeTypeDescription = (output, context) => {
    const contents = {};
    if (output[_AN] != null) {
        contents[_AN] = __expectString(output[_AN]);
    }
    if (output[_ATt] != null) {
        contents[_ATt] = __expectString(output[_ATt]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    return contents;
};
const de_PolicyAttributeTypeDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyAttributeTypeDescription(entry, context);
    });
};
const de_PolicyDescription = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_PTN] != null) {
        contents[_PTN] = __expectString(output[_PTN]);
    }
    if (output.PolicyAttributeDescriptions === "") {
        contents[_PAD] = [];
    }
    else if (output[_PAD] != null && output[_PAD][_m] != null) {
        contents[_PAD] = de_PolicyAttributeDescriptions(__getArrayIfSingleItem(output[_PAD][_m]), context);
    }
    return contents;
};
const de_PolicyDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyDescription(entry, context);
    });
};
const de_PolicyNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PolicyNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_PolicyTypeDescription = (output, context) => {
    const contents = {};
    if (output[_PTN] != null) {
        contents[_PTN] = __expectString(output[_PTN]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output.PolicyAttributeTypeDescriptions === "") {
        contents[_PATD] = [];
    }
    else if (output[_PATD] != null && output[_PATD][_m] != null) {
        contents[_PATD] = de_PolicyAttributeTypeDescriptions(__getArrayIfSingleItem(output[_PATD][_m]), context);
    }
    return contents;
};
const de_PolicyTypeDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyTypeDescription(entry, context);
    });
};
const de_PolicyTypeNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_RegisterEndPointsOutput = (output, context) => {
    const contents = {};
    if (output.Instances === "") {
        contents[_I] = [];
    }
    else if (output[_I] != null && output[_I][_m] != null) {
        contents[_I] = de_Instances(__getArrayIfSingleItem(output[_I][_m]), context);
    }
    return contents;
};
const de_RemoveAvailabilityZonesOutput = (output, context) => {
    const contents = {};
    if (output.AvailabilityZones === "") {
        contents[_AZ] = [];
    }
    else if (output[_AZ] != null && output[_AZ][_m] != null) {
        contents[_AZ] = de_AvailabilityZones(__getArrayIfSingleItem(output[_AZ][_m]), context);
    }
    return contents;
};
const de_RemoveTagsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_SecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SetLoadBalancerListenerSSLCertificateOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_SetLoadBalancerPoliciesForBackendServerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_SetLoadBalancerPoliciesOfListenerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_SourceSecurityGroup = (output, context) => {
    const contents = {};
    if (output[_OA] != null) {
        contents[_OA] = __expectString(output[_OA]);
    }
    if (output[_GN] != null) {
        contents[_GN] = __expectString(output[_GN]);
    }
    return contents;
};
const de_SubnetNotFoundException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_Subnets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Va] != null) {
        contents[_Va] = __expectString(output[_Va]);
    }
    return contents;
};
const de_TagDescription = (output, context) => {
    const contents = {};
    if (output[_LBN] != null) {
        contents[_LBN] = __expectString(output[_LBN]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_m] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_m]), context);
    }
    return contents;
};
const de_TagDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagDescription(entry, context);
    });
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TooManyAccessPointsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyPoliciesException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_TooManyTagsException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const de_UnsupportedProtocolException = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2012-06-01";
const _A = "Action";
const _AA = "AdditionalAttributes";
const _ACSP = "AppCookieStickinessPolicies";
const _AL = "AccessLog";
const _ALBTS = "AttachLoadBalancerToSubnets";
const _AN = "AttributeName";
const _ASGTLB = "ApplySecurityGroupsToLoadBalancer";
const _AT = "AddTags";
const _ATt = "AttributeType";
const _AV = "AttributeValue";
const _AZ = "AvailabilityZones";
const _BSD = "BackendServerDescriptions";
const _C = "Cardinality";
const _CACSP = "CreateAppCookieStickinessPolicy";
const _CD = "ConnectionDraining";
const _CEP = "CookieExpirationPeriod";
const _CHC = "ConfigureHealthCheck";
const _CHZN = "CanonicalHostedZoneName";
const _CHZNID = "CanonicalHostedZoneNameID";
const _CLB = "CreateLoadBalancer";
const _CLBCSP = "CreateLBCookieStickinessPolicy";
const _CLBL = "CreateLoadBalancerListeners";
const _CLBP = "CreateLoadBalancerPolicy";
const _CN = "CookieName";
const _CS = "ConnectionSettings";
const _CT = "CreatedTime";
const _CZLB = "CrossZoneLoadBalancing";
const _D = "Description";
const _DAL = "DescribeAccountLimits";
const _DAZFLB = "DisableAvailabilityZonesForLoadBalancer";
const _DIFLB = "DeregisterInstancesFromLoadBalancer";
const _DIH = "DescribeInstanceHealth";
const _DLB = "DeleteLoadBalancer";
const _DLBA = "DescribeLoadBalancerAttributes";
const _DLBFS = "DetachLoadBalancerFromSubnets";
const _DLBL = "DeleteLoadBalancerListeners";
const _DLBP = "DeleteLoadBalancerPolicy";
const _DLBPT = "DescribeLoadBalancerPolicyTypes";
const _DLBPe = "DescribeLoadBalancerPolicies";
const _DLBe = "DescribeLoadBalancers";
const _DNSN = "DNSName";
const _DT = "DescribeTags";
const _DV = "DefaultValue";
const _E = "Enabled";
const _EAZFLB = "EnableAvailabilityZonesForLoadBalancer";
const _EI = "EmitInterval";
const _GN = "GroupName";
const _HC = "HealthCheck";
const _HT = "HealthyThreshold";
const _I = "Instances";
const _II = "InstanceId";
const _IP = "InstanceProtocol";
const _IPn = "InstancePort";
const _IS = "InstanceStates";
const _IT = "IdleTimeout";
const _In = "Interval";
const _K = "Key";
const _L = "Listeners";
const _LBA = "LoadBalancerAttributes";
const _LBCSP = "LBCookieStickinessPolicies";
const _LBD = "LoadBalancerDescriptions";
const _LBN = "LoadBalancerName";
const _LBNo = "LoadBalancerNames";
const _LBP = "LoadBalancerPorts";
const _LBPo = "LoadBalancerPort";
const _LD = "ListenerDescriptions";
const _Li = "Limits";
const _Lis = "Listener";
const _M = "Marker";
const _MLBA = "ModifyLoadBalancerAttributes";
const _Ma = "Max";
const _Me = "Message";
const _N = "Name";
const _NM = "NextMarker";
const _OA = "OwnerAlias";
const _OP = "OtherPolicies";
const _P = "Protocol";
const _PA = "PolicyAttributes";
const _PAD = "PolicyAttributeDescriptions";
const _PATD = "PolicyAttributeTypeDescriptions";
const _PD = "PolicyDescriptions";
const _PN = "PolicyName";
const _PNo = "PolicyNames";
const _PS = "PageSize";
const _PTD = "PolicyTypeDescriptions";
const _PTN = "PolicyTypeName";
const _PTNo = "PolicyTypeNames";
const _Po = "Policies";
const _RC = "ReasonCode";
const _RIWLB = "RegisterInstancesWithLoadBalancer";
const _RT = "RemoveTags";
const _S = "Subnets";
const _SBN = "S3BucketName";
const _SBP = "S3BucketPrefix";
const _SG = "SecurityGroups";
const _SLBLSSLC = "SetLoadBalancerListenerSSLCertificate";
const _SLBPFBS = "SetLoadBalancerPoliciesForBackendServer";
const _SLBPOL = "SetLoadBalancerPoliciesOfListener";
const _SSG = "SourceSecurityGroup";
const _SSLCI = "SSLCertificateId";
const _Sc = "Scheme";
const _St = "State";
const _T = "Tags";
const _TD = "TagDescriptions";
const _Ta = "Target";
const _Ti = "Timeout";
const _UT = "UnhealthyThreshold";
const _V = "Version";
const _VPCI = "VPCId";
const _Va = "Value";
const _m = "member";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

export function streamReader(stream, onChunk, chunkSize = 1048576) {
    return new Promise((resolve, reject) => {
        let temporaryBuffer;
        stream.on("error", reject);
        stream.on("end", () => {
            if (temporaryBuffer?.byteLength) {
                for (let i = 0; i < temporaryBuffer.byteLength; i += chunkSize) {
                    onChunk(temporaryBuffer.subarray(i, Math.min(i + chunkSize, temporaryBuffer.byteLength)));
                }
                temporaryBuffer = void 0;
            }
            resolve();
        });
        stream.on("data", (chunk) => {
            if (!temporaryBuffer) {
                temporaryBuffer = chunk;
            }
            else {
                temporaryBuffer = mergeUint8Arrays(temporaryBuffer, chunk);
            }
            let pointer = 0;
            while (temporaryBuffer.byteLength - pointer >= chunkSize) {
                onChunk(temporaryBuffer.subarray(pointer, pointer + chunkSize));
                pointer += chunkSize;
            }
            temporaryBuffer = temporaryBuffer.subarray(pointer);
        });
        stream.resume();
    });
}
function mergeUint8Arrays(a, b) {
    const result = new Uint8Array(a.byteLength + b.byteLength);
    result.set(a);
    result.set(b, a.byteLength);
    return result;
}

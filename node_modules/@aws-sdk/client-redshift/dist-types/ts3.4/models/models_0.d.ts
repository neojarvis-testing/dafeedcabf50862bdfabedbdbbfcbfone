import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { RedshiftServiceException as __BaseException } from "./RedshiftServiceException";
export interface AcceptReservedNodeExchangeInputMessage {
  ReservedNodeId: string | undefined;
  TargetReservedNodeOfferingId: string | undefined;
}
export interface RecurringCharge {
  RecurringChargeAmount?: number;
  RecurringChargeFrequency?: string;
}
export declare const ReservedNodeOfferingType: {
  readonly Regular: "Regular";
  readonly Upgradable: "Upgradable";
};
export type ReservedNodeOfferingType =
  (typeof ReservedNodeOfferingType)[keyof typeof ReservedNodeOfferingType];
export interface ReservedNode {
  ReservedNodeId?: string;
  ReservedNodeOfferingId?: string;
  NodeType?: string;
  StartTime?: Date;
  Duration?: number;
  FixedPrice?: number;
  UsagePrice?: number;
  CurrencyCode?: string;
  NodeCount?: number;
  State?: string;
  OfferingType?: string;
  RecurringCharges?: RecurringCharge[];
  ReservedNodeOfferingType?: ReservedNodeOfferingType;
}
export interface AcceptReservedNodeExchangeOutputMessage {
  ExchangedReservedNode?: ReservedNode;
}
export declare class DependentServiceUnavailableFault extends __BaseException {
  readonly name: "DependentServiceUnavailableFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      DependentServiceUnavailableFault,
      __BaseException
    >
  );
}
export declare class InvalidReservedNodeStateFault extends __BaseException {
  readonly name: "InvalidReservedNodeStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidReservedNodeStateFault, __BaseException>
  );
}
export declare class ReservedNodeAlreadyExistsFault extends __BaseException {
  readonly name: "ReservedNodeAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReservedNodeAlreadyExistsFault, __BaseException>
  );
}
export declare class ReservedNodeAlreadyMigratedFault extends __BaseException {
  readonly name: "ReservedNodeAlreadyMigratedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReservedNodeAlreadyMigratedFault,
      __BaseException
    >
  );
}
export declare class ReservedNodeNotFoundFault extends __BaseException {
  readonly name: "ReservedNodeNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReservedNodeNotFoundFault, __BaseException>
  );
}
export declare class ReservedNodeOfferingNotFoundFault extends __BaseException {
  readonly name: "ReservedNodeOfferingNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReservedNodeOfferingNotFoundFault,
      __BaseException
    >
  );
}
export declare class UnsupportedOperationFault extends __BaseException {
  readonly name: "UnsupportedOperationFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnsupportedOperationFault, __BaseException>
  );
}
export declare class AccessToClusterDeniedFault extends __BaseException {
  readonly name: "AccessToClusterDeniedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessToClusterDeniedFault, __BaseException>
  );
}
export declare class AccessToSnapshotDeniedFault extends __BaseException {
  readonly name: "AccessToSnapshotDeniedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessToSnapshotDeniedFault, __BaseException>
  );
}
export interface AttributeValueTarget {
  AttributeValue?: string;
}
export interface AccountAttribute {
  AttributeName?: string;
  AttributeValues?: AttributeValueTarget[];
}
export interface AccountAttributeList {
  AccountAttributes?: AccountAttribute[];
}
export interface AccountWithRestoreAccess {
  AccountId?: string;
  AccountAlias?: string;
}
export declare const ActionType: {
  readonly RECOMMEND_NODE_CONFIG: "recommend-node-config";
  readonly RESIZE_CLUSTER: "resize-cluster";
  readonly RESTORE_CLUSTER: "restore-cluster";
};
export type ActionType = (typeof ActionType)[keyof typeof ActionType];
export declare class ClusterNotFoundFault extends __BaseException {
  readonly name: "ClusterNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterNotFoundFault, __BaseException>
  );
}
export interface PartnerIntegrationInputMessage {
  AccountId: string | undefined;
  ClusterIdentifier: string | undefined;
  DatabaseName: string | undefined;
  PartnerName: string | undefined;
}
export interface PartnerIntegrationOutputMessage {
  DatabaseName?: string;
  PartnerName?: string;
}
export declare class PartnerNotFoundFault extends __BaseException {
  readonly name: "PartnerNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<PartnerNotFoundFault, __BaseException>
  );
}
export declare class UnauthorizedPartnerIntegrationFault extends __BaseException {
  readonly name: "UnauthorizedPartnerIntegrationFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      UnauthorizedPartnerIntegrationFault,
      __BaseException
    >
  );
}
export declare const AquaConfigurationStatus: {
  readonly AUTO: "auto";
  readonly DISABLED: "disabled";
  readonly ENABLED: "enabled";
};
export type AquaConfigurationStatus =
  (typeof AquaConfigurationStatus)[keyof typeof AquaConfigurationStatus];
export declare const AquaStatus: {
  readonly APPLYING: "applying";
  readonly DISABLED: "disabled";
  readonly ENABLED: "enabled";
};
export type AquaStatus = (typeof AquaStatus)[keyof typeof AquaStatus];
export interface AquaConfiguration {
  AquaStatus?: AquaStatus;
  AquaConfigurationStatus?: AquaConfigurationStatus;
}
export interface AssociateDataShareConsumerMessage {
  DataShareArn: string | undefined;
  AssociateEntireAccount?: boolean;
  ConsumerArn?: string;
  ConsumerRegion?: string;
  AllowWrites?: boolean;
}
export declare const DataShareStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly AUTHORIZED: "AUTHORIZED";
  readonly AVAILABLE: "AVAILABLE";
  readonly DEAUTHORIZED: "DEAUTHORIZED";
  readonly PENDING_AUTHORIZATION: "PENDING_AUTHORIZATION";
  readonly REJECTED: "REJECTED";
};
export type DataShareStatus =
  (typeof DataShareStatus)[keyof typeof DataShareStatus];
export interface DataShareAssociation {
  ConsumerIdentifier?: string;
  Status?: DataShareStatus;
  ConsumerRegion?: string;
  CreatedDate?: Date;
  StatusChangeDate?: Date;
  ProducerAllowedWrites?: boolean;
  ConsumerAcceptedWrites?: boolean;
}
export interface DataShare {
  DataShareArn?: string;
  ProducerArn?: string;
  AllowPubliclyAccessibleConsumers?: boolean;
  DataShareAssociations?: DataShareAssociation[];
  ManagedBy?: string;
}
export declare class InvalidDataShareFault extends __BaseException {
  readonly name: "InvalidDataShareFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidDataShareFault, __BaseException>
  );
}
export declare class InvalidNamespaceFault extends __BaseException {
  readonly name: "InvalidNamespaceFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidNamespaceFault, __BaseException>
  );
}
export declare const ScheduleState: {
  readonly ACTIVE: "ACTIVE";
  readonly FAILED: "FAILED";
  readonly MODIFYING: "MODIFYING";
};
export type ScheduleState = (typeof ScheduleState)[keyof typeof ScheduleState];
export interface ClusterAssociatedToSchedule {
  ClusterIdentifier?: string;
  ScheduleAssociationState?: ScheduleState;
}
export interface CertificateAssociation {
  CustomDomainName?: string;
  ClusterIdentifier?: string;
}
export interface Association {
  CustomDomainCertificateArn?: string;
  CustomDomainCertificateExpiryDate?: Date;
  CertificateAssociations?: CertificateAssociation[];
}
export interface AuthenticationProfile {
  AuthenticationProfileName?: string;
  AuthenticationProfileContent?: string;
}
export declare class AuthenticationProfileAlreadyExistsFault extends __BaseException {
  readonly name: "AuthenticationProfileAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AuthenticationProfileAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class AuthenticationProfileNotFoundFault extends __BaseException {
  readonly name: "AuthenticationProfileNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AuthenticationProfileNotFoundFault,
      __BaseException
    >
  );
}
export declare class AuthenticationProfileQuotaExceededFault extends __BaseException {
  readonly name: "AuthenticationProfileQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AuthenticationProfileQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class AuthorizationAlreadyExistsFault extends __BaseException {
  readonly name: "AuthorizationAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AuthorizationAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class AuthorizationNotFoundFault extends __BaseException {
  readonly name: "AuthorizationNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AuthorizationNotFoundFault, __BaseException>
  );
}
export declare class AuthorizationQuotaExceededFault extends __BaseException {
  readonly name: "AuthorizationQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      AuthorizationQuotaExceededFault,
      __BaseException
    >
  );
}
export declare const AuthorizationStatus: {
  readonly AUTHORIZED: "Authorized";
  readonly REVOKING: "Revoking";
};
export type AuthorizationStatus =
  (typeof AuthorizationStatus)[keyof typeof AuthorizationStatus];
export interface AuthorizeClusterSecurityGroupIngressMessage {
  ClusterSecurityGroupName: string | undefined;
  CIDRIP?: string;
  EC2SecurityGroupName?: string;
  EC2SecurityGroupOwnerId?: string;
}
export interface Tag {
  Key?: string;
  Value?: string;
}
export interface EC2SecurityGroup {
  Status?: string;
  EC2SecurityGroupName?: string;
  EC2SecurityGroupOwnerId?: string;
  Tags?: Tag[];
}
export interface IPRange {
  Status?: string;
  CIDRIP?: string;
  Tags?: Tag[];
}
export interface ClusterSecurityGroup {
  ClusterSecurityGroupName?: string;
  Description?: string;
  EC2SecurityGroups?: EC2SecurityGroup[];
  IPRanges?: IPRange[];
  Tags?: Tag[];
}
export interface AuthorizeClusterSecurityGroupIngressResult {
  ClusterSecurityGroup?: ClusterSecurityGroup;
}
export declare class ClusterSecurityGroupNotFoundFault extends __BaseException {
  readonly name: "ClusterSecurityGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSecurityGroupNotFoundFault,
      __BaseException
    >
  );
}
export declare class InvalidClusterSecurityGroupStateFault extends __BaseException {
  readonly name: "InvalidClusterSecurityGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidClusterSecurityGroupStateFault,
      __BaseException
    >
  );
}
export interface AuthorizeDataShareMessage {
  DataShareArn: string | undefined;
  ConsumerIdentifier: string | undefined;
  AllowWrites?: boolean;
}
export interface AuthorizedTokenIssuer {
  TrustedTokenIssuerArn?: string;
  AuthorizedAudiencesList?: string[];
}
export interface AuthorizeEndpointAccessMessage {
  ClusterIdentifier?: string;
  Account: string | undefined;
  VpcIds?: string[];
}
export interface EndpointAuthorization {
  Grantor?: string;
  Grantee?: string;
  ClusterIdentifier?: string;
  AuthorizeTime?: Date;
  ClusterStatus?: string;
  Status?: AuthorizationStatus;
  AllowedAllVPCs?: boolean;
  AllowedVPCs?: string[];
  EndpointCount?: number;
}
export declare class EndpointAuthorizationAlreadyExistsFault extends __BaseException {
  readonly name: "EndpointAuthorizationAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      EndpointAuthorizationAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class EndpointAuthorizationsPerClusterLimitExceededFault extends __BaseException {
  readonly name: "EndpointAuthorizationsPerClusterLimitExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      EndpointAuthorizationsPerClusterLimitExceededFault,
      __BaseException
    >
  );
}
export declare class InvalidAuthorizationStateFault extends __BaseException {
  readonly name: "InvalidAuthorizationStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidAuthorizationStateFault, __BaseException>
  );
}
export declare class InvalidClusterStateFault extends __BaseException {
  readonly name: "InvalidClusterStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidClusterStateFault, __BaseException>
  );
}
export interface AuthorizeSnapshotAccessMessage {
  SnapshotIdentifier?: string;
  SnapshotArn?: string;
  SnapshotClusterIdentifier?: string;
  AccountWithRestoreAccess: string | undefined;
}
export interface Snapshot {
  SnapshotIdentifier?: string;
  ClusterIdentifier?: string;
  SnapshotCreateTime?: Date;
  Status?: string;
  Port?: number;
  AvailabilityZone?: string;
  ClusterCreateTime?: Date;
  MasterUsername?: string;
  ClusterVersion?: string;
  EngineFullVersion?: string;
  SnapshotType?: string;
  NodeType?: string;
  NumberOfNodes?: number;
  DBName?: string;
  VpcId?: string;
  Encrypted?: boolean;
  KmsKeyId?: string;
  EncryptedWithHSM?: boolean;
  AccountsWithRestoreAccess?: AccountWithRestoreAccess[];
  OwnerAccount?: string;
  TotalBackupSizeInMegaBytes?: number;
  ActualIncrementalBackupSizeInMegaBytes?: number;
  BackupProgressInMegaBytes?: number;
  CurrentBackupRateInMegaBytesPerSecond?: number;
  EstimatedSecondsToCompletion?: number;
  ElapsedTimeInSeconds?: number;
  SourceRegion?: string;
  Tags?: Tag[];
  RestorableNodeTypes?: string[];
  EnhancedVpcRouting?: boolean;
  MaintenanceTrackName?: string;
  ManualSnapshotRetentionPeriod?: number;
  ManualSnapshotRemainingDays?: number;
  SnapshotRetentionStartTime?: Date;
  MasterPasswordSecretArn?: string;
  MasterPasswordSecretKmsKeyId?: string;
  SnapshotArn?: string;
}
export interface AuthorizeSnapshotAccessResult {
  Snapshot?: Snapshot;
}
export declare class ClusterSnapshotNotFoundFault extends __BaseException {
  readonly name: "ClusterSnapshotNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterSnapshotNotFoundFault, __BaseException>
  );
}
export declare class DependentServiceRequestThrottlingFault extends __BaseException {
  readonly name: "DependentServiceRequestThrottlingFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      DependentServiceRequestThrottlingFault,
      __BaseException
    >
  );
}
export declare class InvalidClusterSnapshotStateFault extends __BaseException {
  readonly name: "InvalidClusterSnapshotStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidClusterSnapshotStateFault,
      __BaseException
    >
  );
}
export declare class LimitExceededFault extends __BaseException {
  readonly name: "LimitExceededFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<LimitExceededFault, __BaseException>);
}
export interface SupportedPlatform {
  Name?: string;
}
export interface AvailabilityZone {
  Name?: string;
  SupportedPlatforms?: SupportedPlatform[];
}
export interface DeleteClusterSnapshotMessage {
  SnapshotIdentifier: string | undefined;
  SnapshotClusterIdentifier?: string;
}
export interface BatchDeleteClusterSnapshotsRequest {
  Identifiers: DeleteClusterSnapshotMessage[] | undefined;
}
export interface SnapshotErrorMessage {
  SnapshotIdentifier?: string;
  SnapshotClusterIdentifier?: string;
  FailureCode?: string;
  FailureReason?: string;
}
export interface BatchDeleteClusterSnapshotsResult {
  Resources?: string[];
  Errors?: SnapshotErrorMessage[];
}
export declare class BatchDeleteRequestSizeExceededFault extends __BaseException {
  readonly name: "BatchDeleteRequestSizeExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      BatchDeleteRequestSizeExceededFault,
      __BaseException
    >
  );
}
export declare class BatchModifyClusterSnapshotsLimitExceededFault extends __BaseException {
  readonly name: "BatchModifyClusterSnapshotsLimitExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      BatchModifyClusterSnapshotsLimitExceededFault,
      __BaseException
    >
  );
}
export interface BatchModifyClusterSnapshotsMessage {
  SnapshotIdentifierList: string[] | undefined;
  ManualSnapshotRetentionPeriod?: number;
  Force?: boolean;
}
export interface BatchModifyClusterSnapshotsOutputMessage {
  Resources?: string[];
  Errors?: SnapshotErrorMessage[];
}
export declare class InvalidRetentionPeriodFault extends __BaseException {
  readonly name: "InvalidRetentionPeriodFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidRetentionPeriodFault, __BaseException>
  );
}
export declare class BucketNotFoundFault extends __BaseException {
  readonly name: "BucketNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<BucketNotFoundFault, __BaseException>
  );
}
export interface CancelResizeMessage {
  ClusterIdentifier: string | undefined;
}
export declare class ResizeNotFoundFault extends __BaseException {
  readonly name: "ResizeNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResizeNotFoundFault, __BaseException>
  );
}
export interface ResizeProgressMessage {
  TargetNodeType?: string;
  TargetNumberOfNodes?: number;
  TargetClusterType?: string;
  Status?: string;
  ImportTablesCompleted?: string[];
  ImportTablesInProgress?: string[];
  ImportTablesNotStarted?: string[];
  AvgResizeRateInMegaBytesPerSecond?: number;
  TotalResizeDataInMegaBytes?: number;
  ProgressInMegaBytes?: number;
  ElapsedTimeInSeconds?: number;
  EstimatedTimeToCompletionInSeconds?: number;
  ResizeType?: string;
  Message?: string;
  TargetEncryptionType?: string;
  DataTransferProgressPercent?: number;
}
export interface ClusterNode {
  NodeRole?: string;
  PrivateIPAddress?: string;
  PublicIPAddress?: string;
}
export interface ClusterParameterStatus {
  ParameterName?: string;
  ParameterApplyStatus?: string;
  ParameterApplyErrorDescription?: string;
}
export interface ClusterParameterGroupStatus {
  ParameterGroupName?: string;
  ParameterApplyStatus?: string;
  ClusterParameterStatusList?: ClusterParameterStatus[];
}
export interface ClusterSecurityGroupMembership {
  ClusterSecurityGroupName?: string;
  Status?: string;
}
export interface ClusterSnapshotCopyStatus {
  DestinationRegion?: string;
  RetentionPeriod?: number;
  ManualSnapshotRetentionPeriod?: number;
  SnapshotCopyGrantName?: string;
}
export interface DataTransferProgress {
  Status?: string;
  CurrentRateInMegaBytesPerSecond?: number;
  TotalDataInMegaBytes?: number;
  DataTransferredInMegaBytes?: number;
  EstimatedTimeToCompletionInSeconds?: number;
  ElapsedTimeInSeconds?: number;
}
export interface DeferredMaintenanceWindow {
  DeferMaintenanceIdentifier?: string;
  DeferMaintenanceStartTime?: Date;
  DeferMaintenanceEndTime?: Date;
}
export interface ElasticIpStatus {
  ElasticIp?: string;
  Status?: string;
}
export interface NetworkInterface {
  NetworkInterfaceId?: string;
  SubnetId?: string;
  PrivateIpAddress?: string;
  AvailabilityZone?: string;
  Ipv6Address?: string;
}
export interface VpcEndpoint {
  VpcEndpointId?: string;
  VpcId?: string;
  NetworkInterfaces?: NetworkInterface[];
}
export interface Endpoint {
  Address?: string;
  Port?: number;
  VpcEndpoints?: VpcEndpoint[];
}
export interface HsmStatus {
  HsmClientCertificateIdentifier?: string;
  HsmConfigurationIdentifier?: string;
  Status?: string;
}
export interface ClusterIamRole {
  IamRoleArn?: string;
  ApplyStatus?: string;
}
export interface SecondaryClusterInfo {
  AvailabilityZone?: string;
  ClusterNodes?: ClusterNode[];
}
export interface PendingModifiedValues {
  MasterUserPassword?: string;
  NodeType?: string;
  NumberOfNodes?: number;
  ClusterType?: string;
  ClusterVersion?: string;
  AutomatedSnapshotRetentionPeriod?: number;
  ClusterIdentifier?: string;
  PubliclyAccessible?: boolean;
  EnhancedVpcRouting?: boolean;
  MaintenanceTrackName?: string;
  EncryptionType?: string;
}
export declare const ReservedNodeExchangeStatusType: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly PENDING: "PENDING";
  readonly REQUESTED: "REQUESTED";
  readonly RETRYING: "RETRYING";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type ReservedNodeExchangeStatusType =
  (typeof ReservedNodeExchangeStatusType)[keyof typeof ReservedNodeExchangeStatusType];
export interface ReservedNodeExchangeStatus {
  ReservedNodeExchangeRequestId?: string;
  Status?: ReservedNodeExchangeStatusType;
  RequestTime?: Date;
  SourceReservedNodeId?: string;
  SourceReservedNodeType?: string;
  SourceReservedNodeCount?: number;
  TargetReservedNodeOfferingId?: string;
  TargetReservedNodeType?: string;
  TargetReservedNodeCount?: number;
}
export interface ResizeInfo {
  ResizeType?: string;
  AllowCancelResize?: boolean;
}
export interface RestoreStatus {
  Status?: string;
  CurrentRestoreRateInMegaBytesPerSecond?: number;
  SnapshotSizeInMegaBytes?: number;
  ProgressInMegaBytes?: number;
  ElapsedTimeInSeconds?: number;
  EstimatedTimeToCompletionInSeconds?: number;
}
export interface VpcSecurityGroupMembership {
  VpcSecurityGroupId?: string;
  Status?: string;
}
export interface Cluster {
  ClusterIdentifier?: string;
  NodeType?: string;
  ClusterStatus?: string;
  ClusterAvailabilityStatus?: string;
  ModifyStatus?: string;
  MasterUsername?: string;
  DBName?: string;
  Endpoint?: Endpoint;
  ClusterCreateTime?: Date;
  AutomatedSnapshotRetentionPeriod?: number;
  ManualSnapshotRetentionPeriod?: number;
  ClusterSecurityGroups?: ClusterSecurityGroupMembership[];
  VpcSecurityGroups?: VpcSecurityGroupMembership[];
  ClusterParameterGroups?: ClusterParameterGroupStatus[];
  ClusterSubnetGroupName?: string;
  VpcId?: string;
  AvailabilityZone?: string;
  PreferredMaintenanceWindow?: string;
  PendingModifiedValues?: PendingModifiedValues;
  ClusterVersion?: string;
  AllowVersionUpgrade?: boolean;
  NumberOfNodes?: number;
  PubliclyAccessible?: boolean;
  Encrypted?: boolean;
  RestoreStatus?: RestoreStatus;
  DataTransferProgress?: DataTransferProgress;
  HsmStatus?: HsmStatus;
  ClusterSnapshotCopyStatus?: ClusterSnapshotCopyStatus;
  ClusterPublicKey?: string;
  ClusterNodes?: ClusterNode[];
  ElasticIpStatus?: ElasticIpStatus;
  ClusterRevisionNumber?: string;
  Tags?: Tag[];
  KmsKeyId?: string;
  EnhancedVpcRouting?: boolean;
  IamRoles?: ClusterIamRole[];
  PendingActions?: string[];
  MaintenanceTrackName?: string;
  ElasticResizeNumberOfNodeOptions?: string;
  DeferredMaintenanceWindows?: DeferredMaintenanceWindow[];
  SnapshotScheduleIdentifier?: string;
  SnapshotScheduleState?: ScheduleState;
  ExpectedNextSnapshotScheduleTime?: Date;
  ExpectedNextSnapshotScheduleTimeStatus?: string;
  NextMaintenanceWindowStartTime?: Date;
  ResizeInfo?: ResizeInfo;
  AvailabilityZoneRelocationStatus?: string;
  ClusterNamespaceArn?: string;
  TotalStorageCapacityInMegaBytes?: number;
  AquaConfiguration?: AquaConfiguration;
  DefaultIamRoleArn?: string;
  ReservedNodeExchangeStatus?: ReservedNodeExchangeStatus;
  CustomDomainName?: string;
  CustomDomainCertificateArn?: string;
  CustomDomainCertificateExpiryDate?: Date;
  MasterPasswordSecretArn?: string;
  MasterPasswordSecretKmsKeyId?: string;
  IpAddressType?: string;
  MultiAZ?: string;
  MultiAZSecondary?: SecondaryClusterInfo;
}
export declare class ClusterAlreadyExistsFault extends __BaseException {
  readonly name: "ClusterAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterAlreadyExistsFault, __BaseException>
  );
}
export interface ClusterCredentials {
  DbUser?: string;
  DbPassword?: string;
  Expiration?: Date;
}
export interface RevisionTarget {
  DatabaseRevision?: string;
  Description?: string;
  DatabaseRevisionReleaseDate?: Date;
}
export interface ClusterDbRevision {
  ClusterIdentifier?: string;
  CurrentDatabaseRevision?: string;
  DatabaseRevisionReleaseDate?: Date;
  RevisionTargets?: RevisionTarget[];
}
export interface ClusterDbRevisionsMessage {
  Marker?: string;
  ClusterDbRevisions?: ClusterDbRevision[];
}
export interface ClusterExtendedCredentials {
  DbUser?: string;
  DbPassword?: string;
  Expiration?: Date;
  NextRefreshTime?: Date;
}
export declare class ClusterOnLatestRevisionFault extends __BaseException {
  readonly name: "ClusterOnLatestRevisionFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterOnLatestRevisionFault, __BaseException>
  );
}
export interface ClusterParameterGroup {
  ParameterGroupName?: string;
  ParameterGroupFamily?: string;
  Description?: string;
  Tags?: Tag[];
}
export declare class ClusterParameterGroupAlreadyExistsFault extends __BaseException {
  readonly name: "ClusterParameterGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterParameterGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare const ParameterApplyType: {
  readonly dynamic: "dynamic";
  readonly static: "static";
};
export type ParameterApplyType =
  (typeof ParameterApplyType)[keyof typeof ParameterApplyType];
export interface Parameter {
  ParameterName?: string;
  ParameterValue?: string;
  Description?: string;
  Source?: string;
  DataType?: string;
  AllowedValues?: string;
  ApplyType?: ParameterApplyType;
  IsModifiable?: boolean;
  MinimumEngineVersion?: string;
}
export interface ClusterParameterGroupDetails {
  Parameters?: Parameter[];
  Marker?: string;
}
export interface ClusterParameterGroupNameMessage {
  ParameterGroupName?: string;
  ParameterGroupStatus?: string;
}
export declare class ClusterParameterGroupNotFoundFault extends __BaseException {
  readonly name: "ClusterParameterGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterParameterGroupNotFoundFault,
      __BaseException
    >
  );
}
export declare class ClusterParameterGroupQuotaExceededFault extends __BaseException {
  readonly name: "ClusterParameterGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterParameterGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export interface ClusterParameterGroupsMessage {
  Marker?: string;
  ParameterGroups?: ClusterParameterGroup[];
}
export declare class ClusterQuotaExceededFault extends __BaseException {
  readonly name: "ClusterQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterQuotaExceededFault, __BaseException>
  );
}
export declare class ClusterSecurityGroupAlreadyExistsFault extends __BaseException {
  readonly name: "ClusterSecurityGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSecurityGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export interface ClusterSecurityGroupMessage {
  Marker?: string;
  ClusterSecurityGroups?: ClusterSecurityGroup[];
}
export declare class ClusterSecurityGroupQuotaExceededFault extends __BaseException {
  readonly name: "ClusterSecurityGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSecurityGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export interface ClustersMessage {
  Marker?: string;
  Clusters?: Cluster[];
}
export declare class ClusterSnapshotAlreadyExistsFault extends __BaseException {
  readonly name: "ClusterSnapshotAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSnapshotAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class ClusterSnapshotQuotaExceededFault extends __BaseException {
  readonly name: "ClusterSnapshotQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSnapshotQuotaExceededFault,
      __BaseException
    >
  );
}
export interface Subnet {
  SubnetIdentifier?: string;
  SubnetAvailabilityZone?: AvailabilityZone;
  SubnetStatus?: string;
}
export interface ClusterSubnetGroup {
  ClusterSubnetGroupName?: string;
  Description?: string;
  VpcId?: string;
  SubnetGroupStatus?: string;
  Subnets?: Subnet[];
  Tags?: Tag[];
  SupportedClusterIpAddressTypes?: string[];
}
export declare class ClusterSubnetGroupAlreadyExistsFault extends __BaseException {
  readonly name: "ClusterSubnetGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSubnetGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export interface ClusterSubnetGroupMessage {
  Marker?: string;
  ClusterSubnetGroups?: ClusterSubnetGroup[];
}
export declare class ClusterSubnetGroupNotFoundFault extends __BaseException {
  readonly name: "ClusterSubnetGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSubnetGroupNotFoundFault,
      __BaseException
    >
  );
}
export declare class ClusterSubnetGroupQuotaExceededFault extends __BaseException {
  readonly name: "ClusterSubnetGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSubnetGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class ClusterSubnetQuotaExceededFault extends __BaseException {
  readonly name: "ClusterSubnetQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterSubnetQuotaExceededFault,
      __BaseException
    >
  );
}
export interface ClusterVersion {
  ClusterVersion?: string;
  ClusterParameterGroupFamily?: string;
  Description?: string;
}
export interface ClusterVersionsMessage {
  Marker?: string;
  ClusterVersions?: ClusterVersion[];
}
export declare class ConflictPolicyUpdateFault extends __BaseException {
  readonly name: "ConflictPolicyUpdateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ConflictPolicyUpdateFault, __BaseException>
  );
}
export interface CopyClusterSnapshotMessage {
  SourceSnapshotIdentifier: string | undefined;
  SourceSnapshotClusterIdentifier?: string;
  TargetSnapshotIdentifier: string | undefined;
  ManualSnapshotRetentionPeriod?: number;
}
export interface CopyClusterSnapshotResult {
  Snapshot?: Snapshot;
}
export declare class CopyToRegionDisabledFault extends __BaseException {
  readonly name: "CopyToRegionDisabledFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CopyToRegionDisabledFault, __BaseException>
  );
}
export interface CreateAuthenticationProfileMessage {
  AuthenticationProfileName: string | undefined;
  AuthenticationProfileContent: string | undefined;
}
export interface CreateAuthenticationProfileResult {
  AuthenticationProfileName?: string;
  AuthenticationProfileContent?: string;
}
export declare class InvalidAuthenticationProfileRequestFault extends __BaseException {
  readonly name: "InvalidAuthenticationProfileRequestFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidAuthenticationProfileRequestFault,
      __BaseException
    >
  );
}
export interface CreateClusterMessage {
  DBName?: string;
  ClusterIdentifier: string | undefined;
  ClusterType?: string;
  NodeType: string | undefined;
  MasterUsername: string | undefined;
  MasterUserPassword?: string;
  ClusterSecurityGroups?: string[];
  VpcSecurityGroupIds?: string[];
  ClusterSubnetGroupName?: string;
  AvailabilityZone?: string;
  PreferredMaintenanceWindow?: string;
  ClusterParameterGroupName?: string;
  AutomatedSnapshotRetentionPeriod?: number;
  ManualSnapshotRetentionPeriod?: number;
  Port?: number;
  ClusterVersion?: string;
  AllowVersionUpgrade?: boolean;
  NumberOfNodes?: number;
  PubliclyAccessible?: boolean;
  Encrypted?: boolean;
  HsmClientCertificateIdentifier?: string;
  HsmConfigurationIdentifier?: string;
  ElasticIp?: string;
  Tags?: Tag[];
  KmsKeyId?: string;
  EnhancedVpcRouting?: boolean;
  AdditionalInfo?: string;
  IamRoles?: string[];
  MaintenanceTrackName?: string;
  SnapshotScheduleIdentifier?: string;
  AvailabilityZoneRelocation?: boolean;
  AquaConfigurationStatus?: AquaConfigurationStatus;
  DefaultIamRoleArn?: string;
  LoadSampleData?: string;
  ManageMasterPassword?: boolean;
  MasterPasswordSecretKmsKeyId?: string;
  IpAddressType?: string;
  MultiAZ?: boolean;
  RedshiftIdcApplicationArn?: string;
}
export interface CreateClusterResult {
  Cluster?: Cluster;
}
export declare class HsmClientCertificateNotFoundFault extends __BaseException {
  readonly name: "HsmClientCertificateNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      HsmClientCertificateNotFoundFault,
      __BaseException
    >
  );
}
export declare class HsmConfigurationNotFoundFault extends __BaseException {
  readonly name: "HsmConfigurationNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<HsmConfigurationNotFoundFault, __BaseException>
  );
}
export declare class InsufficientClusterCapacityFault extends __BaseException {
  readonly name: "InsufficientClusterCapacityFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InsufficientClusterCapacityFault,
      __BaseException
    >
  );
}
export declare class InvalidClusterSubnetGroupStateFault extends __BaseException {
  readonly name: "InvalidClusterSubnetGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidClusterSubnetGroupStateFault,
      __BaseException
    >
  );
}
export declare class InvalidClusterTrackFault extends __BaseException {
  readonly name: "InvalidClusterTrackFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidClusterTrackFault, __BaseException>
  );
}
export declare class InvalidElasticIpFault extends __BaseException {
  readonly name: "InvalidElasticIpFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidElasticIpFault, __BaseException>
  );
}
export declare class InvalidSubnet extends __BaseException {
  readonly name: "InvalidSubnet";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidSubnet, __BaseException>);
}
export declare class InvalidTagFault extends __BaseException {
  readonly name: "InvalidTagFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidTagFault, __BaseException>);
}
export declare class InvalidVPCNetworkStateFault extends __BaseException {
  readonly name: "InvalidVPCNetworkStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidVPCNetworkStateFault, __BaseException>
  );
}
export declare class Ipv6CidrBlockNotFoundFault extends __BaseException {
  readonly name: "Ipv6CidrBlockNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<Ipv6CidrBlockNotFoundFault, __BaseException>
  );
}
export declare class NumberOfNodesPerClusterLimitExceededFault extends __BaseException {
  readonly name: "NumberOfNodesPerClusterLimitExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NumberOfNodesPerClusterLimitExceededFault,
      __BaseException
    >
  );
}
export declare class NumberOfNodesQuotaExceededFault extends __BaseException {
  readonly name: "NumberOfNodesQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NumberOfNodesQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class RedshiftIdcApplicationNotExistsFault extends __BaseException {
  readonly name: "RedshiftIdcApplicationNotExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RedshiftIdcApplicationNotExistsFault,
      __BaseException
    >
  );
}
export declare class SnapshotScheduleNotFoundFault extends __BaseException {
  readonly name: "SnapshotScheduleNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotScheduleNotFoundFault, __BaseException>
  );
}
export declare class TagLimitExceededFault extends __BaseException {
  readonly name: "TagLimitExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TagLimitExceededFault, __BaseException>
  );
}
export declare class UnauthorizedOperation extends __BaseException {
  readonly name: "UnauthorizedOperation";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnauthorizedOperation, __BaseException>
  );
}
export interface CreateClusterParameterGroupMessage {
  ParameterGroupName: string | undefined;
  ParameterGroupFamily: string | undefined;
  Description: string | undefined;
  Tags?: Tag[];
}
export interface CreateClusterParameterGroupResult {
  ClusterParameterGroup?: ClusterParameterGroup;
}
export interface CreateClusterSecurityGroupMessage {
  ClusterSecurityGroupName: string | undefined;
  Description: string | undefined;
  Tags?: Tag[];
}
export interface CreateClusterSecurityGroupResult {
  ClusterSecurityGroup?: ClusterSecurityGroup;
}
export interface CreateClusterSnapshotMessage {
  SnapshotIdentifier: string | undefined;
  ClusterIdentifier: string | undefined;
  ManualSnapshotRetentionPeriod?: number;
  Tags?: Tag[];
}
export interface CreateClusterSnapshotResult {
  Snapshot?: Snapshot;
}
export interface CreateClusterSubnetGroupMessage {
  ClusterSubnetGroupName: string | undefined;
  Description: string | undefined;
  SubnetIds: string[] | undefined;
  Tags?: Tag[];
}
export interface CreateClusterSubnetGroupResult {
  ClusterSubnetGroup?: ClusterSubnetGroup;
}
export interface CreateCustomDomainAssociationMessage {
  CustomDomainName: string | undefined;
  CustomDomainCertificateArn: string | undefined;
  ClusterIdentifier: string | undefined;
}
export interface CreateCustomDomainAssociationResult {
  CustomDomainName?: string;
  CustomDomainCertificateArn?: string;
  ClusterIdentifier?: string;
  CustomDomainCertExpiryTime?: string;
}
export declare class CustomCnameAssociationFault extends __BaseException {
  readonly name: "CustomCnameAssociationFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CustomCnameAssociationFault, __BaseException>
  );
}
export interface CreateEndpointAccessMessage {
  ClusterIdentifier?: string;
  ResourceOwner?: string;
  EndpointName: string | undefined;
  SubnetGroupName: string | undefined;
  VpcSecurityGroupIds?: string[];
}
export interface EndpointAccess {
  ClusterIdentifier?: string;
  ResourceOwner?: string;
  SubnetGroupName?: string;
  EndpointStatus?: string;
  EndpointName?: string;
  EndpointCreateTime?: Date;
  Port?: number;
  Address?: string;
  VpcSecurityGroups?: VpcSecurityGroupMembership[];
  VpcEndpoint?: VpcEndpoint;
}
export declare class EndpointAlreadyExistsFault extends __BaseException {
  readonly name: "EndpointAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<EndpointAlreadyExistsFault, __BaseException>
  );
}
export declare class EndpointsPerAuthorizationLimitExceededFault extends __BaseException {
  readonly name: "EndpointsPerAuthorizationLimitExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      EndpointsPerAuthorizationLimitExceededFault,
      __BaseException
    >
  );
}
export declare class EndpointsPerClusterLimitExceededFault extends __BaseException {
  readonly name: "EndpointsPerClusterLimitExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      EndpointsPerClusterLimitExceededFault,
      __BaseException
    >
  );
}
export interface CreateEventSubscriptionMessage {
  SubscriptionName: string | undefined;
  SnsTopicArn: string | undefined;
  SourceType?: string;
  SourceIds?: string[];
  EventCategories?: string[];
  Severity?: string;
  Enabled?: boolean;
  Tags?: Tag[];
}
export interface EventSubscription {
  CustomerAwsId?: string;
  CustSubscriptionId?: string;
  SnsTopicArn?: string;
  Status?: string;
  SubscriptionCreationTime?: Date;
  SourceType?: string;
  SourceIdsList?: string[];
  EventCategoriesList?: string[];
  Severity?: string;
  Enabled?: boolean;
  Tags?: Tag[];
}
export interface CreateEventSubscriptionResult {
  EventSubscription?: EventSubscription;
}
export declare class EventSubscriptionQuotaExceededFault extends __BaseException {
  readonly name: "EventSubscriptionQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      EventSubscriptionQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class SNSInvalidTopicFault extends __BaseException {
  readonly name: "SNSInvalidTopicFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SNSInvalidTopicFault, __BaseException>
  );
}
export declare class SNSNoAuthorizationFault extends __BaseException {
  readonly name: "SNSNoAuthorizationFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SNSNoAuthorizationFault, __BaseException>
  );
}
export declare class SNSTopicArnNotFoundFault extends __BaseException {
  readonly name: "SNSTopicArnNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SNSTopicArnNotFoundFault, __BaseException>
  );
}
export declare class SourceNotFoundFault extends __BaseException {
  readonly name: "SourceNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SourceNotFoundFault, __BaseException>
  );
}
export declare class SubscriptionAlreadyExistFault extends __BaseException {
  readonly name: "SubscriptionAlreadyExistFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubscriptionAlreadyExistFault, __BaseException>
  );
}
export declare class SubscriptionCategoryNotFoundFault extends __BaseException {
  readonly name: "SubscriptionCategoryNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SubscriptionCategoryNotFoundFault,
      __BaseException
    >
  );
}
export declare class SubscriptionEventIdNotFoundFault extends __BaseException {
  readonly name: "SubscriptionEventIdNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SubscriptionEventIdNotFoundFault,
      __BaseException
    >
  );
}
export declare class SubscriptionSeverityNotFoundFault extends __BaseException {
  readonly name: "SubscriptionSeverityNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SubscriptionSeverityNotFoundFault,
      __BaseException
    >
  );
}
export interface CreateHsmClientCertificateMessage {
  HsmClientCertificateIdentifier: string | undefined;
  Tags?: Tag[];
}
export interface HsmClientCertificate {
  HsmClientCertificateIdentifier?: string;
  HsmClientCertificatePublicKey?: string;
  Tags?: Tag[];
}
export interface CreateHsmClientCertificateResult {
  HsmClientCertificate?: HsmClientCertificate;
}
export declare class HsmClientCertificateAlreadyExistsFault extends __BaseException {
  readonly name: "HsmClientCertificateAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      HsmClientCertificateAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class HsmClientCertificateQuotaExceededFault extends __BaseException {
  readonly name: "HsmClientCertificateQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      HsmClientCertificateQuotaExceededFault,
      __BaseException
    >
  );
}
export interface CreateHsmConfigurationMessage {
  HsmConfigurationIdentifier: string | undefined;
  Description: string | undefined;
  HsmIpAddress: string | undefined;
  HsmPartitionName: string | undefined;
  HsmPartitionPassword: string | undefined;
  HsmServerPublicCertificate: string | undefined;
  Tags?: Tag[];
}
export interface HsmConfiguration {
  HsmConfigurationIdentifier?: string;
  Description?: string;
  HsmIpAddress?: string;
  HsmPartitionName?: string;
  Tags?: Tag[];
}
export interface CreateHsmConfigurationResult {
  HsmConfiguration?: HsmConfiguration;
}
export declare class HsmConfigurationAlreadyExistsFault extends __BaseException {
  readonly name: "HsmConfigurationAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      HsmConfigurationAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class HsmConfigurationQuotaExceededFault extends __BaseException {
  readonly name: "HsmConfigurationQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      HsmConfigurationQuotaExceededFault,
      __BaseException
    >
  );
}
export declare const ServiceAuthorization: {
  readonly DISABLED: "Disabled";
  readonly ENABLED: "Enabled";
};
export type ServiceAuthorization =
  (typeof ServiceAuthorization)[keyof typeof ServiceAuthorization];
export interface LakeFormationQuery {
  Authorization: ServiceAuthorization | undefined;
}
export type LakeFormationScopeUnion =
  | LakeFormationScopeUnion.LakeFormationQueryMember
  | LakeFormationScopeUnion.$UnknownMember;
export declare namespace LakeFormationScopeUnion {
  interface LakeFormationQueryMember {
    LakeFormationQuery: LakeFormationQuery;
    $unknown?: never;
  }
  interface $UnknownMember {
    LakeFormationQuery?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    LakeFormationQuery: (value: LakeFormationQuery) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: LakeFormationScopeUnion, visitor: Visitor<T>) => T;
}
export type ServiceIntegrationsUnion =
  | ServiceIntegrationsUnion.LakeFormationMember
  | ServiceIntegrationsUnion.$UnknownMember;
export declare namespace ServiceIntegrationsUnion {
  interface LakeFormationMember {
    LakeFormation: LakeFormationScopeUnion[];
    $unknown?: never;
  }
  interface $UnknownMember {
    LakeFormation?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    LakeFormation: (value: LakeFormationScopeUnion[]) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ServiceIntegrationsUnion, visitor: Visitor<T>) => T;
}
export interface CreateRedshiftIdcApplicationMessage {
  IdcInstanceArn: string | undefined;
  RedshiftIdcApplicationName: string | undefined;
  IdentityNamespace?: string;
  IdcDisplayName: string | undefined;
  IamRoleArn: string | undefined;
  AuthorizedTokenIssuerList?: AuthorizedTokenIssuer[];
  ServiceIntegrations?: ServiceIntegrationsUnion[];
}
export interface RedshiftIdcApplication {
  IdcInstanceArn?: string;
  RedshiftIdcApplicationName?: string;
  RedshiftIdcApplicationArn?: string;
  IdentityNamespace?: string;
  IdcDisplayName?: string;
  IamRoleArn?: string;
  IdcManagedApplicationArn?: string;
  IdcOnboardStatus?: string;
  AuthorizedTokenIssuerList?: AuthorizedTokenIssuer[];
  ServiceIntegrations?: ServiceIntegrationsUnion[];
}
export interface CreateRedshiftIdcApplicationResult {
  RedshiftIdcApplication?: RedshiftIdcApplication;
}
export declare class DependentServiceAccessDeniedFault extends __BaseException {
  readonly name: "DependentServiceAccessDeniedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      DependentServiceAccessDeniedFault,
      __BaseException
    >
  );
}
export declare class RedshiftIdcApplicationAlreadyExistsFault extends __BaseException {
  readonly name: "RedshiftIdcApplicationAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RedshiftIdcApplicationAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class RedshiftIdcApplicationQuotaExceededFault extends __BaseException {
  readonly name: "RedshiftIdcApplicationQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RedshiftIdcApplicationQuotaExceededFault,
      __BaseException
    >
  );
}
export interface PauseClusterMessage {
  ClusterIdentifier: string | undefined;
}
export interface ResizeClusterMessage {
  ClusterIdentifier: string | undefined;
  ClusterType?: string;
  NodeType?: string;
  NumberOfNodes?: number;
  Classic?: boolean;
  ReservedNodeId?: string;
  TargetReservedNodeOfferingId?: string;
}
export interface ResumeClusterMessage {
  ClusterIdentifier: string | undefined;
}
export interface ScheduledActionType {
  ResizeCluster?: ResizeClusterMessage;
  PauseCluster?: PauseClusterMessage;
  ResumeCluster?: ResumeClusterMessage;
}
export interface CreateScheduledActionMessage {
  ScheduledActionName: string | undefined;
  TargetAction: ScheduledActionType | undefined;
  Schedule: string | undefined;
  IamRole: string | undefined;
  ScheduledActionDescription?: string;
  StartTime?: Date;
  EndTime?: Date;
  Enable?: boolean;
}
export declare class InvalidScheduledActionFault extends __BaseException {
  readonly name: "InvalidScheduledActionFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidScheduledActionFault, __BaseException>
  );
}
export declare class InvalidScheduleFault extends __BaseException {
  readonly name: "InvalidScheduleFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidScheduleFault, __BaseException>
  );
}
export declare const ScheduledActionState: {
  readonly ACTIVE: "ACTIVE";
  readonly DISABLED: "DISABLED";
};
export type ScheduledActionState =
  (typeof ScheduledActionState)[keyof typeof ScheduledActionState];
export interface ScheduledAction {
  ScheduledActionName?: string;
  TargetAction?: ScheduledActionType;
  Schedule?: string;
  IamRole?: string;
  ScheduledActionDescription?: string;
  State?: ScheduledActionState;
  NextInvocations?: Date[];
  StartTime?: Date;
  EndTime?: Date;
}
export declare class ScheduledActionAlreadyExistsFault extends __BaseException {
  readonly name: "ScheduledActionAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ScheduledActionAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class ScheduledActionQuotaExceededFault extends __BaseException {
  readonly name: "ScheduledActionQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ScheduledActionQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class ScheduledActionTypeUnsupportedFault extends __BaseException {
  readonly name: "ScheduledActionTypeUnsupportedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ScheduledActionTypeUnsupportedFault,
      __BaseException
    >
  );
}
export interface CreateSnapshotCopyGrantMessage {
  SnapshotCopyGrantName: string | undefined;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface SnapshotCopyGrant {
  SnapshotCopyGrantName?: string;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface CreateSnapshotCopyGrantResult {
  SnapshotCopyGrant?: SnapshotCopyGrant;
}
export declare class SnapshotCopyGrantAlreadyExistsFault extends __BaseException {
  readonly name: "SnapshotCopyGrantAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SnapshotCopyGrantAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class SnapshotCopyGrantQuotaExceededFault extends __BaseException {
  readonly name: "SnapshotCopyGrantQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SnapshotCopyGrantQuotaExceededFault,
      __BaseException
    >
  );
}
export interface CreateSnapshotScheduleMessage {
  ScheduleDefinitions?: string[];
  ScheduleIdentifier?: string;
  ScheduleDescription?: string;
  Tags?: Tag[];
  DryRun?: boolean;
  NextInvocations?: number;
}
export declare class ScheduleDefinitionTypeUnsupportedFault extends __BaseException {
  readonly name: "ScheduleDefinitionTypeUnsupportedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ScheduleDefinitionTypeUnsupportedFault,
      __BaseException
    >
  );
}
export interface SnapshotSchedule {
  ScheduleDefinitions?: string[];
  ScheduleIdentifier?: string;
  ScheduleDescription?: string;
  Tags?: Tag[];
  NextInvocations?: Date[];
  AssociatedClusterCount?: number;
  AssociatedClusters?: ClusterAssociatedToSchedule[];
}
export declare class SnapshotScheduleAlreadyExistsFault extends __BaseException {
  readonly name: "SnapshotScheduleAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SnapshotScheduleAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class SnapshotScheduleQuotaExceededFault extends __BaseException {
  readonly name: "SnapshotScheduleQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      SnapshotScheduleQuotaExceededFault,
      __BaseException
    >
  );
}
export interface CreateTagsMessage {
  ResourceName: string | undefined;
  Tags: Tag[] | undefined;
}
export declare class ResourceNotFoundFault extends __BaseException {
  readonly name: "ResourceNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundFault, __BaseException>
  );
}
export declare const UsageLimitBreachAction: {
  readonly DISABLE: "disable";
  readonly EMIT_METRIC: "emit-metric";
  readonly LOG: "log";
};
export type UsageLimitBreachAction =
  (typeof UsageLimitBreachAction)[keyof typeof UsageLimitBreachAction];
export declare const UsageLimitFeatureType: {
  readonly CONCURRENCY_SCALING: "concurrency-scaling";
  readonly CROSS_REGION_DATASHARING: "cross-region-datasharing";
  readonly SPECTRUM: "spectrum";
};
export type UsageLimitFeatureType =
  (typeof UsageLimitFeatureType)[keyof typeof UsageLimitFeatureType];
export declare const UsageLimitLimitType: {
  readonly DATA_SCANNED: "data-scanned";
  readonly TIME: "time";
};
export type UsageLimitLimitType =
  (typeof UsageLimitLimitType)[keyof typeof UsageLimitLimitType];
export declare const UsageLimitPeriod: {
  readonly DAILY: "daily";
  readonly MONTHLY: "monthly";
  readonly WEEKLY: "weekly";
};
export type UsageLimitPeriod =
  (typeof UsageLimitPeriod)[keyof typeof UsageLimitPeriod];
export interface CreateUsageLimitMessage {
  ClusterIdentifier: string | undefined;
  FeatureType: UsageLimitFeatureType | undefined;
  LimitType: UsageLimitLimitType | undefined;
  Amount: number | undefined;
  Period?: UsageLimitPeriod;
  BreachAction?: UsageLimitBreachAction;
  Tags?: Tag[];
}
export declare class InvalidUsageLimitFault extends __BaseException {
  readonly name: "InvalidUsageLimitFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidUsageLimitFault, __BaseException>
  );
}
export interface UsageLimit {
  UsageLimitId?: string;
  ClusterIdentifier?: string;
  FeatureType?: UsageLimitFeatureType;
  LimitType?: UsageLimitLimitType;
  Amount?: number;
  Period?: UsageLimitPeriod;
  BreachAction?: UsageLimitBreachAction;
  Tags?: Tag[];
}
export declare class UsageLimitAlreadyExistsFault extends __BaseException {
  readonly name: "UsageLimitAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UsageLimitAlreadyExistsFault, __BaseException>
  );
}
export declare class CustomDomainAssociationNotFoundFault extends __BaseException {
  readonly name: "CustomDomainAssociationNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      CustomDomainAssociationNotFoundFault,
      __BaseException
    >
  );
}
export interface CustomDomainAssociationsMessage {
  Marker?: string;
  Associations?: Association[];
}
export interface CustomerStorageMessage {
  TotalBackupSizeInMegaBytes?: number;
  TotalProvisionedStorageInMegaBytes?: number;
}
export declare const DataShareStatusForConsumer: {
  readonly ACTIVE: "ACTIVE";
  readonly AVAILABLE: "AVAILABLE";
};
export type DataShareStatusForConsumer =
  (typeof DataShareStatusForConsumer)[keyof typeof DataShareStatusForConsumer];
export declare const DataShareStatusForProducer: {
  readonly ACTIVE: "ACTIVE";
  readonly AUTHORIZED: "AUTHORIZED";
  readonly DEAUTHORIZED: "DEAUTHORIZED";
  readonly PENDING_AUTHORIZATION: "PENDING_AUTHORIZATION";
  readonly REJECTED: "REJECTED";
};
export type DataShareStatusForProducer =
  (typeof DataShareStatusForProducer)[keyof typeof DataShareStatusForProducer];
export interface DeauthorizeDataShareMessage {
  DataShareArn: string | undefined;
  ConsumerIdentifier: string | undefined;
}
export interface DefaultClusterParameters {
  ParameterGroupFamily?: string;
  Marker?: string;
  Parameters?: Parameter[];
}
export interface DeleteAuthenticationProfileMessage {
  AuthenticationProfileName: string | undefined;
}
export interface DeleteAuthenticationProfileResult {
  AuthenticationProfileName?: string;
}
export interface DeleteClusterMessage {
  ClusterIdentifier: string | undefined;
  SkipFinalClusterSnapshot?: boolean;
  FinalClusterSnapshotIdentifier?: string;
  FinalClusterSnapshotRetentionPeriod?: number;
}
export interface DeleteClusterResult {
  Cluster?: Cluster;
}
export interface DeleteClusterParameterGroupMessage {
  ParameterGroupName: string | undefined;
}
export declare class InvalidClusterParameterGroupStateFault extends __BaseException {
  readonly name: "InvalidClusterParameterGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidClusterParameterGroupStateFault,
      __BaseException
    >
  );
}
export interface DeleteClusterSecurityGroupMessage {
  ClusterSecurityGroupName: string | undefined;
}
export interface DeleteClusterSnapshotResult {
  Snapshot?: Snapshot;
}
export interface DeleteClusterSubnetGroupMessage {
  ClusterSubnetGroupName: string | undefined;
}
export declare class InvalidClusterSubnetStateFault extends __BaseException {
  readonly name: "InvalidClusterSubnetStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidClusterSubnetStateFault, __BaseException>
  );
}
export interface DeleteCustomDomainAssociationMessage {
  ClusterIdentifier: string | undefined;
  CustomDomainName: string | undefined;
}
export interface DeleteEndpointAccessMessage {
  EndpointName: string | undefined;
}
export declare class EndpointNotFoundFault extends __BaseException {
  readonly name: "EndpointNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<EndpointNotFoundFault, __BaseException>
  );
}
export declare class InvalidEndpointStateFault extends __BaseException {
  readonly name: "InvalidEndpointStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidEndpointStateFault, __BaseException>
  );
}
export interface DeleteEventSubscriptionMessage {
  SubscriptionName: string | undefined;
}
export declare class InvalidSubscriptionStateFault extends __BaseException {
  readonly name: "InvalidSubscriptionStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSubscriptionStateFault, __BaseException>
  );
}
export declare class SubscriptionNotFoundFault extends __BaseException {
  readonly name: "SubscriptionNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubscriptionNotFoundFault, __BaseException>
  );
}
export interface DeleteHsmClientCertificateMessage {
  HsmClientCertificateIdentifier: string | undefined;
}
export declare class InvalidHsmClientCertificateStateFault extends __BaseException {
  readonly name: "InvalidHsmClientCertificateStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidHsmClientCertificateStateFault,
      __BaseException
    >
  );
}
export interface DeleteHsmConfigurationMessage {
  HsmConfigurationIdentifier: string | undefined;
}
export declare class InvalidHsmConfigurationStateFault extends __BaseException {
  readonly name: "InvalidHsmConfigurationStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidHsmConfigurationStateFault,
      __BaseException
    >
  );
}
export interface DeleteRedshiftIdcApplicationMessage {
  RedshiftIdcApplicationArn: string | undefined;
}
export interface DeleteResourcePolicyMessage {
  ResourceArn: string | undefined;
}
export interface DeleteScheduledActionMessage {
  ScheduledActionName: string | undefined;
}
export declare class ScheduledActionNotFoundFault extends __BaseException {
  readonly name: "ScheduledActionNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ScheduledActionNotFoundFault, __BaseException>
  );
}
export interface DeleteSnapshotCopyGrantMessage {
  SnapshotCopyGrantName: string | undefined;
}
export declare class InvalidSnapshotCopyGrantStateFault extends __BaseException {
  readonly name: "InvalidSnapshotCopyGrantStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidSnapshotCopyGrantStateFault,
      __BaseException
    >
  );
}
export declare class SnapshotCopyGrantNotFoundFault extends __BaseException {
  readonly name: "SnapshotCopyGrantNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotCopyGrantNotFoundFault, __BaseException>
  );
}
export interface DeleteSnapshotScheduleMessage {
  ScheduleIdentifier: string | undefined;
}
export declare class InvalidClusterSnapshotScheduleStateFault extends __BaseException {
  readonly name: "InvalidClusterSnapshotScheduleStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidClusterSnapshotScheduleStateFault,
      __BaseException
    >
  );
}
export interface DeleteTagsMessage {
  ResourceName: string | undefined;
  TagKeys: string[] | undefined;
}
export interface DeleteUsageLimitMessage {
  UsageLimitId: string | undefined;
}
export declare class UsageLimitNotFoundFault extends __BaseException {
  readonly name: "UsageLimitNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UsageLimitNotFoundFault, __BaseException>
  );
}
export interface DescribeAccountAttributesMessage {
  AttributeNames?: string[];
}
export interface DescribeAuthenticationProfilesMessage {
  AuthenticationProfileName?: string;
}
export interface DescribeAuthenticationProfilesResult {
  AuthenticationProfiles?: AuthenticationProfile[];
}
export interface DescribeClusterDbRevisionsMessage {
  ClusterIdentifier?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface DescribeClusterParameterGroupsMessage {
  ParameterGroupName?: string;
  MaxRecords?: number;
  Marker?: string;
  TagKeys?: string[];
  TagValues?: string[];
}
export interface DescribeClusterParametersMessage {
  ParameterGroupName: string | undefined;
  Source?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface DescribeClustersMessage {
  ClusterIdentifier?: string;
  MaxRecords?: number;
  Marker?: string;
  TagKeys?: string[];
  TagValues?: string[];
}
export interface DescribeClusterSecurityGroupsMessage {
  ClusterSecurityGroupName?: string;
  MaxRecords?: number;
  Marker?: string;
  TagKeys?: string[];
  TagValues?: string[];
}
export declare const SnapshotAttributeToSortBy: {
  readonly CREATE_TIME: "CREATE_TIME";
  readonly SOURCE_TYPE: "SOURCE_TYPE";
  readonly TOTAL_SIZE: "TOTAL_SIZE";
};
export type SnapshotAttributeToSortBy =
  (typeof SnapshotAttributeToSortBy)[keyof typeof SnapshotAttributeToSortBy];
export declare const SortByOrder: {
  readonly ASCENDING: "ASC";
  readonly DESCENDING: "DESC";
};
export type SortByOrder = (typeof SortByOrder)[keyof typeof SortByOrder];
export interface SnapshotSortingEntity {
  Attribute: SnapshotAttributeToSortBy | undefined;
  SortOrder?: SortByOrder;
}
export interface DescribeClusterSnapshotsMessage {
  ClusterIdentifier?: string;
  SnapshotIdentifier?: string;
  SnapshotArn?: string;
  SnapshotType?: string;
  StartTime?: Date;
  EndTime?: Date;
  MaxRecords?: number;
  Marker?: string;
  OwnerAccount?: string;
  TagKeys?: string[];
  TagValues?: string[];
  ClusterExists?: boolean;
  SortingEntities?: SnapshotSortingEntity[];
}
export interface SnapshotMessage {
  Marker?: string;
  Snapshots?: Snapshot[];
}
export interface DescribeClusterSubnetGroupsMessage {
  ClusterSubnetGroupName?: string;
  MaxRecords?: number;
  Marker?: string;
  TagKeys?: string[];
  TagValues?: string[];
}
export interface DescribeClusterTracksMessage {
  MaintenanceTrackName?: string;
  MaxRecords?: number;
  Marker?: string;
}
export interface SupportedOperation {
  OperationName?: string;
}
export interface UpdateTarget {
  MaintenanceTrackName?: string;
  DatabaseVersion?: string;
  SupportedOperations?: SupportedOperation[];
}
export interface MaintenanceTrack {
  MaintenanceTrackName?: string;
  DatabaseVersion?: string;
  UpdateTargets?: UpdateTarget[];
}
export interface TrackListMessage {
  MaintenanceTracks?: MaintenanceTrack[];
  Marker?: string;
}
export declare const PendingModifiedValuesFilterSensitiveLog: (
  obj: PendingModifiedValues
) => any;
export declare const ClusterFilterSensitiveLog: (obj: Cluster) => any;
export declare const ClusterCredentialsFilterSensitiveLog: (
  obj: ClusterCredentials
) => any;
export declare const ClusterExtendedCredentialsFilterSensitiveLog: (
  obj: ClusterExtendedCredentials
) => any;
export declare const ClustersMessageFilterSensitiveLog: (
  obj: ClustersMessage
) => any;
export declare const CreateClusterMessageFilterSensitiveLog: (
  obj: CreateClusterMessage
) => any;
export declare const CreateClusterResultFilterSensitiveLog: (
  obj: CreateClusterResult
) => any;
export declare const DeleteClusterResultFilterSensitiveLog: (
  obj: DeleteClusterResult
) => any;

import { parseXmlBody as parseBody, parseXmlErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, expectUnion as __expectUnion, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeDateTime as __serializeDateTime, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { AccessToClusterDeniedFault, AccessToSnapshotDeniedFault, AuthenticationProfileAlreadyExistsFault, AuthenticationProfileNotFoundFault, AuthenticationProfileQuotaExceededFault, AuthorizationAlreadyExistsFault, AuthorizationNotFoundFault, AuthorizationQuotaExceededFault, BatchDeleteRequestSizeExceededFault, BatchModifyClusterSnapshotsLimitExceededFault, BucketNotFoundFault, ClusterAlreadyExistsFault, ClusterNotFoundFault, ClusterOnLatestRevisionFault, ClusterParameterGroupAlreadyExistsFault, ClusterParameterGroupNotFoundFault, ClusterParameterGroupQuotaExceededFault, ClusterQuotaExceededFault, ClusterSecurityGroupAlreadyExistsFault, ClusterSecurityGroupNotFoundFault, ClusterSecurityGroupQuotaExceededFault, ClusterSnapshotAlreadyExistsFault, ClusterSnapshotNotFoundFault, ClusterSnapshotQuotaExceededFault, ClusterSubnetGroupAlreadyExistsFault, ClusterSubnetGroupNotFoundFault, ClusterSubnetGroupQuotaExceededFault, ClusterSubnetQuotaExceededFault, ConflictPolicyUpdateFault, CopyToRegionDisabledFault, CustomCnameAssociationFault, CustomDomainAssociationNotFoundFault, DependentServiceAccessDeniedFault, DependentServiceRequestThrottlingFault, DependentServiceUnavailableFault, EndpointAlreadyExistsFault, EndpointAuthorizationAlreadyExistsFault, EndpointAuthorizationsPerClusterLimitExceededFault, EndpointNotFoundFault, EndpointsPerAuthorizationLimitExceededFault, EndpointsPerClusterLimitExceededFault, EventSubscriptionQuotaExceededFault, HsmClientCertificateAlreadyExistsFault, HsmClientCertificateNotFoundFault, HsmClientCertificateQuotaExceededFault, HsmConfigurationAlreadyExistsFault, HsmConfigurationNotFoundFault, HsmConfigurationQuotaExceededFault, InsufficientClusterCapacityFault, InvalidAuthenticationProfileRequestFault, InvalidAuthorizationStateFault, InvalidClusterParameterGroupStateFault, InvalidClusterSecurityGroupStateFault, InvalidClusterSnapshotScheduleStateFault, InvalidClusterSnapshotStateFault, InvalidClusterStateFault, InvalidClusterSubnetGroupStateFault, InvalidClusterSubnetStateFault, InvalidClusterTrackFault, InvalidDataShareFault, InvalidElasticIpFault, InvalidEndpointStateFault, InvalidHsmClientCertificateStateFault, InvalidHsmConfigurationStateFault, InvalidNamespaceFault, InvalidReservedNodeStateFault, InvalidRetentionPeriodFault, InvalidScheduledActionFault, InvalidScheduleFault, InvalidSnapshotCopyGrantStateFault, InvalidSubnet, InvalidSubscriptionStateFault, InvalidTagFault, InvalidUsageLimitFault, InvalidVPCNetworkStateFault, Ipv6CidrBlockNotFoundFault, LakeFormationScopeUnion, LimitExceededFault, NumberOfNodesPerClusterLimitExceededFault, NumberOfNodesQuotaExceededFault, PartnerNotFoundFault, RedshiftIdcApplicationAlreadyExistsFault, RedshiftIdcApplicationNotExistsFault, RedshiftIdcApplicationQuotaExceededFault, ReservedNodeAlreadyExistsFault, ReservedNodeAlreadyMigratedFault, ReservedNodeNotFoundFault, ReservedNodeOfferingNotFoundFault, ResizeNotFoundFault, ResourceNotFoundFault, ScheduledActionAlreadyExistsFault, ScheduledActionNotFoundFault, ScheduledActionQuotaExceededFault, ScheduledActionTypeUnsupportedFault, ScheduleDefinitionTypeUnsupportedFault, ServiceIntegrationsUnion, SnapshotCopyGrantAlreadyExistsFault, SnapshotCopyGrantNotFoundFault, SnapshotCopyGrantQuotaExceededFault, SnapshotScheduleAlreadyExistsFault, SnapshotScheduleNotFoundFault, SnapshotScheduleQuotaExceededFault, SNSInvalidTopicFault, SNSNoAuthorizationFault, SNSTopicArnNotFoundFault, SourceNotFoundFault, SubscriptionAlreadyExistFault, SubscriptionCategoryNotFoundFault, SubscriptionEventIdNotFoundFault, SubscriptionNotFoundFault, SubscriptionSeverityNotFoundFault, TagLimitExceededFault, UnauthorizedOperation, UnauthorizedPartnerIntegrationFault, UnsupportedOperationFault, UsageLimitAlreadyExistsFault, UsageLimitNotFoundFault, } from "../models/models_0";
import { EndpointAuthorizationNotFoundFault, IncompatibleOrderableOptions, InProgressTableRestoreQuotaExceededFault, InsufficientS3BucketPolicyFault, IntegrationNotFoundFault, InvalidPolicyFault, InvalidRestoreFault, InvalidS3BucketNameFault, InvalidS3KeyPrefixFault, InvalidTableRestoreArgumentFault, ReservedNodeExchangeNotFoundFault, ReservedNodeQuotaExceededFault, SnapshotCopyAlreadyDisabledFault, SnapshotCopyAlreadyEnabledFault, SnapshotCopyDisabledFault, SnapshotScheduleUpdateInProgressFault, SubnetAlreadyInUse, TableLimitExceededFault, TableRestoreNotFoundFault, UnknownSnapshotCopyRegionFault, UnsupportedOptionFault, } from "../models/models_1";
import { RedshiftServiceException as __BaseException } from "../models/RedshiftServiceException";
export const se_AcceptReservedNodeExchangeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AcceptReservedNodeExchangeInputMessage(input, context),
        [_A]: _ARNE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AddPartnerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PartnerIntegrationInputMessage(input, context),
        [_A]: _AP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AssociateDataShareConsumerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssociateDataShareConsumerMessage(input, context),
        [_A]: _ADSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeClusterSecurityGroupIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeClusterSecurityGroupIngressMessage(input, context),
        [_A]: _ACSGI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeDataShareCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeDataShareMessage(input, context),
        [_A]: _ADS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeEndpointAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeEndpointAccessMessage(input, context),
        [_A]: _AEA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AuthorizeSnapshotAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AuthorizeSnapshotAccessMessage(input, context),
        [_A]: _ASA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchDeleteClusterSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchDeleteClusterSnapshotsRequest(input, context),
        [_A]: _BDCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchModifyClusterSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BatchModifyClusterSnapshotsMessage(input, context),
        [_A]: _BMCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelResizeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CancelResizeMessage(input, context),
        [_A]: _CR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CopyClusterSnapshotMessage(input, context),
        [_A]: _CCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAuthenticationProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAuthenticationProfileMessage(input, context),
        [_A]: _CAP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClusterMessage(input, context),
        [_A]: _CC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClusterParameterGroupMessage(input, context),
        [_A]: _CCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClusterSecurityGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClusterSecurityGroupMessage(input, context),
        [_A]: _CCSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClusterSnapshotMessage(input, context),
        [_A]: _CCSr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClusterSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateClusterSubnetGroupMessage(input, context),
        [_A]: _CCSGr,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateCustomDomainAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateCustomDomainAssociationMessage(input, context),
        [_A]: _CCDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateEndpointAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateEndpointAccessMessage(input, context),
        [_A]: _CEA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateEventSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateEventSubscriptionMessage(input, context),
        [_A]: _CES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateHsmClientCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateHsmClientCertificateMessage(input, context),
        [_A]: _CHCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateHsmConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateHsmConfigurationMessage(input, context),
        [_A]: _CHC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRedshiftIdcApplicationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRedshiftIdcApplicationMessage(input, context),
        [_A]: _CRIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateScheduledActionMessage(input, context),
        [_A]: _CSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotCopyGrantCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSnapshotCopyGrantMessage(input, context),
        [_A]: _CSCG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotScheduleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSnapshotScheduleMessage(input, context),
        [_A]: _CSS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTagsMessage(input, context),
        [_A]: _CT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateUsageLimitCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateUsageLimitMessage(input, context),
        [_A]: _CUL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeauthorizeDataShareCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeauthorizeDataShareMessage(input, context),
        [_A]: _DDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAuthenticationProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAuthenticationProfileMessage(input, context),
        [_A]: _DAP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClusterMessage(input, context),
        [_A]: _DC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClusterParameterGroupMessage(input, context),
        [_A]: _DCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClusterSecurityGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClusterSecurityGroupMessage(input, context),
        [_A]: _DCSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClusterSnapshotMessage(input, context),
        [_A]: _DCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClusterSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteClusterSubnetGroupMessage(input, context),
        [_A]: _DCSGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteCustomDomainAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteCustomDomainAssociationMessage(input, context),
        [_A]: _DCDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteEndpointAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteEndpointAccessMessage(input, context),
        [_A]: _DEA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteEventSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteEventSubscriptionMessage(input, context),
        [_A]: _DES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteHsmClientCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteHsmClientCertificateMessage(input, context),
        [_A]: _DHCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteHsmConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteHsmConfigurationMessage(input, context),
        [_A]: _DHC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePartnerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PartnerIntegrationInputMessage(input, context),
        [_A]: _DP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRedshiftIdcApplicationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRedshiftIdcApplicationMessage(input, context),
        [_A]: _DRIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteResourcePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteResourcePolicyMessage(input, context),
        [_A]: _DRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteScheduledActionMessage(input, context),
        [_A]: _DSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSnapshotCopyGrantCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSnapshotCopyGrantMessage(input, context),
        [_A]: _DSCG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSnapshotScheduleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSnapshotScheduleMessage(input, context),
        [_A]: _DSS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTagsMessage(input, context),
        [_A]: _DT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUsageLimitCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUsageLimitMessage(input, context),
        [_A]: _DUL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAccountAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAccountAttributesMessage(input, context),
        [_A]: _DAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAuthenticationProfilesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAuthenticationProfilesMessage(input, context),
        [_A]: _DAPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterDbRevisionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterDbRevisionsMessage(input, context),
        [_A]: _DCDR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterParameterGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterParameterGroupsMessage(input, context),
        [_A]: _DCPGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterParametersMessage(input, context),
        [_A]: _DCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClustersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClustersMessage(input, context),
        [_A]: _DCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterSecurityGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterSecurityGroupsMessage(input, context),
        [_A]: _DCSGes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterSnapshotsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterSnapshotsMessage(input, context),
        [_A]: _DCSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterSubnetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterSubnetGroupsMessage(input, context),
        [_A]: _DCSGesc,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterTracksCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterTracksMessage(input, context),
        [_A]: _DCT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClusterVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeClusterVersionsMessage(input, context),
        [_A]: _DCV,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeCustomDomainAssociationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeCustomDomainAssociationsMessage(input, context),
        [_A]: _DCDAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDataSharesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDataSharesMessage(input, context),
        [_A]: _DDSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDataSharesForConsumerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDataSharesForConsumerMessage(input, context),
        [_A]: _DDSFC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDataSharesForProducerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDataSharesForProducerMessage(input, context),
        [_A]: _DDSFP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDefaultClusterParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDefaultClusterParametersMessage(input, context),
        [_A]: _DDCP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEndpointAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEndpointAccessMessage(input, context),
        [_A]: _DEAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEndpointAuthorizationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEndpointAuthorizationMessage(input, context),
        [_A]: _DEAes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventCategoriesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventCategoriesMessage(input, context),
        [_A]: _DEC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventsMessage(input, context),
        [_A]: _DE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventSubscriptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeEventSubscriptionsMessage(input, context),
        [_A]: _DESe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeHsmClientCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeHsmClientCertificatesMessage(input, context),
        [_A]: _DHCCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeHsmConfigurationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeHsmConfigurationsMessage(input, context),
        [_A]: _DHCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInboundIntegrationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInboundIntegrationsMessage(input, context),
        [_A]: _DII,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeLoggingStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoggingStatusMessage(input, context),
        [_A]: _DLS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeNodeConfigurationOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeNodeConfigurationOptionsMessage(input, context),
        [_A]: _DNCO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeOrderableClusterOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeOrderableClusterOptionsMessage(input, context),
        [_A]: _DOCO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribePartnersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribePartnersInputMessage(input, context),
        [_A]: _DPe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRedshiftIdcApplicationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRedshiftIdcApplicationsMessage(input, context),
        [_A]: _DRIAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedNodeExchangeStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedNodeExchangeStatusInputMessage(input, context),
        [_A]: _DRNES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedNodeOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedNodeOfferingsMessage(input, context),
        [_A]: _DRNO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedNodesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeReservedNodesMessage(input, context),
        [_A]: _DRN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeResizeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeResizeMessage(input, context),
        [_A]: _DR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScheduledActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScheduledActionsMessage(input, context),
        [_A]: _DSAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotCopyGrantsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSnapshotCopyGrantsMessage(input, context),
        [_A]: _DSCGe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotSchedulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSnapshotSchedulesMessage(input, context),
        [_A]: _DSSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeStorageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _DS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTableRestoreStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTableRestoreStatusMessage(input, context),
        [_A]: _DTRS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsMessage(input, context),
        [_A]: _DTe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeUsageLimitsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeUsageLimitsMessage(input, context),
        [_A]: _DULe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableLoggingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableLoggingMessage(input, context),
        [_A]: _DL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableSnapshotCopyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableSnapshotCopyMessage(input, context),
        [_A]: _DSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateDataShareConsumerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisassociateDataShareConsumerMessage(input, context),
        [_A]: _DDSC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableLoggingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableLoggingMessage(input, context),
        [_A]: _EL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableSnapshotCopyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableSnapshotCopyMessage(input, context),
        [_A]: _ESC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_FailoverPrimaryComputeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_FailoverPrimaryComputeInputMessage(input, context),
        [_A]: _FPC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetClusterCredentialsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetClusterCredentialsMessage(input, context),
        [_A]: _GCC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetClusterCredentialsWithIAMCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetClusterCredentialsWithIAMMessage(input, context),
        [_A]: _GCCWIAM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetReservedNodeExchangeConfigurationOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetReservedNodeExchangeConfigurationOptionsInputMessage(input, context),
        [_A]: _GRNECO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetReservedNodeExchangeOfferingsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetReservedNodeExchangeOfferingsInputMessage(input, context),
        [_A]: _GRNEO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetResourcePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetResourcePolicyMessage(input, context),
        [_A]: _GRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListRecommendationsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRecommendationsMessage(input, context),
        [_A]: _LR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyAquaConfigurationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyAquaInputMessage(input, context),
        [_A]: _MAC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyAuthenticationProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyAuthenticationProfileMessage(input, context),
        [_A]: _MAP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterMessage(input, context),
        [_A]: _MC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterDbRevisionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterDbRevisionMessage(input, context),
        [_A]: _MCDR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterIamRolesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterIamRolesMessage(input, context),
        [_A]: _MCIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterMaintenanceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterMaintenanceMessage(input, context),
        [_A]: _MCM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterParameterGroupMessage(input, context),
        [_A]: _MCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterSnapshotMessage(input, context),
        [_A]: _MCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterSnapshotScheduleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterSnapshotScheduleMessage(input, context),
        [_A]: _MCSS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyClusterSubnetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyClusterSubnetGroupMessage(input, context),
        [_A]: _MCSG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyCustomDomainAssociationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyCustomDomainAssociationMessage(input, context),
        [_A]: _MCDA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyEndpointAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyEndpointAccessMessage(input, context),
        [_A]: _MEA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyEventSubscriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyEventSubscriptionMessage(input, context),
        [_A]: _MES,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyRedshiftIdcApplicationCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyRedshiftIdcApplicationMessage(input, context),
        [_A]: _MRIA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyScheduledActionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyScheduledActionMessage(input, context),
        [_A]: _MSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySnapshotCopyRetentionPeriodCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySnapshotCopyRetentionPeriodMessage(input, context),
        [_A]: _MSCRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifySnapshotScheduleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifySnapshotScheduleMessage(input, context),
        [_A]: _MSS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ModifyUsageLimitCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyUsageLimitMessage(input, context),
        [_A]: _MUL,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PauseClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PauseClusterMessage(input, context),
        [_A]: _PC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseReservedNodeOfferingCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PurchaseReservedNodeOfferingMessage(input, context),
        [_A]: _PRNO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutResourcePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutResourcePolicyMessage(input, context),
        [_A]: _PRP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RebootClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RebootClusterMessage(input, context),
        [_A]: _RC,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RejectDataShareCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RejectDataShareMessage(input, context),
        [_A]: _RDS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetClusterParameterGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetClusterParameterGroupMessage(input, context),
        [_A]: _RCPG,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResizeClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResizeClusterMessage(input, context),
        [_A]: _RCe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreFromClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreFromClusterSnapshotMessage(input, context),
        [_A]: _RFCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreTableFromClusterSnapshotCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RestoreTableFromClusterSnapshotMessage(input, context),
        [_A]: _RTFCS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResumeClusterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResumeClusterMessage(input, context),
        [_A]: _RCes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeClusterSecurityGroupIngressCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeClusterSecurityGroupIngressMessage(input, context),
        [_A]: _RCSGI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeEndpointAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeEndpointAccessMessage(input, context),
        [_A]: _REA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RevokeSnapshotAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RevokeSnapshotAccessMessage(input, context),
        [_A]: _RSA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RotateEncryptionKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RotateEncryptionKeyMessage(input, context),
        [_A]: _REK,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdatePartnerStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdatePartnerStatusInputMessage(input, context),
        [_A]: _UPS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AcceptReservedNodeExchangeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AcceptReservedNodeExchangeOutputMessage(data.AcceptReservedNodeExchangeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AddPartnerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PartnerIntegrationOutputMessage(data.AddPartnerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AssociateDataShareConsumerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DataShare(data.AssociateDataShareConsumerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeClusterSecurityGroupIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AuthorizeClusterSecurityGroupIngressResult(data.AuthorizeClusterSecurityGroupIngressResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeDataShareCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DataShare(data.AuthorizeDataShareResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeEndpointAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAuthorization(data.AuthorizeEndpointAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_AuthorizeSnapshotAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AuthorizeSnapshotAccessResult(data.AuthorizeSnapshotAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchDeleteClusterSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchDeleteClusterSnapshotsResult(data.BatchDeleteClusterSnapshotsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchModifyClusterSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchModifyClusterSnapshotsOutputMessage(data.BatchModifyClusterSnapshotsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelResizeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResizeProgressMessage(data.CancelResizeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyClusterSnapshotResult(data.CopyClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateAuthenticationProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAuthenticationProfileResult(data.CreateAuthenticationProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClusterResult(data.CreateClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClusterParameterGroupResult(data.CreateClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClusterSecurityGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClusterSecurityGroupResult(data.CreateClusterSecurityGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClusterSnapshotResult(data.CreateClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClusterSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClusterSubnetGroupResult(data.CreateClusterSubnetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateCustomDomainAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateCustomDomainAssociationResult(data.CreateCustomDomainAssociationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateEndpointAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAccess(data.CreateEndpointAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateEventSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateEventSubscriptionResult(data.CreateEventSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateHsmClientCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateHsmClientCertificateResult(data.CreateHsmClientCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateHsmConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateHsmConfigurationResult(data.CreateHsmConfigurationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRedshiftIdcApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRedshiftIdcApplicationResult(data.CreateRedshiftIdcApplicationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScheduledAction(data.CreateScheduledActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotCopyGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSnapshotCopyGrantResult(data.CreateSnapshotCopyGrantResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SnapshotSchedule(data.CreateSnapshotScheduleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_CreateUsageLimitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UsageLimit(data.CreateUsageLimitResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeauthorizeDataShareCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DataShare(data.DeauthorizeDataShareResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteAuthenticationProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAuthenticationProfileResult(data.DeleteAuthenticationProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteClusterResult(data.DeleteClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteClusterSecurityGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteClusterSnapshotResult(data.DeleteClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteClusterSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteCustomDomainAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteEndpointAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAccess(data.DeleteEndpointAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteEventSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteHsmClientCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteHsmConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeletePartnerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PartnerIntegrationOutputMessage(data.DeletePartnerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRedshiftIdcApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteSnapshotCopyGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteSnapshotScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DeleteUsageLimitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_DescribeAccountAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AccountAttributeList(data.DescribeAccountAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAuthenticationProfilesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAuthenticationProfilesResult(data.DescribeAuthenticationProfilesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterDbRevisionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterDbRevisionsMessage(data.DescribeClusterDbRevisionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterParameterGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterParameterGroupsMessage(data.DescribeClusterParameterGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterParameterGroupDetails(data.DescribeClusterParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClustersMessage(data.DescribeClustersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterSecurityGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterSecurityGroupMessage(data.DescribeClusterSecurityGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SnapshotMessage(data.DescribeClusterSnapshotsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterSubnetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterSubnetGroupMessage(data.DescribeClusterSubnetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterTracksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TrackListMessage(data.DescribeClusterTracksResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClusterVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterVersionsMessage(data.DescribeClusterVersionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeCustomDomainAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CustomDomainAssociationsMessage(data.DescribeCustomDomainAssociationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDataSharesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDataSharesResult(data.DescribeDataSharesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDataSharesForConsumerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDataSharesForConsumerResult(data.DescribeDataSharesForConsumerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDataSharesForProducerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDataSharesForProducerResult(data.DescribeDataSharesForProducerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDefaultClusterParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDefaultClusterParametersResult(data.DescribeDefaultClusterParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEndpointAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAccessList(data.DescribeEndpointAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEndpointAuthorizationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAuthorizationList(data.DescribeEndpointAuthorizationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventCategoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventCategoriesMessage(data.DescribeEventCategoriesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventsMessage(data.DescribeEventsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventSubscriptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EventSubscriptionsMessage(data.DescribeEventSubscriptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeHsmClientCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_HsmClientCertificateMessage(data.DescribeHsmClientCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeHsmConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_HsmConfigurationMessage(data.DescribeHsmConfigurationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeInboundIntegrationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_InboundIntegrationsMessage(data.DescribeInboundIntegrationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeLoggingStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LoggingStatus(data.DescribeLoggingStatusResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeNodeConfigurationOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_NodeConfigurationOptionsMessage(data.DescribeNodeConfigurationOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeOrderableClusterOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_OrderableClusterOptionsMessage(data.DescribeOrderableClusterOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribePartnersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribePartnersOutputMessage(data.DescribePartnersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRedshiftIdcApplicationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRedshiftIdcApplicationsResult(data.DescribeRedshiftIdcApplicationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedNodeExchangeStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedNodeExchangeStatusOutputMessage(data.DescribeReservedNodeExchangeStatusResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedNodeOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReservedNodeOfferingsMessage(data.DescribeReservedNodeOfferingsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedNodesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReservedNodesMessage(data.DescribeReservedNodesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeResizeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResizeProgressMessage(data.DescribeResizeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScheduledActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScheduledActionsMessage(data.DescribeScheduledActionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotCopyGrantsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SnapshotCopyGrantMessage(data.DescribeSnapshotCopyGrantsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotSchedulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotSchedulesOutputMessage(data.DescribeSnapshotSchedulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStorageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CustomerStorageMessage(data.DescribeStorageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTableRestoreStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TableRestoreStatusMessage(data.DescribeTableRestoreStatusResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TaggedResourceListMessage(data.DescribeTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeUsageLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UsageLimitList(data.DescribeUsageLimitsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableLoggingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LoggingStatus(data.DisableLoggingResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisableSnapshotCopyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableSnapshotCopyResult(data.DisableSnapshotCopyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateDataShareConsumerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DataShare(data.DisassociateDataShareConsumerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableLoggingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_LoggingStatus(data.EnableLoggingResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_EnableSnapshotCopyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableSnapshotCopyResult(data.EnableSnapshotCopyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_FailoverPrimaryComputeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_FailoverPrimaryComputeResult(data.FailoverPrimaryComputeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetClusterCredentialsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterCredentials(data.GetClusterCredentialsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetClusterCredentialsWithIAMCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterExtendedCredentials(data.GetClusterCredentialsWithIAMResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetReservedNodeExchangeConfigurationOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetReservedNodeExchangeConfigurationOptionsOutputMessage(data.GetReservedNodeExchangeConfigurationOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetReservedNodeExchangeOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetReservedNodeExchangeOfferingsOutputMessage(data.GetReservedNodeExchangeOfferingsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetResourcePolicyResult(data.GetResourcePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListRecommendationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRecommendationsResult(data.ListRecommendationsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyAquaConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyAquaOutputMessage(data.ModifyAquaConfigurationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyAuthenticationProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyAuthenticationProfileResult(data.ModifyAuthenticationProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClusterResult(data.ModifyClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterDbRevisionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClusterDbRevisionResult(data.ModifyClusterDbRevisionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterIamRolesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClusterIamRolesResult(data.ModifyClusterIamRolesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterMaintenanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClusterMaintenanceResult(data.ModifyClusterMaintenanceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterParameterGroupNameMessage(data.ModifyClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClusterSnapshotResult(data.ModifyClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyClusterSnapshotScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
export const de_ModifyClusterSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyClusterSubnetGroupResult(data.ModifyClusterSubnetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyCustomDomainAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyCustomDomainAssociationResult(data.ModifyCustomDomainAssociationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyEndpointAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAccess(data.ModifyEndpointAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyEventSubscriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyEventSubscriptionResult(data.ModifyEventSubscriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyRedshiftIdcApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyRedshiftIdcApplicationResult(data.ModifyRedshiftIdcApplicationResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyScheduledActionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ScheduledAction(data.ModifyScheduledActionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifySnapshotCopyRetentionPeriodCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifySnapshotCopyRetentionPeriodResult(data.ModifySnapshotCopyRetentionPeriodResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifySnapshotScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SnapshotSchedule(data.ModifySnapshotScheduleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ModifyUsageLimitCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UsageLimit(data.ModifyUsageLimitResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PauseClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PauseClusterResult(data.PauseClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseReservedNodeOfferingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseReservedNodeOfferingResult(data.PurchaseReservedNodeOfferingResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutResourcePolicyResult(data.PutResourcePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RebootClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RebootClusterResult(data.RebootClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RejectDataShareCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DataShare(data.RejectDataShareResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetClusterParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ClusterParameterGroupNameMessage(data.ResetClusterParameterGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResizeClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResizeClusterResult(data.ResizeClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreFromClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreFromClusterSnapshotResult(data.RestoreFromClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreTableFromClusterSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreTableFromClusterSnapshotResult(data.RestoreTableFromClusterSnapshotResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResumeClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResumeClusterResult(data.ResumeClusterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeClusterSecurityGroupIngressCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RevokeClusterSecurityGroupIngressResult(data.RevokeClusterSecurityGroupIngressResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeEndpointAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EndpointAuthorization(data.RevokeEndpointAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RevokeSnapshotAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RevokeSnapshotAccessResult(data.RevokeSnapshotAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RotateEncryptionKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RotateEncryptionKeyResult(data.RotateEncryptionKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdatePartnerStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PartnerIntegrationOutputMessage(data.UpdatePartnerStatusResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependentServiceUnavailableFault":
        case "com.amazonaws.redshift#DependentServiceUnavailableFault":
            throw await de_DependentServiceUnavailableFaultRes(parsedOutput, context);
        case "InvalidReservedNodeState":
        case "com.amazonaws.redshift#InvalidReservedNodeStateFault":
            throw await de_InvalidReservedNodeStateFaultRes(parsedOutput, context);
        case "ReservedNodeAlreadyExists":
        case "com.amazonaws.redshift#ReservedNodeAlreadyExistsFault":
            throw await de_ReservedNodeAlreadyExistsFaultRes(parsedOutput, context);
        case "ReservedNodeAlreadyMigrated":
        case "com.amazonaws.redshift#ReservedNodeAlreadyMigratedFault":
            throw await de_ReservedNodeAlreadyMigratedFaultRes(parsedOutput, context);
        case "ReservedNodeNotFound":
        case "com.amazonaws.redshift#ReservedNodeNotFoundFault":
            throw await de_ReservedNodeNotFoundFaultRes(parsedOutput, context);
        case "ReservedNodeOfferingNotFound":
        case "com.amazonaws.redshift#ReservedNodeOfferingNotFoundFault":
            throw await de_ReservedNodeOfferingNotFoundFaultRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.redshift#UnsupportedOperationFault":
            throw await de_UnsupportedOperationFaultRes(parsedOutput, context);
        case "ClusterNotFound":
        case "com.amazonaws.redshift#ClusterNotFoundFault":
            throw await de_ClusterNotFoundFaultRes(parsedOutput, context);
        case "PartnerNotFound":
        case "com.amazonaws.redshift#PartnerNotFoundFault":
            throw await de_PartnerNotFoundFaultRes(parsedOutput, context);
        case "UnauthorizedPartnerIntegration":
        case "com.amazonaws.redshift#UnauthorizedPartnerIntegrationFault":
            throw await de_UnauthorizedPartnerIntegrationFaultRes(parsedOutput, context);
        case "InvalidDataShareFault":
        case "com.amazonaws.redshift#InvalidDataShareFault":
            throw await de_InvalidDataShareFaultRes(parsedOutput, context);
        case "InvalidNamespaceFault":
        case "com.amazonaws.redshift#InvalidNamespaceFault":
            throw await de_InvalidNamespaceFaultRes(parsedOutput, context);
        case "AuthorizationAlreadyExists":
        case "com.amazonaws.redshift#AuthorizationAlreadyExistsFault":
            throw await de_AuthorizationAlreadyExistsFaultRes(parsedOutput, context);
        case "AuthorizationQuotaExceeded":
        case "com.amazonaws.redshift#AuthorizationQuotaExceededFault":
            throw await de_AuthorizationQuotaExceededFaultRes(parsedOutput, context);
        case "ClusterSecurityGroupNotFound":
        case "com.amazonaws.redshift#ClusterSecurityGroupNotFoundFault":
            throw await de_ClusterSecurityGroupNotFoundFaultRes(parsedOutput, context);
        case "InvalidClusterSecurityGroupState":
        case "com.amazonaws.redshift#InvalidClusterSecurityGroupStateFault":
            throw await de_InvalidClusterSecurityGroupStateFaultRes(parsedOutput, context);
        case "EndpointAuthorizationAlreadyExists":
        case "com.amazonaws.redshift#EndpointAuthorizationAlreadyExistsFault":
            throw await de_EndpointAuthorizationAlreadyExistsFaultRes(parsedOutput, context);
        case "EndpointAuthorizationsPerClusterLimitExceeded":
        case "com.amazonaws.redshift#EndpointAuthorizationsPerClusterLimitExceededFault":
            throw await de_EndpointAuthorizationsPerClusterLimitExceededFaultRes(parsedOutput, context);
        case "InvalidAuthorizationState":
        case "com.amazonaws.redshift#InvalidAuthorizationStateFault":
            throw await de_InvalidAuthorizationStateFaultRes(parsedOutput, context);
        case "InvalidClusterState":
        case "com.amazonaws.redshift#InvalidClusterStateFault":
            throw await de_InvalidClusterStateFaultRes(parsedOutput, context);
        case "ClusterSnapshotNotFound":
        case "com.amazonaws.redshift#ClusterSnapshotNotFoundFault":
            throw await de_ClusterSnapshotNotFoundFaultRes(parsedOutput, context);
        case "DependentServiceRequestThrottlingFault":
        case "com.amazonaws.redshift#DependentServiceRequestThrottlingFault":
            throw await de_DependentServiceRequestThrottlingFaultRes(parsedOutput, context);
        case "InvalidClusterSnapshotState":
        case "com.amazonaws.redshift#InvalidClusterSnapshotStateFault":
            throw await de_InvalidClusterSnapshotStateFaultRes(parsedOutput, context);
        case "LimitExceededFault":
        case "com.amazonaws.redshift#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        case "BatchDeleteRequestSizeExceeded":
        case "com.amazonaws.redshift#BatchDeleteRequestSizeExceededFault":
            throw await de_BatchDeleteRequestSizeExceededFaultRes(parsedOutput, context);
        case "BatchModifyClusterSnapshotsLimitExceededFault":
        case "com.amazonaws.redshift#BatchModifyClusterSnapshotsLimitExceededFault":
            throw await de_BatchModifyClusterSnapshotsLimitExceededFaultRes(parsedOutput, context);
        case "InvalidRetentionPeriodFault":
        case "com.amazonaws.redshift#InvalidRetentionPeriodFault":
            throw await de_InvalidRetentionPeriodFaultRes(parsedOutput, context);
        case "ResizeNotFound":
        case "com.amazonaws.redshift#ResizeNotFoundFault":
            throw await de_ResizeNotFoundFaultRes(parsedOutput, context);
        case "ClusterSnapshotAlreadyExists":
        case "com.amazonaws.redshift#ClusterSnapshotAlreadyExistsFault":
            throw await de_ClusterSnapshotAlreadyExistsFaultRes(parsedOutput, context);
        case "ClusterSnapshotQuotaExceeded":
        case "com.amazonaws.redshift#ClusterSnapshotQuotaExceededFault":
            throw await de_ClusterSnapshotQuotaExceededFaultRes(parsedOutput, context);
        case "AuthenticationProfileAlreadyExistsFault":
        case "com.amazonaws.redshift#AuthenticationProfileAlreadyExistsFault":
            throw await de_AuthenticationProfileAlreadyExistsFaultRes(parsedOutput, context);
        case "AuthenticationProfileQuotaExceededFault":
        case "com.amazonaws.redshift#AuthenticationProfileQuotaExceededFault":
            throw await de_AuthenticationProfileQuotaExceededFaultRes(parsedOutput, context);
        case "InvalidAuthenticationProfileRequestFault":
        case "com.amazonaws.redshift#InvalidAuthenticationProfileRequestFault":
            throw await de_InvalidAuthenticationProfileRequestFaultRes(parsedOutput, context);
        case "ClusterAlreadyExists":
        case "com.amazonaws.redshift#ClusterAlreadyExistsFault":
            throw await de_ClusterAlreadyExistsFaultRes(parsedOutput, context);
        case "ClusterParameterGroupNotFound":
        case "com.amazonaws.redshift#ClusterParameterGroupNotFoundFault":
            throw await de_ClusterParameterGroupNotFoundFaultRes(parsedOutput, context);
        case "ClusterQuotaExceeded":
        case "com.amazonaws.redshift#ClusterQuotaExceededFault":
            throw await de_ClusterQuotaExceededFaultRes(parsedOutput, context);
        case "ClusterSubnetGroupNotFoundFault":
        case "com.amazonaws.redshift#ClusterSubnetGroupNotFoundFault":
            throw await de_ClusterSubnetGroupNotFoundFaultRes(parsedOutput, context);
        case "HsmClientCertificateNotFoundFault":
        case "com.amazonaws.redshift#HsmClientCertificateNotFoundFault":
            throw await de_HsmClientCertificateNotFoundFaultRes(parsedOutput, context);
        case "HsmConfigurationNotFoundFault":
        case "com.amazonaws.redshift#HsmConfigurationNotFoundFault":
            throw await de_HsmConfigurationNotFoundFaultRes(parsedOutput, context);
        case "InsufficientClusterCapacity":
        case "com.amazonaws.redshift#InsufficientClusterCapacityFault":
            throw await de_InsufficientClusterCapacityFaultRes(parsedOutput, context);
        case "InvalidClusterSubnetGroupStateFault":
        case "com.amazonaws.redshift#InvalidClusterSubnetGroupStateFault":
            throw await de_InvalidClusterSubnetGroupStateFaultRes(parsedOutput, context);
        case "InvalidClusterTrack":
        case "com.amazonaws.redshift#InvalidClusterTrackFault":
            throw await de_InvalidClusterTrackFaultRes(parsedOutput, context);
        case "InvalidElasticIpFault":
        case "com.amazonaws.redshift#InvalidElasticIpFault":
            throw await de_InvalidElasticIpFaultRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.redshift#InvalidSubnet":
            throw await de_InvalidSubnetRes(parsedOutput, context);
        case "InvalidTagFault":
        case "com.amazonaws.redshift#InvalidTagFault":
            throw await de_InvalidTagFaultRes(parsedOutput, context);
        case "InvalidVPCNetworkStateFault":
        case "com.amazonaws.redshift#InvalidVPCNetworkStateFault":
            throw await de_InvalidVPCNetworkStateFaultRes(parsedOutput, context);
        case "Ipv6CidrBlockNotFoundFault":
        case "com.amazonaws.redshift#Ipv6CidrBlockNotFoundFault":
            throw await de_Ipv6CidrBlockNotFoundFaultRes(parsedOutput, context);
        case "NumberOfNodesPerClusterLimitExceeded":
        case "com.amazonaws.redshift#NumberOfNodesPerClusterLimitExceededFault":
            throw await de_NumberOfNodesPerClusterLimitExceededFaultRes(parsedOutput, context);
        case "NumberOfNodesQuotaExceeded":
        case "com.amazonaws.redshift#NumberOfNodesQuotaExceededFault":
            throw await de_NumberOfNodesQuotaExceededFaultRes(parsedOutput, context);
        case "RedshiftIdcApplicationNotExists":
        case "com.amazonaws.redshift#RedshiftIdcApplicationNotExistsFault":
            throw await de_RedshiftIdcApplicationNotExistsFaultRes(parsedOutput, context);
        case "SnapshotScheduleNotFound":
        case "com.amazonaws.redshift#SnapshotScheduleNotFoundFault":
            throw await de_SnapshotScheduleNotFoundFaultRes(parsedOutput, context);
        case "TagLimitExceededFault":
        case "com.amazonaws.redshift#TagLimitExceededFault":
            throw await de_TagLimitExceededFaultRes(parsedOutput, context);
        case "UnauthorizedOperation":
        case "com.amazonaws.redshift#UnauthorizedOperation":
            throw await de_UnauthorizedOperationRes(parsedOutput, context);
        case "ClusterParameterGroupAlreadyExists":
        case "com.amazonaws.redshift#ClusterParameterGroupAlreadyExistsFault":
            throw await de_ClusterParameterGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "ClusterParameterGroupQuotaExceeded":
        case "com.amazonaws.redshift#ClusterParameterGroupQuotaExceededFault":
            throw await de_ClusterParameterGroupQuotaExceededFaultRes(parsedOutput, context);
        case "ClusterSecurityGroupAlreadyExists":
        case "com.amazonaws.redshift#ClusterSecurityGroupAlreadyExistsFault":
            throw await de_ClusterSecurityGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "QuotaExceeded.ClusterSecurityGroup":
        case "com.amazonaws.redshift#ClusterSecurityGroupQuotaExceededFault":
            throw await de_ClusterSecurityGroupQuotaExceededFaultRes(parsedOutput, context);
        case "ClusterSubnetGroupAlreadyExists":
        case "com.amazonaws.redshift#ClusterSubnetGroupAlreadyExistsFault":
            throw await de_ClusterSubnetGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "ClusterSubnetGroupQuotaExceeded":
        case "com.amazonaws.redshift#ClusterSubnetGroupQuotaExceededFault":
            throw await de_ClusterSubnetGroupQuotaExceededFaultRes(parsedOutput, context);
        case "ClusterSubnetQuotaExceededFault":
        case "com.amazonaws.redshift#ClusterSubnetQuotaExceededFault":
            throw await de_ClusterSubnetQuotaExceededFaultRes(parsedOutput, context);
        case "CustomCnameAssociationFault":
        case "com.amazonaws.redshift#CustomCnameAssociationFault":
            throw await de_CustomCnameAssociationFaultRes(parsedOutput, context);
        case "AccessToClusterDenied":
        case "com.amazonaws.redshift#AccessToClusterDeniedFault":
            throw await de_AccessToClusterDeniedFaultRes(parsedOutput, context);
        case "EndpointAlreadyExists":
        case "com.amazonaws.redshift#EndpointAlreadyExistsFault":
            throw await de_EndpointAlreadyExistsFaultRes(parsedOutput, context);
        case "EndpointsPerAuthorizationLimitExceeded":
        case "com.amazonaws.redshift#EndpointsPerAuthorizationLimitExceededFault":
            throw await de_EndpointsPerAuthorizationLimitExceededFaultRes(parsedOutput, context);
        case "EndpointsPerClusterLimitExceeded":
        case "com.amazonaws.redshift#EndpointsPerClusterLimitExceededFault":
            throw await de_EndpointsPerClusterLimitExceededFaultRes(parsedOutput, context);
        case "EventSubscriptionQuotaExceeded":
        case "com.amazonaws.redshift#EventSubscriptionQuotaExceededFault":
            throw await de_EventSubscriptionQuotaExceededFaultRes(parsedOutput, context);
        case "SNSInvalidTopic":
        case "com.amazonaws.redshift#SNSInvalidTopicFault":
            throw await de_SNSInvalidTopicFaultRes(parsedOutput, context);
        case "SNSNoAuthorization":
        case "com.amazonaws.redshift#SNSNoAuthorizationFault":
            throw await de_SNSNoAuthorizationFaultRes(parsedOutput, context);
        case "SNSTopicArnNotFound":
        case "com.amazonaws.redshift#SNSTopicArnNotFoundFault":
            throw await de_SNSTopicArnNotFoundFaultRes(parsedOutput, context);
        case "SourceNotFound":
        case "com.amazonaws.redshift#SourceNotFoundFault":
            throw await de_SourceNotFoundFaultRes(parsedOutput, context);
        case "SubscriptionAlreadyExist":
        case "com.amazonaws.redshift#SubscriptionAlreadyExistFault":
            throw await de_SubscriptionAlreadyExistFaultRes(parsedOutput, context);
        case "SubscriptionCategoryNotFound":
        case "com.amazonaws.redshift#SubscriptionCategoryNotFoundFault":
            throw await de_SubscriptionCategoryNotFoundFaultRes(parsedOutput, context);
        case "SubscriptionEventIdNotFound":
        case "com.amazonaws.redshift#SubscriptionEventIdNotFoundFault":
            throw await de_SubscriptionEventIdNotFoundFaultRes(parsedOutput, context);
        case "SubscriptionSeverityNotFound":
        case "com.amazonaws.redshift#SubscriptionSeverityNotFoundFault":
            throw await de_SubscriptionSeverityNotFoundFaultRes(parsedOutput, context);
        case "HsmClientCertificateAlreadyExistsFault":
        case "com.amazonaws.redshift#HsmClientCertificateAlreadyExistsFault":
            throw await de_HsmClientCertificateAlreadyExistsFaultRes(parsedOutput, context);
        case "HsmClientCertificateQuotaExceededFault":
        case "com.amazonaws.redshift#HsmClientCertificateQuotaExceededFault":
            throw await de_HsmClientCertificateQuotaExceededFaultRes(parsedOutput, context);
        case "HsmConfigurationAlreadyExistsFault":
        case "com.amazonaws.redshift#HsmConfigurationAlreadyExistsFault":
            throw await de_HsmConfigurationAlreadyExistsFaultRes(parsedOutput, context);
        case "HsmConfigurationQuotaExceededFault":
        case "com.amazonaws.redshift#HsmConfigurationQuotaExceededFault":
            throw await de_HsmConfigurationQuotaExceededFaultRes(parsedOutput, context);
        case "DependentServiceAccessDenied":
        case "com.amazonaws.redshift#DependentServiceAccessDeniedFault":
            throw await de_DependentServiceAccessDeniedFaultRes(parsedOutput, context);
        case "RedshiftIdcApplicationAlreadyExists":
        case "com.amazonaws.redshift#RedshiftIdcApplicationAlreadyExistsFault":
            throw await de_RedshiftIdcApplicationAlreadyExistsFaultRes(parsedOutput, context);
        case "RedshiftIdcApplicationQuotaExceeded":
        case "com.amazonaws.redshift#RedshiftIdcApplicationQuotaExceededFault":
            throw await de_RedshiftIdcApplicationQuotaExceededFaultRes(parsedOutput, context);
        case "InvalidSchedule":
        case "com.amazonaws.redshift#InvalidScheduleFault":
            throw await de_InvalidScheduleFaultRes(parsedOutput, context);
        case "InvalidScheduledAction":
        case "com.amazonaws.redshift#InvalidScheduledActionFault":
            throw await de_InvalidScheduledActionFaultRes(parsedOutput, context);
        case "ScheduledActionAlreadyExists":
        case "com.amazonaws.redshift#ScheduledActionAlreadyExistsFault":
            throw await de_ScheduledActionAlreadyExistsFaultRes(parsedOutput, context);
        case "ScheduledActionQuotaExceeded":
        case "com.amazonaws.redshift#ScheduledActionQuotaExceededFault":
            throw await de_ScheduledActionQuotaExceededFaultRes(parsedOutput, context);
        case "ScheduledActionTypeUnsupported":
        case "com.amazonaws.redshift#ScheduledActionTypeUnsupportedFault":
            throw await de_ScheduledActionTypeUnsupportedFaultRes(parsedOutput, context);
        case "SnapshotCopyGrantAlreadyExistsFault":
        case "com.amazonaws.redshift#SnapshotCopyGrantAlreadyExistsFault":
            throw await de_SnapshotCopyGrantAlreadyExistsFaultRes(parsedOutput, context);
        case "SnapshotCopyGrantQuotaExceededFault":
        case "com.amazonaws.redshift#SnapshotCopyGrantQuotaExceededFault":
            throw await de_SnapshotCopyGrantQuotaExceededFaultRes(parsedOutput, context);
        case "ScheduleDefinitionTypeUnsupported":
        case "com.amazonaws.redshift#ScheduleDefinitionTypeUnsupportedFault":
            throw await de_ScheduleDefinitionTypeUnsupportedFaultRes(parsedOutput, context);
        case "SnapshotScheduleAlreadyExists":
        case "com.amazonaws.redshift#SnapshotScheduleAlreadyExistsFault":
            throw await de_SnapshotScheduleAlreadyExistsFaultRes(parsedOutput, context);
        case "SnapshotScheduleQuotaExceeded":
        case "com.amazonaws.redshift#SnapshotScheduleQuotaExceededFault":
            throw await de_SnapshotScheduleQuotaExceededFaultRes(parsedOutput, context);
        case "ResourceNotFoundFault":
        case "com.amazonaws.redshift#ResourceNotFoundFault":
            throw await de_ResourceNotFoundFaultRes(parsedOutput, context);
        case "InvalidUsageLimit":
        case "com.amazonaws.redshift#InvalidUsageLimitFault":
            throw await de_InvalidUsageLimitFaultRes(parsedOutput, context);
        case "UsageLimitAlreadyExists":
        case "com.amazonaws.redshift#UsageLimitAlreadyExistsFault":
            throw await de_UsageLimitAlreadyExistsFaultRes(parsedOutput, context);
        case "AuthenticationProfileNotFoundFault":
        case "com.amazonaws.redshift#AuthenticationProfileNotFoundFault":
            throw await de_AuthenticationProfileNotFoundFaultRes(parsedOutput, context);
        case "InvalidClusterParameterGroupState":
        case "com.amazonaws.redshift#InvalidClusterParameterGroupStateFault":
            throw await de_InvalidClusterParameterGroupStateFaultRes(parsedOutput, context);
        case "InvalidClusterSubnetStateFault":
        case "com.amazonaws.redshift#InvalidClusterSubnetStateFault":
            throw await de_InvalidClusterSubnetStateFaultRes(parsedOutput, context);
        case "CustomDomainAssociationNotFoundFault":
        case "com.amazonaws.redshift#CustomDomainAssociationNotFoundFault":
            throw await de_CustomDomainAssociationNotFoundFaultRes(parsedOutput, context);
        case "EndpointNotFound":
        case "com.amazonaws.redshift#EndpointNotFoundFault":
            throw await de_EndpointNotFoundFaultRes(parsedOutput, context);
        case "InvalidEndpointState":
        case "com.amazonaws.redshift#InvalidEndpointStateFault":
            throw await de_InvalidEndpointStateFaultRes(parsedOutput, context);
        case "InvalidSubscriptionStateFault":
        case "com.amazonaws.redshift#InvalidSubscriptionStateFault":
            throw await de_InvalidSubscriptionStateFaultRes(parsedOutput, context);
        case "SubscriptionNotFound":
        case "com.amazonaws.redshift#SubscriptionNotFoundFault":
            throw await de_SubscriptionNotFoundFaultRes(parsedOutput, context);
        case "InvalidHsmClientCertificateStateFault":
        case "com.amazonaws.redshift#InvalidHsmClientCertificateStateFault":
            throw await de_InvalidHsmClientCertificateStateFaultRes(parsedOutput, context);
        case "InvalidHsmConfigurationStateFault":
        case "com.amazonaws.redshift#InvalidHsmConfigurationStateFault":
            throw await de_InvalidHsmConfigurationStateFaultRes(parsedOutput, context);
        case "ScheduledActionNotFound":
        case "com.amazonaws.redshift#ScheduledActionNotFoundFault":
            throw await de_ScheduledActionNotFoundFaultRes(parsedOutput, context);
        case "InvalidSnapshotCopyGrantStateFault":
        case "com.amazonaws.redshift#InvalidSnapshotCopyGrantStateFault":
            throw await de_InvalidSnapshotCopyGrantStateFaultRes(parsedOutput, context);
        case "SnapshotCopyGrantNotFoundFault":
        case "com.amazonaws.redshift#SnapshotCopyGrantNotFoundFault":
            throw await de_SnapshotCopyGrantNotFoundFaultRes(parsedOutput, context);
        case "InvalidClusterSnapshotScheduleState":
        case "com.amazonaws.redshift#InvalidClusterSnapshotScheduleStateFault":
            throw await de_InvalidClusterSnapshotScheduleStateFaultRes(parsedOutput, context);
        case "UsageLimitNotFound":
        case "com.amazonaws.redshift#UsageLimitNotFoundFault":
            throw await de_UsageLimitNotFoundFaultRes(parsedOutput, context);
        case "IntegrationNotFoundFault":
        case "com.amazonaws.redshift#IntegrationNotFoundFault":
            throw await de_IntegrationNotFoundFaultRes(parsedOutput, context);
        case "AccessToSnapshotDenied":
        case "com.amazonaws.redshift#AccessToSnapshotDeniedFault":
            throw await de_AccessToSnapshotDeniedFaultRes(parsedOutput, context);
        case "ReservedNodeExchangeNotFond":
        case "com.amazonaws.redshift#ReservedNodeExchangeNotFoundFault":
            throw await de_ReservedNodeExchangeNotFoundFaultRes(parsedOutput, context);
        case "TableRestoreNotFoundFault":
        case "com.amazonaws.redshift#TableRestoreNotFoundFault":
            throw await de_TableRestoreNotFoundFaultRes(parsedOutput, context);
        case "SnapshotCopyAlreadyDisabledFault":
        case "com.amazonaws.redshift#SnapshotCopyAlreadyDisabledFault":
            throw await de_SnapshotCopyAlreadyDisabledFaultRes(parsedOutput, context);
        case "BucketNotFoundFault":
        case "com.amazonaws.redshift#BucketNotFoundFault":
            throw await de_BucketNotFoundFaultRes(parsedOutput, context);
        case "InsufficientS3BucketPolicyFault":
        case "com.amazonaws.redshift#InsufficientS3BucketPolicyFault":
            throw await de_InsufficientS3BucketPolicyFaultRes(parsedOutput, context);
        case "InvalidS3BucketNameFault":
        case "com.amazonaws.redshift#InvalidS3BucketNameFault":
            throw await de_InvalidS3BucketNameFaultRes(parsedOutput, context);
        case "InvalidS3KeyPrefixFault":
        case "com.amazonaws.redshift#InvalidS3KeyPrefixFault":
            throw await de_InvalidS3KeyPrefixFaultRes(parsedOutput, context);
        case "CopyToRegionDisabledFault":
        case "com.amazonaws.redshift#CopyToRegionDisabledFault":
            throw await de_CopyToRegionDisabledFaultRes(parsedOutput, context);
        case "IncompatibleOrderableOptions":
        case "com.amazonaws.redshift#IncompatibleOrderableOptions":
            throw await de_IncompatibleOrderableOptionsRes(parsedOutput, context);
        case "SnapshotCopyAlreadyEnabledFault":
        case "com.amazonaws.redshift#SnapshotCopyAlreadyEnabledFault":
            throw await de_SnapshotCopyAlreadyEnabledFaultRes(parsedOutput, context);
        case "UnknownSnapshotCopyRegionFault":
        case "com.amazonaws.redshift#UnknownSnapshotCopyRegionFault":
            throw await de_UnknownSnapshotCopyRegionFaultRes(parsedOutput, context);
        case "InvalidPolicyFault":
        case "com.amazonaws.redshift#InvalidPolicyFault":
            throw await de_InvalidPolicyFaultRes(parsedOutput, context);
        case "TableLimitExceeded":
        case "com.amazonaws.redshift#TableLimitExceededFault":
            throw await de_TableLimitExceededFaultRes(parsedOutput, context);
        case "UnsupportedOptionFault":
        case "com.amazonaws.redshift#UnsupportedOptionFault":
            throw await de_UnsupportedOptionFaultRes(parsedOutput, context);
        case "ClusterOnLatestRevision":
        case "com.amazonaws.redshift#ClusterOnLatestRevisionFault":
            throw await de_ClusterOnLatestRevisionFaultRes(parsedOutput, context);
        case "SubnetAlreadyInUse":
        case "com.amazonaws.redshift#SubnetAlreadyInUse":
            throw await de_SubnetAlreadyInUseRes(parsedOutput, context);
        case "SnapshotCopyDisabledFault":
        case "com.amazonaws.redshift#SnapshotCopyDisabledFault":
            throw await de_SnapshotCopyDisabledFaultRes(parsedOutput, context);
        case "SnapshotScheduleUpdateInProgress":
        case "com.amazonaws.redshift#SnapshotScheduleUpdateInProgressFault":
            throw await de_SnapshotScheduleUpdateInProgressFaultRes(parsedOutput, context);
        case "ReservedNodeQuotaExceeded":
        case "com.amazonaws.redshift#ReservedNodeQuotaExceededFault":
            throw await de_ReservedNodeQuotaExceededFaultRes(parsedOutput, context);
        case "ConflictPolicyUpdateFault":
        case "com.amazonaws.redshift#ConflictPolicyUpdateFault":
            throw await de_ConflictPolicyUpdateFaultRes(parsedOutput, context);
        case "InvalidRestore":
        case "com.amazonaws.redshift#InvalidRestoreFault":
            throw await de_InvalidRestoreFaultRes(parsedOutput, context);
        case "InProgressTableRestoreQuotaExceededFault":
        case "com.amazonaws.redshift#InProgressTableRestoreQuotaExceededFault":
            throw await de_InProgressTableRestoreQuotaExceededFaultRes(parsedOutput, context);
        case "InvalidTableRestoreArgument":
        case "com.amazonaws.redshift#InvalidTableRestoreArgumentFault":
            throw await de_InvalidTableRestoreArgumentFaultRes(parsedOutput, context);
        case "AuthorizationNotFound":
        case "com.amazonaws.redshift#AuthorizationNotFoundFault":
            throw await de_AuthorizationNotFoundFaultRes(parsedOutput, context);
        case "EndpointAuthorizationNotFound":
        case "com.amazonaws.redshift#EndpointAuthorizationNotFoundFault":
            throw await de_EndpointAuthorizationNotFoundFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AccessToClusterDeniedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AccessToClusterDeniedFault(body.Error, context);
    const exception = new AccessToClusterDeniedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AccessToSnapshotDeniedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AccessToSnapshotDeniedFault(body.Error, context);
    const exception = new AccessToSnapshotDeniedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthenticationProfileAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthenticationProfileAlreadyExistsFault(body.Error, context);
    const exception = new AuthenticationProfileAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthenticationProfileNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthenticationProfileNotFoundFault(body.Error, context);
    const exception = new AuthenticationProfileNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthenticationProfileQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthenticationProfileQuotaExceededFault(body.Error, context);
    const exception = new AuthenticationProfileQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthorizationAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthorizationAlreadyExistsFault(body.Error, context);
    const exception = new AuthorizationAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthorizationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthorizationNotFoundFault(body.Error, context);
    const exception = new AuthorizationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_AuthorizationQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AuthorizationQuotaExceededFault(body.Error, context);
    const exception = new AuthorizationQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BatchDeleteRequestSizeExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_BatchDeleteRequestSizeExceededFault(body.Error, context);
    const exception = new BatchDeleteRequestSizeExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BatchModifyClusterSnapshotsLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_BatchModifyClusterSnapshotsLimitExceededFault(body.Error, context);
    const exception = new BatchModifyClusterSnapshotsLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BucketNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_BucketNotFoundFault(body.Error, context);
    const exception = new BucketNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterAlreadyExistsFault(body.Error, context);
    const exception = new ClusterAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterNotFoundFault(body.Error, context);
    const exception = new ClusterNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterOnLatestRevisionFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterOnLatestRevisionFault(body.Error, context);
    const exception = new ClusterOnLatestRevisionFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterParameterGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterParameterGroupAlreadyExistsFault(body.Error, context);
    const exception = new ClusterParameterGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterParameterGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterParameterGroupNotFoundFault(body.Error, context);
    const exception = new ClusterParameterGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterParameterGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterParameterGroupQuotaExceededFault(body.Error, context);
    const exception = new ClusterParameterGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterQuotaExceededFault(body.Error, context);
    const exception = new ClusterQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSecurityGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSecurityGroupAlreadyExistsFault(body.Error, context);
    const exception = new ClusterSecurityGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSecurityGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSecurityGroupNotFoundFault(body.Error, context);
    const exception = new ClusterSecurityGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSecurityGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSecurityGroupQuotaExceededFault(body.Error, context);
    const exception = new ClusterSecurityGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSnapshotAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSnapshotAlreadyExistsFault(body.Error, context);
    const exception = new ClusterSnapshotAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSnapshotNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSnapshotNotFoundFault(body.Error, context);
    const exception = new ClusterSnapshotNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSnapshotQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSnapshotQuotaExceededFault(body.Error, context);
    const exception = new ClusterSnapshotQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSubnetGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSubnetGroupAlreadyExistsFault(body.Error, context);
    const exception = new ClusterSubnetGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSubnetGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSubnetGroupNotFoundFault(body.Error, context);
    const exception = new ClusterSubnetGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSubnetGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSubnetGroupQuotaExceededFault(body.Error, context);
    const exception = new ClusterSubnetGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterSubnetQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ClusterSubnetQuotaExceededFault(body.Error, context);
    const exception = new ClusterSubnetQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ConflictPolicyUpdateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConflictPolicyUpdateFault(body.Error, context);
    const exception = new ConflictPolicyUpdateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CopyToRegionDisabledFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CopyToRegionDisabledFault(body.Error, context);
    const exception = new CopyToRegionDisabledFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CustomCnameAssociationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CustomCnameAssociationFault(body.Error, context);
    const exception = new CustomCnameAssociationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CustomDomainAssociationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CustomDomainAssociationNotFoundFault(body.Error, context);
    const exception = new CustomDomainAssociationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DependentServiceAccessDeniedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DependentServiceAccessDeniedFault(body.Error, context);
    const exception = new DependentServiceAccessDeniedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DependentServiceRequestThrottlingFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DependentServiceRequestThrottlingFault(body.Error, context);
    const exception = new DependentServiceRequestThrottlingFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DependentServiceUnavailableFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DependentServiceUnavailableFault(body.Error, context);
    const exception = new DependentServiceUnavailableFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointAlreadyExistsFault(body.Error, context);
    const exception = new EndpointAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointAuthorizationAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointAuthorizationAlreadyExistsFault(body.Error, context);
    const exception = new EndpointAuthorizationAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointAuthorizationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointAuthorizationNotFoundFault(body.Error, context);
    const exception = new EndpointAuthorizationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointAuthorizationsPerClusterLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointAuthorizationsPerClusterLimitExceededFault(body.Error, context);
    const exception = new EndpointAuthorizationsPerClusterLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointNotFoundFault(body.Error, context);
    const exception = new EndpointNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointsPerAuthorizationLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointsPerAuthorizationLimitExceededFault(body.Error, context);
    const exception = new EndpointsPerAuthorizationLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EndpointsPerClusterLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EndpointsPerClusterLimitExceededFault(body.Error, context);
    const exception = new EndpointsPerClusterLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EventSubscriptionQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EventSubscriptionQuotaExceededFault(body.Error, context);
    const exception = new EventSubscriptionQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HsmClientCertificateAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HsmClientCertificateAlreadyExistsFault(body.Error, context);
    const exception = new HsmClientCertificateAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HsmClientCertificateNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HsmClientCertificateNotFoundFault(body.Error, context);
    const exception = new HsmClientCertificateNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HsmClientCertificateQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HsmClientCertificateQuotaExceededFault(body.Error, context);
    const exception = new HsmClientCertificateQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HsmConfigurationAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HsmConfigurationAlreadyExistsFault(body.Error, context);
    const exception = new HsmConfigurationAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HsmConfigurationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HsmConfigurationNotFoundFault(body.Error, context);
    const exception = new HsmConfigurationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_HsmConfigurationQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HsmConfigurationQuotaExceededFault(body.Error, context);
    const exception = new HsmConfigurationQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IncompatibleOrderableOptionsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IncompatibleOrderableOptions(body.Error, context);
    const exception = new IncompatibleOrderableOptions({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InProgressTableRestoreQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InProgressTableRestoreQuotaExceededFault(body.Error, context);
    const exception = new InProgressTableRestoreQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientClusterCapacityFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientClusterCapacityFault(body.Error, context);
    const exception = new InsufficientClusterCapacityFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientS3BucketPolicyFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InsufficientS3BucketPolicyFault(body.Error, context);
    const exception = new InsufficientS3BucketPolicyFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IntegrationNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IntegrationNotFoundFault(body.Error, context);
    const exception = new IntegrationNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAuthenticationProfileRequestFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthenticationProfileRequestFault(body.Error, context);
    const exception = new InvalidAuthenticationProfileRequestFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAuthorizationStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthorizationStateFault(body.Error, context);
    const exception = new InvalidAuthorizationStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterParameterGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterParameterGroupStateFault(body.Error, context);
    const exception = new InvalidClusterParameterGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterSecurityGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterSecurityGroupStateFault(body.Error, context);
    const exception = new InvalidClusterSecurityGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterSnapshotScheduleStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterSnapshotScheduleStateFault(body.Error, context);
    const exception = new InvalidClusterSnapshotScheduleStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterSnapshotStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterSnapshotStateFault(body.Error, context);
    const exception = new InvalidClusterSnapshotStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterStateFault(body.Error, context);
    const exception = new InvalidClusterStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterSubnetGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterSubnetGroupStateFault(body.Error, context);
    const exception = new InvalidClusterSubnetGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterSubnetStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterSubnetStateFault(body.Error, context);
    const exception = new InvalidClusterSubnetStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterTrackFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidClusterTrackFault(body.Error, context);
    const exception = new InvalidClusterTrackFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDataShareFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidDataShareFault(body.Error, context);
    const exception = new InvalidDataShareFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidElasticIpFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidElasticIpFault(body.Error, context);
    const exception = new InvalidElasticIpFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidEndpointStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidEndpointStateFault(body.Error, context);
    const exception = new InvalidEndpointStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidHsmClientCertificateStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidHsmClientCertificateStateFault(body.Error, context);
    const exception = new InvalidHsmClientCertificateStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidHsmConfigurationStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidHsmConfigurationStateFault(body.Error, context);
    const exception = new InvalidHsmConfigurationStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNamespaceFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNamespaceFault(body.Error, context);
    const exception = new InvalidNamespaceFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPolicyFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPolicyFault(body.Error, context);
    const exception = new InvalidPolicyFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidReservedNodeStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidReservedNodeStateFault(body.Error, context);
    const exception = new InvalidReservedNodeStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRestoreFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidRestoreFault(body.Error, context);
    const exception = new InvalidRestoreFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRetentionPeriodFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidRetentionPeriodFault(body.Error, context);
    const exception = new InvalidRetentionPeriodFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidS3BucketNameFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidS3BucketNameFault(body.Error, context);
    const exception = new InvalidS3BucketNameFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidS3KeyPrefixFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidS3KeyPrefixFault(body.Error, context);
    const exception = new InvalidS3KeyPrefixFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidScheduledActionFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidScheduledActionFault(body.Error, context);
    const exception = new InvalidScheduledActionFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidScheduleFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidScheduleFault(body.Error, context);
    const exception = new InvalidScheduleFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSnapshotCopyGrantStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSnapshotCopyGrantStateFault(body.Error, context);
    const exception = new InvalidSnapshotCopyGrantStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubnetRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubnet(body.Error, context);
    const exception = new InvalidSubnet({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubscriptionStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubscriptionStateFault(body.Error, context);
    const exception = new InvalidSubscriptionStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTableRestoreArgumentFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTableRestoreArgumentFault(body.Error, context);
    const exception = new InvalidTableRestoreArgumentFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTagFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTagFault(body.Error, context);
    const exception = new InvalidTagFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidUsageLimitFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUsageLimitFault(body.Error, context);
    const exception = new InvalidUsageLimitFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidVPCNetworkStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidVPCNetworkStateFault(body.Error, context);
    const exception = new InvalidVPCNetworkStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_Ipv6CidrBlockNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_Ipv6CidrBlockNotFoundFault(body.Error, context);
    const exception = new Ipv6CidrBlockNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededFault(body.Error, context);
    const exception = new LimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NumberOfNodesPerClusterLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NumberOfNodesPerClusterLimitExceededFault(body.Error, context);
    const exception = new NumberOfNodesPerClusterLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NumberOfNodesQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NumberOfNodesQuotaExceededFault(body.Error, context);
    const exception = new NumberOfNodesQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PartnerNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PartnerNotFoundFault(body.Error, context);
    const exception = new PartnerNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RedshiftIdcApplicationAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RedshiftIdcApplicationAlreadyExistsFault(body.Error, context);
    const exception = new RedshiftIdcApplicationAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RedshiftIdcApplicationNotExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RedshiftIdcApplicationNotExistsFault(body.Error, context);
    const exception = new RedshiftIdcApplicationNotExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RedshiftIdcApplicationQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RedshiftIdcApplicationQuotaExceededFault(body.Error, context);
    const exception = new RedshiftIdcApplicationQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedNodeAlreadyExistsFault(body.Error, context);
    const exception = new ReservedNodeAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeAlreadyMigratedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedNodeAlreadyMigratedFault(body.Error, context);
    const exception = new ReservedNodeAlreadyMigratedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeExchangeNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedNodeExchangeNotFoundFault(body.Error, context);
    const exception = new ReservedNodeExchangeNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedNodeNotFoundFault(body.Error, context);
    const exception = new ReservedNodeNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeOfferingNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedNodeOfferingNotFoundFault(body.Error, context);
    const exception = new ReservedNodeOfferingNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReservedNodeQuotaExceededFault(body.Error, context);
    const exception = new ReservedNodeQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResizeNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResizeNotFoundFault(body.Error, context);
    const exception = new ResizeNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundFault(body.Error, context);
    const exception = new ResourceNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScheduledActionAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScheduledActionAlreadyExistsFault(body.Error, context);
    const exception = new ScheduledActionAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScheduledActionNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScheduledActionNotFoundFault(body.Error, context);
    const exception = new ScheduledActionNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScheduledActionQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScheduledActionQuotaExceededFault(body.Error, context);
    const exception = new ScheduledActionQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScheduledActionTypeUnsupportedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScheduledActionTypeUnsupportedFault(body.Error, context);
    const exception = new ScheduledActionTypeUnsupportedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ScheduleDefinitionTypeUnsupportedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ScheduleDefinitionTypeUnsupportedFault(body.Error, context);
    const exception = new ScheduleDefinitionTypeUnsupportedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotCopyAlreadyDisabledFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotCopyAlreadyDisabledFault(body.Error, context);
    const exception = new SnapshotCopyAlreadyDisabledFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotCopyAlreadyEnabledFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotCopyAlreadyEnabledFault(body.Error, context);
    const exception = new SnapshotCopyAlreadyEnabledFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotCopyDisabledFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotCopyDisabledFault(body.Error, context);
    const exception = new SnapshotCopyDisabledFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotCopyGrantAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotCopyGrantAlreadyExistsFault(body.Error, context);
    const exception = new SnapshotCopyGrantAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotCopyGrantNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotCopyGrantNotFoundFault(body.Error, context);
    const exception = new SnapshotCopyGrantNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotCopyGrantQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotCopyGrantQuotaExceededFault(body.Error, context);
    const exception = new SnapshotCopyGrantQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotScheduleAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotScheduleAlreadyExistsFault(body.Error, context);
    const exception = new SnapshotScheduleAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotScheduleNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotScheduleNotFoundFault(body.Error, context);
    const exception = new SnapshotScheduleNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotScheduleQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotScheduleQuotaExceededFault(body.Error, context);
    const exception = new SnapshotScheduleQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotScheduleUpdateInProgressFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SnapshotScheduleUpdateInProgressFault(body.Error, context);
    const exception = new SnapshotScheduleUpdateInProgressFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SNSInvalidTopicFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SNSInvalidTopicFault(body.Error, context);
    const exception = new SNSInvalidTopicFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SNSNoAuthorizationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SNSNoAuthorizationFault(body.Error, context);
    const exception = new SNSNoAuthorizationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SNSTopicArnNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SNSTopicArnNotFoundFault(body.Error, context);
    const exception = new SNSTopicArnNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SourceNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SourceNotFoundFault(body.Error, context);
    const exception = new SourceNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetAlreadyInUseRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetAlreadyInUse(body.Error, context);
    const exception = new SubnetAlreadyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionAlreadyExistFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionAlreadyExistFault(body.Error, context);
    const exception = new SubscriptionAlreadyExistFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionCategoryNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionCategoryNotFoundFault(body.Error, context);
    const exception = new SubscriptionCategoryNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionEventIdNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionEventIdNotFoundFault(body.Error, context);
    const exception = new SubscriptionEventIdNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionNotFoundFault(body.Error, context);
    const exception = new SubscriptionNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubscriptionSeverityNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubscriptionSeverityNotFoundFault(body.Error, context);
    const exception = new SubscriptionSeverityNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TableLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TableLimitExceededFault(body.Error, context);
    const exception = new TableLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TableRestoreNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TableRestoreNotFoundFault(body.Error, context);
    const exception = new TableRestoreNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TagLimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TagLimitExceededFault(body.Error, context);
    const exception = new TagLimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnauthorizedOperationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnauthorizedOperation(body.Error, context);
    const exception = new UnauthorizedOperation({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnauthorizedPartnerIntegrationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnauthorizedPartnerIntegrationFault(body.Error, context);
    const exception = new UnauthorizedPartnerIntegrationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnknownSnapshotCopyRegionFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnknownSnapshotCopyRegionFault(body.Error, context);
    const exception = new UnknownSnapshotCopyRegionFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedOperationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedOperationFault(body.Error, context);
    const exception = new UnsupportedOperationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedOptionFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedOptionFault(body.Error, context);
    const exception = new UnsupportedOptionFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UsageLimitAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UsageLimitAlreadyExistsFault(body.Error, context);
    const exception = new UsageLimitAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UsageLimitNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UsageLimitNotFoundFault(body.Error, context);
    const exception = new UsageLimitNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AcceptReservedNodeExchangeInputMessage = (input, context) => {
    const entries = {};
    if (input[_RNI] != null) {
        entries[_RNI] = input[_RNI];
    }
    if (input[_TRNOI] != null) {
        entries[_TRNOI] = input[_TRNOI];
    }
    return entries;
};
const se_AssociateDataShareConsumerMessage = (input, context) => {
    const entries = {};
    if (input[_DSAa] != null) {
        entries[_DSAa] = input[_DSAa];
    }
    if (input[_AEAs] != null) {
        entries[_AEAs] = input[_AEAs];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_CRo] != null) {
        entries[_CRo] = input[_CRo];
    }
    if (input[_AW] != null) {
        entries[_AW] = input[_AW];
    }
    return entries;
};
const se_AttributeNameList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`AttributeName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AuthorizeClusterSecurityGroupIngressMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_CIDRIP] != null) {
        entries[_CIDRIP] = input[_CIDRIP];
    }
    if (input[_ECSGN] != null) {
        entries[_ECSGN] = input[_ECSGN];
    }
    if (input[_ECSGOI] != null) {
        entries[_ECSGOI] = input[_ECSGOI];
    }
    return entries;
};
const se_AuthorizeDataShareMessage = (input, context) => {
    const entries = {};
    if (input[_DSAa] != null) {
        entries[_DSAa] = input[_DSAa];
    }
    if (input[_CI] != null) {
        entries[_CI] = input[_CI];
    }
    if (input[_AW] != null) {
        entries[_AW] = input[_AW];
    }
    return entries;
};
const se_AuthorizedAudienceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AuthorizedTokenIssuer = (input, context) => {
    const entries = {};
    if (input[_TTIA] != null) {
        entries[_TTIA] = input[_TTIA];
    }
    if (input[_AAL] != null) {
        const memberEntries = se_AuthorizedAudienceList(input[_AAL], context);
        if (input[_AAL]?.length === 0) {
            entries.AuthorizedAudiencesList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthorizedAudiencesList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AuthorizedTokenIssuerList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_AuthorizedTokenIssuer(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AuthorizeEndpointAccessMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_Ac] != null) {
        entries[_Ac] = input[_Ac];
    }
    if (input[_VI] != null) {
        const memberEntries = se_VpcIdentifierList(input[_VI], context);
        if (input[_VI]?.length === 0) {
            entries.VpcIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AuthorizeSnapshotAccessMessage = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_SCI] != null) {
        entries[_SCI] = input[_SCI];
    }
    if (input[_AWRA] != null) {
        entries[_AWRA] = input[_AWRA];
    }
    return entries;
};
const se_BatchDeleteClusterSnapshotsRequest = (input, context) => {
    const entries = {};
    if (input[_I] != null) {
        const memberEntries = se_DeleteClusterSnapshotMessageList(input[_I], context);
        if (input[_I]?.length === 0) {
            entries.Identifiers = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Identifiers.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BatchModifyClusterSnapshotsMessage = (input, context) => {
    const entries = {};
    if (input[_SIL] != null) {
        const memberEntries = se_SnapshotIdentifierList(input[_SIL], context);
        if (input[_SIL]?.length === 0) {
            entries.SnapshotIdentifierList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SnapshotIdentifierList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    return entries;
};
const se_CancelResizeMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_ClusterSecurityGroupNameList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ClusterSecurityGroupName.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CopyClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SSI] != null) {
        entries[_SSI] = input[_SSI];
    }
    if (input[_SSCI] != null) {
        entries[_SSCI] = input[_SSCI];
    }
    if (input[_TSI] != null) {
        entries[_TSI] = input[_TSI];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    return entries;
};
const se_CreateAuthenticationProfileMessage = (input, context) => {
    const entries = {};
    if (input[_APN] != null) {
        entries[_APN] = input[_APN];
    }
    if (input[_APC] != null) {
        entries[_APC] = input[_APC];
    }
    return entries;
};
const se_CreateClusterMessage = (input, context) => {
    const entries = {};
    if (input[_DBN] != null) {
        entries[_DBN] = input[_DBN];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MU] != null) {
        entries[_MU] = input[_MU];
    }
    if (input[_MUP] != null) {
        entries[_MUP] = input[_MUP];
    }
    if (input[_CSG] != null) {
        const memberEntries = se_ClusterSecurityGroupNameList(input[_CSG], context);
        if (input[_CSG]?.length === 0) {
            entries.ClusterSecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClusterSecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CSGNl] != null) {
        entries[_CSGNl] = input[_CSGNl];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_ASRP] != null) {
        entries[_ASRP] = input[_ASRP];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_CV] != null) {
        entries[_CV] = input[_CV];
    }
    if (input[_AVU] != null) {
        entries[_AVU] = input[_AVU];
    }
    if (input[_NON] != null) {
        entries[_NON] = input[_NON];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_HCCI] != null) {
        entries[_HCCI] = input[_HCCI];
    }
    if (input[_HCI] != null) {
        entries[_HCI] = input[_HCI];
    }
    if (input[_EI] != null) {
        entries[_EI] = input[_EI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_EVR] != null) {
        entries[_EVR] = input[_EVR];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_IR] != null) {
        const memberEntries = se_IamRoleArnList(input[_IR], context);
        if (input[_IR]?.length === 0) {
            entries.IamRoles = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamRoles.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MTN] != null) {
        entries[_MTN] = input[_MTN];
    }
    if (input[_SSIn] != null) {
        entries[_SSIn] = input[_SSIn];
    }
    if (input[_AZR] != null) {
        entries[_AZR] = input[_AZR];
    }
    if (input[_ACS] != null) {
        entries[_ACS] = input[_ACS];
    }
    if (input[_DIRA] != null) {
        entries[_DIRA] = input[_DIRA];
    }
    if (input[_LSD] != null) {
        entries[_LSD] = input[_LSD];
    }
    if (input[_MMP] != null) {
        entries[_MMP] = input[_MMP];
    }
    if (input[_MPSKKI] != null) {
        entries[_MPSKKI] = input[_MPSKKI];
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_MAZ] != null) {
        entries[_MAZ] = input[_MAZ];
    }
    if (input[_RIAA] != null) {
        entries[_RIAA] = input[_RIAA];
    }
    return entries;
};
const se_CreateClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_PGN] != null) {
        entries[_PGN] = input[_PGN];
    }
    if (input[_PGF] != null) {
        entries[_PGF] = input[_PGF];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateClusterSecurityGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateClusterSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNl] != null) {
        entries[_CSGNl] = input[_CSGNl];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_SubnetIdentifierList(input[_SIu], context);
        if (input[_SIu]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateCustomDomainAssociationMessage = (input, context) => {
    const entries = {};
    if (input[_CDN] != null) {
        entries[_CDN] = input[_CDN];
    }
    if (input[_CDCA] != null) {
        entries[_CDCA] = input[_CDCA];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_CreateEndpointAccessMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_RO] != null) {
        entries[_RO] = input[_RO];
    }
    if (input[_EN] != null) {
        entries[_EN] = input[_EN];
    }
    if (input[_SGN] != null) {
        entries[_SGN] = input[_SGN];
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateEventSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_STA] != null) {
        entries[_STA] = input[_STA];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_SIo] != null) {
        const memberEntries = se_SourceIdsList(input[_SIo], context);
        if (input[_SIo]?.length === 0) {
            entries.SourceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EC] != null) {
        const memberEntries = se_EventCategoriesList(input[_EC], context);
        if (input[_EC]?.length === 0) {
            entries.EventCategories = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EventCategories.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateHsmClientCertificateMessage = (input, context) => {
    const entries = {};
    if (input[_HCCI] != null) {
        entries[_HCCI] = input[_HCCI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateHsmConfigurationMessage = (input, context) => {
    const entries = {};
    if (input[_HCI] != null) {
        entries[_HCI] = input[_HCI];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_HIA] != null) {
        entries[_HIA] = input[_HIA];
    }
    if (input[_HPN] != null) {
        entries[_HPN] = input[_HPN];
    }
    if (input[_HPP] != null) {
        entries[_HPP] = input[_HPP];
    }
    if (input[_HSPC] != null) {
        entries[_HSPC] = input[_HSPC];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateRedshiftIdcApplicationMessage = (input, context) => {
    const entries = {};
    if (input[_IIA] != null) {
        entries[_IIA] = input[_IIA];
    }
    if (input[_RIAN] != null) {
        entries[_RIAN] = input[_RIAN];
    }
    if (input[_IN] != null) {
        entries[_IN] = input[_IN];
    }
    if (input[_IDN] != null) {
        entries[_IDN] = input[_IDN];
    }
    if (input[_IRA] != null) {
        entries[_IRA] = input[_IRA];
    }
    if (input[_ATIL] != null) {
        const memberEntries = se_AuthorizedTokenIssuerList(input[_ATIL], context);
        if (input[_ATIL]?.length === 0) {
            entries.AuthorizedTokenIssuerList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthorizedTokenIssuerList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIe] != null) {
        const memberEntries = se_ServiceIntegrationList(input[_SIe], context);
        if (input[_SIe]?.length === 0) {
            entries.ServiceIntegrations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceIntegrations.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateScheduledActionMessage = (input, context) => {
    const entries = {};
    if (input[_SAN] != null) {
        entries[_SAN] = input[_SAN];
    }
    if (input[_TA] != null) {
        const memberEntries = se_ScheduledActionType(input[_TA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetAction.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    if (input[_IRa] != null) {
        entries[_IRa] = input[_IRa];
    }
    if (input[_SAD] != null) {
        entries[_SAD] = input[_SAD];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_Ena] != null) {
        entries[_Ena] = input[_Ena];
    }
    return entries;
};
const se_CreateSnapshotCopyGrantMessage = (input, context) => {
    const entries = {};
    if (input[_SCGN] != null) {
        entries[_SCGN] = input[_SCGN];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateSnapshotScheduleMessage = (input, context) => {
    const entries = {};
    if (input[_SD] != null) {
        const memberEntries = se_ScheduleDefinitionList(input[_SD], context);
        if (input[_SD]?.length === 0) {
            entries.ScheduleDefinitions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduleDefinitions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIc] != null) {
        entries[_SIc] = input[_SIc];
    }
    if (input[_SDc] != null) {
        entries[_SDc] = input[_SDc];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DRr] != null) {
        entries[_DRr] = input[_DRr];
    }
    if (input[_NI] != null) {
        entries[_NI] = input[_NI];
    }
    return entries;
};
const se_CreateTagsMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateUsageLimitMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_FT] != null) {
        entries[_FT] = input[_FT];
    }
    if (input[_LT] != null) {
        entries[_LT] = input[_LT];
    }
    if (input[_Am] != null) {
        entries[_Am] = input[_Am];
    }
    if (input[_Pe] != null) {
        entries[_Pe] = input[_Pe];
    }
    if (input[_BA] != null) {
        entries[_BA] = input[_BA];
    }
    if (input[_T] != null) {
        const memberEntries = se_TagList(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DbGroupList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`DbGroup.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DeauthorizeDataShareMessage = (input, context) => {
    const entries = {};
    if (input[_DSAa] != null) {
        entries[_DSAa] = input[_DSAa];
    }
    if (input[_CI] != null) {
        entries[_CI] = input[_CI];
    }
    return entries;
};
const se_DeleteAuthenticationProfileMessage = (input, context) => {
    const entries = {};
    if (input[_APN] != null) {
        entries[_APN] = input[_APN];
    }
    return entries;
};
const se_DeleteClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SFCS] != null) {
        entries[_SFCS] = input[_SFCS];
    }
    if (input[_FCSI] != null) {
        entries[_FCSI] = input[_FCSI];
    }
    if (input[_FCSRP] != null) {
        entries[_FCSRP] = input[_FCSRP];
    }
    return entries;
};
const se_DeleteClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_PGN] != null) {
        entries[_PGN] = input[_PGN];
    }
    return entries;
};
const se_DeleteClusterSecurityGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    return entries;
};
const se_DeleteClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SCI] != null) {
        entries[_SCI] = input[_SCI];
    }
    return entries;
};
const se_DeleteClusterSnapshotMessageList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_DeleteClusterSnapshotMessage(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`DeleteClusterSnapshotMessage.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DeleteClusterSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNl] != null) {
        entries[_CSGNl] = input[_CSGNl];
    }
    return entries;
};
const se_DeleteCustomDomainAssociationMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CDN] != null) {
        entries[_CDN] = input[_CDN];
    }
    return entries;
};
const se_DeleteEndpointAccessMessage = (input, context) => {
    const entries = {};
    if (input[_EN] != null) {
        entries[_EN] = input[_EN];
    }
    return entries;
};
const se_DeleteEventSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    return entries;
};
const se_DeleteHsmClientCertificateMessage = (input, context) => {
    const entries = {};
    if (input[_HCCI] != null) {
        entries[_HCCI] = input[_HCCI];
    }
    return entries;
};
const se_DeleteHsmConfigurationMessage = (input, context) => {
    const entries = {};
    if (input[_HCI] != null) {
        entries[_HCI] = input[_HCI];
    }
    return entries;
};
const se_DeleteRedshiftIdcApplicationMessage = (input, context) => {
    const entries = {};
    if (input[_RIAA] != null) {
        entries[_RIAA] = input[_RIAA];
    }
    return entries;
};
const se_DeleteResourcePolicyMessage = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    return entries;
};
const se_DeleteScheduledActionMessage = (input, context) => {
    const entries = {};
    if (input[_SAN] != null) {
        entries[_SAN] = input[_SAN];
    }
    return entries;
};
const se_DeleteSnapshotCopyGrantMessage = (input, context) => {
    const entries = {};
    if (input[_SCGN] != null) {
        entries[_SCGN] = input[_SCGN];
    }
    return entries;
};
const se_DeleteSnapshotScheduleMessage = (input, context) => {
    const entries = {};
    if (input[_SIc] != null) {
        entries[_SIc] = input[_SIc];
    }
    return entries;
};
const se_DeleteTagsMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteUsageLimitMessage = (input, context) => {
    const entries = {};
    if (input[_ULI] != null) {
        entries[_ULI] = input[_ULI];
    }
    return entries;
};
const se_DescribeAccountAttributesMessage = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AttributeNameList(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AttributeNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AttributeNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAuthenticationProfilesMessage = (input, context) => {
    const entries = {};
    if (input[_APN] != null) {
        entries[_APN] = input[_APN];
    }
    return entries;
};
const se_DescribeClusterDbRevisionsMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeClusterParameterGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_PGN] != null) {
        entries[_PGN] = input[_PGN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeClusterParametersMessage = (input, context) => {
    const entries = {};
    if (input[_PGN] != null) {
        entries[_PGN] = input[_PGN];
    }
    if (input[_So] != null) {
        entries[_So] = input[_So];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeClusterSecurityGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeClustersMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeClusterSnapshotsMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_STn] != null) {
        entries[_STn] = input[_STn];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CE] != null) {
        entries[_CE] = input[_CE];
    }
    if (input[_SE] != null) {
        const memberEntries = se_SnapshotSortingEntityList(input[_SE], context);
        if (input[_SE]?.length === 0) {
            entries.SortingEntities = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SortingEntities.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeClusterSubnetGroupsMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNl] != null) {
        entries[_CSGNl] = input[_CSGNl];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeClusterTracksMessage = (input, context) => {
    const entries = {};
    if (input[_MTN] != null) {
        entries[_MTN] = input[_MTN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeClusterVersionsMessage = (input, context) => {
    const entries = {};
    if (input[_CV] != null) {
        entries[_CV] = input[_CV];
    }
    if (input[_CPGF] != null) {
        entries[_CPGF] = input[_CPGF];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeCustomDomainAssociationsMessage = (input, context) => {
    const entries = {};
    if (input[_CDN] != null) {
        entries[_CDN] = input[_CDN];
    }
    if (input[_CDCA] != null) {
        entries[_CDCA] = input[_CDCA];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDataSharesForConsumerMessage = (input, context) => {
    const entries = {};
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDataSharesForProducerMessage = (input, context) => {
    const entries = {};
    if (input[_PAr] != null) {
        entries[_PAr] = input[_PAr];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDataSharesMessage = (input, context) => {
    const entries = {};
    if (input[_DSAa] != null) {
        entries[_DSAa] = input[_DSAa];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeDefaultClusterParametersMessage = (input, context) => {
    const entries = {};
    if (input[_PGF] != null) {
        entries[_PGF] = input[_PGF];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEndpointAccessMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_RO] != null) {
        entries[_RO] = input[_RO];
    }
    if (input[_EN] != null) {
        entries[_EN] = input[_EN];
    }
    if (input[_VIp] != null) {
        entries[_VIp] = input[_VIp];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEndpointAuthorizationMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_Ac] != null) {
        entries[_Ac] = input[_Ac];
    }
    if (input[_G] != null) {
        entries[_G] = input[_G];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEventCategoriesMessage = (input, context) => {
    const entries = {};
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    return entries;
};
const se_DescribeEventsMessage = (input, context) => {
    const entries = {};
    if (input[_SIou] != null) {
        entries[_SIou] = input[_SIou];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_Du] != null) {
        entries[_Du] = input[_Du];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeEventSubscriptionsMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeHsmClientCertificatesMessage = (input, context) => {
    const entries = {};
    if (input[_HCCI] != null) {
        entries[_HCCI] = input[_HCCI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeHsmConfigurationsMessage = (input, context) => {
    const entries = {};
    if (input[_HCI] != null) {
        entries[_HCI] = input[_HCI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeInboundIntegrationsMessage = (input, context) => {
    const entries = {};
    if (input[_IA] != null) {
        entries[_IA] = input[_IA];
    }
    if (input[_TAa] != null) {
        entries[_TAa] = input[_TAa];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeLoggingStatusMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_DescribeNodeConfigurationOptionsMessage = (input, context) => {
    const entries = {};
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_NodeConfigurationOptionsFilterList(input[_Fi], context);
        if (input[_Fi]?.length === 0) {
            entries.Filter = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeOrderableClusterOptionsMessage = (input, context) => {
    const entries = {};
    if (input[_CV] != null) {
        entries[_CV] = input[_CV];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribePartnersInputMessage = (input, context) => {
    const entries = {};
    if (input[_AIc] != null) {
        entries[_AIc] = input[_AIc];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_DescribeRedshiftIdcApplicationsMessage = (input, context) => {
    const entries = {};
    if (input[_RIAA] != null) {
        entries[_RIAA] = input[_RIAA];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeReservedNodeExchangeStatusInputMessage = (input, context) => {
    const entries = {};
    if (input[_RNI] != null) {
        entries[_RNI] = input[_RNI];
    }
    if (input[_RNERI] != null) {
        entries[_RNERI] = input[_RNERI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeReservedNodeOfferingsMessage = (input, context) => {
    const entries = {};
    if (input[_RNOI] != null) {
        entries[_RNOI] = input[_RNOI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeReservedNodesMessage = (input, context) => {
    const entries = {};
    if (input[_RNI] != null) {
        entries[_RNI] = input[_RNI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeResizeMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_DescribeScheduledActionsMessage = (input, context) => {
    const entries = {};
    if (input[_SAN] != null) {
        entries[_SAN] = input[_SAN];
    }
    if (input[_TAT] != null) {
        entries[_TAT] = input[_TAT];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_Act] != null) {
        entries[_Act] = input[_Act];
    }
    if (input[_Fi] != null) {
        const memberEntries = se_ScheduledActionFilterList(input[_Fi], context);
        if (input[_Fi]?.length === 0) {
            entries.Filters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeSnapshotCopyGrantsMessage = (input, context) => {
    const entries = {};
    if (input[_SCGN] != null) {
        entries[_SCGN] = input[_SCGN];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeSnapshotSchedulesMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SIc] != null) {
        entries[_SIc] = input[_SIc];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    return entries;
};
const se_DescribeTableRestoreStatusMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_TRRI] != null) {
        entries[_TRRI] = input[_TRRI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_DescribeTagsMessage = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        entries[_RN] = input[_RN];
    }
    if (input[_RT] != null) {
        entries[_RT] = input[_RT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeUsageLimitsMessage = (input, context) => {
    const entries = {};
    if (input[_ULI] != null) {
        entries[_ULI] = input[_ULI];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_FT] != null) {
        entries[_FT] = input[_FT];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TV] != null) {
        const memberEntries = se_TagValueList(input[_TV], context);
        if (input[_TV]?.length === 0) {
            entries.TagValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagValues.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisableLoggingMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_DisableSnapshotCopyMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_DisassociateDataShareConsumerMessage = (input, context) => {
    const entries = {};
    if (input[_DSAa] != null) {
        entries[_DSAa] = input[_DSAa];
    }
    if (input[_DEAi] != null) {
        entries[_DEAi] = input[_DEAi];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    if (input[_CRo] != null) {
        entries[_CRo] = input[_CRo];
    }
    return entries;
};
const se_EnableLoggingMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_BN] != null) {
        entries[_BN] = input[_BN];
    }
    if (input[_SKP] != null) {
        entries[_SKP] = input[_SKP];
    }
    if (input[_LDT] != null) {
        entries[_LDT] = input[_LDT];
    }
    if (input[_LE] != null) {
        const memberEntries = se_LogTypeList(input[_LE], context);
        if (input[_LE]?.length === 0) {
            entries.LogExports = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LogExports.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableSnapshotCopyMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DRe] != null) {
        entries[_DRe] = input[_DRe];
    }
    if (input[_RP] != null) {
        entries[_RP] = input[_RP];
    }
    if (input[_SCGN] != null) {
        entries[_SCGN] = input[_SCGN];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    return entries;
};
const se_EventCategoriesList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`EventCategory.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_FailoverPrimaryComputeInputMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_GetClusterCredentialsMessage = (input, context) => {
    const entries = {};
    if (input[_DU] != null) {
        entries[_DU] = input[_DU];
    }
    if (input[_DNb] != null) {
        entries[_DNb] = input[_DNb];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DSu] != null) {
        entries[_DSu] = input[_DSu];
    }
    if (input[_AC] != null) {
        entries[_AC] = input[_AC];
    }
    if (input[_DG] != null) {
        const memberEntries = se_DbGroupList(input[_DG], context);
        if (input[_DG]?.length === 0) {
            entries.DbGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DbGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_CDN] != null) {
        entries[_CDN] = input[_CDN];
    }
    return entries;
};
const se_GetClusterCredentialsWithIAMMessage = (input, context) => {
    const entries = {};
    if (input[_DNb] != null) {
        entries[_DNb] = input[_DNb];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DSu] != null) {
        entries[_DSu] = input[_DSu];
    }
    if (input[_CDN] != null) {
        entries[_CDN] = input[_CDN];
    }
    return entries;
};
const se_GetReservedNodeExchangeConfigurationOptionsInputMessage = (input, context) => {
    const entries = {};
    if (input[_AT] != null) {
        entries[_AT] = input[_AT];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_GetReservedNodeExchangeOfferingsInputMessage = (input, context) => {
    const entries = {};
    if (input[_RNI] != null) {
        entries[_RNI] = input[_RNI];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_GetResourcePolicyMessage = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    return entries;
};
const se_IamRoleArnList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`IamRoleArn.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LakeFormationQuery = (input, context) => {
    const entries = {};
    if (input[_Au] != null) {
        entries[_Au] = input[_Au];
    }
    return entries;
};
const se_LakeFormationScopeUnion = (input, context) => {
    const entries = {};
    LakeFormationScopeUnion.visit(input, {
        LakeFormationQuery: (value) => {
            const memberEntries = se_LakeFormationQuery(value, context);
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `LakeFormationQuery.${key}`;
                entries[loc] = value;
            });
        },
        _: (name, value) => {
            entries[name] = value;
        },
    });
    return entries;
};
const se_LakeFormationServiceIntegrations = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LakeFormationScopeUnion(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ListRecommendationsMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_NA] != null) {
        entries[_NA] = input[_NA];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_M] != null) {
        entries[_M] = input[_M];
    }
    return entries;
};
const se_LogTypeList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ModifyAquaInputMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_ACS] != null) {
        entries[_ACS] = input[_ACS];
    }
    return entries;
};
const se_ModifyAuthenticationProfileMessage = (input, context) => {
    const entries = {};
    if (input[_APN] != null) {
        entries[_APN] = input[_APN];
    }
    if (input[_APC] != null) {
        entries[_APC] = input[_APC];
    }
    return entries;
};
const se_ModifyClusterDbRevisionMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_RTe] != null) {
        entries[_RTe] = input[_RTe];
    }
    return entries;
};
const se_ModifyClusterIamRolesMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_AIR] != null) {
        const memberEntries = se_IamRoleArnList(input[_AIR], context);
        if (input[_AIR]?.length === 0) {
            entries.AddIamRoles = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AddIamRoles.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RIR] != null) {
        const memberEntries = se_IamRoleArnList(input[_RIR], context);
        if (input[_RIR]?.length === 0) {
            entries.RemoveIamRoles = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RemoveIamRoles.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DIRA] != null) {
        entries[_DIRA] = input[_DIRA];
    }
    return entries;
};
const se_ModifyClusterMaintenanceMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DM] != null) {
        entries[_DM] = input[_DM];
    }
    if (input[_DMI] != null) {
        entries[_DMI] = input[_DMI];
    }
    if (input[_DMST] != null) {
        entries[_DMST] = __serializeDateTime(input[_DMST]);
    }
    if (input[_DMET] != null) {
        entries[_DMET] = __serializeDateTime(input[_DMET]);
    }
    if (input[_DMD] != null) {
        entries[_DMD] = input[_DMD];
    }
    return entries;
};
const se_ModifyClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_NON] != null) {
        entries[_NON] = input[_NON];
    }
    if (input[_CSG] != null) {
        const memberEntries = se_ClusterSecurityGroupNameList(input[_CSG], context);
        if (input[_CSG]?.length === 0) {
            entries.ClusterSecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClusterSecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MUP] != null) {
        entries[_MUP] = input[_MUP];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_ASRP] != null) {
        entries[_ASRP] = input[_ASRP];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_CV] != null) {
        entries[_CV] = input[_CV];
    }
    if (input[_AVU] != null) {
        entries[_AVU] = input[_AVU];
    }
    if (input[_HCCI] != null) {
        entries[_HCCI] = input[_HCCI];
    }
    if (input[_HCI] != null) {
        entries[_HCI] = input[_HCI];
    }
    if (input[_NCI] != null) {
        entries[_NCI] = input[_NCI];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_EI] != null) {
        entries[_EI] = input[_EI];
    }
    if (input[_EVR] != null) {
        entries[_EVR] = input[_EVR];
    }
    if (input[_MTN] != null) {
        entries[_MTN] = input[_MTN];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_AZR] != null) {
        entries[_AZR] = input[_AZR];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_MMP] != null) {
        entries[_MMP] = input[_MMP];
    }
    if (input[_MPSKKI] != null) {
        entries[_MPSKKI] = input[_MPSKKI];
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_MAZ] != null) {
        entries[_MAZ] = input[_MAZ];
    }
    return entries;
};
const se_ModifyClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_PGN] != null) {
        entries[_PGN] = input[_PGN];
    }
    if (input[_Pa] != null) {
        const memberEntries = se_ParametersList(input[_Pa], context);
        if (input[_Pa]?.length === 0) {
            entries.Parameters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Parameters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    return entries;
};
const se_ModifyClusterSnapshotScheduleMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SIc] != null) {
        entries[_SIc] = input[_SIc];
    }
    if (input[_DSi] != null) {
        entries[_DSi] = input[_DSi];
    }
    return entries;
};
const se_ModifyClusterSubnetGroupMessage = (input, context) => {
    const entries = {};
    if (input[_CSGNl] != null) {
        entries[_CSGNl] = input[_CSGNl];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_SIu] != null) {
        const memberEntries = se_SubnetIdentifierList(input[_SIu], context);
        if (input[_SIu]?.length === 0) {
            entries.SubnetIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyCustomDomainAssociationMessage = (input, context) => {
    const entries = {};
    if (input[_CDN] != null) {
        entries[_CDN] = input[_CDN];
    }
    if (input[_CDCA] != null) {
        entries[_CDCA] = input[_CDCA];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_ModifyEndpointAccessMessage = (input, context) => {
    const entries = {};
    if (input[_EN] != null) {
        entries[_EN] = input[_EN];
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyEventSubscriptionMessage = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_STA] != null) {
        entries[_STA] = input[_STA];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST];
    }
    if (input[_SIo] != null) {
        const memberEntries = se_SourceIdsList(input[_SIo], context);
        if (input[_SIo]?.length === 0) {
            entries.SourceIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EC] != null) {
        const memberEntries = se_EventCategoriesList(input[_EC], context);
        if (input[_EC]?.length === 0) {
            entries.EventCategories = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `EventCategories.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_En] != null) {
        entries[_En] = input[_En];
    }
    return entries;
};
const se_ModifyRedshiftIdcApplicationMessage = (input, context) => {
    const entries = {};
    if (input[_RIAA] != null) {
        entries[_RIAA] = input[_RIAA];
    }
    if (input[_IN] != null) {
        entries[_IN] = input[_IN];
    }
    if (input[_IRA] != null) {
        entries[_IRA] = input[_IRA];
    }
    if (input[_IDN] != null) {
        entries[_IDN] = input[_IDN];
    }
    if (input[_ATIL] != null) {
        const memberEntries = se_AuthorizedTokenIssuerList(input[_ATIL], context);
        if (input[_ATIL]?.length === 0) {
            entries.AuthorizedTokenIssuerList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthorizedTokenIssuerList.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SIe] != null) {
        const memberEntries = se_ServiceIntegrationList(input[_SIe], context);
        if (input[_SIe]?.length === 0) {
            entries.ServiceIntegrations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceIntegrations.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyScheduledActionMessage = (input, context) => {
    const entries = {};
    if (input[_SAN] != null) {
        entries[_SAN] = input[_SAN];
    }
    if (input[_TA] != null) {
        const memberEntries = se_ScheduledActionType(input[_TA], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetAction.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Sc] != null) {
        entries[_Sc] = input[_Sc];
    }
    if (input[_IRa] != null) {
        entries[_IRa] = input[_IRa];
    }
    if (input[_SAD] != null) {
        entries[_SAD] = input[_SAD];
    }
    if (input[_STt] != null) {
        entries[_STt] = __serializeDateTime(input[_STt]);
    }
    if (input[_ET] != null) {
        entries[_ET] = __serializeDateTime(input[_ET]);
    }
    if (input[_Ena] != null) {
        entries[_Ena] = input[_Ena];
    }
    return entries;
};
const se_ModifySnapshotCopyRetentionPeriodMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_RP] != null) {
        entries[_RP] = input[_RP];
    }
    if (input[_Ma] != null) {
        entries[_Ma] = input[_Ma];
    }
    return entries;
};
const se_ModifySnapshotScheduleMessage = (input, context) => {
    const entries = {};
    if (input[_SIc] != null) {
        entries[_SIc] = input[_SIc];
    }
    if (input[_SD] != null) {
        const memberEntries = se_ScheduleDefinitionList(input[_SD], context);
        if (input[_SD]?.length === 0) {
            entries.ScheduleDefinitions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScheduleDefinitions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyUsageLimitMessage = (input, context) => {
    const entries = {};
    if (input[_ULI] != null) {
        entries[_ULI] = input[_ULI];
    }
    if (input[_Am] != null) {
        entries[_Am] = input[_Am];
    }
    if (input[_BA] != null) {
        entries[_BA] = input[_BA];
    }
    return entries;
};
const se_NodeConfigurationOptionsFilter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_O] != null) {
        entries[_O] = input[_O];
    }
    if (input[_Va] != null) {
        const memberEntries = se_ValueStringList(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Value = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Value.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_NodeConfigurationOptionsFilterList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_NodeConfigurationOptionsFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`NodeConfigurationOptionsFilter.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Parameter = (input, context) => {
    const entries = {};
    if (input[_PNa] != null) {
        entries[_PNa] = input[_PNa];
    }
    if (input[_PV] != null) {
        entries[_PV] = input[_PV];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    if (input[_So] != null) {
        entries[_So] = input[_So];
    }
    if (input[_DTa] != null) {
        entries[_DTa] = input[_DTa];
    }
    if (input[_AV] != null) {
        entries[_AV] = input[_AV];
    }
    if (input[_ATp] != null) {
        entries[_ATp] = input[_ATp];
    }
    if (input[_IM] != null) {
        entries[_IM] = input[_IM];
    }
    if (input[_MEV] != null) {
        entries[_MEV] = input[_MEV];
    }
    return entries;
};
const se_ParametersList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Parameter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Parameter.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PartnerIntegrationInputMessage = (input, context) => {
    const entries = {};
    if (input[_AIc] != null) {
        entries[_AIc] = input[_AIc];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    return entries;
};
const se_PauseClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_PurchaseReservedNodeOfferingMessage = (input, context) => {
    const entries = {};
    if (input[_RNOI] != null) {
        entries[_RNOI] = input[_RNOI];
    }
    if (input[_NC] != null) {
        entries[_NC] = input[_NC];
    }
    return entries;
};
const se_PutResourcePolicyMessage = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_Po] != null) {
        entries[_Po] = input[_Po];
    }
    return entries;
};
const se_RebootClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_RejectDataShareMessage = (input, context) => {
    const entries = {};
    if (input[_DSAa] != null) {
        entries[_DSAa] = input[_DSAa];
    }
    return entries;
};
const se_ResetClusterParameterGroupMessage = (input, context) => {
    const entries = {};
    if (input[_PGN] != null) {
        entries[_PGN] = input[_PGN];
    }
    if (input[_RAP] != null) {
        entries[_RAP] = input[_RAP];
    }
    if (input[_Pa] != null) {
        const memberEntries = se_ParametersList(input[_Pa], context);
        if (input[_Pa]?.length === 0) {
            entries.Parameters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Parameters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ResizeClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_CTl] != null) {
        entries[_CTl] = input[_CTl];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_NON] != null) {
        entries[_NON] = input[_NON];
    }
    if (input[_C] != null) {
        entries[_C] = input[_C];
    }
    if (input[_RNI] != null) {
        entries[_RNI] = input[_RNI];
    }
    if (input[_TRNOI] != null) {
        entries[_TRNOI] = input[_TRNOI];
    }
    return entries;
};
const se_RestoreFromClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_SCI] != null) {
        entries[_SCI] = input[_SCI];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_AZ] != null) {
        entries[_AZ] = input[_AZ];
    }
    if (input[_AVU] != null) {
        entries[_AVU] = input[_AVU];
    }
    if (input[_CSGNl] != null) {
        entries[_CSGNl] = input[_CSGNl];
    }
    if (input[_PA] != null) {
        entries[_PA] = input[_PA];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    if (input[_HCCI] != null) {
        entries[_HCCI] = input[_HCCI];
    }
    if (input[_HCI] != null) {
        entries[_HCI] = input[_HCI];
    }
    if (input[_EI] != null) {
        entries[_EI] = input[_EI];
    }
    if (input[_CPGN] != null) {
        entries[_CPGN] = input[_CPGN];
    }
    if (input[_CSG] != null) {
        const memberEntries = se_ClusterSecurityGroupNameList(input[_CSG], context);
        if (input[_CSG]?.length === 0) {
            entries.ClusterSecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClusterSecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_VSGI] != null) {
        const memberEntries = se_VpcSecurityGroupIdList(input[_VSGI], context);
        if (input[_VSGI]?.length === 0) {
            entries.VpcSecurityGroupIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcSecurityGroupIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PMW] != null) {
        entries[_PMW] = input[_PMW];
    }
    if (input[_ASRP] != null) {
        entries[_ASRP] = input[_ASRP];
    }
    if (input[_MSRP] != null) {
        entries[_MSRP] = input[_MSRP];
    }
    if (input[_KKI] != null) {
        entries[_KKI] = input[_KKI];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_EVR] != null) {
        entries[_EVR] = input[_EVR];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    if (input[_IR] != null) {
        const memberEntries = se_IamRoleArnList(input[_IR], context);
        if (input[_IR]?.length === 0) {
            entries.IamRoles = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IamRoles.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MTN] != null) {
        entries[_MTN] = input[_MTN];
    }
    if (input[_SSIn] != null) {
        entries[_SSIn] = input[_SSIn];
    }
    if (input[_NON] != null) {
        entries[_NON] = input[_NON];
    }
    if (input[_AZR] != null) {
        entries[_AZR] = input[_AZR];
    }
    if (input[_ACS] != null) {
        entries[_ACS] = input[_ACS];
    }
    if (input[_DIRA] != null) {
        entries[_DIRA] = input[_DIRA];
    }
    if (input[_RNI] != null) {
        entries[_RNI] = input[_RNI];
    }
    if (input[_TRNOI] != null) {
        entries[_TRNOI] = input[_TRNOI];
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_MMP] != null) {
        entries[_MMP] = input[_MMP];
    }
    if (input[_MPSKKI] != null) {
        entries[_MPSKKI] = input[_MPSKKI];
    }
    if (input[_IAT] != null) {
        entries[_IAT] = input[_IAT];
    }
    if (input[_MAZ] != null) {
        entries[_MAZ] = input[_MAZ];
    }
    return entries;
};
const se_RestoreTableFromClusterSnapshotMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SDN] != null) {
        entries[_SDN] = input[_SDN];
    }
    if (input[_SSN] != null) {
        entries[_SSN] = input[_SSN];
    }
    if (input[_STN] != null) {
        entries[_STN] = input[_STN];
    }
    if (input[_TDN] != null) {
        entries[_TDN] = input[_TDN];
    }
    if (input[_TSN] != null) {
        entries[_TSN] = input[_TSN];
    }
    if (input[_NTN] != null) {
        entries[_NTN] = input[_NTN];
    }
    if (input[_ECSI] != null) {
        entries[_ECSI] = input[_ECSI];
    }
    return entries;
};
const se_ResumeClusterMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_RevokeClusterSecurityGroupIngressMessage = (input, context) => {
    const entries = {};
    if (input[_CSGN] != null) {
        entries[_CSGN] = input[_CSGN];
    }
    if (input[_CIDRIP] != null) {
        entries[_CIDRIP] = input[_CIDRIP];
    }
    if (input[_ECSGN] != null) {
        entries[_ECSGN] = input[_ECSGN];
    }
    if (input[_ECSGOI] != null) {
        entries[_ECSGOI] = input[_ECSGOI];
    }
    return entries;
};
const se_RevokeEndpointAccessMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_Ac] != null) {
        entries[_Ac] = input[_Ac];
    }
    if (input[_VI] != null) {
        const memberEntries = se_VpcIdentifierList(input[_VI], context);
        if (input[_VI]?.length === 0) {
            entries.VpcIds = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `VpcIds.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_F] != null) {
        entries[_F] = input[_F];
    }
    return entries;
};
const se_RevokeSnapshotAccessMessage = (input, context) => {
    const entries = {};
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_SA] != null) {
        entries[_SA] = input[_SA];
    }
    if (input[_SCI] != null) {
        entries[_SCI] = input[_SCI];
    }
    if (input[_AWRA] != null) {
        entries[_AWRA] = input[_AWRA];
    }
    return entries;
};
const se_RotateEncryptionKeyMessage = (input, context) => {
    const entries = {};
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    return entries;
};
const se_ScheduledActionFilter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_Va] != null) {
        const memberEntries = se_ValueStringList(input[_Va], context);
        if (input[_Va]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ScheduledActionFilterList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ScheduledActionFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`ScheduledActionFilter.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ScheduledActionType = (input, context) => {
    const entries = {};
    if (input[_RCe] != null) {
        const memberEntries = se_ResizeClusterMessage(input[_RCe], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResizeCluster.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_PC] != null) {
        const memberEntries = se_PauseClusterMessage(input[_PC], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PauseCluster.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_RCes] != null) {
        const memberEntries = se_ResumeClusterMessage(input[_RCes], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResumeCluster.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ScheduleDefinitionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`ScheduleDefinition.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ServiceIntegrationList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ServiceIntegrationsUnion(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ServiceIntegrationsUnion = (input, context) => {
    const entries = {};
    ServiceIntegrationsUnion.visit(input, {
        LakeFormation: (value) => {
            const memberEntries = se_LakeFormationServiceIntegrations(value, context);
            if (value?.length === 0) {
                entries.LakeFormation = [];
            }
            Object.entries(memberEntries).forEach(([key, value]) => {
                const loc = `LakeFormation.${key}`;
                entries[loc] = value;
            });
        },
        _: (name, value) => {
            entries[name] = value;
        },
    });
    return entries;
};
const se_SnapshotIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`String.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SnapshotSortingEntity = (input, context) => {
    const entries = {};
    if (input[_At] != null) {
        entries[_At] = input[_At];
    }
    if (input[_SO] != null) {
        entries[_SO] = input[_SO];
    }
    return entries;
};
const se_SnapshotSortingEntityList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SnapshotSortingEntity(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`SnapshotSortingEntity.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_SourceIdsList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SourceId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SubnetIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`SubnetIdentifier.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Val] != null) {
        entries[_Val] = input[_Val];
    }
    return entries;
};
const se_TagKeyList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`TagKey.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`Tag.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagValueList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`TagValue.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UpdatePartnerStatusInputMessage = (input, context) => {
    const entries = {};
    if (input[_AIc] != null) {
        entries[_AIc] = input[_AIc];
    }
    if (input[_CIl] != null) {
        entries[_CIl] = input[_CIl];
    }
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_PN] != null) {
        entries[_PN] = input[_PN];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_SM] != null) {
        entries[_SM] = input[_SM];
    }
    return entries;
};
const se_ValueStringList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`item.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcIdentifierList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpcIdentifier.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_VpcSecurityGroupIdList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`VpcSecurityGroupId.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const de_AcceptReservedNodeExchangeOutputMessage = (output, context) => {
    const contents = {};
    if (output[_ERN] != null) {
        contents[_ERN] = de_ReservedNode(output[_ERN], context);
    }
    return contents;
};
const de_AccessToClusterDeniedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AccessToSnapshotDeniedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AccountAttribute = (output, context) => {
    const contents = {};
    if (output[_ANt] != null) {
        contents[_ANt] = __expectString(output[_ANt]);
    }
    if (output.AttributeValues === "") {
        contents[_AVt] = [];
    }
    else if (output[_AVt] != null && output[_AVt][_AVT] != null) {
        contents[_AVt] = de_AttributeValueList(__getArrayIfSingleItem(output[_AVt][_AVT]), context);
    }
    return contents;
};
const de_AccountAttributeList = (output, context) => {
    const contents = {};
    if (output.AccountAttributes === "") {
        contents[_AA] = [];
    }
    else if (output[_AA] != null && output[_AA][_AAc] != null) {
        contents[_AA] = de_AttributeList(__getArrayIfSingleItem(output[_AA][_AAc]), context);
    }
    return contents;
};
const de_AccountsWithRestoreAccessList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccountWithRestoreAccess(entry, context);
    });
};
const de_AccountWithRestoreAccess = (output, context) => {
    const contents = {};
    if (output[_AIc] != null) {
        contents[_AIc] = __expectString(output[_AIc]);
    }
    if (output[_AAcc] != null) {
        contents[_AAcc] = __expectString(output[_AAcc]);
    }
    return contents;
};
const de_AquaConfiguration = (output, context) => {
    const contents = {};
    if (output[_AS] != null) {
        contents[_AS] = __expectString(output[_AS]);
    }
    if (output[_ACS] != null) {
        contents[_ACS] = __expectString(output[_ACS]);
    }
    return contents;
};
const de_AssociatedClusterList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterAssociatedToSchedule(entry, context);
    });
};
const de_Association = (output, context) => {
    const contents = {};
    if (output[_CDCA] != null) {
        contents[_CDCA] = __expectString(output[_CDCA]);
    }
    if (output[_CDCED] != null) {
        contents[_CDCED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CDCED]));
    }
    if (output.CertificateAssociations === "") {
        contents[_CAe] = [];
    }
    else if (output[_CAe] != null && output[_CAe][_CAer] != null) {
        contents[_CAe] = de_CertificateAssociationList(__getArrayIfSingleItem(output[_CAe][_CAer]), context);
    }
    return contents;
};
const de_AssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Association(entry, context);
    });
};
const de_AttributeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccountAttribute(entry, context);
    });
};
const de_AttributeValueList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeValueTarget(entry, context);
    });
};
const de_AttributeValueTarget = (output, context) => {
    const contents = {};
    if (output[_AVtt] != null) {
        contents[_AVtt] = __expectString(output[_AVtt]);
    }
    return contents;
};
const de_AuthenticationProfile = (output, context) => {
    const contents = {};
    if (output[_APN] != null) {
        contents[_APN] = __expectString(output[_APN]);
    }
    if (output[_APC] != null) {
        contents[_APC] = __expectString(output[_APC]);
    }
    return contents;
};
const de_AuthenticationProfileAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AuthenticationProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuthenticationProfile(entry, context);
    });
};
const de_AuthenticationProfileNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AuthenticationProfileQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AuthorizationAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AuthorizationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AuthorizationQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_AuthorizeClusterSecurityGroupIngressResult = (output, context) => {
    const contents = {};
    if (output[_CSGl] != null) {
        contents[_CSGl] = de_ClusterSecurityGroup(output[_CSGl], context);
    }
    return contents;
};
const de_AuthorizedAudienceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AuthorizedTokenIssuer = (output, context) => {
    const contents = {};
    if (output[_TTIA] != null) {
        contents[_TTIA] = __expectString(output[_TTIA]);
    }
    if (output.AuthorizedAudiencesList === "") {
        contents[_AAL] = [];
    }
    else if (output[_AAL] != null && output[_AAL][_me] != null) {
        contents[_AAL] = de_AuthorizedAudienceList(__getArrayIfSingleItem(output[_AAL][_me]), context);
    }
    return contents;
};
const de_AuthorizedTokenIssuerList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuthorizedTokenIssuer(entry, context);
    });
};
const de_AuthorizeSnapshotAccessResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_AvailabilityZone = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output.SupportedPlatforms === "") {
        contents[_SP] = [];
    }
    else if (output[_SP] != null && output[_SP][_SPu] != null) {
        contents[_SP] = de_SupportedPlatformsList(__getArrayIfSingleItem(output[_SP][_SPu]), context);
    }
    return contents;
};
const de_AvailabilityZoneList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AvailabilityZone(entry, context);
    });
};
const de_BatchDeleteClusterSnapshotsResult = (output, context) => {
    const contents = {};
    if (output.Resources === "") {
        contents[_R] = [];
    }
    else if (output[_R] != null && output[_R][_Str] != null) {
        contents[_R] = de_SnapshotIdentifierList(__getArrayIfSingleItem(output[_R][_Str]), context);
    }
    if (output.Errors === "") {
        contents[_Er] = [];
    }
    else if (output[_Er] != null && output[_Er][_SEM] != null) {
        contents[_Er] = de_BatchSnapshotOperationErrorList(__getArrayIfSingleItem(output[_Er][_SEM]), context);
    }
    return contents;
};
const de_BatchDeleteRequestSizeExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_BatchModifyClusterSnapshotsLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_BatchModifyClusterSnapshotsOutputMessage = (output, context) => {
    const contents = {};
    if (output.Resources === "") {
        contents[_R] = [];
    }
    else if (output[_R] != null && output[_R][_Str] != null) {
        contents[_R] = de_SnapshotIdentifierList(__getArrayIfSingleItem(output[_R][_Str]), context);
    }
    if (output.Errors === "") {
        contents[_Er] = [];
    }
    else if (output[_Er] != null && output[_Er][_SEM] != null) {
        contents[_Er] = de_BatchSnapshotOperationErrors(__getArrayIfSingleItem(output[_Er][_SEM]), context);
    }
    return contents;
};
const de_BatchSnapshotOperationErrorList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotErrorMessage(entry, context);
    });
};
const de_BatchSnapshotOperationErrors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotErrorMessage(entry, context);
    });
};
const de_BucketNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_CertificateAssociation = (output, context) => {
    const contents = {};
    if (output[_CDN] != null) {
        contents[_CDN] = __expectString(output[_CDN]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    return contents;
};
const de_CertificateAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CertificateAssociation(entry, context);
    });
};
const de_Cluster = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_CS] != null) {
        contents[_CS] = __expectString(output[_CS]);
    }
    if (output[_CAS] != null) {
        contents[_CAS] = __expectString(output[_CAS]);
    }
    if (output[_MS] != null) {
        contents[_MS] = __expectString(output[_MS]);
    }
    if (output[_MU] != null) {
        contents[_MU] = __expectString(output[_MU]);
    }
    if (output[_DBN] != null) {
        contents[_DBN] = __expectString(output[_DBN]);
    }
    if (output[_End] != null) {
        contents[_End] = de_Endpoint(output[_End], context);
    }
    if (output[_CCT] != null) {
        contents[_CCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CCT]));
    }
    if (output[_ASRP] != null) {
        contents[_ASRP] = __strictParseInt32(output[_ASRP]);
    }
    if (output[_MSRP] != null) {
        contents[_MSRP] = __strictParseInt32(output[_MSRP]);
    }
    if (output.ClusterSecurityGroups === "") {
        contents[_CSG] = [];
    }
    else if (output[_CSG] != null && output[_CSG][_CSGl] != null) {
        contents[_CSG] = de_ClusterSecurityGroupMembershipList(__getArrayIfSingleItem(output[_CSG][_CSGl]), context);
    }
    if (output.VpcSecurityGroups === "") {
        contents[_VSG] = [];
    }
    else if (output[_VSG] != null && output[_VSG][_VSGp] != null) {
        contents[_VSG] = de_VpcSecurityGroupMembershipList(__getArrayIfSingleItem(output[_VSG][_VSGp]), context);
    }
    if (output.ClusterParameterGroups === "") {
        contents[_CPG] = [];
    }
    else if (output[_CPG] != null && output[_CPG][_CPGl] != null) {
        contents[_CPG] = de_ClusterParameterGroupStatusList(__getArrayIfSingleItem(output[_CPG][_CPGl]), context);
    }
    if (output[_CSGNl] != null) {
        contents[_CSGNl] = __expectString(output[_CSGNl]);
    }
    if (output[_VIp] != null) {
        contents[_VIp] = __expectString(output[_VIp]);
    }
    if (output[_AZ] != null) {
        contents[_AZ] = __expectString(output[_AZ]);
    }
    if (output[_PMW] != null) {
        contents[_PMW] = __expectString(output[_PMW]);
    }
    if (output[_PMV] != null) {
        contents[_PMV] = de_PendingModifiedValues(output[_PMV], context);
    }
    if (output[_CV] != null) {
        contents[_CV] = __expectString(output[_CV]);
    }
    if (output[_AVU] != null) {
        contents[_AVU] = __parseBoolean(output[_AVU]);
    }
    if (output[_NON] != null) {
        contents[_NON] = __strictParseInt32(output[_NON]);
    }
    if (output[_PA] != null) {
        contents[_PA] = __parseBoolean(output[_PA]);
    }
    if (output[_E] != null) {
        contents[_E] = __parseBoolean(output[_E]);
    }
    if (output[_RS] != null) {
        contents[_RS] = de_RestoreStatus(output[_RS], context);
    }
    if (output[_DTP] != null) {
        contents[_DTP] = de_DataTransferProgress(output[_DTP], context);
    }
    if (output[_HS] != null) {
        contents[_HS] = de_HsmStatus(output[_HS], context);
    }
    if (output[_CSCS] != null) {
        contents[_CSCS] = de_ClusterSnapshotCopyStatus(output[_CSCS], context);
    }
    if (output[_CPK] != null) {
        contents[_CPK] = __expectString(output[_CPK]);
    }
    if (output.ClusterNodes === "") {
        contents[_CN] = [];
    }
    else if (output[_CN] != null && output[_CN][_me] != null) {
        contents[_CN] = de_ClusterNodesList(__getArrayIfSingleItem(output[_CN][_me]), context);
    }
    if (output[_EIS] != null) {
        contents[_EIS] = de_ElasticIpStatus(output[_EIS], context);
    }
    if (output[_CRN] != null) {
        contents[_CRN] = __expectString(output[_CRN]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_EVR] != null) {
        contents[_EVR] = __parseBoolean(output[_EVR]);
    }
    if (output.IamRoles === "") {
        contents[_IR] = [];
    }
    else if (output[_IR] != null && output[_IR][_CIR] != null) {
        contents[_IR] = de_ClusterIamRoleList(__getArrayIfSingleItem(output[_IR][_CIR]), context);
    }
    if (output.PendingActions === "") {
        contents[_PAe] = [];
    }
    else if (output[_PAe] != null && output[_PAe][_me] != null) {
        contents[_PAe] = de_PendingActionsList(__getArrayIfSingleItem(output[_PAe][_me]), context);
    }
    if (output[_MTN] != null) {
        contents[_MTN] = __expectString(output[_MTN]);
    }
    if (output[_ERNONO] != null) {
        contents[_ERNONO] = __expectString(output[_ERNONO]);
    }
    if (output.DeferredMaintenanceWindows === "") {
        contents[_DMW] = [];
    }
    else if (output[_DMW] != null && output[_DMW][_DMWe] != null) {
        contents[_DMW] = de_DeferredMaintenanceWindowsList(__getArrayIfSingleItem(output[_DMW][_DMWe]), context);
    }
    if (output[_SSIn] != null) {
        contents[_SSIn] = __expectString(output[_SSIn]);
    }
    if (output[_SSS] != null) {
        contents[_SSS] = __expectString(output[_SSS]);
    }
    if (output[_ENSST] != null) {
        contents[_ENSST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ENSST]));
    }
    if (output[_ENSSTS] != null) {
        contents[_ENSSTS] = __expectString(output[_ENSSTS]);
    }
    if (output[_NMWST] != null) {
        contents[_NMWST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NMWST]));
    }
    if (output[_RI] != null) {
        contents[_RI] = de_ResizeInfo(output[_RI], context);
    }
    if (output[_AZRS] != null) {
        contents[_AZRS] = __expectString(output[_AZRS]);
    }
    if (output[_CNA] != null) {
        contents[_CNA] = __expectString(output[_CNA]);
    }
    if (output[_TSCIMB] != null) {
        contents[_TSCIMB] = __strictParseLong(output[_TSCIMB]);
    }
    if (output[_ACq] != null) {
        contents[_ACq] = de_AquaConfiguration(output[_ACq], context);
    }
    if (output[_DIRA] != null) {
        contents[_DIRA] = __expectString(output[_DIRA]);
    }
    if (output[_RNES] != null) {
        contents[_RNES] = de_ReservedNodeExchangeStatus(output[_RNES], context);
    }
    if (output[_CDN] != null) {
        contents[_CDN] = __expectString(output[_CDN]);
    }
    if (output[_CDCA] != null) {
        contents[_CDCA] = __expectString(output[_CDCA]);
    }
    if (output[_CDCED] != null) {
        contents[_CDCED] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CDCED]));
    }
    if (output[_MPSA] != null) {
        contents[_MPSA] = __expectString(output[_MPSA]);
    }
    if (output[_MPSKKI] != null) {
        contents[_MPSKKI] = __expectString(output[_MPSKKI]);
    }
    if (output[_IAT] != null) {
        contents[_IAT] = __expectString(output[_IAT]);
    }
    if (output[_MAZ] != null) {
        contents[_MAZ] = __expectString(output[_MAZ]);
    }
    if (output[_MAZS] != null) {
        contents[_MAZS] = de_SecondaryClusterInfo(output[_MAZS], context);
    }
    return contents;
};
const de_ClusterAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterAssociatedToSchedule = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_SAS] != null) {
        contents[_SAS] = __expectString(output[_SAS]);
    }
    return contents;
};
const de_ClusterCredentials = (output, context) => {
    const contents = {};
    if (output[_DU] != null) {
        contents[_DU] = __expectString(output[_DU]);
    }
    if (output[_DPb] != null) {
        contents[_DPb] = __expectString(output[_DPb]);
    }
    if (output[_Ex] != null) {
        contents[_Ex] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ex]));
    }
    return contents;
};
const de_ClusterDbRevision = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_CDR] != null) {
        contents[_CDR] = __expectString(output[_CDR]);
    }
    if (output[_DRRD] != null) {
        contents[_DRRD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_DRRD]));
    }
    if (output.RevisionTargets === "") {
        contents[_RTev] = [];
    }
    else if (output[_RTev] != null && output[_RTev][_RTe] != null) {
        contents[_RTev] = de_RevisionTargetsList(__getArrayIfSingleItem(output[_RTev][_RTe]), context);
    }
    return contents;
};
const de_ClusterDbRevisionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterDbRevision(entry, context);
    });
};
const de_ClusterDbRevisionsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ClusterDbRevisions === "") {
        contents[_CDRl] = [];
    }
    else if (output[_CDRl] != null && output[_CDRl][_CDRlu] != null) {
        contents[_CDRl] = de_ClusterDbRevisionsList(__getArrayIfSingleItem(output[_CDRl][_CDRlu]), context);
    }
    return contents;
};
const de_ClusterExtendedCredentials = (output, context) => {
    const contents = {};
    if (output[_DU] != null) {
        contents[_DU] = __expectString(output[_DU]);
    }
    if (output[_DPb] != null) {
        contents[_DPb] = __expectString(output[_DPb]);
    }
    if (output[_Ex] != null) {
        contents[_Ex] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ex]));
    }
    if (output[_NRT] != null) {
        contents[_NRT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_NRT]));
    }
    return contents;
};
const de_ClusterIamRole = (output, context) => {
    const contents = {};
    if (output[_IRA] != null) {
        contents[_IRA] = __expectString(output[_IRA]);
    }
    if (output[_ASp] != null) {
        contents[_ASp] = __expectString(output[_ASp]);
    }
    return contents;
};
const de_ClusterIamRoleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterIamRole(entry, context);
    });
};
const de_ClusterList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cluster(entry, context);
    });
};
const de_ClusterNode = (output, context) => {
    const contents = {};
    if (output[_NR] != null) {
        contents[_NR] = __expectString(output[_NR]);
    }
    if (output[_PIPA] != null) {
        contents[_PIPA] = __expectString(output[_PIPA]);
    }
    if (output[_PIPAu] != null) {
        contents[_PIPAu] = __expectString(output[_PIPAu]);
    }
    return contents;
};
const de_ClusterNodesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterNode(entry, context);
    });
};
const de_ClusterNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterOnLatestRevisionFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterParameterGroup = (output, context) => {
    const contents = {};
    if (output[_PGN] != null) {
        contents[_PGN] = __expectString(output[_PGN]);
    }
    if (output[_PGF] != null) {
        contents[_PGF] = __expectString(output[_PGF]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_ClusterParameterGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterParameterGroupDetails = (output, context) => {
    const contents = {};
    if (output.Parameters === "") {
        contents[_Pa] = [];
    }
    else if (output[_Pa] != null && output[_Pa][_Par] != null) {
        contents[_Pa] = de_ParametersList(__getArrayIfSingleItem(output[_Pa][_Par]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ClusterParameterGroupNameMessage = (output, context) => {
    const contents = {};
    if (output[_PGN] != null) {
        contents[_PGN] = __expectString(output[_PGN]);
    }
    if (output[_PGS] != null) {
        contents[_PGS] = __expectString(output[_PGS]);
    }
    return contents;
};
const de_ClusterParameterGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterParameterGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterParameterGroupsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ParameterGroups === "") {
        contents[_PG] = [];
    }
    else if (output[_PG] != null && output[_PG][_CPGl] != null) {
        contents[_PG] = de_ParameterGroupList(__getArrayIfSingleItem(output[_PG][_CPGl]), context);
    }
    return contents;
};
const de_ClusterParameterGroupStatus = (output, context) => {
    const contents = {};
    if (output[_PGN] != null) {
        contents[_PGN] = __expectString(output[_PGN]);
    }
    if (output[_PAS] != null) {
        contents[_PAS] = __expectString(output[_PAS]);
    }
    if (output.ClusterParameterStatusList === "") {
        contents[_CPSL] = [];
    }
    else if (output[_CPSL] != null && output[_CPSL][_me] != null) {
        contents[_CPSL] = de_ClusterParameterStatusList(__getArrayIfSingleItem(output[_CPSL][_me]), context);
    }
    return contents;
};
const de_ClusterParameterGroupStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterParameterGroupStatus(entry, context);
    });
};
const de_ClusterParameterStatus = (output, context) => {
    const contents = {};
    if (output[_PNa] != null) {
        contents[_PNa] = __expectString(output[_PNa]);
    }
    if (output[_PAS] != null) {
        contents[_PAS] = __expectString(output[_PAS]);
    }
    if (output[_PAED] != null) {
        contents[_PAED] = __expectString(output[_PAED]);
    }
    return contents;
};
const de_ClusterParameterStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterParameterStatus(entry, context);
    });
};
const de_ClusterQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSecurityGroup = (output, context) => {
    const contents = {};
    if (output[_CSGN] != null) {
        contents[_CSGN] = __expectString(output[_CSGN]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output.EC2SecurityGroups === "") {
        contents[_ECSG] = [];
    }
    else if (output[_ECSG] != null && output[_ECSG][_ECSGe] != null) {
        contents[_ECSG] = de_EC2SecurityGroupList(__getArrayIfSingleItem(output[_ECSG][_ECSGe]), context);
    }
    if (output.IPRanges === "") {
        contents[_IPR] = [];
    }
    else if (output[_IPR] != null && output[_IPR][_IPRa] != null) {
        contents[_IPR] = de_IPRangeList(__getArrayIfSingleItem(output[_IPR][_IPRa]), context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_ClusterSecurityGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSecurityGroupMembership = (output, context) => {
    const contents = {};
    if (output[_CSGN] != null) {
        contents[_CSGN] = __expectString(output[_CSGN]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_ClusterSecurityGroupMembershipList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterSecurityGroupMembership(entry, context);
    });
};
const de_ClusterSecurityGroupMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ClusterSecurityGroups === "") {
        contents[_CSG] = [];
    }
    else if (output[_CSG] != null && output[_CSG][_CSGl] != null) {
        contents[_CSG] = de_ClusterSecurityGroups(__getArrayIfSingleItem(output[_CSG][_CSGl]), context);
    }
    return contents;
};
const de_ClusterSecurityGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSecurityGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterSecurityGroup(entry, context);
    });
};
const de_ClustersMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Clusters === "") {
        contents[_Cl] = [];
    }
    else if (output[_Cl] != null && output[_Cl][_Clu] != null) {
        contents[_Cl] = de_ClusterList(__getArrayIfSingleItem(output[_Cl][_Clu]), context);
    }
    return contents;
};
const de_ClusterSnapshotAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSnapshotCopyStatus = (output, context) => {
    const contents = {};
    if (output[_DRe] != null) {
        contents[_DRe] = __expectString(output[_DRe]);
    }
    if (output[_RP] != null) {
        contents[_RP] = __strictParseLong(output[_RP]);
    }
    if (output[_MSRP] != null) {
        contents[_MSRP] = __strictParseInt32(output[_MSRP]);
    }
    if (output[_SCGN] != null) {
        contents[_SCGN] = __expectString(output[_SCGN]);
    }
    return contents;
};
const de_ClusterSnapshotNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSnapshotQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSubnetGroup = (output, context) => {
    const contents = {};
    if (output[_CSGNl] != null) {
        contents[_CSGNl] = __expectString(output[_CSGNl]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_VIp] != null) {
        contents[_VIp] = __expectString(output[_VIp]);
    }
    if (output[_SGS] != null) {
        contents[_SGS] = __expectString(output[_SGS]);
    }
    if (output.Subnets === "") {
        contents[_Su] = [];
    }
    else if (output[_Su] != null && output[_Su][_Sub] != null) {
        contents[_Su] = de_SubnetList(__getArrayIfSingleItem(output[_Su][_Sub]), context);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    if (output.SupportedClusterIpAddressTypes === "") {
        contents[_SCIAT] = [];
    }
    else if (output[_SCIAT] != null && output[_SCIAT][_i] != null) {
        contents[_SCIAT] = de_ValueStringList(__getArrayIfSingleItem(output[_SCIAT][_i]), context);
    }
    return contents;
};
const de_ClusterSubnetGroupAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSubnetGroupMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ClusterSubnetGroups === "") {
        contents[_CSGlu] = [];
    }
    else if (output[_CSGlu] != null && output[_CSGlu][_CSGlus] != null) {
        contents[_CSGlu] = de_ClusterSubnetGroups(__getArrayIfSingleItem(output[_CSGlu][_CSGlus]), context);
    }
    return contents;
};
const de_ClusterSubnetGroupNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSubnetGroupQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterSubnetGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterSubnetGroup(entry, context);
    });
};
const de_ClusterSubnetQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ClusterVersion = (output, context) => {
    const contents = {};
    if (output[_CV] != null) {
        contents[_CV] = __expectString(output[_CV]);
    }
    if (output[_CPGF] != null) {
        contents[_CPGF] = __expectString(output[_CPGF]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    return contents;
};
const de_ClusterVersionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterVersion(entry, context);
    });
};
const de_ClusterVersionsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ClusterVersions === "") {
        contents[_CVl] = [];
    }
    else if (output[_CVl] != null && output[_CVl][_CV] != null) {
        contents[_CVl] = de_ClusterVersionList(__getArrayIfSingleItem(output[_CVl][_CV]), context);
    }
    return contents;
};
const de_ConflictPolicyUpdateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_CopyClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_CopyToRegionDisabledFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_CreateAuthenticationProfileResult = (output, context) => {
    const contents = {};
    if (output[_APN] != null) {
        contents[_APN] = __expectString(output[_APN]);
    }
    if (output[_APC] != null) {
        contents[_APC] = __expectString(output[_APC]);
    }
    return contents;
};
const de_CreateClusterParameterGroupResult = (output, context) => {
    const contents = {};
    if (output[_CPGl] != null) {
        contents[_CPGl] = de_ClusterParameterGroup(output[_CPGl], context);
    }
    return contents;
};
const de_CreateClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_CreateClusterSecurityGroupResult = (output, context) => {
    const contents = {};
    if (output[_CSGl] != null) {
        contents[_CSGl] = de_ClusterSecurityGroup(output[_CSGl], context);
    }
    return contents;
};
const de_CreateClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_CreateClusterSubnetGroupResult = (output, context) => {
    const contents = {};
    if (output[_CSGlus] != null) {
        contents[_CSGlus] = de_ClusterSubnetGroup(output[_CSGlus], context);
    }
    return contents;
};
const de_CreateCustomDomainAssociationResult = (output, context) => {
    const contents = {};
    if (output[_CDN] != null) {
        contents[_CDN] = __expectString(output[_CDN]);
    }
    if (output[_CDCA] != null) {
        contents[_CDCA] = __expectString(output[_CDCA]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_CDCET] != null) {
        contents[_CDCET] = __expectString(output[_CDCET]);
    }
    return contents;
};
const de_CreateEventSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_CreateHsmClientCertificateResult = (output, context) => {
    const contents = {};
    if (output[_HCC] != null) {
        contents[_HCC] = de_HsmClientCertificate(output[_HCC], context);
    }
    return contents;
};
const de_CreateHsmConfigurationResult = (output, context) => {
    const contents = {};
    if (output[_HC] != null) {
        contents[_HC] = de_HsmConfiguration(output[_HC], context);
    }
    return contents;
};
const de_CreateRedshiftIdcApplicationResult = (output, context) => {
    const contents = {};
    if (output[_RIA] != null) {
        contents[_RIA] = de_RedshiftIdcApplication(output[_RIA], context);
    }
    return contents;
};
const de_CreateSnapshotCopyGrantResult = (output, context) => {
    const contents = {};
    if (output[_SCG] != null) {
        contents[_SCG] = de_SnapshotCopyGrant(output[_SCG], context);
    }
    return contents;
};
const de_CustomCnameAssociationFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_CustomDomainAssociationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_CustomDomainAssociationsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Associations === "") {
        contents[_As] = [];
    }
    else if (output[_As] != null && output[_As][_Ass] != null) {
        contents[_As] = de_AssociationList(__getArrayIfSingleItem(output[_As][_Ass]), context);
    }
    return contents;
};
const de_CustomerStorageMessage = (output, context) => {
    const contents = {};
    if (output[_TBSIMB] != null) {
        contents[_TBSIMB] = __strictParseFloat(output[_TBSIMB]);
    }
    if (output[_TPSIMB] != null) {
        contents[_TPSIMB] = __strictParseFloat(output[_TPSIMB]);
    }
    return contents;
};
const de_DataShare = (output, context) => {
    const contents = {};
    if (output[_DSAa] != null) {
        contents[_DSAa] = __expectString(output[_DSAa]);
    }
    if (output[_PAr] != null) {
        contents[_PAr] = __expectString(output[_PAr]);
    }
    if (output[_APAC] != null) {
        contents[_APAC] = __parseBoolean(output[_APAC]);
    }
    if (output.DataShareAssociations === "") {
        contents[_DSAat] = [];
    }
    else if (output[_DSAat] != null && output[_DSAat][_me] != null) {
        contents[_DSAat] = de_DataShareAssociationList(__getArrayIfSingleItem(output[_DSAat][_me]), context);
    }
    if (output[_MB] != null) {
        contents[_MB] = __expectString(output[_MB]);
    }
    return contents;
};
const de_DataShareAssociation = (output, context) => {
    const contents = {};
    if (output[_CI] != null) {
        contents[_CI] = __expectString(output[_CI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CRo] != null) {
        contents[_CRo] = __expectString(output[_CRo]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_SCD] != null) {
        contents[_SCD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SCD]));
    }
    if (output[_PAW] != null) {
        contents[_PAW] = __parseBoolean(output[_PAW]);
    }
    if (output[_CAW] != null) {
        contents[_CAW] = __parseBoolean(output[_CAW]);
    }
    return contents;
};
const de_DataShareAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DataShareAssociation(entry, context);
    });
};
const de_DataShareList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DataShare(entry, context);
    });
};
const de_DataTransferProgress = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CRIMBPS] != null) {
        contents[_CRIMBPS] = __strictParseFloat(output[_CRIMBPS]);
    }
    if (output[_TDIMB] != null) {
        contents[_TDIMB] = __strictParseLong(output[_TDIMB]);
    }
    if (output[_DTIMB] != null) {
        contents[_DTIMB] = __strictParseLong(output[_DTIMB]);
    }
    if (output[_ETTCIS] != null) {
        contents[_ETTCIS] = __strictParseLong(output[_ETTCIS]);
    }
    if (output[_ETIS] != null) {
        contents[_ETIS] = __strictParseLong(output[_ETIS]);
    }
    return contents;
};
const de_DefaultClusterParameters = (output, context) => {
    const contents = {};
    if (output[_PGF] != null) {
        contents[_PGF] = __expectString(output[_PGF]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Parameters === "") {
        contents[_Pa] = [];
    }
    else if (output[_Pa] != null && output[_Pa][_Par] != null) {
        contents[_Pa] = de_ParametersList(__getArrayIfSingleItem(output[_Pa][_Par]), context);
    }
    return contents;
};
const de_DeferredMaintenanceWindow = (output, context) => {
    const contents = {};
    if (output[_DMI] != null) {
        contents[_DMI] = __expectString(output[_DMI]);
    }
    if (output[_DMST] != null) {
        contents[_DMST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_DMST]));
    }
    if (output[_DMET] != null) {
        contents[_DMET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_DMET]));
    }
    return contents;
};
const de_DeferredMaintenanceWindowsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeferredMaintenanceWindow(entry, context);
    });
};
const de_DeleteAuthenticationProfileResult = (output, context) => {
    const contents = {};
    if (output[_APN] != null) {
        contents[_APN] = __expectString(output[_APN]);
    }
    return contents;
};
const de_DeleteClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_DeleteClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_DependentServiceAccessDeniedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DependentServiceRequestThrottlingFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DependentServiceUnavailableFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_DescribeAuthenticationProfilesResult = (output, context) => {
    const contents = {};
    if (output.AuthenticationProfiles === "") {
        contents[_APu] = [];
    }
    else if (output[_APu] != null && output[_APu][_me] != null) {
        contents[_APu] = de_AuthenticationProfileList(__getArrayIfSingleItem(output[_APu][_me]), context);
    }
    return contents;
};
const de_DescribeDataSharesForConsumerResult = (output, context) => {
    const contents = {};
    if (output.DataShares === "") {
        contents[_DSa] = [];
    }
    else if (output[_DSa] != null && output[_DSa][_me] != null) {
        contents[_DSa] = de_DataShareList(__getArrayIfSingleItem(output[_DSa][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DescribeDataSharesForProducerResult = (output, context) => {
    const contents = {};
    if (output.DataShares === "") {
        contents[_DSa] = [];
    }
    else if (output[_DSa] != null && output[_DSa][_me] != null) {
        contents[_DSa] = de_DataShareList(__getArrayIfSingleItem(output[_DSa][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DescribeDataSharesResult = (output, context) => {
    const contents = {};
    if (output.DataShares === "") {
        contents[_DSa] = [];
    }
    else if (output[_DSa] != null && output[_DSa][_me] != null) {
        contents[_DSa] = de_DataShareList(__getArrayIfSingleItem(output[_DSa][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DescribeDefaultClusterParametersResult = (output, context) => {
    const contents = {};
    if (output[_DCPe] != null) {
        contents[_DCPe] = de_DefaultClusterParameters(output[_DCPe], context);
    }
    return contents;
};
const de_DescribePartnersOutputMessage = (output, context) => {
    const contents = {};
    if (output.PartnerIntegrationInfoList === "") {
        contents[_PIIL] = [];
    }
    else if (output[_PIIL] != null && output[_PIIL][_PII] != null) {
        contents[_PIIL] = de_PartnerIntegrationInfoList(__getArrayIfSingleItem(output[_PIIL][_PII]), context);
    }
    return contents;
};
const de_DescribeRedshiftIdcApplicationsResult = (output, context) => {
    const contents = {};
    if (output.RedshiftIdcApplications === "") {
        contents[_RIAe] = [];
    }
    else if (output[_RIAe] != null && output[_RIAe][_me] != null) {
        contents[_RIAe] = de_RedshiftIdcApplicationList(__getArrayIfSingleItem(output[_RIAe][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DescribeReservedNodeExchangeStatusOutputMessage = (output, context) => {
    const contents = {};
    if (output.ReservedNodeExchangeStatusDetails === "") {
        contents[_RNESD] = [];
    }
    else if (output[_RNESD] != null && output[_RNESD][_RNES] != null) {
        contents[_RNESD] = de_ReservedNodeExchangeStatusList(__getArrayIfSingleItem(output[_RNESD][_RNES]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DescribeSnapshotSchedulesOutputMessage = (output, context) => {
    const contents = {};
    if (output.SnapshotSchedules === "") {
        contents[_SS] = [];
    }
    else if (output[_SS] != null && output[_SS][_SSn] != null) {
        contents[_SS] = de_SnapshotScheduleList(__getArrayIfSingleItem(output[_SS][_SSn]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DisableSnapshotCopyResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_EC2SecurityGroup = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_ECSGN] != null) {
        contents[_ECSGN] = __expectString(output[_ECSGN]);
    }
    if (output[_ECSGOI] != null) {
        contents[_ECSGOI] = __expectString(output[_ECSGOI]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_EC2SecurityGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EC2SecurityGroup(entry, context);
    });
};
const de_ElasticIpStatus = (output, context) => {
    const contents = {};
    if (output[_EI] != null) {
        contents[_EI] = __expectString(output[_EI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_EligibleTracksToUpdateList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UpdateTarget(entry, context);
    });
};
const de_EnableSnapshotCopyResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_Endpoint = (output, context) => {
    const contents = {};
    if (output[_Ad] != null) {
        contents[_Ad] = __expectString(output[_Ad]);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output.VpcEndpoints === "") {
        contents[_VE] = [];
    }
    else if (output[_VE] != null && output[_VE][_VEp] != null) {
        contents[_VE] = de_VpcEndpointsList(__getArrayIfSingleItem(output[_VE][_VEp]), context);
    }
    return contents;
};
const de_EndpointAccess = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_RO] != null) {
        contents[_RO] = __expectString(output[_RO]);
    }
    if (output[_SGN] != null) {
        contents[_SGN] = __expectString(output[_SGN]);
    }
    if (output[_ESn] != null) {
        contents[_ESn] = __expectString(output[_ESn]);
    }
    if (output[_EN] != null) {
        contents[_EN] = __expectString(output[_EN]);
    }
    if (output[_ECT] != null) {
        contents[_ECT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ECT]));
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_Ad] != null) {
        contents[_Ad] = __expectString(output[_Ad]);
    }
    if (output.VpcSecurityGroups === "") {
        contents[_VSG] = [];
    }
    else if (output[_VSG] != null && output[_VSG][_VSGp] != null) {
        contents[_VSG] = de_VpcSecurityGroupMembershipList(__getArrayIfSingleItem(output[_VSG][_VSGp]), context);
    }
    if (output[_VEp] != null) {
        contents[_VEp] = de_VpcEndpoint(output[_VEp], context);
    }
    return contents;
};
const de_EndpointAccesses = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EndpointAccess(entry, context);
    });
};
const de_EndpointAccessList = (output, context) => {
    const contents = {};
    if (output.EndpointAccessList === "") {
        contents[_EAL] = [];
    }
    else if (output[_EAL] != null && output[_EAL][_me] != null) {
        contents[_EAL] = de_EndpointAccesses(__getArrayIfSingleItem(output[_EAL][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_EndpointAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EndpointAuthorization = (output, context) => {
    const contents = {};
    if (output[_Gr] != null) {
        contents[_Gr] = __expectString(output[_Gr]);
    }
    if (output[_G] != null) {
        contents[_G] = __expectString(output[_G]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_ATu] != null) {
        contents[_ATu] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ATu]));
    }
    if (output[_CS] != null) {
        contents[_CS] = __expectString(output[_CS]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_AAVPC] != null) {
        contents[_AAVPC] = __parseBoolean(output[_AAVPC]);
    }
    if (output.AllowedVPCs === "") {
        contents[_AVPC] = [];
    }
    else if (output[_AVPC] != null && output[_AVPC][_VIpc] != null) {
        contents[_AVPC] = de_VpcIdentifierList(__getArrayIfSingleItem(output[_AVPC][_VIpc]), context);
    }
    if (output[_ECn] != null) {
        contents[_ECn] = __strictParseInt32(output[_ECn]);
    }
    return contents;
};
const de_EndpointAuthorizationAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EndpointAuthorizationList = (output, context) => {
    const contents = {};
    if (output.EndpointAuthorizationList === "") {
        contents[_EALn] = [];
    }
    else if (output[_EALn] != null && output[_EALn][_me] != null) {
        contents[_EALn] = de_EndpointAuthorizations(__getArrayIfSingleItem(output[_EALn][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_EndpointAuthorizationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EndpointAuthorizations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EndpointAuthorization(entry, context);
    });
};
const de_EndpointAuthorizationsPerClusterLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EndpointNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EndpointsPerAuthorizationLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EndpointsPerClusterLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_Event = (output, context) => {
    const contents = {};
    if (output[_SIou] != null) {
        contents[_SIou] = __expectString(output[_SIou]);
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    if (output.EventCategories === "") {
        contents[_EC] = [];
    }
    else if (output[_EC] != null && output[_EC][_ECv] != null) {
        contents[_EC] = de_EventCategoriesList(__getArrayIfSingleItem(output[_EC][_ECv]), context);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_Da] != null) {
        contents[_Da] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Da]));
    }
    if (output[_EIv] != null) {
        contents[_EIv] = __expectString(output[_EIv]);
    }
    return contents;
};
const de_EventCategoriesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_EventCategoriesMap = (output, context) => {
    const contents = {};
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    if (output.Events === "") {
        contents[_Ev] = [];
    }
    else if (output[_Ev] != null && output[_Ev][_EIM] != null) {
        contents[_Ev] = de_EventInfoMapList(__getArrayIfSingleItem(output[_Ev][_EIM]), context);
    }
    return contents;
};
const de_EventCategoriesMapList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EventCategoriesMap(entry, context);
    });
};
const de_EventCategoriesMessage = (output, context) => {
    const contents = {};
    if (output.EventCategoriesMapList === "") {
        contents[_ECML] = [];
    }
    else if (output[_ECML] != null && output[_ECML][_ECM] != null) {
        contents[_ECML] = de_EventCategoriesMapList(__getArrayIfSingleItem(output[_ECML][_ECM]), context);
    }
    return contents;
};
const de_EventInfoMap = (output, context) => {
    const contents = {};
    if (output[_EIv] != null) {
        contents[_EIv] = __expectString(output[_EIv]);
    }
    if (output.EventCategories === "") {
        contents[_EC] = [];
    }
    else if (output[_EC] != null && output[_EC][_ECv] != null) {
        contents[_EC] = de_EventCategoriesList(__getArrayIfSingleItem(output[_EC][_ECv]), context);
    }
    if (output[_ED] != null) {
        contents[_ED] = __expectString(output[_ED]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    return contents;
};
const de_EventInfoMapList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EventInfoMap(entry, context);
    });
};
const de_EventList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Event(entry, context);
    });
};
const de_EventsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Events === "") {
        contents[_Ev] = [];
    }
    else if (output[_Ev] != null && output[_Ev][_Eve] != null) {
        contents[_Ev] = de_EventList(__getArrayIfSingleItem(output[_Ev][_Eve]), context);
    }
    return contents;
};
const de_EventSubscription = (output, context) => {
    const contents = {};
    if (output[_CAI] != null) {
        contents[_CAI] = __expectString(output[_CAI]);
    }
    if (output[_CSI] != null) {
        contents[_CSI] = __expectString(output[_CSI]);
    }
    if (output[_STA] != null) {
        contents[_STA] = __expectString(output[_STA]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_SCT] != null) {
        contents[_SCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SCT]));
    }
    if (output[_ST] != null) {
        contents[_ST] = __expectString(output[_ST]);
    }
    if (output.SourceIdsList === "") {
        contents[_SILo] = [];
    }
    else if (output[_SILo] != null && output[_SILo][_SIour] != null) {
        contents[_SILo] = de_SourceIdsList(__getArrayIfSingleItem(output[_SILo][_SIour]), context);
    }
    if (output.EventCategoriesList === "") {
        contents[_ECL] = [];
    }
    else if (output[_ECL] != null && output[_ECL][_ECv] != null) {
        contents[_ECL] = de_EventCategoriesList(__getArrayIfSingleItem(output[_ECL][_ECv]), context);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_En] != null) {
        contents[_En] = __parseBoolean(output[_En]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_EventSubscriptionQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_EventSubscriptionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EventSubscription(entry, context);
    });
};
const de_EventSubscriptionsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.EventSubscriptionsList === "") {
        contents[_ESL] = [];
    }
    else if (output[_ESL] != null && output[_ESL][_ES] != null) {
        contents[_ESL] = de_EventSubscriptionsList(__getArrayIfSingleItem(output[_ESL][_ES]), context);
    }
    return contents;
};
const de_FailoverPrimaryComputeResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_GetReservedNodeExchangeConfigurationOptionsOutputMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ReservedNodeConfigurationOptionList === "") {
        contents[_RNCOL] = [];
    }
    else if (output[_RNCOL] != null && output[_RNCOL][_RNCO] != null) {
        contents[_RNCOL] = de_ReservedNodeConfigurationOptionList(__getArrayIfSingleItem(output[_RNCOL][_RNCO]), context);
    }
    return contents;
};
const de_GetReservedNodeExchangeOfferingsOutputMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ReservedNodeOfferings === "") {
        contents[_RNO] = [];
    }
    else if (output[_RNO] != null && output[_RNO][_RNOe] != null) {
        contents[_RNO] = de_ReservedNodeOfferingList(__getArrayIfSingleItem(output[_RNO][_RNOe]), context);
    }
    return contents;
};
const de_GetResourcePolicyResult = (output, context) => {
    const contents = {};
    if (output[_RPe] != null) {
        contents[_RPe] = de_ResourcePolicy(output[_RPe], context);
    }
    return contents;
};
const de_HsmClientCertificate = (output, context) => {
    const contents = {};
    if (output[_HCCI] != null) {
        contents[_HCCI] = __expectString(output[_HCCI]);
    }
    if (output[_HCCPK] != null) {
        contents[_HCCPK] = __expectString(output[_HCCPK]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_HsmClientCertificateAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_HsmClientCertificateList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HsmClientCertificate(entry, context);
    });
};
const de_HsmClientCertificateMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.HsmClientCertificates === "") {
        contents[_HCCs] = [];
    }
    else if (output[_HCCs] != null && output[_HCCs][_HCC] != null) {
        contents[_HCCs] = de_HsmClientCertificateList(__getArrayIfSingleItem(output[_HCCs][_HCC]), context);
    }
    return contents;
};
const de_HsmClientCertificateNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_HsmClientCertificateQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_HsmConfiguration = (output, context) => {
    const contents = {};
    if (output[_HCI] != null) {
        contents[_HCI] = __expectString(output[_HCI]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_HIA] != null) {
        contents[_HIA] = __expectString(output[_HIA]);
    }
    if (output[_HPN] != null) {
        contents[_HPN] = __expectString(output[_HPN]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_HsmConfigurationAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_HsmConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HsmConfiguration(entry, context);
    });
};
const de_HsmConfigurationMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.HsmConfigurations === "") {
        contents[_HCs] = [];
    }
    else if (output[_HCs] != null && output[_HCs][_HC] != null) {
        contents[_HCs] = de_HsmConfigurationList(__getArrayIfSingleItem(output[_HCs][_HC]), context);
    }
    return contents;
};
const de_HsmConfigurationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_HsmConfigurationQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_HsmStatus = (output, context) => {
    const contents = {};
    if (output[_HCCI] != null) {
        contents[_HCCI] = __expectString(output[_HCCI]);
    }
    if (output[_HCI] != null) {
        contents[_HCI] = __expectString(output[_HCI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_ImportTablesCompleted = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ImportTablesInProgress = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ImportTablesNotStarted = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InboundIntegration = (output, context) => {
    const contents = {};
    if (output[_IA] != null) {
        contents[_IA] = __expectString(output[_IA]);
    }
    if (output[_SAo] != null) {
        contents[_SAo] = __expectString(output[_SAo]);
    }
    if (output[_TAa] != null) {
        contents[_TAa] = __expectString(output[_TAa]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output.Errors === "") {
        contents[_Er] = [];
    }
    else if (output[_Er] != null && output[_Er][_IE] != null) {
        contents[_Er] = de_IntegrationErrorList(__getArrayIfSingleItem(output[_Er][_IE]), context);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CTr]));
    }
    return contents;
};
const de_InboundIntegrationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InboundIntegration(entry, context);
    });
};
const de_InboundIntegrationsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.InboundIntegrations === "") {
        contents[_II] = [];
    }
    else if (output[_II] != null && output[_II][_IIn] != null) {
        contents[_II] = de_InboundIntegrationList(__getArrayIfSingleItem(output[_II][_IIn]), context);
    }
    return contents;
};
const de_IncompatibleOrderableOptions = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InProgressTableRestoreQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InsufficientClusterCapacityFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InsufficientS3BucketPolicyFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_IntegrationError = (output, context) => {
    const contents = {};
    if (output[_ECr] != null) {
        contents[_ECr] = __expectString(output[_ECr]);
    }
    if (output[_EM] != null) {
        contents[_EM] = __expectString(output[_EM]);
    }
    return contents;
};
const de_IntegrationErrorList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IntegrationError(entry, context);
    });
};
const de_IntegrationNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidAuthenticationProfileRequestFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidAuthorizationStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterParameterGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterSecurityGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterSnapshotScheduleStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterSnapshotStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterSubnetGroupStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterSubnetStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidClusterTrackFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidDataShareFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidElasticIpFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidEndpointStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidHsmClientCertificateStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidHsmConfigurationStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidNamespaceFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidPolicyFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidReservedNodeStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidRestoreFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidRetentionPeriodFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidS3BucketNameFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidS3KeyPrefixFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidScheduledActionFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidScheduleFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidSnapshotCopyGrantStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidSubnet = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidSubscriptionStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidTableRestoreArgumentFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidTagFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidUsageLimitFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_InvalidVPCNetworkStateFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_IPRange = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CIDRIP] != null) {
        contents[_CIDRIP] = __expectString(output[_CIDRIP]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_IPRangeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IPRange(entry, context);
    });
};
const de_Ipv6CidrBlockNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_LakeFormationQuery = (output, context) => {
    const contents = {};
    if (output[_Au] != null) {
        contents[_Au] = __expectString(output[_Au]);
    }
    return contents;
};
const de_LakeFormationScopeUnion = (output, context) => {
    if (output[_LFQ] != null) {
        return {
            LakeFormationQuery: de_LakeFormationQuery(output[_LFQ], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_LakeFormationServiceIntegrations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LakeFormationScopeUnion(__expectUnion(entry), context);
    });
};
const de_LimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ListRecommendationsResult = (output, context) => {
    const contents = {};
    if (output.Recommendations === "") {
        contents[_Re] = [];
    }
    else if (output[_Re] != null && output[_Re][_Rec] != null) {
        contents[_Re] = de_RecommendationList(__getArrayIfSingleItem(output[_Re][_Rec]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_LoggingStatus = (output, context) => {
    const contents = {};
    if (output[_LEo] != null) {
        contents[_LEo] = __parseBoolean(output[_LEo]);
    }
    if (output[_BN] != null) {
        contents[_BN] = __expectString(output[_BN]);
    }
    if (output[_SKP] != null) {
        contents[_SKP] = __expectString(output[_SKP]);
    }
    if (output[_LSDT] != null) {
        contents[_LSDT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LSDT]));
    }
    if (output[_LFT] != null) {
        contents[_LFT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LFT]));
    }
    if (output[_LFM] != null) {
        contents[_LFM] = __expectString(output[_LFM]);
    }
    if (output[_LDT] != null) {
        contents[_LDT] = __expectString(output[_LDT]);
    }
    if (output.LogExports === "") {
        contents[_LE] = [];
    }
    else if (output[_LE] != null && output[_LE][_me] != null) {
        contents[_LE] = de_LogTypeList(__getArrayIfSingleItem(output[_LE][_me]), context);
    }
    return contents;
};
const de_LogTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MaintenanceTrack = (output, context) => {
    const contents = {};
    if (output[_MTN] != null) {
        contents[_MTN] = __expectString(output[_MTN]);
    }
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output.UpdateTargets === "") {
        contents[_UT] = [];
    }
    else if (output[_UT] != null && output[_UT][_UTp] != null) {
        contents[_UT] = de_EligibleTracksToUpdateList(__getArrayIfSingleItem(output[_UT][_UTp]), context);
    }
    return contents;
};
const de_ModifyAquaOutputMessage = (output, context) => {
    const contents = {};
    if (output[_ACq] != null) {
        contents[_ACq] = de_AquaConfiguration(output[_ACq], context);
    }
    return contents;
};
const de_ModifyAuthenticationProfileResult = (output, context) => {
    const contents = {};
    if (output[_APN] != null) {
        contents[_APN] = __expectString(output[_APN]);
    }
    if (output[_APC] != null) {
        contents[_APC] = __expectString(output[_APC]);
    }
    return contents;
};
const de_ModifyClusterDbRevisionResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_ModifyClusterIamRolesResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_ModifyClusterMaintenanceResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_ModifyClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_ModifyClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_ModifyClusterSubnetGroupResult = (output, context) => {
    const contents = {};
    if (output[_CSGlus] != null) {
        contents[_CSGlus] = de_ClusterSubnetGroup(output[_CSGlus], context);
    }
    return contents;
};
const de_ModifyCustomDomainAssociationResult = (output, context) => {
    const contents = {};
    if (output[_CDN] != null) {
        contents[_CDN] = __expectString(output[_CDN]);
    }
    if (output[_CDCA] != null) {
        contents[_CDCA] = __expectString(output[_CDCA]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_CDCET] != null) {
        contents[_CDCET] = __expectString(output[_CDCET]);
    }
    return contents;
};
const de_ModifyEventSubscriptionResult = (output, context) => {
    const contents = {};
    if (output[_ES] != null) {
        contents[_ES] = de_EventSubscription(output[_ES], context);
    }
    return contents;
};
const de_ModifyRedshiftIdcApplicationResult = (output, context) => {
    const contents = {};
    if (output[_RIA] != null) {
        contents[_RIA] = de_RedshiftIdcApplication(output[_RIA], context);
    }
    return contents;
};
const de_ModifySnapshotCopyRetentionPeriodResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_NetworkInterface = (output, context) => {
    const contents = {};
    if (output[_NII] != null) {
        contents[_NII] = __expectString(output[_NII]);
    }
    if (output[_SIub] != null) {
        contents[_SIub] = __expectString(output[_SIub]);
    }
    if (output[_PIA] != null) {
        contents[_PIA] = __expectString(output[_PIA]);
    }
    if (output[_AZ] != null) {
        contents[_AZ] = __expectString(output[_AZ]);
    }
    if (output[_IAp] != null) {
        contents[_IAp] = __expectString(output[_IAp]);
    }
    return contents;
};
const de_NetworkInterfaceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NetworkInterface(entry, context);
    });
};
const de_NodeConfigurationOption = (output, context) => {
    const contents = {};
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_NON] != null) {
        contents[_NON] = __strictParseInt32(output[_NON]);
    }
    if (output[_EDUP] != null) {
        contents[_EDUP] = __strictParseFloat(output[_EDUP]);
    }
    if (output[_Mo] != null) {
        contents[_Mo] = __expectString(output[_Mo]);
    }
    return contents;
};
const de_NodeConfigurationOptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NodeConfigurationOption(entry, context);
    });
};
const de_NodeConfigurationOptionsMessage = (output, context) => {
    const contents = {};
    if (output.NodeConfigurationOptionList === "") {
        contents[_NCOL] = [];
    }
    else if (output[_NCOL] != null && output[_NCOL][_NCO] != null) {
        contents[_NCOL] = de_NodeConfigurationOptionList(__getArrayIfSingleItem(output[_NCOL][_NCO]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_NumberOfNodesPerClusterLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_NumberOfNodesQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_OrderableClusterOption = (output, context) => {
    const contents = {};
    if (output[_CV] != null) {
        contents[_CV] = __expectString(output[_CV]);
    }
    if (output[_CTl] != null) {
        contents[_CTl] = __expectString(output[_CTl]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output.AvailabilityZones === "") {
        contents[_AZv] = [];
    }
    else if (output[_AZv] != null && output[_AZv][_AZ] != null) {
        contents[_AZv] = de_AvailabilityZoneList(__getArrayIfSingleItem(output[_AZv][_AZ]), context);
    }
    return contents;
};
const de_OrderableClusterOptionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OrderableClusterOption(entry, context);
    });
};
const de_OrderableClusterOptionsMessage = (output, context) => {
    const contents = {};
    if (output.OrderableClusterOptions === "") {
        contents[_OCO] = [];
    }
    else if (output[_OCO] != null && output[_OCO][_OCOr] != null) {
        contents[_OCO] = de_OrderableClusterOptionsList(__getArrayIfSingleItem(output[_OCO][_OCOr]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_Parameter = (output, context) => {
    const contents = {};
    if (output[_PNa] != null) {
        contents[_PNa] = __expectString(output[_PNa]);
    }
    if (output[_PV] != null) {
        contents[_PV] = __expectString(output[_PV]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_So] != null) {
        contents[_So] = __expectString(output[_So]);
    }
    if (output[_DTa] != null) {
        contents[_DTa] = __expectString(output[_DTa]);
    }
    if (output[_AV] != null) {
        contents[_AV] = __expectString(output[_AV]);
    }
    if (output[_ATp] != null) {
        contents[_ATp] = __expectString(output[_ATp]);
    }
    if (output[_IM] != null) {
        contents[_IM] = __parseBoolean(output[_IM]);
    }
    if (output[_MEV] != null) {
        contents[_MEV] = __expectString(output[_MEV]);
    }
    return contents;
};
const de_ParameterGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClusterParameterGroup(entry, context);
    });
};
const de_ParametersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Parameter(entry, context);
    });
};
const de_PartnerIntegrationInfo = (output, context) => {
    const contents = {};
    if (output[_DN] != null) {
        contents[_DN] = __expectString(output[_DN]);
    }
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_SM] != null) {
        contents[_SM] = __expectString(output[_SM]);
    }
    if (output[_CAr] != null) {
        contents[_CAr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CAr]));
    }
    if (output[_UA] != null) {
        contents[_UA] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UA]));
    }
    return contents;
};
const de_PartnerIntegrationInfoList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PartnerIntegrationInfo(entry, context);
    });
};
const de_PartnerIntegrationOutputMessage = (output, context) => {
    const contents = {};
    if (output[_DN] != null) {
        contents[_DN] = __expectString(output[_DN]);
    }
    if (output[_PN] != null) {
        contents[_PN] = __expectString(output[_PN]);
    }
    return contents;
};
const de_PartnerNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_PauseClusterMessage = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    return contents;
};
const de_PauseClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_PendingActionsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PendingModifiedValues = (output, context) => {
    const contents = {};
    if (output[_MUP] != null) {
        contents[_MUP] = __expectString(output[_MUP]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_NON] != null) {
        contents[_NON] = __strictParseInt32(output[_NON]);
    }
    if (output[_CTl] != null) {
        contents[_CTl] = __expectString(output[_CTl]);
    }
    if (output[_CV] != null) {
        contents[_CV] = __expectString(output[_CV]);
    }
    if (output[_ASRP] != null) {
        contents[_ASRP] = __strictParseInt32(output[_ASRP]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_PA] != null) {
        contents[_PA] = __parseBoolean(output[_PA]);
    }
    if (output[_EVR] != null) {
        contents[_EVR] = __parseBoolean(output[_EVR]);
    }
    if (output[_MTN] != null) {
        contents[_MTN] = __expectString(output[_MTN]);
    }
    if (output[_ETn] != null) {
        contents[_ETn] = __expectString(output[_ETn]);
    }
    return contents;
};
const de_PurchaseReservedNodeOfferingResult = (output, context) => {
    const contents = {};
    if (output[_RNe] != null) {
        contents[_RNe] = de_ReservedNode(output[_RNe], context);
    }
    return contents;
};
const de_PutResourcePolicyResult = (output, context) => {
    const contents = {};
    if (output[_RPe] != null) {
        contents[_RPe] = de_ResourcePolicy(output[_RPe], context);
    }
    return contents;
};
const de_RebootClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_Recommendation = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = __expectString(output[_Id]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_NA] != null) {
        contents[_NA] = __expectString(output[_NA]);
    }
    if (output[_CAr] != null) {
        contents[_CAr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CAr]));
    }
    if (output[_RTec] != null) {
        contents[_RTec] = __expectString(output[_RTec]);
    }
    if (output[_Ti] != null) {
        contents[_Ti] = __expectString(output[_Ti]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_Ob] != null) {
        contents[_Ob] = __expectString(output[_Ob]);
    }
    if (output[_IRm] != null) {
        contents[_IRm] = __expectString(output[_IRm]);
    }
    if (output[_RTeco] != null) {
        contents[_RTeco] = __expectString(output[_RTeco]);
    }
    if (output.RecommendedActions === "") {
        contents[_RAe] = [];
    }
    else if (output[_RAe] != null && output[_RAe][_RAec] != null) {
        contents[_RAe] = de_RecommendedActionList(__getArrayIfSingleItem(output[_RAe][_RAec]), context);
    }
    if (output.ReferenceLinks === "") {
        contents[_RL] = [];
    }
    else if (output[_RL] != null && output[_RL][_RLe] != null) {
        contents[_RL] = de_ReferenceLinkList(__getArrayIfSingleItem(output[_RL][_RLe]), context);
    }
    return contents;
};
const de_RecommendationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Recommendation(entry, context);
    });
};
const de_RecommendedAction = (output, context) => {
    const contents = {};
    if (output[_Te] != null) {
        contents[_Te] = __expectString(output[_Te]);
    }
    if (output[_Dat] != null) {
        contents[_Dat] = __expectString(output[_Dat]);
    }
    if (output[_Co] != null) {
        contents[_Co] = __expectString(output[_Co]);
    }
    if (output[_Ty] != null) {
        contents[_Ty] = __expectString(output[_Ty]);
    }
    return contents;
};
const de_RecommendedActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RecommendedAction(entry, context);
    });
};
const de_RecurringCharge = (output, context) => {
    const contents = {};
    if (output[_RCA] != null) {
        contents[_RCA] = __strictParseFloat(output[_RCA]);
    }
    if (output[_RCF] != null) {
        contents[_RCF] = __expectString(output[_RCF]);
    }
    return contents;
};
const de_RecurringChargeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RecurringCharge(entry, context);
    });
};
const de_RedshiftIdcApplication = (output, context) => {
    const contents = {};
    if (output[_IIA] != null) {
        contents[_IIA] = __expectString(output[_IIA]);
    }
    if (output[_RIAN] != null) {
        contents[_RIAN] = __expectString(output[_RIAN]);
    }
    if (output[_RIAA] != null) {
        contents[_RIAA] = __expectString(output[_RIAA]);
    }
    if (output[_IN] != null) {
        contents[_IN] = __expectString(output[_IN]);
    }
    if (output[_IDN] != null) {
        contents[_IDN] = __expectString(output[_IDN]);
    }
    if (output[_IRA] != null) {
        contents[_IRA] = __expectString(output[_IRA]);
    }
    if (output[_IMAA] != null) {
        contents[_IMAA] = __expectString(output[_IMAA]);
    }
    if (output[_IOS] != null) {
        contents[_IOS] = __expectString(output[_IOS]);
    }
    if (output.AuthorizedTokenIssuerList === "") {
        contents[_ATIL] = [];
    }
    else if (output[_ATIL] != null && output[_ATIL][_me] != null) {
        contents[_ATIL] = de_AuthorizedTokenIssuerList(__getArrayIfSingleItem(output[_ATIL][_me]), context);
    }
    if (output.ServiceIntegrations === "") {
        contents[_SIe] = [];
    }
    else if (output[_SIe] != null && output[_SIe][_me] != null) {
        contents[_SIe] = de_ServiceIntegrationList(__getArrayIfSingleItem(output[_SIe][_me]), context);
    }
    return contents;
};
const de_RedshiftIdcApplicationAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_RedshiftIdcApplicationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RedshiftIdcApplication(entry, context);
    });
};
const de_RedshiftIdcApplicationNotExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_RedshiftIdcApplicationQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReferenceLink = (output, context) => {
    const contents = {};
    if (output[_Te] != null) {
        contents[_Te] = __expectString(output[_Te]);
    }
    if (output[_L] != null) {
        contents[_L] = __expectString(output[_L]);
    }
    return contents;
};
const de_ReferenceLinkList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReferenceLink(entry, context);
    });
};
const de_ReservedNode = (output, context) => {
    const contents = {};
    if (output[_RNI] != null) {
        contents[_RNI] = __expectString(output[_RNI]);
    }
    if (output[_RNOI] != null) {
        contents[_RNOI] = __expectString(output[_RNOI]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_STt] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STt]));
    }
    if (output[_Du] != null) {
        contents[_Du] = __strictParseInt32(output[_Du]);
    }
    if (output[_FP] != null) {
        contents[_FP] = __strictParseFloat(output[_FP]);
    }
    if (output[_UP] != null) {
        contents[_UP] = __strictParseFloat(output[_UP]);
    }
    if (output[_CCu] != null) {
        contents[_CCu] = __expectString(output[_CCu]);
    }
    if (output[_NC] != null) {
        contents[_NC] = __strictParseInt32(output[_NC]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output[_OT] != null) {
        contents[_OT] = __expectString(output[_OT]);
    }
    if (output.RecurringCharges === "") {
        contents[_RCec] = [];
    }
    else if (output[_RCec] != null && output[_RCec][_RCecu] != null) {
        contents[_RCec] = de_RecurringChargeList(__getArrayIfSingleItem(output[_RCec][_RCecu]), context);
    }
    if (output[_RNOT] != null) {
        contents[_RNOT] = __expectString(output[_RNOT]);
    }
    return contents;
};
const de_ReservedNodeAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReservedNodeAlreadyMigratedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReservedNodeConfigurationOption = (output, context) => {
    const contents = {};
    if (output[_SRN] != null) {
        contents[_SRN] = de_ReservedNode(output[_SRN], context);
    }
    if (output[_TRNC] != null) {
        contents[_TRNC] = __strictParseInt32(output[_TRNC]);
    }
    if (output[_TRNO] != null) {
        contents[_TRNO] = de_ReservedNodeOffering(output[_TRNO], context);
    }
    return contents;
};
const de_ReservedNodeConfigurationOptionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedNodeConfigurationOption(entry, context);
    });
};
const de_ReservedNodeExchangeNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReservedNodeExchangeStatus = (output, context) => {
    const contents = {};
    if (output[_RNERI] != null) {
        contents[_RNERI] = __expectString(output[_RNERI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_RTeq] != null) {
        contents[_RTeq] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_RTeq]));
    }
    if (output[_SRNI] != null) {
        contents[_SRNI] = __expectString(output[_SRNI]);
    }
    if (output[_SRNT] != null) {
        contents[_SRNT] = __expectString(output[_SRNT]);
    }
    if (output[_SRNC] != null) {
        contents[_SRNC] = __strictParseInt32(output[_SRNC]);
    }
    if (output[_TRNOI] != null) {
        contents[_TRNOI] = __expectString(output[_TRNOI]);
    }
    if (output[_TRNT] != null) {
        contents[_TRNT] = __expectString(output[_TRNT]);
    }
    if (output[_TRNC] != null) {
        contents[_TRNC] = __strictParseInt32(output[_TRNC]);
    }
    return contents;
};
const de_ReservedNodeExchangeStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedNodeExchangeStatus(entry, context);
    });
};
const de_ReservedNodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedNode(entry, context);
    });
};
const de_ReservedNodeNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReservedNodeOffering = (output, context) => {
    const contents = {};
    if (output[_RNOI] != null) {
        contents[_RNOI] = __expectString(output[_RNOI]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_Du] != null) {
        contents[_Du] = __strictParseInt32(output[_Du]);
    }
    if (output[_FP] != null) {
        contents[_FP] = __strictParseFloat(output[_FP]);
    }
    if (output[_UP] != null) {
        contents[_UP] = __strictParseFloat(output[_UP]);
    }
    if (output[_CCu] != null) {
        contents[_CCu] = __expectString(output[_CCu]);
    }
    if (output[_OT] != null) {
        contents[_OT] = __expectString(output[_OT]);
    }
    if (output.RecurringCharges === "") {
        contents[_RCec] = [];
    }
    else if (output[_RCec] != null && output[_RCec][_RCecu] != null) {
        contents[_RCec] = de_RecurringChargeList(__getArrayIfSingleItem(output[_RCec][_RCecu]), context);
    }
    if (output[_RNOT] != null) {
        contents[_RNOT] = __expectString(output[_RNOT]);
    }
    return contents;
};
const de_ReservedNodeOfferingList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedNodeOffering(entry, context);
    });
};
const de_ReservedNodeOfferingNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReservedNodeOfferingsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ReservedNodeOfferings === "") {
        contents[_RNO] = [];
    }
    else if (output[_RNO] != null && output[_RNO][_RNOe] != null) {
        contents[_RNO] = de_ReservedNodeOfferingList(__getArrayIfSingleItem(output[_RNO][_RNOe]), context);
    }
    return contents;
};
const de_ReservedNodeQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ReservedNodesMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ReservedNodes === "") {
        contents[_RNes] = [];
    }
    else if (output[_RNes] != null && output[_RNes][_RNe] != null) {
        contents[_RNes] = de_ReservedNodeList(__getArrayIfSingleItem(output[_RNes][_RNe]), context);
    }
    return contents;
};
const de_ResizeClusterMessage = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_CTl] != null) {
        contents[_CTl] = __expectString(output[_CTl]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_NON] != null) {
        contents[_NON] = __strictParseInt32(output[_NON]);
    }
    if (output[_C] != null) {
        contents[_C] = __parseBoolean(output[_C]);
    }
    if (output[_RNI] != null) {
        contents[_RNI] = __expectString(output[_RNI]);
    }
    if (output[_TRNOI] != null) {
        contents[_TRNOI] = __expectString(output[_TRNOI]);
    }
    return contents;
};
const de_ResizeClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_ResizeInfo = (output, context) => {
    const contents = {};
    if (output[_RTes] != null) {
        contents[_RTes] = __expectString(output[_RTes]);
    }
    if (output[_ACR] != null) {
        contents[_ACR] = __parseBoolean(output[_ACR]);
    }
    return contents;
};
const de_ResizeNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ResizeProgressMessage = (output, context) => {
    const contents = {};
    if (output[_TNT] != null) {
        contents[_TNT] = __expectString(output[_TNT]);
    }
    if (output[_TNON] != null) {
        contents[_TNON] = __strictParseInt32(output[_TNON]);
    }
    if (output[_TCT] != null) {
        contents[_TCT] = __expectString(output[_TCT]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output.ImportTablesCompleted === "") {
        contents[_ITC] = [];
    }
    else if (output[_ITC] != null && output[_ITC][_me] != null) {
        contents[_ITC] = de_ImportTablesCompleted(__getArrayIfSingleItem(output[_ITC][_me]), context);
    }
    if (output.ImportTablesInProgress === "") {
        contents[_ITIP] = [];
    }
    else if (output[_ITIP] != null && output[_ITIP][_me] != null) {
        contents[_ITIP] = de_ImportTablesInProgress(__getArrayIfSingleItem(output[_ITIP][_me]), context);
    }
    if (output.ImportTablesNotStarted === "") {
        contents[_ITNS] = [];
    }
    else if (output[_ITNS] != null && output[_ITNS][_me] != null) {
        contents[_ITNS] = de_ImportTablesNotStarted(__getArrayIfSingleItem(output[_ITNS][_me]), context);
    }
    if (output[_ARRIMBPS] != null) {
        contents[_ARRIMBPS] = __strictParseFloat(output[_ARRIMBPS]);
    }
    if (output[_TRDIMB] != null) {
        contents[_TRDIMB] = __strictParseLong(output[_TRDIMB]);
    }
    if (output[_PIMB] != null) {
        contents[_PIMB] = __strictParseLong(output[_PIMB]);
    }
    if (output[_ETIS] != null) {
        contents[_ETIS] = __strictParseLong(output[_ETIS]);
    }
    if (output[_ETTCIS] != null) {
        contents[_ETTCIS] = __strictParseLong(output[_ETTCIS]);
    }
    if (output[_RTes] != null) {
        contents[_RTes] = __expectString(output[_RTes]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    if (output[_TET] != null) {
        contents[_TET] = __expectString(output[_TET]);
    }
    if (output[_DTPP] != null) {
        contents[_DTPP] = __strictParseFloat(output[_DTPP]);
    }
    return contents;
};
const de_ResourceNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ResourcePolicy = (output, context) => {
    const contents = {};
    if (output[_RA] != null) {
        contents[_RA] = __expectString(output[_RA]);
    }
    if (output[_Po] != null) {
        contents[_Po] = __expectString(output[_Po]);
    }
    return contents;
};
const de_RestorableNodeTypeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_RestoreFromClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_RestoreStatus = (output, context) => {
    const contents = {};
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_CRRIMBPS] != null) {
        contents[_CRRIMBPS] = __strictParseFloat(output[_CRRIMBPS]);
    }
    if (output[_SSIMB] != null) {
        contents[_SSIMB] = __strictParseLong(output[_SSIMB]);
    }
    if (output[_PIMB] != null) {
        contents[_PIMB] = __strictParseLong(output[_PIMB]);
    }
    if (output[_ETIS] != null) {
        contents[_ETIS] = __strictParseLong(output[_ETIS]);
    }
    if (output[_ETTCIS] != null) {
        contents[_ETTCIS] = __strictParseLong(output[_ETTCIS]);
    }
    return contents;
};
const de_RestoreTableFromClusterSnapshotResult = (output, context) => {
    const contents = {};
    if (output[_TRS] != null) {
        contents[_TRS] = de_TableRestoreStatus(output[_TRS], context);
    }
    return contents;
};
const de_ResumeClusterMessage = (output, context) => {
    const contents = {};
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    return contents;
};
const de_ResumeClusterResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_RevisionTarget = (output, context) => {
    const contents = {};
    if (output[_DRa] != null) {
        contents[_DRa] = __expectString(output[_DRa]);
    }
    if (output[_D] != null) {
        contents[_D] = __expectString(output[_D]);
    }
    if (output[_DRRD] != null) {
        contents[_DRRD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_DRRD]));
    }
    return contents;
};
const de_RevisionTargetsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RevisionTarget(entry, context);
    });
};
const de_RevokeClusterSecurityGroupIngressResult = (output, context) => {
    const contents = {};
    if (output[_CSGl] != null) {
        contents[_CSGl] = de_ClusterSecurityGroup(output[_CSGl], context);
    }
    return contents;
};
const de_RevokeSnapshotAccessResult = (output, context) => {
    const contents = {};
    if (output[_Sn] != null) {
        contents[_Sn] = de_Snapshot(output[_Sn], context);
    }
    return contents;
};
const de_RotateEncryptionKeyResult = (output, context) => {
    const contents = {};
    if (output[_Clu] != null) {
        contents[_Clu] = de_Cluster(output[_Clu], context);
    }
    return contents;
};
const de_ScheduledAction = (output, context) => {
    const contents = {};
    if (output[_SAN] != null) {
        contents[_SAN] = __expectString(output[_SAN]);
    }
    if (output[_TA] != null) {
        contents[_TA] = de_ScheduledActionType(output[_TA], context);
    }
    if (output[_Sc] != null) {
        contents[_Sc] = __expectString(output[_Sc]);
    }
    if (output[_IRa] != null) {
        contents[_IRa] = __expectString(output[_IRa]);
    }
    if (output[_SAD] != null) {
        contents[_SAD] = __expectString(output[_SAD]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = __expectString(output[_Sta]);
    }
    if (output.NextInvocations === "") {
        contents[_NI] = [];
    }
    else if (output[_NI] != null && output[_NI][_SAT] != null) {
        contents[_NI] = de_ScheduledActionTimeList(__getArrayIfSingleItem(output[_NI][_SAT]), context);
    }
    if (output[_STt] != null) {
        contents[_STt] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STt]));
    }
    if (output[_ET] != null) {
        contents[_ET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ET]));
    }
    return contents;
};
const de_ScheduledActionAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ScheduledActionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledAction(entry, context);
    });
};
const de_ScheduledActionNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ScheduledActionQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ScheduledActionsMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.ScheduledActions === "") {
        contents[_SAc] = [];
    }
    else if (output[_SAc] != null && output[_SAc][_SAch] != null) {
        contents[_SAc] = de_ScheduledActionList(__getArrayIfSingleItem(output[_SAc][_SAch]), context);
    }
    return contents;
};
const de_ScheduledActionTimeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));
    });
};
const de_ScheduledActionType = (output, context) => {
    const contents = {};
    if (output[_RCe] != null) {
        contents[_RCe] = de_ResizeClusterMessage(output[_RCe], context);
    }
    if (output[_PC] != null) {
        contents[_PC] = de_PauseClusterMessage(output[_PC], context);
    }
    if (output[_RCes] != null) {
        contents[_RCes] = de_ResumeClusterMessage(output[_RCes], context);
    }
    return contents;
};
const de_ScheduledActionTypeUnsupportedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ScheduleDefinitionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ScheduleDefinitionTypeUnsupportedFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_ScheduledSnapshotTimeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));
    });
};
const de_SecondaryClusterInfo = (output, context) => {
    const contents = {};
    if (output[_AZ] != null) {
        contents[_AZ] = __expectString(output[_AZ]);
    }
    if (output.ClusterNodes === "") {
        contents[_CN] = [];
    }
    else if (output[_CN] != null && output[_CN][_me] != null) {
        contents[_CN] = de_ClusterNodesList(__getArrayIfSingleItem(output[_CN][_me]), context);
    }
    return contents;
};
const de_ServiceIntegrationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceIntegrationsUnion(__expectUnion(entry), context);
    });
};
const de_ServiceIntegrationsUnion = (output, context) => {
    if (output.LakeFormation === "") {
        return {
            [_LF]: [],
        };
    }
    else if (output[_LF] != null && output[_LF][_me] != null) {
        return {
            LakeFormation: de_LakeFormationServiceIntegrations(__getArrayIfSingleItem(output[_LF][_me]), context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_Snapshot = (output, context) => {
    const contents = {};
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_SCTn] != null) {
        contents[_SCTn] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SCTn]));
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_AZ] != null) {
        contents[_AZ] = __expectString(output[_AZ]);
    }
    if (output[_CCT] != null) {
        contents[_CCT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CCT]));
    }
    if (output[_MU] != null) {
        contents[_MU] = __expectString(output[_MU]);
    }
    if (output[_CV] != null) {
        contents[_CV] = __expectString(output[_CV]);
    }
    if (output[_EFV] != null) {
        contents[_EFV] = __expectString(output[_EFV]);
    }
    if (output[_STn] != null) {
        contents[_STn] = __expectString(output[_STn]);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output[_NON] != null) {
        contents[_NON] = __strictParseInt32(output[_NON]);
    }
    if (output[_DBN] != null) {
        contents[_DBN] = __expectString(output[_DBN]);
    }
    if (output[_VIp] != null) {
        contents[_VIp] = __expectString(output[_VIp]);
    }
    if (output[_E] != null) {
        contents[_E] = __parseBoolean(output[_E]);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output[_EWHSM] != null) {
        contents[_EWHSM] = __parseBoolean(output[_EWHSM]);
    }
    if (output.AccountsWithRestoreAccess === "") {
        contents[_AWRAc] = [];
    }
    else if (output[_AWRAc] != null && output[_AWRAc][_AWRA] != null) {
        contents[_AWRAc] = de_AccountsWithRestoreAccessList(__getArrayIfSingleItem(output[_AWRAc][_AWRA]), context);
    }
    if (output[_OA] != null) {
        contents[_OA] = __expectString(output[_OA]);
    }
    if (output[_TBSIMB] != null) {
        contents[_TBSIMB] = __strictParseFloat(output[_TBSIMB]);
    }
    if (output[_AIBSIMB] != null) {
        contents[_AIBSIMB] = __strictParseFloat(output[_AIBSIMB]);
    }
    if (output[_BPIMB] != null) {
        contents[_BPIMB] = __strictParseFloat(output[_BPIMB]);
    }
    if (output[_CBRIMBPS] != null) {
        contents[_CBRIMBPS] = __strictParseFloat(output[_CBRIMBPS]);
    }
    if (output[_ESTC] != null) {
        contents[_ESTC] = __strictParseLong(output[_ESTC]);
    }
    if (output[_ETIS] != null) {
        contents[_ETIS] = __strictParseLong(output[_ETIS]);
    }
    if (output[_SR] != null) {
        contents[_SR] = __expectString(output[_SR]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    if (output.RestorableNodeTypes === "") {
        contents[_RNT] = [];
    }
    else if (output[_RNT] != null && output[_RNT][_NT] != null) {
        contents[_RNT] = de_RestorableNodeTypeList(__getArrayIfSingleItem(output[_RNT][_NT]), context);
    }
    if (output[_EVR] != null) {
        contents[_EVR] = __parseBoolean(output[_EVR]);
    }
    if (output[_MTN] != null) {
        contents[_MTN] = __expectString(output[_MTN]);
    }
    if (output[_MSRP] != null) {
        contents[_MSRP] = __strictParseInt32(output[_MSRP]);
    }
    if (output[_MSRD] != null) {
        contents[_MSRD] = __strictParseInt32(output[_MSRD]);
    }
    if (output[_SRST] != null) {
        contents[_SRST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SRST]));
    }
    if (output[_MPSA] != null) {
        contents[_MPSA] = __expectString(output[_MPSA]);
    }
    if (output[_MPSKKI] != null) {
        contents[_MPSKKI] = __expectString(output[_MPSKKI]);
    }
    if (output[_SA] != null) {
        contents[_SA] = __expectString(output[_SA]);
    }
    return contents;
};
const de_SnapshotCopyAlreadyDisabledFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotCopyAlreadyEnabledFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotCopyDisabledFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotCopyGrant = (output, context) => {
    const contents = {};
    if (output[_SCGN] != null) {
        contents[_SCGN] = __expectString(output[_SCGN]);
    }
    if (output[_KKI] != null) {
        contents[_KKI] = __expectString(output[_KKI]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_SnapshotCopyGrantAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotCopyGrantList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotCopyGrant(entry, context);
    });
};
const de_SnapshotCopyGrantMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.SnapshotCopyGrants === "") {
        contents[_SCGn] = [];
    }
    else if (output[_SCGn] != null && output[_SCGn][_SCG] != null) {
        contents[_SCGn] = de_SnapshotCopyGrantList(__getArrayIfSingleItem(output[_SCGn][_SCG]), context);
    }
    return contents;
};
const de_SnapshotCopyGrantNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotCopyGrantQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotErrorMessage = (output, context) => {
    const contents = {};
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    if (output[_SCI] != null) {
        contents[_SCI] = __expectString(output[_SCI]);
    }
    if (output[_FC] != null) {
        contents[_FC] = __expectString(output[_FC]);
    }
    if (output[_FR] != null) {
        contents[_FR] = __expectString(output[_FR]);
    }
    return contents;
};
const de_SnapshotIdentifierList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SnapshotList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Snapshot(entry, context);
    });
};
const de_SnapshotMessage = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    if (output.Snapshots === "") {
        contents[_Sna] = [];
    }
    else if (output[_Sna] != null && output[_Sna][_Sn] != null) {
        contents[_Sna] = de_SnapshotList(__getArrayIfSingleItem(output[_Sna][_Sn]), context);
    }
    return contents;
};
const de_SnapshotSchedule = (output, context) => {
    const contents = {};
    if (output.ScheduleDefinitions === "") {
        contents[_SD] = [];
    }
    else if (output[_SD] != null && output[_SD][_SDch] != null) {
        contents[_SD] = de_ScheduleDefinitionList(__getArrayIfSingleItem(output[_SD][_SDch]), context);
    }
    if (output[_SIc] != null) {
        contents[_SIc] = __expectString(output[_SIc]);
    }
    if (output[_SDc] != null) {
        contents[_SDc] = __expectString(output[_SDc]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    if (output.NextInvocations === "") {
        contents[_NI] = [];
    }
    else if (output[_NI] != null && output[_NI][_STna] != null) {
        contents[_NI] = de_ScheduledSnapshotTimeList(__getArrayIfSingleItem(output[_NI][_STna]), context);
    }
    if (output[_ACC] != null) {
        contents[_ACC] = __strictParseInt32(output[_ACC]);
    }
    if (output.AssociatedClusters === "") {
        contents[_ACs] = [];
    }
    else if (output[_ACs] != null && output[_ACs][_CATS] != null) {
        contents[_ACs] = de_AssociatedClusterList(__getArrayIfSingleItem(output[_ACs][_CATS]), context);
    }
    return contents;
};
const de_SnapshotScheduleAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotScheduleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SnapshotSchedule(entry, context);
    });
};
const de_SnapshotScheduleNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotScheduleQuotaExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SnapshotScheduleUpdateInProgressFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SNSInvalidTopicFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SNSNoAuthorizationFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SNSTopicArnNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SourceIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_SourceNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_Subnet = (output, context) => {
    const contents = {};
    if (output[_SIubn] != null) {
        contents[_SIubn] = __expectString(output[_SIubn]);
    }
    if (output[_SAZ] != null) {
        contents[_SAZ] = de_AvailabilityZone(output[_SAZ], context);
    }
    if (output[_SSu] != null) {
        contents[_SSu] = __expectString(output[_SSu]);
    }
    return contents;
};
const de_SubnetAlreadyInUse = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubnetList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Subnet(entry, context);
    });
};
const de_SubscriptionAlreadyExistFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubscriptionCategoryNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubscriptionEventIdNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubscriptionNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SubscriptionSeverityNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_SupportedOperation = (output, context) => {
    const contents = {};
    if (output[_ON] != null) {
        contents[_ON] = __expectString(output[_ON]);
    }
    return contents;
};
const de_SupportedOperationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SupportedOperation(entry, context);
    });
};
const de_SupportedPlatform = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    return contents;
};
const de_SupportedPlatformsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SupportedPlatform(entry, context);
    });
};
const de_TableLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_TableRestoreNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_TableRestoreStatus = (output, context) => {
    const contents = {};
    if (output[_TRRI] != null) {
        contents[_TRRI] = __expectString(output[_TRRI]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_Me] != null) {
        contents[_Me] = __expectString(output[_Me]);
    }
    if (output[_RTeq] != null) {
        contents[_RTeq] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_RTeq]));
    }
    if (output[_PIMB] != null) {
        contents[_PIMB] = __strictParseLong(output[_PIMB]);
    }
    if (output[_TDIMB] != null) {
        contents[_TDIMB] = __strictParseLong(output[_TDIMB]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_SI] != null) {
        contents[_SI] = __expectString(output[_SI]);
    }
    if (output[_SDN] != null) {
        contents[_SDN] = __expectString(output[_SDN]);
    }
    if (output[_SSN] != null) {
        contents[_SSN] = __expectString(output[_SSN]);
    }
    if (output[_STN] != null) {
        contents[_STN] = __expectString(output[_STN]);
    }
    if (output[_TDN] != null) {
        contents[_TDN] = __expectString(output[_TDN]);
    }
    if (output[_TSN] != null) {
        contents[_TSN] = __expectString(output[_TSN]);
    }
    if (output[_NTN] != null) {
        contents[_NTN] = __expectString(output[_NTN]);
    }
    return contents;
};
const de_TableRestoreStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TableRestoreStatus(entry, context);
    });
};
const de_TableRestoreStatusMessage = (output, context) => {
    const contents = {};
    if (output.TableRestoreStatusDetails === "") {
        contents[_TRSD] = [];
    }
    else if (output[_TRSD] != null && output[_TRSD][_TRS] != null) {
        contents[_TRSD] = de_TableRestoreStatusList(__getArrayIfSingleItem(output[_TRSD][_TRS]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Val] != null) {
        contents[_Val] = __expectString(output[_Val]);
    }
    return contents;
};
const de_TaggedResource = (output, context) => {
    const contents = {};
    if (output[_Ta] != null) {
        contents[_Ta] = de_Tag(output[_Ta], context);
    }
    if (output[_RN] != null) {
        contents[_RN] = __expectString(output[_RN]);
    }
    if (output[_RT] != null) {
        contents[_RT] = __expectString(output[_RT]);
    }
    return contents;
};
const de_TaggedResourceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TaggedResource(entry, context);
    });
};
const de_TaggedResourceListMessage = (output, context) => {
    const contents = {};
    if (output.TaggedResources === "") {
        contents[_TR] = [];
    }
    else if (output[_TR] != null && output[_TR][_TRa] != null) {
        contents[_TR] = de_TaggedResourceList(__getArrayIfSingleItem(output[_TR][_TRa]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_TagLimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TrackList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MaintenanceTrack(entry, context);
    });
};
const de_TrackListMessage = (output, context) => {
    const contents = {};
    if (output.MaintenanceTracks === "") {
        contents[_MT] = [];
    }
    else if (output[_MT] != null && output[_MT][_MTa] != null) {
        contents[_MT] = de_TrackList(__getArrayIfSingleItem(output[_MT][_MTa]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_UnauthorizedOperation = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UnauthorizedPartnerIntegrationFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UnknownSnapshotCopyRegionFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UnsupportedOperationFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UnsupportedOptionFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UpdateTarget = (output, context) => {
    const contents = {};
    if (output[_MTN] != null) {
        contents[_MTN] = __expectString(output[_MTN]);
    }
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output.SupportedOperations === "") {
        contents[_SOu] = [];
    }
    else if (output[_SOu] != null && output[_SOu][_SOup] != null) {
        contents[_SOu] = de_SupportedOperationList(__getArrayIfSingleItem(output[_SOu][_SOup]), context);
    }
    return contents;
};
const de_UsageLimit = (output, context) => {
    const contents = {};
    if (output[_ULI] != null) {
        contents[_ULI] = __expectString(output[_ULI]);
    }
    if (output[_CIl] != null) {
        contents[_CIl] = __expectString(output[_CIl]);
    }
    if (output[_FT] != null) {
        contents[_FT] = __expectString(output[_FT]);
    }
    if (output[_LT] != null) {
        contents[_LT] = __expectString(output[_LT]);
    }
    if (output[_Am] != null) {
        contents[_Am] = __strictParseLong(output[_Am]);
    }
    if (output[_Pe] != null) {
        contents[_Pe] = __expectString(output[_Pe]);
    }
    if (output[_BA] != null) {
        contents[_BA] = __expectString(output[_BA]);
    }
    if (output.Tags === "") {
        contents[_T] = [];
    }
    else if (output[_T] != null && output[_T][_Ta] != null) {
        contents[_T] = de_TagList(__getArrayIfSingleItem(output[_T][_Ta]), context);
    }
    return contents;
};
const de_UsageLimitAlreadyExistsFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UsageLimitList = (output, context) => {
    const contents = {};
    if (output.UsageLimits === "") {
        contents[_UL] = [];
    }
    else if (output[_UL] != null && output[_UL][_me] != null) {
        contents[_UL] = de_UsageLimits(__getArrayIfSingleItem(output[_UL][_me]), context);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_UsageLimitNotFoundFault = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = __expectString(output[_m]);
    }
    return contents;
};
const de_UsageLimits = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UsageLimit(entry, context);
    });
};
const de_ValueStringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_VpcEndpoint = (output, context) => {
    const contents = {};
    if (output[_VEI] != null) {
        contents[_VEI] = __expectString(output[_VEI]);
    }
    if (output[_VIp] != null) {
        contents[_VIp] = __expectString(output[_VIp]);
    }
    if (output.NetworkInterfaces === "") {
        contents[_NIe] = [];
    }
    else if (output[_NIe] != null && output[_NIe][_NIet] != null) {
        contents[_NIe] = de_NetworkInterfaceList(__getArrayIfSingleItem(output[_NIe][_NIet]), context);
    }
    return contents;
};
const de_VpcEndpointsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcEndpoint(entry, context);
    });
};
const de_VpcIdentifierList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_VpcSecurityGroupMembership = (output, context) => {
    const contents = {};
    if (output[_VSGIp] != null) {
        contents[_VSGIp] = __expectString(output[_VSGIp]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    return contents;
};
const de_VpcSecurityGroupMembershipList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcSecurityGroupMembership(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2012-12-01";
const _A = "Action";
const _AA = "AccountAttributes";
const _AAL = "AuthorizedAudiencesList";
const _AAVPC = "AllowedAllVPCs";
const _AAc = "AccountAttribute";
const _AAcc = "AccountAlias";
const _AC = "AutoCreate";
const _ACC = "AssociatedClusterCount";
const _ACR = "AllowCancelResize";
const _ACS = "AquaConfigurationStatus";
const _ACSGI = "AuthorizeClusterSecurityGroupIngress";
const _ACq = "AquaConfiguration";
const _ACs = "AssociatedClusters";
const _ADS = "AuthorizeDataShare";
const _ADSC = "AssociateDataShareConsumer";
const _AEA = "AuthorizeEndpointAccess";
const _AEAs = "AssociateEntireAccount";
const _AI = "AdditionalInfo";
const _AIBSIMB = "ActualIncrementalBackupSizeInMegaBytes";
const _AIR = "AddIamRoles";
const _AIc = "AccountId";
const _AN = "AttributeNames";
const _ANt = "AttributeName";
const _AP = "AddPartner";
const _APAC = "AllowPubliclyAccessibleConsumers";
const _APC = "AuthenticationProfileContent";
const _APN = "AuthenticationProfileName";
const _APu = "AuthenticationProfiles";
const _ARNE = "AcceptReservedNodeExchange";
const _ARRIMBPS = "AvgResizeRateInMegaBytesPerSecond";
const _AS = "AquaStatus";
const _ASA = "AuthorizeSnapshotAccess";
const _ASRP = "AutomatedSnapshotRetentionPeriod";
const _ASp = "ApplyStatus";
const _AT = "ActionType";
const _ATIL = "AuthorizedTokenIssuerList";
const _ATp = "ApplyType";
const _ATu = "AuthorizeTime";
const _AV = "AllowedValues";
const _AVPC = "AllowedVPCs";
const _AVT = "AttributeValueTarget";
const _AVU = "AllowVersionUpgrade";
const _AVt = "AttributeValues";
const _AVtt = "AttributeValue";
const _AW = "AllowWrites";
const _AWRA = "AccountWithRestoreAccess";
const _AWRAc = "AccountsWithRestoreAccess";
const _AZ = "AvailabilityZone";
const _AZR = "AvailabilityZoneRelocation";
const _AZRS = "AvailabilityZoneRelocationStatus";
const _AZv = "AvailabilityZones";
const _Ac = "Account";
const _Act = "Active";
const _Ad = "Address";
const _Am = "Amount";
const _As = "Associations";
const _Ass = "Association";
const _At = "Attribute";
const _Au = "Authorization";
const _BA = "BreachAction";
const _BDCS = "BatchDeleteClusterSnapshots";
const _BMCS = "BatchModifyClusterSnapshots";
const _BN = "BucketName";
const _BPIMB = "BackupProgressInMegaBytes";
const _C = "Classic";
const _CA = "ConsumerArn";
const _CAI = "CustomerAwsId";
const _CAP = "CreateAuthenticationProfile";
const _CAS = "ClusterAvailabilityStatus";
const _CATS = "ClusterAssociatedToSchedule";
const _CAW = "ConsumerAcceptedWrites";
const _CAe = "CertificateAssociations";
const _CAer = "CertificateAssociation";
const _CAr = "CreatedAt";
const _CBRIMBPS = "CurrentBackupRateInMegaBytesPerSecond";
const _CC = "CreateCluster";
const _CCDA = "CreateCustomDomainAssociation";
const _CCPG = "CreateClusterParameterGroup";
const _CCS = "CopyClusterSnapshot";
const _CCSG = "CreateClusterSecurityGroup";
const _CCSGr = "CreateClusterSubnetGroup";
const _CCSr = "CreateClusterSnapshot";
const _CCT = "ClusterCreateTime";
const _CCu = "CurrencyCode";
const _CD = "CreatedDate";
const _CDCA = "CustomDomainCertificateArn";
const _CDCED = "CustomDomainCertificateExpiryDate";
const _CDCET = "CustomDomainCertExpiryTime";
const _CDN = "CustomDomainName";
const _CDR = "CurrentDatabaseRevision";
const _CDRl = "ClusterDbRevisions";
const _CDRlu = "ClusterDbRevision";
const _CE = "ClusterExists";
const _CEA = "CreateEndpointAccess";
const _CES = "CreateEventSubscription";
const _CHC = "CreateHsmConfiguration";
const _CHCC = "CreateHsmClientCertificate";
const _CI = "ConsumerIdentifier";
const _CIDRIP = "CIDRIP";
const _CIR = "ClusterIamRole";
const _CIl = "ClusterIdentifier";
const _CN = "ClusterNodes";
const _CNA = "ClusterNamespaceArn";
const _CPG = "ClusterParameterGroups";
const _CPGF = "ClusterParameterGroupFamily";
const _CPGN = "ClusterParameterGroupName";
const _CPGl = "ClusterParameterGroup";
const _CPK = "ClusterPublicKey";
const _CPSL = "ClusterParameterStatusList";
const _CR = "CancelResize";
const _CRIA = "CreateRedshiftIdcApplication";
const _CRIMBPS = "CurrentRateInMegaBytesPerSecond";
const _CRN = "ClusterRevisionNumber";
const _CRRIMBPS = "CurrentRestoreRateInMegaBytesPerSecond";
const _CRo = "ConsumerRegion";
const _CS = "ClusterStatus";
const _CSA = "CreateScheduledAction";
const _CSCG = "CreateSnapshotCopyGrant";
const _CSCS = "ClusterSnapshotCopyStatus";
const _CSG = "ClusterSecurityGroups";
const _CSGN = "ClusterSecurityGroupName";
const _CSGNl = "ClusterSubnetGroupName";
const _CSGl = "ClusterSecurityGroup";
const _CSGlu = "ClusterSubnetGroups";
const _CSGlus = "ClusterSubnetGroup";
const _CSI = "CustSubscriptionId";
const _CSS = "CreateSnapshotSchedule";
const _CT = "CreateTags";
const _CTl = "ClusterType";
const _CTr = "CreateTime";
const _CUL = "CreateUsageLimit";
const _CV = "ClusterVersion";
const _CVl = "ClusterVersions";
const _Cl = "Clusters";
const _Clu = "Cluster";
const _Co = "Command";
const _D = "Description";
const _DAA = "DescribeAccountAttributes";
const _DAP = "DeleteAuthenticationProfile";
const _DAPe = "DescribeAuthenticationProfiles";
const _DBN = "DBName";
const _DC = "DeleteCluster";
const _DCDA = "DeleteCustomDomainAssociation";
const _DCDAe = "DescribeCustomDomainAssociations";
const _DCDR = "DescribeClusterDbRevisions";
const _DCP = "DescribeClusterParameters";
const _DCPG = "DeleteClusterParameterGroup";
const _DCPGe = "DescribeClusterParameterGroups";
const _DCPe = "DefaultClusterParameters";
const _DCS = "DeleteClusterSnapshot";
const _DCSG = "DeleteClusterSecurityGroup";
const _DCSGe = "DeleteClusterSubnetGroup";
const _DCSGes = "DescribeClusterSecurityGroups";
const _DCSGesc = "DescribeClusterSubnetGroups";
const _DCSe = "DescribeClusterSnapshots";
const _DCT = "DescribeClusterTracks";
const _DCV = "DescribeClusterVersions";
const _DCe = "DescribeClusters";
const _DDCP = "DescribeDefaultClusterParameters";
const _DDS = "DeauthorizeDataShare";
const _DDSC = "DisassociateDataShareConsumer";
const _DDSFC = "DescribeDataSharesForConsumer";
const _DDSFP = "DescribeDataSharesForProducer";
const _DDSe = "DescribeDataShares";
const _DE = "DescribeEvents";
const _DEA = "DeleteEndpointAccess";
const _DEAe = "DescribeEndpointAccess";
const _DEAes = "DescribeEndpointAuthorization";
const _DEAi = "DisassociateEntireAccount";
const _DEC = "DescribeEventCategories";
const _DES = "DeleteEventSubscription";
const _DESe = "DescribeEventSubscriptions";
const _DG = "DbGroups";
const _DHC = "DeleteHsmConfiguration";
const _DHCC = "DeleteHsmClientCertificate";
const _DHCCe = "DescribeHsmClientCertificates";
const _DHCe = "DescribeHsmConfigurations";
const _DII = "DescribeInboundIntegrations";
const _DIRA = "DefaultIamRoleArn";
const _DL = "DisableLogging";
const _DLS = "DescribeLoggingStatus";
const _DM = "DeferMaintenance";
const _DMD = "DeferMaintenanceDuration";
const _DMET = "DeferMaintenanceEndTime";
const _DMI = "DeferMaintenanceIdentifier";
const _DMST = "DeferMaintenanceStartTime";
const _DMW = "DeferredMaintenanceWindows";
const _DMWe = "DeferredMaintenanceWindow";
const _DN = "DatabaseName";
const _DNCO = "DescribeNodeConfigurationOptions";
const _DNb = "DbName";
const _DOCO = "DescribeOrderableClusterOptions";
const _DP = "DeletePartner";
const _DPb = "DbPassword";
const _DPe = "DescribePartners";
const _DR = "DescribeResize";
const _DRIA = "DeleteRedshiftIdcApplication";
const _DRIAe = "DescribeRedshiftIdcApplications";
const _DRN = "DescribeReservedNodes";
const _DRNES = "DescribeReservedNodeExchangeStatus";
const _DRNO = "DescribeReservedNodeOfferings";
const _DRP = "DeleteResourcePolicy";
const _DRRD = "DatabaseRevisionReleaseDate";
const _DRa = "DatabaseRevision";
const _DRe = "DestinationRegion";
const _DRr = "DryRun";
const _DS = "DescribeStorage";
const _DSA = "DeleteScheduledAction";
const _DSAa = "DataShareArn";
const _DSAat = "DataShareAssociations";
const _DSAe = "DescribeScheduledActions";
const _DSC = "DisableSnapshotCopy";
const _DSCG = "DeleteSnapshotCopyGrant";
const _DSCGe = "DescribeSnapshotCopyGrants";
const _DSS = "DeleteSnapshotSchedule";
const _DSSe = "DescribeSnapshotSchedules";
const _DSa = "DataShares";
const _DSi = "DisassociateSchedule";
const _DSu = "DurationSeconds";
const _DT = "DeleteTags";
const _DTIMB = "DataTransferredInMegaBytes";
const _DTP = "DataTransferProgress";
const _DTPP = "DataTransferProgressPercent";
const _DTRS = "DescribeTableRestoreStatus";
const _DTa = "DataType";
const _DTe = "DescribeTags";
const _DU = "DbUser";
const _DUL = "DeleteUsageLimit";
const _DULe = "DescribeUsageLimits";
const _DV = "DatabaseVersion";
const _Da = "Date";
const _Dat = "Database";
const _Du = "Duration";
const _E = "Encrypted";
const _EAL = "EndpointAccessList";
const _EALn = "EndpointAuthorizationList";
const _EC = "EventCategories";
const _ECL = "EventCategoriesList";
const _ECM = "EventCategoriesMap";
const _ECML = "EventCategoriesMapList";
const _ECSG = "EC2SecurityGroups";
const _ECSGN = "EC2SecurityGroupName";
const _ECSGOI = "EC2SecurityGroupOwnerId";
const _ECSGe = "EC2SecurityGroup";
const _ECSI = "EnableCaseSensitiveIdentifier";
const _ECT = "EndpointCreateTime";
const _ECn = "EndpointCount";
const _ECr = "ErrorCode";
const _ECv = "EventCategory";
const _ED = "EventDescription";
const _EDUP = "EstimatedDiskUtilizationPercent";
const _EFV = "EngineFullVersion";
const _EI = "ElasticIp";
const _EIM = "EventInfoMap";
const _EIS = "ElasticIpStatus";
const _EIv = "EventId";
const _EL = "EnableLogging";
const _EM = "ErrorMessage";
const _EN = "EndpointName";
const _ENSST = "ExpectedNextSnapshotScheduleTime";
const _ENSSTS = "ExpectedNextSnapshotScheduleTimeStatus";
const _ERN = "ExchangedReservedNode";
const _ERNONO = "ElasticResizeNumberOfNodeOptions";
const _ES = "EventSubscription";
const _ESC = "EnableSnapshotCopy";
const _ESL = "EventSubscriptionsList";
const _ESTC = "EstimatedSecondsToCompletion";
const _ESn = "EndpointStatus";
const _ET = "EndTime";
const _ETIS = "ElapsedTimeInSeconds";
const _ETTCIS = "EstimatedTimeToCompletionInSeconds";
const _ETn = "EncryptionType";
const _EVR = "EnhancedVpcRouting";
const _EWHSM = "EncryptedWithHSM";
const _En = "Enabled";
const _Ena = "Enable";
const _End = "Endpoint";
const _Er = "Errors";
const _Ev = "Events";
const _Eve = "Event";
const _Ex = "Expiration";
const _F = "Force";
const _FC = "FailureCode";
const _FCSI = "FinalClusterSnapshotIdentifier";
const _FCSRP = "FinalClusterSnapshotRetentionPeriod";
const _FP = "FixedPrice";
const _FPC = "FailoverPrimaryCompute";
const _FR = "FailureReason";
const _FT = "FeatureType";
const _Fi = "Filters";
const _G = "Grantee";
const _GCC = "GetClusterCredentials";
const _GCCWIAM = "GetClusterCredentialsWithIAM";
const _GRNECO = "GetReservedNodeExchangeConfigurationOptions";
const _GRNEO = "GetReservedNodeExchangeOfferings";
const _GRP = "GetResourcePolicy";
const _Gr = "Grantor";
const _HC = "HsmConfiguration";
const _HCC = "HsmClientCertificate";
const _HCCI = "HsmClientCertificateIdentifier";
const _HCCPK = "HsmClientCertificatePublicKey";
const _HCCs = "HsmClientCertificates";
const _HCI = "HsmConfigurationIdentifier";
const _HCs = "HsmConfigurations";
const _HIA = "HsmIpAddress";
const _HPN = "HsmPartitionName";
const _HPP = "HsmPartitionPassword";
const _HS = "HsmStatus";
const _HSPC = "HsmServerPublicCertificate";
const _I = "Identifiers";
const _IA = "IntegrationArn";
const _IAT = "IpAddressType";
const _IAp = "Ipv6Address";
const _IDN = "IdcDisplayName";
const _IE = "IntegrationError";
const _II = "InboundIntegrations";
const _IIA = "IdcInstanceArn";
const _IIn = "InboundIntegration";
const _IM = "IsModifiable";
const _IMAA = "IdcManagedApplicationArn";
const _IN = "IdentityNamespace";
const _IOS = "IdcOnboardStatus";
const _IPR = "IPRanges";
const _IPRa = "IPRange";
const _IR = "IamRoles";
const _IRA = "IamRoleArn";
const _IRa = "IamRole";
const _IRm = "ImpactRanking";
const _ITC = "ImportTablesCompleted";
const _ITIP = "ImportTablesInProgress";
const _ITNS = "ImportTablesNotStarted";
const _Id = "Id";
const _K = "Key";
const _KKI = "KmsKeyId";
const _L = "Link";
const _LDT = "LogDestinationType";
const _LE = "LogExports";
const _LEo = "LoggingEnabled";
const _LF = "LakeFormation";
const _LFM = "LastFailureMessage";
const _LFQ = "LakeFormationQuery";
const _LFT = "LastFailureTime";
const _LR = "ListRecommendations";
const _LSD = "LoadSampleData";
const _LSDT = "LastSuccessfulDeliveryTime";
const _LT = "LimitType";
const _M = "Marker";
const _MAC = "ModifyAquaConfiguration";
const _MAP = "ModifyAuthenticationProfile";
const _MAZ = "MultiAZ";
const _MAZS = "MultiAZSecondary";
const _MB = "ManagedBy";
const _MC = "ModifyCluster";
const _MCDA = "ModifyCustomDomainAssociation";
const _MCDR = "ModifyClusterDbRevision";
const _MCIR = "ModifyClusterIamRoles";
const _MCM = "ModifyClusterMaintenance";
const _MCPG = "ModifyClusterParameterGroup";
const _MCS = "ModifyClusterSnapshot";
const _MCSG = "ModifyClusterSubnetGroup";
const _MCSS = "ModifyClusterSnapshotSchedule";
const _MEA = "ModifyEndpointAccess";
const _MES = "ModifyEventSubscription";
const _MEV = "MinimumEngineVersion";
const _MMP = "ManageMasterPassword";
const _MPSA = "MasterPasswordSecretArn";
const _MPSKKI = "MasterPasswordSecretKmsKeyId";
const _MR = "MaxRecords";
const _MRIA = "ModifyRedshiftIdcApplication";
const _MS = "ModifyStatus";
const _MSA = "ModifyScheduledAction";
const _MSCRP = "ModifySnapshotCopyRetentionPeriod";
const _MSRD = "ManualSnapshotRemainingDays";
const _MSRP = "ManualSnapshotRetentionPeriod";
const _MSS = "ModifySnapshotSchedule";
const _MT = "MaintenanceTracks";
const _MTN = "MaintenanceTrackName";
const _MTa = "MaintenanceTrack";
const _MU = "MasterUsername";
const _MUL = "ModifyUsageLimit";
const _MUP = "MasterUserPassword";
const _Ma = "Manual";
const _Me = "Message";
const _Mo = "Mode";
const _N = "Name";
const _NA = "NamespaceArn";
const _NC = "NodeCount";
const _NCI = "NewClusterIdentifier";
const _NCO = "NodeConfigurationOption";
const _NCOL = "NodeConfigurationOptionList";
const _NI = "NextInvocations";
const _NII = "NetworkInterfaceId";
const _NIe = "NetworkInterfaces";
const _NIet = "NetworkInterface";
const _NMWST = "NextMaintenanceWindowStartTime";
const _NON = "NumberOfNodes";
const _NR = "NodeRole";
const _NRT = "NextRefreshTime";
const _NT = "NodeType";
const _NTN = "NewTableName";
const _O = "Operator";
const _OA = "OwnerAccount";
const _OCO = "OrderableClusterOptions";
const _OCOr = "OrderableClusterOption";
const _ON = "OperationName";
const _OT = "OfferingType";
const _Ob = "Observation";
const _P = "Port";
const _PA = "PubliclyAccessible";
const _PAED = "ParameterApplyErrorDescription";
const _PAS = "ParameterApplyStatus";
const _PAW = "ProducerAllowedWrites";
const _PAe = "PendingActions";
const _PAr = "ProducerArn";
const _PC = "PauseCluster";
const _PG = "ParameterGroups";
const _PGF = "ParameterGroupFamily";
const _PGN = "ParameterGroupName";
const _PGS = "ParameterGroupStatus";
const _PIA = "PrivateIpAddress";
const _PII = "PartnerIntegrationInfo";
const _PIIL = "PartnerIntegrationInfoList";
const _PIMB = "ProgressInMegaBytes";
const _PIPA = "PrivateIPAddress";
const _PIPAu = "PublicIPAddress";
const _PMV = "PendingModifiedValues";
const _PMW = "PreferredMaintenanceWindow";
const _PN = "PartnerName";
const _PNa = "ParameterName";
const _PRNO = "PurchaseReservedNodeOffering";
const _PRP = "PutResourcePolicy";
const _PV = "ParameterValue";
const _Pa = "Parameters";
const _Par = "Parameter";
const _Pe = "Period";
const _Po = "Policy";
const _R = "Resources";
const _RA = "ResourceArn";
const _RAP = "ResetAllParameters";
const _RAe = "RecommendedActions";
const _RAec = "RecommendedAction";
const _RC = "RebootCluster";
const _RCA = "RecurringChargeAmount";
const _RCF = "RecurringChargeFrequency";
const _RCPG = "ResetClusterParameterGroup";
const _RCSGI = "RevokeClusterSecurityGroupIngress";
const _RCe = "ResizeCluster";
const _RCec = "RecurringCharges";
const _RCecu = "RecurringCharge";
const _RCes = "ResumeCluster";
const _RDS = "RejectDataShare";
const _REA = "RevokeEndpointAccess";
const _REK = "RotateEncryptionKey";
const _RFCS = "RestoreFromClusterSnapshot";
const _RI = "ResizeInfo";
const _RIA = "RedshiftIdcApplication";
const _RIAA = "RedshiftIdcApplicationArn";
const _RIAN = "RedshiftIdcApplicationName";
const _RIAe = "RedshiftIdcApplications";
const _RIR = "RemoveIamRoles";
const _RL = "ReferenceLinks";
const _RLe = "ReferenceLink";
const _RN = "ResourceName";
const _RNCO = "ReservedNodeConfigurationOption";
const _RNCOL = "ReservedNodeConfigurationOptionList";
const _RNERI = "ReservedNodeExchangeRequestId";
const _RNES = "ReservedNodeExchangeStatus";
const _RNESD = "ReservedNodeExchangeStatusDetails";
const _RNI = "ReservedNodeId";
const _RNO = "ReservedNodeOfferings";
const _RNOI = "ReservedNodeOfferingId";
const _RNOT = "ReservedNodeOfferingType";
const _RNOe = "ReservedNodeOffering";
const _RNT = "RestorableNodeTypes";
const _RNe = "ReservedNode";
const _RNes = "ReservedNodes";
const _RO = "ResourceOwner";
const _RP = "RetentionPeriod";
const _RPe = "ResourcePolicy";
const _RS = "RestoreStatus";
const _RSA = "RevokeSnapshotAccess";
const _RT = "ResourceType";
const _RTFCS = "RestoreTableFromClusterSnapshot";
const _RTe = "RevisionTarget";
const _RTec = "RecommendationType";
const _RTeco = "RecommendationText";
const _RTeq = "RequestTime";
const _RTes = "ResizeType";
const _RTev = "RevisionTargets";
const _Re = "Recommendations";
const _Rec = "Recommendation";
const _S = "Severity";
const _SA = "SnapshotArn";
const _SAD = "ScheduledActionDescription";
const _SAN = "ScheduledActionName";
const _SAS = "ScheduleAssociationState";
const _SAT = "ScheduledActionTime";
const _SAZ = "SubnetAvailabilityZone";
const _SAc = "ScheduledActions";
const _SAch = "ScheduledAction";
const _SAo = "SourceArn";
const _SCD = "StatusChangeDate";
const _SCG = "SnapshotCopyGrant";
const _SCGN = "SnapshotCopyGrantName";
const _SCGn = "SnapshotCopyGrants";
const _SCI = "SnapshotClusterIdentifier";
const _SCIAT = "SupportedClusterIpAddressTypes";
const _SCT = "SubscriptionCreationTime";
const _SCTn = "SnapshotCreateTime";
const _SD = "ScheduleDefinitions";
const _SDN = "SourceDatabaseName";
const _SDc = "ScheduleDescription";
const _SDch = "ScheduleDefinition";
const _SE = "SortingEntities";
const _SEM = "SnapshotErrorMessage";
const _SFCS = "SkipFinalClusterSnapshot";
const _SGN = "SubnetGroupName";
const _SGS = "SubnetGroupStatus";
const _SI = "SnapshotIdentifier";
const _SIL = "SnapshotIdentifierList";
const _SILo = "SourceIdsList";
const _SIc = "ScheduleIdentifier";
const _SIe = "ServiceIntegrations";
const _SIo = "SourceIds";
const _SIou = "SourceIdentifier";
const _SIour = "SourceId";
const _SIu = "SubnetIds";
const _SIub = "SubnetId";
const _SIubn = "SubnetIdentifier";
const _SKP = "S3KeyPrefix";
const _SM = "StatusMessage";
const _SN = "SubscriptionName";
const _SO = "SortOrder";
const _SOu = "SupportedOperations";
const _SOup = "SupportedOperation";
const _SP = "SupportedPlatforms";
const _SPu = "SupportedPlatform";
const _SR = "SourceRegion";
const _SRN = "SourceReservedNode";
const _SRNC = "SourceReservedNodeCount";
const _SRNI = "SourceReservedNodeId";
const _SRNT = "SourceReservedNodeType";
const _SRST = "SnapshotRetentionStartTime";
const _SS = "SnapshotSchedules";
const _SSCI = "SourceSnapshotClusterIdentifier";
const _SSI = "SourceSnapshotIdentifier";
const _SSIMB = "SnapshotSizeInMegaBytes";
const _SSIn = "SnapshotScheduleIdentifier";
const _SSN = "SourceSchemaName";
const _SSS = "SnapshotScheduleState";
const _SSn = "SnapshotSchedule";
const _SSu = "SubnetStatus";
const _ST = "SourceType";
const _STA = "SnsTopicArn";
const _STN = "SourceTableName";
const _STn = "SnapshotType";
const _STna = "SnapshotTime";
const _STt = "StartTime";
const _Sc = "Schedule";
const _Sn = "Snapshot";
const _Sna = "Snapshots";
const _So = "Source";
const _St = "Status";
const _Sta = "State";
const _Str = "String";
const _Su = "Subnets";
const _Sub = "Subnet";
const _T = "Tags";
const _TA = "TargetAction";
const _TAT = "TargetActionType";
const _TAa = "TargetArn";
const _TBSIMB = "TotalBackupSizeInMegaBytes";
const _TCT = "TargetClusterType";
const _TDIMB = "TotalDataInMegaBytes";
const _TDN = "TargetDatabaseName";
const _TET = "TargetEncryptionType";
const _TK = "TagKeys";
const _TNON = "TargetNumberOfNodes";
const _TNT = "TargetNodeType";
const _TPSIMB = "TotalProvisionedStorageInMegaBytes";
const _TR = "TaggedResources";
const _TRDIMB = "TotalResizeDataInMegaBytes";
const _TRNC = "TargetReservedNodeCount";
const _TRNO = "TargetReservedNodeOffering";
const _TRNOI = "TargetReservedNodeOfferingId";
const _TRNT = "TargetReservedNodeType";
const _TRRI = "TableRestoreRequestId";
const _TRS = "TableRestoreStatus";
const _TRSD = "TableRestoreStatusDetails";
const _TRa = "TaggedResource";
const _TSCIMB = "TotalStorageCapacityInMegaBytes";
const _TSI = "TargetSnapshotIdentifier";
const _TSN = "TargetSchemaName";
const _TTIA = "TrustedTokenIssuerArn";
const _TV = "TagValues";
const _Ta = "Tag";
const _Te = "Text";
const _Ti = "Title";
const _Ty = "Type";
const _UA = "UpdatedAt";
const _UL = "UsageLimits";
const _ULI = "UsageLimitId";
const _UP = "UsagePrice";
const _UPS = "UpdatePartnerStatus";
const _UT = "UpdateTargets";
const _UTp = "UpdateTarget";
const _V = "Version";
const _VE = "VpcEndpoints";
const _VEI = "VpcEndpointId";
const _VEp = "VpcEndpoint";
const _VI = "VpcIds";
const _VIp = "VpcId";
const _VIpc = "VpcIdentifier";
const _VSG = "VpcSecurityGroups";
const _VSGI = "VpcSecurityGroupIds";
const _VSGIp = "VpcSecurityGroupId";
const _VSGp = "VpcSecurityGroup";
const _Va = "Values";
const _Val = "Value";
const _i = "item";
const _m = "message";
const _me = "member";
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

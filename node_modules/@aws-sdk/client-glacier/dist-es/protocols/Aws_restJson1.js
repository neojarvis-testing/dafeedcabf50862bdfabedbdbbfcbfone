import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectLong as __expectLong, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, map, take, withBaseException, } from "@smithy/smithy-client";
import { GlacierServiceException as __BaseException } from "../models/GlacierServiceException";
import { InsufficientCapacityException, InvalidParameterValueException, LimitExceededException, MissingParameterValueException, PolicyEnforcedException, RequestTimeoutException, ResourceNotFoundException, ServiceUnavailableException, } from "../models/models_0";
export const se_AbortMultipartUploadCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("uploadId", () => input.uploadId, "{uploadId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_AbortVaultLockCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/lock-policy");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_AddTagsToVaultCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/vaults/{vaultName}/tags");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    const query = map({
        [_o]: [, "add"],
    });
    let body;
    body = JSON.stringify(take(input, {
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CompleteMultipartUploadCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xaas]: input[_aS],
        [_xasth]: input[_c],
    });
    b.bp("/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("uploadId", () => input.uploadId, "{uploadId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CompleteVaultLockCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/lock-policy/{lockId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("lockId", () => input.lockId, "{lockId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateVaultCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteArchiveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/archives/{archiveId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("archiveId", () => input.archiveId, "{archiveId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteVaultCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteVaultAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/access-policy");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteVaultNotificationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/notification-configuration");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DescribeJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/jobs/{jobId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeVaultCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDataRetrievalPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/policies/data-retrieval");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetJobOutputCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_r]: input[_r],
    });
    b.bp("/{accountId}/vaults/{vaultName}/jobs/{jobId}/output");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetVaultAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/access-policy");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetVaultLockCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/lock-policy");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetVaultNotificationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/notification-configuration");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_InitiateJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/vaults/{vaultName}/jobs");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    if (input.jobParameters !== undefined) {
        body = _json(input.jobParameters);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_InitiateMultipartUploadCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xaad]: input[_aD],
        [_xaps]: input[_pS],
    });
    b.bp("/{accountId}/vaults/{vaultName}/multipart-uploads");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_InitiateVaultLockCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/vaults/{vaultName}/lock-policy");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    if (input.policy !== undefined) {
        body = _json(input.policy);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/jobs");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    const query = map({
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_m]: [, input[_m]],
        [_s]: [, input[_s]],
        [_co]: [, input[_co]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListMultipartUploadsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/multipart-uploads");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    const query = map({
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_m]: [, input[_m]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPartsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("uploadId", () => input.uploadId, "{uploadId}", false);
    const query = map({
        [_m]: [, input[_m]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProvisionedCapacityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/provisioned-capacity");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListTagsForVaultCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults/{vaultName}/tags");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListVaultsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/vaults");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    const query = map({
        [_m]: [, input[_m]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_PurchaseProvisionedCapacityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/{accountId}/provisioned-capacity");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RemoveTagsFromVaultCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/vaults/{vaultName}/tags");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    const query = map({
        [_o]: [, "remove"],
    });
    let body;
    body = JSON.stringify(take(input, {
        TagKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_SetDataRetrievalPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/policies/data-retrieval");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    let body;
    body = JSON.stringify(take(input, {
        Policy: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_SetVaultAccessPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/vaults/{vaultName}/access-policy");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    if (input.policy !== undefined) {
        body = _json(input.policy);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_SetVaultNotificationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/{accountId}/vaults/{vaultName}/notification-configuration");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    let body;
    if (input.vaultNotificationConfig !== undefined) {
        body = _json(input.vaultNotificationConfig);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UploadArchiveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/octet-stream",
        [_xaad]: input[_aD],
        [_xasth]: input[_c],
    });
    b.bp("/{accountId}/vaults/{vaultName}/archives");
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("accountId", () => input.accountId, "{accountId}", false);
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UploadMultipartPartCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/octet-stream",
        [_xasth]: input[_c],
        [_cr]: input[_r],
    });
    b.bp("/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}");
    b.p("accountId", () => input.accountId, "{accountId}", false);
    b.p("vaultName", () => input.vaultName, "{vaultName}", false);
    b.p("uploadId", () => input.uploadId, "{uploadId}", false);
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_AbortMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_AbortVaultLockCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_AddTagsToVaultCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CompleteMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_lo]: [, output.headers[_lo]],
        [_c]: [, output.headers[_xasth]],
        [_aI]: [, output.headers[_xaai]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CompleteVaultLockCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateVaultCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_lo]: [, output.headers[_lo]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteArchiveCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteVaultCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteVaultAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteVaultNotificationsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Action: __expectString,
        ArchiveId: __expectString,
        ArchiveSHA256TreeHash: __expectString,
        ArchiveSizeInBytes: __expectLong,
        Completed: __expectBoolean,
        CompletionDate: __expectString,
        CreationDate: __expectString,
        InventoryRetrievalParameters: _json,
        InventorySizeInBytes: __expectLong,
        JobDescription: __expectString,
        JobId: __expectString,
        JobOutputPath: __expectString,
        OutputLocation: _json,
        RetrievalByteRange: __expectString,
        SHA256TreeHash: __expectString,
        SNSTopic: __expectString,
        SelectParameters: _json,
        StatusCode: __expectString,
        StatusMessage: __expectString,
        Tier: __expectString,
        VaultARN: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeVaultCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreationDate: __expectString,
        LastInventoryDate: __expectString,
        NumberOfArchives: __expectLong,
        SizeInBytes: __expectLong,
        VaultARN: __expectString,
        VaultName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDataRetrievalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Policy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetJobOutputCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_c]: [, output.headers[_xasth]],
        [_cR]: [, output.headers[_cr]],
        [_aR]: [, output.headers[_ar]],
        [_cT]: [, output.headers[_ct]],
        [_aD]: [, output.headers[_xaad]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.body = data;
    map(contents, {
        status: [, output.statusCode],
    });
    return contents;
};
export const de_GetVaultAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectObject(await parseBody(output.body, context));
    contents.policy = _json(data);
    return contents;
};
export const de_GetVaultLockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreationDate: __expectString,
        ExpirationDate: __expectString,
        Policy: __expectString,
        State: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetVaultNotificationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectObject(await parseBody(output.body, context));
    contents.vaultNotificationConfig = _json(data);
    return contents;
};
export const de_InitiateJobCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_lo]: [, output.headers[_lo]],
        [_jI]: [, output.headers[_xaji]],
        [_jOP]: [, output.headers[_xajop]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_InitiateMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_lo]: [, output.headers[_lo]],
        [_uI]: [, output.headers[_xamui]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_InitiateVaultLockCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_lI]: [, output.headers[_xali]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ListJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        JobList: _json,
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListMultipartUploadsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Marker: __expectString,
        UploadsList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ArchiveDescription: __expectString,
        CreationDate: __expectString,
        Marker: __expectString,
        MultipartUploadId: __expectString,
        PartSizeInBytes: __expectLong,
        Parts: _json,
        VaultARN: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProvisionedCapacityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ProvisionedCapacityList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForVaultCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListVaultsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Marker: __expectString,
        VaultList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PurchaseProvisionedCapacityCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_cI]: [, output.headers[_xaci]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RemoveTagsFromVaultCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_SetDataRetrievalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_SetVaultAccessPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_SetVaultNotificationsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UploadArchiveCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_lo]: [, output.headers[_lo]],
        [_c]: [, output.headers[_xasth]],
        [_aI]: [, output.headers[_xaai]],
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UploadMultipartPartCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_c]: [, output.headers[_xasth]],
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValueException":
        case "com.amazonaws.glacier#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameterValueException":
        case "com.amazonaws.glacier#MissingParameterValueException":
            throw await de_MissingParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.glacier#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.glacier#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.glacier#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "InsufficientCapacityException":
        case "com.amazonaws.glacier#InsufficientCapacityException":
            throw await de_InsufficientCapacityExceptionRes(parsedOutput, context);
        case "PolicyEnforcedException":
        case "com.amazonaws.glacier#PolicyEnforcedException":
            throw await de_PolicyEnforcedExceptionRes(parsedOutput, context);
        case "RequestTimeoutException":
        case "com.amazonaws.glacier#RequestTimeoutException":
            throw await de_RequestTimeoutExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_InsufficientCapacityExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InsufficientCapacityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_MissingParameterValueExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new MissingParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_PolicyEnforcedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new PolicyEnforcedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_RequestTimeoutExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new RequestTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _aD = "archiveDescription";
const _aI = "archiveId";
const _aR = "acceptRanges";
const _aS = "archiveSize";
const _ar = "accept-ranges";
const _c = "checksum";
const _cI = "capacityId";
const _cR = "contentRange";
const _cT = "contentType";
const _co = "completed";
const _cr = "content-range";
const _ct = "content-type";
const _jI = "jobId";
const _jOP = "jobOutputPath";
const _l = "limit";
const _lI = "lockId";
const _lo = "location";
const _m = "marker";
const _o = "operation";
const _pS = "partSize";
const _r = "range";
const _s = "statuscode";
const _uI = "uploadId";
const _xaad = "x-amz-archive-description";
const _xaai = "x-amz-archive-id";
const _xaas = "x-amz-archive-size";
const _xaci = "x-amz-capacity-id";
const _xaji = "x-amz-job-id";
const _xajop = "x-amz-job-output-path";
const _xali = "x-amz-lock-id";
const _xamui = "x-amz-multipart-upload-id";
const _xaps = "x-amz-part-size";
const _xasth = "x-amz-sha256-tree-hash";

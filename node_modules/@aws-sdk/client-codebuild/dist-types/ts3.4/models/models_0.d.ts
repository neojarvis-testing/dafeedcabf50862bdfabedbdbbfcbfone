import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { CodeBuildServiceException as __BaseException } from "./CodeBuildServiceException";
export declare class AccountLimitExceededException extends __BaseException {
  readonly name: "AccountLimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccountLimitExceededException, __BaseException>
  );
}
export declare const ArtifactNamespace: {
  readonly BUILD_ID: "BUILD_ID";
  readonly NONE: "NONE";
};
export type ArtifactNamespace =
  (typeof ArtifactNamespace)[keyof typeof ArtifactNamespace];
export declare const ArtifactPackaging: {
  readonly NONE: "NONE";
  readonly ZIP: "ZIP";
};
export type ArtifactPackaging =
  (typeof ArtifactPackaging)[keyof typeof ArtifactPackaging];
export declare const ArtifactsType: {
  readonly CODEPIPELINE: "CODEPIPELINE";
  readonly NO_ARTIFACTS: "NO_ARTIFACTS";
  readonly S3: "S3";
};
export type ArtifactsType = (typeof ArtifactsType)[keyof typeof ArtifactsType];
export declare const AuthType: {
  readonly BASIC_AUTH: "BASIC_AUTH";
  readonly CODECONNECTIONS: "CODECONNECTIONS";
  readonly OAUTH: "OAUTH";
  readonly PERSONAL_ACCESS_TOKEN: "PERSONAL_ACCESS_TOKEN";
};
export type AuthType = (typeof AuthType)[keyof typeof AuthType];
export interface BatchDeleteBuildsInput {
  ids: string[] | undefined;
}
export interface BuildNotDeleted {
  id?: string;
  statusCode?: string;
}
export interface BatchDeleteBuildsOutput {
  buildsDeleted?: string[];
  buildsNotDeleted?: BuildNotDeleted[];
}
export declare class InvalidInputException extends __BaseException {
  readonly name: "InvalidInputException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidInputException, __BaseException>
  );
}
export interface BatchGetBuildBatchesInput {
  ids: string[] | undefined;
}
export declare const BucketOwnerAccess: {
  readonly FULL: "FULL";
  readonly NONE: "NONE";
  readonly READ_ONLY: "READ_ONLY";
};
export type BucketOwnerAccess =
  (typeof BucketOwnerAccess)[keyof typeof BucketOwnerAccess];
export interface BuildArtifacts {
  location?: string;
  sha256sum?: string;
  md5sum?: string;
  overrideArtifactName?: boolean;
  encryptionDisabled?: boolean;
  artifactIdentifier?: string;
  bucketOwnerAccess?: BucketOwnerAccess;
}
export declare const BatchReportModeType: {
  readonly REPORT_AGGREGATED_BATCH: "REPORT_AGGREGATED_BATCH";
  readonly REPORT_INDIVIDUAL_BUILDS: "REPORT_INDIVIDUAL_BUILDS";
};
export type BatchReportModeType =
  (typeof BatchReportModeType)[keyof typeof BatchReportModeType];
export interface BatchRestrictions {
  maximumBuildsAllowed?: number;
  computeTypesAllowed?: string[];
}
export interface ProjectBuildBatchConfig {
  serviceRole?: string;
  combineArtifacts?: boolean;
  restrictions?: BatchRestrictions;
  timeoutInMins?: number;
  batchReportMode?: BatchReportModeType;
}
export declare const StatusType: {
  readonly FAILED: "FAILED";
  readonly FAULT: "FAULT";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly STOPPED: "STOPPED";
  readonly SUCCEEDED: "SUCCEEDED";
  readonly TIMED_OUT: "TIMED_OUT";
};
export type StatusType = (typeof StatusType)[keyof typeof StatusType];
export interface ResolvedArtifact {
  type?: ArtifactsType;
  location?: string;
  identifier?: string;
}
export interface BuildSummary {
  arn?: string;
  requestedOn?: Date;
  buildStatus?: StatusType;
  primaryArtifact?: ResolvedArtifact;
  secondaryArtifacts?: ResolvedArtifact[];
}
export interface BuildGroup {
  identifier?: string;
  dependsOn?: string[];
  ignoreFailure?: boolean;
  currentBuildSummary?: BuildSummary;
  priorBuildSummaryList?: BuildSummary[];
}
export declare const CacheMode: {
  readonly LOCAL_CUSTOM_CACHE: "LOCAL_CUSTOM_CACHE";
  readonly LOCAL_DOCKER_LAYER_CACHE: "LOCAL_DOCKER_LAYER_CACHE";
  readonly LOCAL_SOURCE_CACHE: "LOCAL_SOURCE_CACHE";
};
export type CacheMode = (typeof CacheMode)[keyof typeof CacheMode];
export declare const CacheType: {
  readonly LOCAL: "LOCAL";
  readonly NO_CACHE: "NO_CACHE";
  readonly S3: "S3";
};
export type CacheType = (typeof CacheType)[keyof typeof CacheType];
export interface ProjectCache {
  type: CacheType | undefined;
  location?: string;
  modes?: CacheMode[];
}
export declare const ComputeType: {
  readonly BUILD_GENERAL1_2XLARGE: "BUILD_GENERAL1_2XLARGE";
  readonly BUILD_GENERAL1_LARGE: "BUILD_GENERAL1_LARGE";
  readonly BUILD_GENERAL1_MEDIUM: "BUILD_GENERAL1_MEDIUM";
  readonly BUILD_GENERAL1_SMALL: "BUILD_GENERAL1_SMALL";
  readonly BUILD_GENERAL1_XLARGE: "BUILD_GENERAL1_XLARGE";
  readonly BUILD_LAMBDA_10GB: "BUILD_LAMBDA_10GB";
  readonly BUILD_LAMBDA_1GB: "BUILD_LAMBDA_1GB";
  readonly BUILD_LAMBDA_2GB: "BUILD_LAMBDA_2GB";
  readonly BUILD_LAMBDA_4GB: "BUILD_LAMBDA_4GB";
  readonly BUILD_LAMBDA_8GB: "BUILD_LAMBDA_8GB";
};
export type ComputeType = (typeof ComputeType)[keyof typeof ComputeType];
export declare const EnvironmentVariableType: {
  readonly PARAMETER_STORE: "PARAMETER_STORE";
  readonly PLAINTEXT: "PLAINTEXT";
  readonly SECRETS_MANAGER: "SECRETS_MANAGER";
};
export type EnvironmentVariableType =
  (typeof EnvironmentVariableType)[keyof typeof EnvironmentVariableType];
export interface EnvironmentVariable {
  name: string | undefined;
  value: string | undefined;
  type?: EnvironmentVariableType;
}
export interface ProjectFleet {
  fleetArn?: string;
}
export declare const ImagePullCredentialsType: {
  readonly CODEBUILD: "CODEBUILD";
  readonly SERVICE_ROLE: "SERVICE_ROLE";
};
export type ImagePullCredentialsType =
  (typeof ImagePullCredentialsType)[keyof typeof ImagePullCredentialsType];
export declare const CredentialProviderType: {
  readonly SECRETS_MANAGER: "SECRETS_MANAGER";
};
export type CredentialProviderType =
  (typeof CredentialProviderType)[keyof typeof CredentialProviderType];
export interface RegistryCredential {
  credential: string | undefined;
  credentialProvider: CredentialProviderType | undefined;
}
export declare const EnvironmentType: {
  readonly ARM_CONTAINER: "ARM_CONTAINER";
  readonly ARM_LAMBDA_CONTAINER: "ARM_LAMBDA_CONTAINER";
  readonly LINUX_CONTAINER: "LINUX_CONTAINER";
  readonly LINUX_GPU_CONTAINER: "LINUX_GPU_CONTAINER";
  readonly LINUX_LAMBDA_CONTAINER: "LINUX_LAMBDA_CONTAINER";
  readonly WINDOWS_CONTAINER: "WINDOWS_CONTAINER";
  readonly WINDOWS_SERVER_2019_CONTAINER: "WINDOWS_SERVER_2019_CONTAINER";
};
export type EnvironmentType =
  (typeof EnvironmentType)[keyof typeof EnvironmentType];
export interface ProjectEnvironment {
  type: EnvironmentType | undefined;
  image: string | undefined;
  computeType: ComputeType | undefined;
  fleet?: ProjectFleet;
  environmentVariables?: EnvironmentVariable[];
  privilegedMode?: boolean;
  certificate?: string;
  registryCredential?: RegistryCredential;
  imagePullCredentialsType?: ImagePullCredentialsType;
}
export declare const FileSystemType: {
  readonly EFS: "EFS";
};
export type FileSystemType =
  (typeof FileSystemType)[keyof typeof FileSystemType];
export interface ProjectFileSystemLocation {
  type?: FileSystemType;
  location?: string;
  mountPoint?: string;
  identifier?: string;
  mountOptions?: string;
}
export declare const LogsConfigStatusType: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type LogsConfigStatusType =
  (typeof LogsConfigStatusType)[keyof typeof LogsConfigStatusType];
export interface CloudWatchLogsConfig {
  status: LogsConfigStatusType | undefined;
  groupName?: string;
  streamName?: string;
}
export interface S3LogsConfig {
  status: LogsConfigStatusType | undefined;
  location?: string;
  encryptionDisabled?: boolean;
  bucketOwnerAccess?: BucketOwnerAccess;
}
export interface LogsConfig {
  cloudWatchLogs?: CloudWatchLogsConfig;
  s3Logs?: S3LogsConfig;
}
export interface PhaseContext {
  statusCode?: string;
  message?: string;
}
export declare const BuildBatchPhaseType: {
  readonly COMBINE_ARTIFACTS: "COMBINE_ARTIFACTS";
  readonly DOWNLOAD_BATCHSPEC: "DOWNLOAD_BATCHSPEC";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly STOPPED: "STOPPED";
  readonly SUBMITTED: "SUBMITTED";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type BuildBatchPhaseType =
  (typeof BuildBatchPhaseType)[keyof typeof BuildBatchPhaseType];
export interface BuildBatchPhase {
  phaseType?: BuildBatchPhaseType;
  phaseStatus?: StatusType;
  startTime?: Date;
  endTime?: Date;
  durationInSeconds?: number;
  contexts?: PhaseContext[];
}
export declare const SourceAuthType: {
  readonly CODECONNECTIONS: "CODECONNECTIONS";
  readonly OAUTH: "OAUTH";
};
export type SourceAuthType =
  (typeof SourceAuthType)[keyof typeof SourceAuthType];
export interface SourceAuth {
  type: SourceAuthType | undefined;
  resource?: string;
}
export interface BuildStatusConfig {
  context?: string;
  targetUrl?: string;
}
export interface GitSubmodulesConfig {
  fetchSubmodules: boolean | undefined;
}
export declare const SourceType: {
  readonly BITBUCKET: "BITBUCKET";
  readonly CODECOMMIT: "CODECOMMIT";
  readonly CODEPIPELINE: "CODEPIPELINE";
  readonly GITHUB: "GITHUB";
  readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
  readonly GITLAB: "GITLAB";
  readonly GITLAB_SELF_MANAGED: "GITLAB_SELF_MANAGED";
  readonly NO_SOURCE: "NO_SOURCE";
  readonly S3: "S3";
};
export type SourceType = (typeof SourceType)[keyof typeof SourceType];
export interface ProjectSource {
  type: SourceType | undefined;
  location?: string;
  gitCloneDepth?: number;
  gitSubmodulesConfig?: GitSubmodulesConfig;
  buildspec?: string;
  auth?: SourceAuth;
  reportBuildStatus?: boolean;
  buildStatusConfig?: BuildStatusConfig;
  insecureSsl?: boolean;
  sourceIdentifier?: string;
}
export interface ProjectSourceVersion {
  sourceIdentifier: string | undefined;
  sourceVersion: string | undefined;
}
export interface VpcConfig {
  vpcId?: string;
  subnets?: string[];
  securityGroupIds?: string[];
}
export interface BuildBatch {
  id?: string;
  arn?: string;
  startTime?: Date;
  endTime?: Date;
  currentPhase?: string;
  buildBatchStatus?: StatusType;
  sourceVersion?: string;
  resolvedSourceVersion?: string;
  projectName?: string;
  phases?: BuildBatchPhase[];
  source?: ProjectSource;
  secondarySources?: ProjectSource[];
  secondarySourceVersions?: ProjectSourceVersion[];
  artifacts?: BuildArtifacts;
  secondaryArtifacts?: BuildArtifacts[];
  cache?: ProjectCache;
  environment?: ProjectEnvironment;
  serviceRole?: string;
  logConfig?: LogsConfig;
  buildTimeoutInMinutes?: number;
  queuedTimeoutInMinutes?: number;
  complete?: boolean;
  initiator?: string;
  vpcConfig?: VpcConfig;
  encryptionKey?: string;
  buildBatchNumber?: number;
  fileSystemLocations?: ProjectFileSystemLocation[];
  buildBatchConfig?: ProjectBuildBatchConfig;
  buildGroups?: BuildGroup[];
  debugSessionEnabled?: boolean;
}
export interface BatchGetBuildBatchesOutput {
  buildBatches?: BuildBatch[];
  buildBatchesNotFound?: string[];
}
export interface BatchGetBuildsInput {
  ids: string[] | undefined;
}
export interface DebugSession {
  sessionEnabled?: boolean;
  sessionTarget?: string;
}
export interface ExportedEnvironmentVariable {
  name?: string;
  value?: string;
}
export interface LogsLocation {
  groupName?: string;
  streamName?: string;
  deepLink?: string;
  s3DeepLink?: string;
  cloudWatchLogsArn?: string;
  s3LogsArn?: string;
  cloudWatchLogs?: CloudWatchLogsConfig;
  s3Logs?: S3LogsConfig;
}
export interface NetworkInterface {
  subnetId?: string;
  networkInterfaceId?: string;
}
export declare const BuildPhaseType: {
  readonly BUILD: "BUILD";
  readonly COMPLETED: "COMPLETED";
  readonly DOWNLOAD_SOURCE: "DOWNLOAD_SOURCE";
  readonly FINALIZING: "FINALIZING";
  readonly INSTALL: "INSTALL";
  readonly POST_BUILD: "POST_BUILD";
  readonly PRE_BUILD: "PRE_BUILD";
  readonly PROVISIONING: "PROVISIONING";
  readonly QUEUED: "QUEUED";
  readonly SUBMITTED: "SUBMITTED";
  readonly UPLOAD_ARTIFACTS: "UPLOAD_ARTIFACTS";
};
export type BuildPhaseType =
  (typeof BuildPhaseType)[keyof typeof BuildPhaseType];
export interface BuildPhase {
  phaseType?: BuildPhaseType;
  phaseStatus?: StatusType;
  startTime?: Date;
  endTime?: Date;
  durationInSeconds?: number;
  contexts?: PhaseContext[];
}
export interface Build {
  id?: string;
  arn?: string;
  buildNumber?: number;
  startTime?: Date;
  endTime?: Date;
  currentPhase?: string;
  buildStatus?: StatusType;
  sourceVersion?: string;
  resolvedSourceVersion?: string;
  projectName?: string;
  phases?: BuildPhase[];
  source?: ProjectSource;
  secondarySources?: ProjectSource[];
  secondarySourceVersions?: ProjectSourceVersion[];
  artifacts?: BuildArtifacts;
  secondaryArtifacts?: BuildArtifacts[];
  cache?: ProjectCache;
  environment?: ProjectEnvironment;
  serviceRole?: string;
  logs?: LogsLocation;
  timeoutInMinutes?: number;
  queuedTimeoutInMinutes?: number;
  buildComplete?: boolean;
  initiator?: string;
  vpcConfig?: VpcConfig;
  networkInterface?: NetworkInterface;
  encryptionKey?: string;
  exportedEnvironmentVariables?: ExportedEnvironmentVariable[];
  reportArns?: string[];
  fileSystemLocations?: ProjectFileSystemLocation[];
  debugSession?: DebugSession;
  buildBatchArn?: string;
}
export interface BatchGetBuildsOutput {
  builds?: Build[];
  buildsNotFound?: string[];
}
export interface BatchGetFleetsInput {
  names: string[] | undefined;
}
export declare const FleetOverflowBehavior: {
  readonly ON_DEMAND: "ON_DEMAND";
  readonly QUEUE: "QUEUE";
};
export type FleetOverflowBehavior =
  (typeof FleetOverflowBehavior)[keyof typeof FleetOverflowBehavior];
export declare const FleetScalingType: {
  readonly TARGET_TRACKING_SCALING: "TARGET_TRACKING_SCALING";
};
export type FleetScalingType =
  (typeof FleetScalingType)[keyof typeof FleetScalingType];
export declare const FleetScalingMetricType: {
  readonly FLEET_UTILIZATION_RATE: "FLEET_UTILIZATION_RATE";
};
export type FleetScalingMetricType =
  (typeof FleetScalingMetricType)[keyof typeof FleetScalingMetricType];
export interface TargetTrackingScalingConfiguration {
  metricType?: FleetScalingMetricType;
  targetValue?: number;
}
export interface ScalingConfigurationOutput {
  scalingType?: FleetScalingType;
  targetTrackingScalingConfigs?: TargetTrackingScalingConfiguration[];
  maxCapacity?: number;
  desiredCapacity?: number;
}
export declare const FleetContextCode: {
  readonly ACTION_REQUIRED: "ACTION_REQUIRED";
  readonly CREATE_FAILED: "CREATE_FAILED";
  readonly UPDATE_FAILED: "UPDATE_FAILED";
};
export type FleetContextCode =
  (typeof FleetContextCode)[keyof typeof FleetContextCode];
export declare const FleetStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATE_FAILED: "CREATE_FAILED";
  readonly CREATING: "CREATING";
  readonly DELETING: "DELETING";
  readonly PENDING_DELETION: "PENDING_DELETION";
  readonly ROTATING: "ROTATING";
  readonly UPDATE_ROLLBACK_FAILED: "UPDATE_ROLLBACK_FAILED";
  readonly UPDATING: "UPDATING";
};
export type FleetStatusCode =
  (typeof FleetStatusCode)[keyof typeof FleetStatusCode];
export interface FleetStatus {
  statusCode?: FleetStatusCode;
  context?: FleetContextCode;
  message?: string;
}
export interface Tag {
  key?: string;
  value?: string;
}
export interface Fleet {
  arn?: string;
  name?: string;
  id?: string;
  created?: Date;
  lastModified?: Date;
  status?: FleetStatus;
  baseCapacity?: number;
  environmentType?: EnvironmentType;
  computeType?: ComputeType;
  scalingConfiguration?: ScalingConfigurationOutput;
  overflowBehavior?: FleetOverflowBehavior;
  vpcConfig?: VpcConfig;
  fleetServiceRole?: string;
  tags?: Tag[];
}
export interface BatchGetFleetsOutput {
  fleets?: Fleet[];
  fleetsNotFound?: string[];
}
export interface BatchGetProjectsInput {
  names: string[] | undefined;
}
export interface ProjectArtifacts {
  type: ArtifactsType | undefined;
  location?: string;
  path?: string;
  namespaceType?: ArtifactNamespace;
  name?: string;
  packaging?: ArtifactPackaging;
  overrideArtifactName?: boolean;
  encryptionDisabled?: boolean;
  artifactIdentifier?: string;
  bucketOwnerAccess?: BucketOwnerAccess;
}
export interface ProjectBadge {
  badgeEnabled?: boolean;
  badgeRequestUrl?: string;
}
export declare const ProjectVisibilityType: {
  readonly PRIVATE: "PRIVATE";
  readonly PUBLIC_READ: "PUBLIC_READ";
};
export type ProjectVisibilityType =
  (typeof ProjectVisibilityType)[keyof typeof ProjectVisibilityType];
export declare const WebhookBuildType: {
  readonly BUILD: "BUILD";
  readonly BUILD_BATCH: "BUILD_BATCH";
};
export type WebhookBuildType =
  (typeof WebhookBuildType)[keyof typeof WebhookBuildType];
export declare const WebhookFilterType: {
  readonly ACTOR_ACCOUNT_ID: "ACTOR_ACCOUNT_ID";
  readonly BASE_REF: "BASE_REF";
  readonly COMMIT_MESSAGE: "COMMIT_MESSAGE";
  readonly EVENT: "EVENT";
  readonly FILE_PATH: "FILE_PATH";
  readonly HEAD_REF: "HEAD_REF";
  readonly RELEASE_NAME: "RELEASE_NAME";
  readonly TAG_NAME: "TAG_NAME";
  readonly WORKFLOW_NAME: "WORKFLOW_NAME";
};
export type WebhookFilterType =
  (typeof WebhookFilterType)[keyof typeof WebhookFilterType];
export interface WebhookFilter {
  type: WebhookFilterType | undefined;
  pattern: string | undefined;
  excludeMatchedPattern?: boolean;
}
export interface Webhook {
  url?: string;
  payloadUrl?: string;
  secret?: string;
  branchFilter?: string;
  filterGroups?: WebhookFilter[][];
  buildType?: WebhookBuildType;
  manualCreation?: boolean;
  lastModifiedSecret?: Date;
}
export interface Project {
  name?: string;
  arn?: string;
  description?: string;
  source?: ProjectSource;
  secondarySources?: ProjectSource[];
  sourceVersion?: string;
  secondarySourceVersions?: ProjectSourceVersion[];
  artifacts?: ProjectArtifacts;
  secondaryArtifacts?: ProjectArtifacts[];
  cache?: ProjectCache;
  environment?: ProjectEnvironment;
  serviceRole?: string;
  timeoutInMinutes?: number;
  queuedTimeoutInMinutes?: number;
  encryptionKey?: string;
  tags?: Tag[];
  created?: Date;
  lastModified?: Date;
  webhook?: Webhook;
  vpcConfig?: VpcConfig;
  badge?: ProjectBadge;
  logsConfig?: LogsConfig;
  fileSystemLocations?: ProjectFileSystemLocation[];
  buildBatchConfig?: ProjectBuildBatchConfig;
  concurrentBuildLimit?: number;
  projectVisibility?: ProjectVisibilityType;
  publicProjectAlias?: string;
  resourceAccessRole?: string;
}
export interface BatchGetProjectsOutput {
  projects?: Project[];
  projectsNotFound?: string[];
}
export interface BatchGetReportGroupsInput {
  reportGroupArns: string[] | undefined;
}
export declare const ReportExportConfigType: {
  readonly NO_EXPORT: "NO_EXPORT";
  readonly S3: "S3";
};
export type ReportExportConfigType =
  (typeof ReportExportConfigType)[keyof typeof ReportExportConfigType];
export declare const ReportPackagingType: {
  readonly NONE: "NONE";
  readonly ZIP: "ZIP";
};
export type ReportPackagingType =
  (typeof ReportPackagingType)[keyof typeof ReportPackagingType];
export interface S3ReportExportConfig {
  bucket?: string;
  bucketOwner?: string;
  path?: string;
  packaging?: ReportPackagingType;
  encryptionKey?: string;
  encryptionDisabled?: boolean;
}
export interface ReportExportConfig {
  exportConfigType?: ReportExportConfigType;
  s3Destination?: S3ReportExportConfig;
}
export declare const ReportGroupStatusType: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETING: "DELETING";
};
export type ReportGroupStatusType =
  (typeof ReportGroupStatusType)[keyof typeof ReportGroupStatusType];
export declare const ReportType: {
  readonly CODE_COVERAGE: "CODE_COVERAGE";
  readonly TEST: "TEST";
};
export type ReportType = (typeof ReportType)[keyof typeof ReportType];
export interface ReportGroup {
  arn?: string;
  name?: string;
  type?: ReportType;
  exportConfig?: ReportExportConfig;
  created?: Date;
  lastModified?: Date;
  tags?: Tag[];
  status?: ReportGroupStatusType;
}
export interface BatchGetReportGroupsOutput {
  reportGroups?: ReportGroup[];
  reportGroupsNotFound?: string[];
}
export interface BatchGetReportsInput {
  reportArns: string[] | undefined;
}
export interface CodeCoverageReportSummary {
  lineCoveragePercentage?: number;
  linesCovered?: number;
  linesMissed?: number;
  branchCoveragePercentage?: number;
  branchesCovered?: number;
  branchesMissed?: number;
}
export declare const ReportStatusType: {
  readonly DELETING: "DELETING";
  readonly FAILED: "FAILED";
  readonly GENERATING: "GENERATING";
  readonly INCOMPLETE: "INCOMPLETE";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type ReportStatusType =
  (typeof ReportStatusType)[keyof typeof ReportStatusType];
export interface TestReportSummary {
  total: number | undefined;
  statusCounts: Record<string, number> | undefined;
  durationInNanoSeconds: number | undefined;
}
export interface Report {
  arn?: string;
  type?: ReportType;
  name?: string;
  reportGroupArn?: string;
  executionId?: string;
  status?: ReportStatusType;
  created?: Date;
  expired?: Date;
  exportConfig?: ReportExportConfig;
  truncated?: boolean;
  testSummary?: TestReportSummary;
  codeCoverageSummary?: CodeCoverageReportSummary;
}
export interface BatchGetReportsOutput {
  reports?: Report[];
  reportsNotFound?: string[];
}
export interface BuildBatchFilter {
  status?: StatusType;
}
export interface ScalingConfigurationInput {
  scalingType?: FleetScalingType;
  targetTrackingScalingConfigs?: TargetTrackingScalingConfiguration[];
  maxCapacity?: number;
}
export interface CreateFleetInput {
  name: string | undefined;
  baseCapacity: number | undefined;
  environmentType: EnvironmentType | undefined;
  computeType: ComputeType | undefined;
  scalingConfiguration?: ScalingConfigurationInput;
  overflowBehavior?: FleetOverflowBehavior;
  vpcConfig?: VpcConfig;
  fleetServiceRole?: string;
  tags?: Tag[];
}
export interface CreateFleetOutput {
  fleet?: Fleet;
}
export declare class ResourceAlreadyExistsException extends __BaseException {
  readonly name: "ResourceAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceAlreadyExistsException, __BaseException>
  );
}
export interface CreateProjectInput {
  name: string | undefined;
  description?: string;
  source: ProjectSource | undefined;
  secondarySources?: ProjectSource[];
  sourceVersion?: string;
  secondarySourceVersions?: ProjectSourceVersion[];
  artifacts: ProjectArtifacts | undefined;
  secondaryArtifacts?: ProjectArtifacts[];
  cache?: ProjectCache;
  environment: ProjectEnvironment | undefined;
  serviceRole: string | undefined;
  timeoutInMinutes?: number;
  queuedTimeoutInMinutes?: number;
  encryptionKey?: string;
  tags?: Tag[];
  vpcConfig?: VpcConfig;
  badgeEnabled?: boolean;
  logsConfig?: LogsConfig;
  fileSystemLocations?: ProjectFileSystemLocation[];
  buildBatchConfig?: ProjectBuildBatchConfig;
  concurrentBuildLimit?: number;
}
export interface CreateProjectOutput {
  project?: Project;
}
export interface CreateReportGroupInput {
  name: string | undefined;
  type: ReportType | undefined;
  exportConfig: ReportExportConfig | undefined;
  tags?: Tag[];
}
export interface CreateReportGroupOutput {
  reportGroup?: ReportGroup;
}
export interface CreateWebhookInput {
  projectName: string | undefined;
  branchFilter?: string;
  filterGroups?: WebhookFilter[][];
  buildType?: WebhookBuildType;
  manualCreation?: boolean;
}
export interface CreateWebhookOutput {
  webhook?: Webhook;
}
export declare class OAuthProviderException extends __BaseException {
  readonly name: "OAuthProviderException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<OAuthProviderException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export interface DeleteBuildBatchInput {
  id: string | undefined;
}
export interface DeleteBuildBatchOutput {
  statusCode?: string;
  buildsDeleted?: string[];
  buildsNotDeleted?: BuildNotDeleted[];
}
export interface DeleteFleetInput {
  arn: string | undefined;
}
export interface DeleteFleetOutput {}
export interface DeleteProjectInput {
  name: string | undefined;
}
export interface DeleteProjectOutput {}
export interface DeleteReportInput {
  arn: string | undefined;
}
export interface DeleteReportOutput {}
export interface DeleteReportGroupInput {
  arn: string | undefined;
  deleteReports?: boolean;
}
export interface DeleteReportGroupOutput {}
export interface DeleteResourcePolicyInput {
  resourceArn: string | undefined;
}
export interface DeleteResourcePolicyOutput {}
export interface DeleteSourceCredentialsInput {
  arn: string | undefined;
}
export interface DeleteSourceCredentialsOutput {
  arn?: string;
}
export interface DeleteWebhookInput {
  projectName: string | undefined;
}
export interface DeleteWebhookOutput {}
export declare const ReportCodeCoverageSortByType: {
  readonly FILE_PATH: "FILE_PATH";
  readonly LINE_COVERAGE_PERCENTAGE: "LINE_COVERAGE_PERCENTAGE";
};
export type ReportCodeCoverageSortByType =
  (typeof ReportCodeCoverageSortByType)[keyof typeof ReportCodeCoverageSortByType];
export declare const SortOrderType: {
  readonly ASCENDING: "ASCENDING";
  readonly DESCENDING: "DESCENDING";
};
export type SortOrderType = (typeof SortOrderType)[keyof typeof SortOrderType];
export interface DescribeCodeCoveragesInput {
  reportArn: string | undefined;
  nextToken?: string;
  maxResults?: number;
  sortOrder?: SortOrderType;
  sortBy?: ReportCodeCoverageSortByType;
  minLineCoveragePercentage?: number;
  maxLineCoveragePercentage?: number;
}
export interface CodeCoverage {
  id?: string;
  reportARN?: string;
  filePath?: string;
  lineCoveragePercentage?: number;
  linesCovered?: number;
  linesMissed?: number;
  branchCoveragePercentage?: number;
  branchesCovered?: number;
  branchesMissed?: number;
  expired?: Date;
}
export interface DescribeCodeCoveragesOutput {
  nextToken?: string;
  codeCoverages?: CodeCoverage[];
}
export interface TestCaseFilter {
  status?: string;
  keyword?: string;
}
export interface DescribeTestCasesInput {
  reportArn: string | undefined;
  nextToken?: string;
  maxResults?: number;
  filter?: TestCaseFilter;
}
export interface TestCase {
  reportArn?: string;
  testRawDataPath?: string;
  prefix?: string;
  name?: string;
  status?: string;
  durationInNanoSeconds?: number;
  message?: string;
  expired?: Date;
}
export interface DescribeTestCasesOutput {
  nextToken?: string;
  testCases?: TestCase[];
}
export declare const ReportGroupTrendFieldType: {
  readonly BRANCHES_COVERED: "BRANCHES_COVERED";
  readonly BRANCHES_MISSED: "BRANCHES_MISSED";
  readonly BRANCH_COVERAGE: "BRANCH_COVERAGE";
  readonly DURATION: "DURATION";
  readonly LINES_COVERED: "LINES_COVERED";
  readonly LINES_MISSED: "LINES_MISSED";
  readonly LINE_COVERAGE: "LINE_COVERAGE";
  readonly PASS_RATE: "PASS_RATE";
  readonly TOTAL: "TOTAL";
};
export type ReportGroupTrendFieldType =
  (typeof ReportGroupTrendFieldType)[keyof typeof ReportGroupTrendFieldType];
export interface GetReportGroupTrendInput {
  reportGroupArn: string | undefined;
  numOfReports?: number;
  trendField: ReportGroupTrendFieldType | undefined;
}
export interface ReportWithRawData {
  reportArn?: string;
  data?: string;
}
export interface ReportGroupTrendStats {
  average?: string;
  max?: string;
  min?: string;
}
export interface GetReportGroupTrendOutput {
  stats?: ReportGroupTrendStats;
  rawData?: ReportWithRawData[];
}
export interface GetResourcePolicyInput {
  resourceArn: string | undefined;
}
export interface GetResourcePolicyOutput {
  policy?: string;
}
export declare const ServerType: {
  readonly BITBUCKET: "BITBUCKET";
  readonly GITHUB: "GITHUB";
  readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
  readonly GITLAB: "GITLAB";
  readonly GITLAB_SELF_MANAGED: "GITLAB_SELF_MANAGED";
};
export type ServerType = (typeof ServerType)[keyof typeof ServerType];
export interface ImportSourceCredentialsInput {
  username?: string;
  token: string | undefined;
  serverType: ServerType | undefined;
  authType: AuthType | undefined;
  shouldOverwrite?: boolean;
}
export interface ImportSourceCredentialsOutput {
  arn?: string;
}
export interface InvalidateProjectCacheInput {
  projectName: string | undefined;
}
export interface InvalidateProjectCacheOutput {}
export interface ListBuildBatchesInput {
  filter?: BuildBatchFilter;
  maxResults?: number;
  sortOrder?: SortOrderType;
  nextToken?: string;
}
export interface ListBuildBatchesOutput {
  ids?: string[];
  nextToken?: string;
}
export interface ListBuildBatchesForProjectInput {
  projectName?: string;
  filter?: BuildBatchFilter;
  maxResults?: number;
  sortOrder?: SortOrderType;
  nextToken?: string;
}
export interface ListBuildBatchesForProjectOutput {
  ids?: string[];
  nextToken?: string;
}
export interface ListBuildsInput {
  sortOrder?: SortOrderType;
  nextToken?: string;
}
export interface ListBuildsOutput {
  ids?: string[];
  nextToken?: string;
}
export interface ListBuildsForProjectInput {
  projectName: string | undefined;
  sortOrder?: SortOrderType;
  nextToken?: string;
}
export interface ListBuildsForProjectOutput {
  ids?: string[];
  nextToken?: string;
}
export interface ListCuratedEnvironmentImagesInput {}
export interface EnvironmentImage {
  name?: string;
  description?: string;
  versions?: string[];
}
export declare const LanguageType: {
  readonly ANDROID: "ANDROID";
  readonly BASE: "BASE";
  readonly DOCKER: "DOCKER";
  readonly DOTNET: "DOTNET";
  readonly GOLANG: "GOLANG";
  readonly JAVA: "JAVA";
  readonly NODE_JS: "NODE_JS";
  readonly PHP: "PHP";
  readonly PYTHON: "PYTHON";
  readonly RUBY: "RUBY";
};
export type LanguageType = (typeof LanguageType)[keyof typeof LanguageType];
export interface EnvironmentLanguage {
  language?: LanguageType;
  images?: EnvironmentImage[];
}
export declare const PlatformType: {
  readonly AMAZON_LINUX: "AMAZON_LINUX";
  readonly DEBIAN: "DEBIAN";
  readonly UBUNTU: "UBUNTU";
  readonly WINDOWS_SERVER: "WINDOWS_SERVER";
};
export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType];
export interface EnvironmentPlatform {
  platform?: PlatformType;
  languages?: EnvironmentLanguage[];
}
export interface ListCuratedEnvironmentImagesOutput {
  platforms?: EnvironmentPlatform[];
}
export declare const FleetSortByType: {
  readonly CREATED_TIME: "CREATED_TIME";
  readonly LAST_MODIFIED_TIME: "LAST_MODIFIED_TIME";
  readonly NAME: "NAME";
};
export type FleetSortByType =
  (typeof FleetSortByType)[keyof typeof FleetSortByType];
export interface ListFleetsInput {
  nextToken?: string;
  maxResults?: number;
  sortOrder?: SortOrderType;
  sortBy?: FleetSortByType;
}
export interface ListFleetsOutput {
  nextToken?: string;
  fleets?: string[];
}
export declare const ProjectSortByType: {
  readonly CREATED_TIME: "CREATED_TIME";
  readonly LAST_MODIFIED_TIME: "LAST_MODIFIED_TIME";
  readonly NAME: "NAME";
};
export type ProjectSortByType =
  (typeof ProjectSortByType)[keyof typeof ProjectSortByType];
export interface ListProjectsInput {
  sortBy?: ProjectSortByType;
  sortOrder?: SortOrderType;
  nextToken?: string;
}
export interface ListProjectsOutput {
  nextToken?: string;
  projects?: string[];
}
export declare const ReportGroupSortByType: {
  readonly CREATED_TIME: "CREATED_TIME";
  readonly LAST_MODIFIED_TIME: "LAST_MODIFIED_TIME";
  readonly NAME: "NAME";
};
export type ReportGroupSortByType =
  (typeof ReportGroupSortByType)[keyof typeof ReportGroupSortByType];
export interface ListReportGroupsInput {
  sortOrder?: SortOrderType;
  sortBy?: ReportGroupSortByType;
  nextToken?: string;
  maxResults?: number;
}
export interface ListReportGroupsOutput {
  nextToken?: string;
  reportGroups?: string[];
}
export interface ReportFilter {
  status?: ReportStatusType;
}
export interface ListReportsInput {
  sortOrder?: SortOrderType;
  nextToken?: string;
  maxResults?: number;
  filter?: ReportFilter;
}
export interface ListReportsOutput {
  nextToken?: string;
  reports?: string[];
}
export interface ListReportsForReportGroupInput {
  reportGroupArn: string | undefined;
  nextToken?: string;
  sortOrder?: SortOrderType;
  maxResults?: number;
  filter?: ReportFilter;
}
export interface ListReportsForReportGroupOutput {
  nextToken?: string;
  reports?: string[];
}
export declare const SharedResourceSortByType: {
  readonly ARN: "ARN";
  readonly MODIFIED_TIME: "MODIFIED_TIME";
};
export type SharedResourceSortByType =
  (typeof SharedResourceSortByType)[keyof typeof SharedResourceSortByType];
export interface ListSharedProjectsInput {
  sortBy?: SharedResourceSortByType;
  sortOrder?: SortOrderType;
  maxResults?: number;
  nextToken?: string;
}
export interface ListSharedProjectsOutput {
  nextToken?: string;
  projects?: string[];
}
export interface ListSharedReportGroupsInput {
  sortOrder?: SortOrderType;
  sortBy?: SharedResourceSortByType;
  nextToken?: string;
  maxResults?: number;
}
export interface ListSharedReportGroupsOutput {
  nextToken?: string;
  reportGroups?: string[];
}
export interface ListSourceCredentialsInput {}
export interface SourceCredentialsInfo {
  arn?: string;
  serverType?: ServerType;
  authType?: AuthType;
  resource?: string;
}
export interface ListSourceCredentialsOutput {
  sourceCredentialsInfos?: SourceCredentialsInfo[];
}
export interface PutResourcePolicyInput {
  policy: string | undefined;
  resourceArn: string | undefined;
}
export interface PutResourcePolicyOutput {
  resourceArn?: string;
}
export interface RetryBuildInput {
  id?: string;
  idempotencyToken?: string;
}
export interface RetryBuildOutput {
  build?: Build;
}
export declare const RetryBuildBatchType: {
  readonly RETRY_ALL_BUILDS: "RETRY_ALL_BUILDS";
  readonly RETRY_FAILED_BUILDS: "RETRY_FAILED_BUILDS";
};
export type RetryBuildBatchType =
  (typeof RetryBuildBatchType)[keyof typeof RetryBuildBatchType];
export interface RetryBuildBatchInput {
  id?: string;
  idempotencyToken?: string;
  retryType?: RetryBuildBatchType;
}
export interface RetryBuildBatchOutput {
  buildBatch?: BuildBatch;
}
export interface StartBuildInput {
  projectName: string | undefined;
  secondarySourcesOverride?: ProjectSource[];
  secondarySourcesVersionOverride?: ProjectSourceVersion[];
  sourceVersion?: string;
  artifactsOverride?: ProjectArtifacts;
  secondaryArtifactsOverride?: ProjectArtifacts[];
  environmentVariablesOverride?: EnvironmentVariable[];
  sourceTypeOverride?: SourceType;
  sourceLocationOverride?: string;
  sourceAuthOverride?: SourceAuth;
  gitCloneDepthOverride?: number;
  gitSubmodulesConfigOverride?: GitSubmodulesConfig;
  buildspecOverride?: string;
  insecureSslOverride?: boolean;
  reportBuildStatusOverride?: boolean;
  buildStatusConfigOverride?: BuildStatusConfig;
  environmentTypeOverride?: EnvironmentType;
  imageOverride?: string;
  computeTypeOverride?: ComputeType;
  certificateOverride?: string;
  cacheOverride?: ProjectCache;
  serviceRoleOverride?: string;
  privilegedModeOverride?: boolean;
  timeoutInMinutesOverride?: number;
  queuedTimeoutInMinutesOverride?: number;
  encryptionKeyOverride?: string;
  idempotencyToken?: string;
  logsConfigOverride?: LogsConfig;
  registryCredentialOverride?: RegistryCredential;
  imagePullCredentialsTypeOverride?: ImagePullCredentialsType;
  debugSessionEnabled?: boolean;
  fleetOverride?: ProjectFleet;
}
export interface StartBuildOutput {
  build?: Build;
}
export interface StartBuildBatchInput {
  projectName: string | undefined;
  secondarySourcesOverride?: ProjectSource[];
  secondarySourcesVersionOverride?: ProjectSourceVersion[];
  sourceVersion?: string;
  artifactsOverride?: ProjectArtifacts;
  secondaryArtifactsOverride?: ProjectArtifacts[];
  environmentVariablesOverride?: EnvironmentVariable[];
  sourceTypeOverride?: SourceType;
  sourceLocationOverride?: string;
  sourceAuthOverride?: SourceAuth;
  gitCloneDepthOverride?: number;
  gitSubmodulesConfigOverride?: GitSubmodulesConfig;
  buildspecOverride?: string;
  insecureSslOverride?: boolean;
  reportBuildBatchStatusOverride?: boolean;
  environmentTypeOverride?: EnvironmentType;
  imageOverride?: string;
  computeTypeOverride?: ComputeType;
  certificateOverride?: string;
  cacheOverride?: ProjectCache;
  serviceRoleOverride?: string;
  privilegedModeOverride?: boolean;
  buildTimeoutInMinutesOverride?: number;
  queuedTimeoutInMinutesOverride?: number;
  encryptionKeyOverride?: string;
  idempotencyToken?: string;
  logsConfigOverride?: LogsConfig;
  registryCredentialOverride?: RegistryCredential;
  imagePullCredentialsTypeOverride?: ImagePullCredentialsType;
  buildBatchConfigOverride?: ProjectBuildBatchConfig;
  debugSessionEnabled?: boolean;
}
export interface StartBuildBatchOutput {
  buildBatch?: BuildBatch;
}
export interface StopBuildInput {
  id: string | undefined;
}
export interface StopBuildOutput {
  build?: Build;
}
export interface StopBuildBatchInput {
  id: string | undefined;
}
export interface StopBuildBatchOutput {
  buildBatch?: BuildBatch;
}
export interface UpdateFleetInput {
  arn: string | undefined;
  baseCapacity?: number;
  environmentType?: EnvironmentType;
  computeType?: ComputeType;
  scalingConfiguration?: ScalingConfigurationInput;
  overflowBehavior?: FleetOverflowBehavior;
  vpcConfig?: VpcConfig;
  fleetServiceRole?: string;
  tags?: Tag[];
}
export interface UpdateFleetOutput {
  fleet?: Fleet;
}
export interface UpdateProjectInput {
  name: string | undefined;
  description?: string;
  source?: ProjectSource;
  secondarySources?: ProjectSource[];
  sourceVersion?: string;
  secondarySourceVersions?: ProjectSourceVersion[];
  artifacts?: ProjectArtifacts;
  secondaryArtifacts?: ProjectArtifacts[];
  cache?: ProjectCache;
  environment?: ProjectEnvironment;
  serviceRole?: string;
  timeoutInMinutes?: number;
  queuedTimeoutInMinutes?: number;
  encryptionKey?: string;
  tags?: Tag[];
  vpcConfig?: VpcConfig;
  badgeEnabled?: boolean;
  logsConfig?: LogsConfig;
  fileSystemLocations?: ProjectFileSystemLocation[];
  buildBatchConfig?: ProjectBuildBatchConfig;
  concurrentBuildLimit?: number;
}
export interface UpdateProjectOutput {
  project?: Project;
}
export interface UpdateProjectVisibilityInput {
  projectArn: string | undefined;
  projectVisibility: ProjectVisibilityType | undefined;
  resourceAccessRole?: string;
}
export interface UpdateProjectVisibilityOutput {
  projectArn?: string;
  publicProjectAlias?: string;
  projectVisibility?: ProjectVisibilityType;
}
export interface UpdateReportGroupInput {
  arn: string | undefined;
  exportConfig?: ReportExportConfig;
  tags?: Tag[];
}
export interface UpdateReportGroupOutput {
  reportGroup?: ReportGroup;
}
export interface UpdateWebhookInput {
  projectName: string | undefined;
  branchFilter?: string;
  rotateSecret?: boolean;
  filterGroups?: WebhookFilter[][];
  buildType?: WebhookBuildType;
}
export interface UpdateWebhookOutput {
  webhook?: Webhook;
}
export declare const ImportSourceCredentialsInputFilterSensitiveLog: (
  obj: ImportSourceCredentialsInput
) => any;
export declare const ListFleetsInputFilterSensitiveLog: (
  obj: ListFleetsInput
) => any;

import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ECRPUBLICServiceException as __BaseException } from "./ECRPUBLICServiceException";
export interface AuthorizationData {
  authorizationToken?: string;
  expiresAt?: Date;
}
export interface BatchCheckLayerAvailabilityRequest {
  registryId?: string;
  repositoryName: string | undefined;
  layerDigests: string[] | undefined;
}
export declare const LayerFailureCode: {
  readonly InvalidLayerDigest: "InvalidLayerDigest";
  readonly MissingLayerDigest: "MissingLayerDigest";
};
export type LayerFailureCode =
  (typeof LayerFailureCode)[keyof typeof LayerFailureCode];
export interface LayerFailure {
  layerDigest?: string;
  failureCode?: LayerFailureCode;
  failureReason?: string;
}
export declare const LayerAvailability: {
  readonly AVAILABLE: "AVAILABLE";
  readonly UNAVAILABLE: "UNAVAILABLE";
};
export type LayerAvailability =
  (typeof LayerAvailability)[keyof typeof LayerAvailability];
export interface Layer {
  layerDigest?: string;
  layerAvailability?: LayerAvailability;
  layerSize?: number;
  mediaType?: string;
}
export interface BatchCheckLayerAvailabilityResponse {
  layers?: Layer[];
  failures?: LayerFailure[];
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class RegistryNotFoundException extends __BaseException {
  readonly name: "RegistryNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RegistryNotFoundException, __BaseException>
  );
}
export declare class RepositoryNotFoundException extends __BaseException {
  readonly name: "RepositoryNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RepositoryNotFoundException, __BaseException>
  );
}
export declare class ServerException extends __BaseException {
  readonly name: "ServerException";
  readonly $fault: "server";
  constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
}
export declare class UnsupportedCommandException extends __BaseException {
  readonly name: "UnsupportedCommandException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnsupportedCommandException, __BaseException>
  );
}
export interface ImageIdentifier {
  imageDigest?: string;
  imageTag?: string;
}
export interface BatchDeleteImageRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageIds: ImageIdentifier[] | undefined;
}
export declare const ImageFailureCode: {
  readonly ImageNotFound: "ImageNotFound";
  readonly ImageReferencedByManifestList: "ImageReferencedByManifestList";
  readonly ImageTagDoesNotMatchDigest: "ImageTagDoesNotMatchDigest";
  readonly InvalidImageDigest: "InvalidImageDigest";
  readonly InvalidImageTag: "InvalidImageTag";
  readonly KmsError: "KmsError";
  readonly MissingDigestAndTag: "MissingDigestAndTag";
};
export type ImageFailureCode =
  (typeof ImageFailureCode)[keyof typeof ImageFailureCode];
export interface ImageFailure {
  imageId?: ImageIdentifier;
  failureCode?: ImageFailureCode;
  failureReason?: string;
}
export interface BatchDeleteImageResponse {
  imageIds?: ImageIdentifier[];
  failures?: ImageFailure[];
}
export interface CompleteLayerUploadRequest {
  registryId?: string;
  repositoryName: string | undefined;
  uploadId: string | undefined;
  layerDigests: string[] | undefined;
}
export interface CompleteLayerUploadResponse {
  registryId?: string;
  repositoryName?: string;
  uploadId?: string;
  layerDigest?: string;
}
export declare class EmptyUploadException extends __BaseException {
  readonly name: "EmptyUploadException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<EmptyUploadException, __BaseException>
  );
}
export declare class InvalidLayerException extends __BaseException {
  readonly name: "InvalidLayerException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidLayerException, __BaseException>
  );
}
export declare class LayerAlreadyExistsException extends __BaseException {
  readonly name: "LayerAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayerAlreadyExistsException, __BaseException>
  );
}
export declare class LayerPartTooSmallException extends __BaseException {
  readonly name: "LayerPartTooSmallException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayerPartTooSmallException, __BaseException>
  );
}
export declare class UploadNotFoundException extends __BaseException {
  readonly name: "UploadNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UploadNotFoundException, __BaseException>
  );
}
export interface RepositoryCatalogDataInput {
  description?: string;
  architectures?: string[];
  operatingSystems?: string[];
  logoImageBlob?: Uint8Array;
  aboutText?: string;
  usageText?: string;
}
export interface Tag {
  Key?: string;
  Value?: string;
}
export interface CreateRepositoryRequest {
  repositoryName: string | undefined;
  catalogData?: RepositoryCatalogDataInput;
  tags?: Tag[];
}
export interface RepositoryCatalogData {
  description?: string;
  architectures?: string[];
  operatingSystems?: string[];
  logoUrl?: string;
  aboutText?: string;
  usageText?: string;
  marketplaceCertified?: boolean;
}
export interface Repository {
  repositoryArn?: string;
  registryId?: string;
  repositoryName?: string;
  repositoryUri?: string;
  createdAt?: Date;
}
export interface CreateRepositoryResponse {
  repository?: Repository;
  catalogData?: RepositoryCatalogData;
}
export declare class InvalidTagParameterException extends __BaseException {
  readonly name: "InvalidTagParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidTagParameterException, __BaseException>
  );
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export declare class RepositoryAlreadyExistsException extends __BaseException {
  readonly name: "RepositoryAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RepositoryAlreadyExistsException,
      __BaseException
    >
  );
}
export declare class TooManyTagsException extends __BaseException {
  readonly name: "TooManyTagsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TooManyTagsException, __BaseException>
  );
}
export interface DeleteRepositoryRequest {
  registryId?: string;
  repositoryName: string | undefined;
  force?: boolean;
}
export interface DeleteRepositoryResponse {
  repository?: Repository;
}
export declare class RepositoryNotEmptyException extends __BaseException {
  readonly name: "RepositoryNotEmptyException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RepositoryNotEmptyException, __BaseException>
  );
}
export interface DeleteRepositoryPolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface DeleteRepositoryPolicyResponse {
  registryId?: string;
  repositoryName?: string;
  policyText?: string;
}
export declare class RepositoryPolicyNotFoundException extends __BaseException {
  readonly name: "RepositoryPolicyNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RepositoryPolicyNotFoundException,
      __BaseException
    >
  );
}
export interface DescribeImagesRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageIds?: ImageIdentifier[];
  nextToken?: string;
  maxResults?: number;
}
export interface ImageDetail {
  registryId?: string;
  repositoryName?: string;
  imageDigest?: string;
  imageTags?: string[];
  imageSizeInBytes?: number;
  imagePushedAt?: Date;
  imageManifestMediaType?: string;
  artifactMediaType?: string;
}
export interface DescribeImagesResponse {
  imageDetails?: ImageDetail[];
  nextToken?: string;
}
export declare class ImageNotFoundException extends __BaseException {
  readonly name: "ImageNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ImageNotFoundException, __BaseException>
  );
}
export interface DescribeImageTagsRequest {
  registryId?: string;
  repositoryName: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface ReferencedImageDetail {
  imageDigest?: string;
  imageSizeInBytes?: number;
  imagePushedAt?: Date;
  imageManifestMediaType?: string;
  artifactMediaType?: string;
}
export interface ImageTagDetail {
  imageTag?: string;
  createdAt?: Date;
  imageDetail?: ReferencedImageDetail;
}
export interface DescribeImageTagsResponse {
  imageTagDetails?: ImageTagDetail[];
  nextToken?: string;
}
export interface DescribeRegistriesRequest {
  nextToken?: string;
  maxResults?: number;
}
export declare const RegistryAliasStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly PENDING: "PENDING";
  readonly REJECTED: "REJECTED";
};
export type RegistryAliasStatus =
  (typeof RegistryAliasStatus)[keyof typeof RegistryAliasStatus];
export interface RegistryAlias {
  name: string | undefined;
  status: RegistryAliasStatus | undefined;
  primaryRegistryAlias: boolean | undefined;
  defaultRegistryAlias: boolean | undefined;
}
export interface Registry {
  registryId: string | undefined;
  registryArn: string | undefined;
  registryUri: string | undefined;
  verified: boolean | undefined;
  aliases: RegistryAlias[] | undefined;
}
export interface DescribeRegistriesResponse {
  registries: Registry[] | undefined;
  nextToken?: string;
}
export interface DescribeRepositoriesRequest {
  registryId?: string;
  repositoryNames?: string[];
  nextToken?: string;
  maxResults?: number;
}
export interface DescribeRepositoriesResponse {
  repositories?: Repository[];
  nextToken?: string;
}
export interface GetAuthorizationTokenRequest {}
export interface GetAuthorizationTokenResponse {
  authorizationData?: AuthorizationData;
}
export interface GetRegistryCatalogDataRequest {}
export interface RegistryCatalogData {
  displayName?: string;
}
export interface GetRegistryCatalogDataResponse {
  registryCatalogData: RegistryCatalogData | undefined;
}
export interface GetRepositoryCatalogDataRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface GetRepositoryCatalogDataResponse {
  catalogData?: RepositoryCatalogData;
}
export declare class RepositoryCatalogDataNotFoundException extends __BaseException {
  readonly name: "RepositoryCatalogDataNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RepositoryCatalogDataNotFoundException,
      __BaseException
    >
  );
}
export interface GetRepositoryPolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface GetRepositoryPolicyResponse {
  registryId?: string;
  repositoryName?: string;
  policyText?: string;
}
export interface Image {
  registryId?: string;
  repositoryName?: string;
  imageId?: ImageIdentifier;
  imageManifest?: string;
  imageManifestMediaType?: string;
}
export declare class ImageAlreadyExistsException extends __BaseException {
  readonly name: "ImageAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ImageAlreadyExistsException, __BaseException>
  );
}
export declare class ImageDigestDoesNotMatchException extends __BaseException {
  readonly name: "ImageDigestDoesNotMatchException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ImageDigestDoesNotMatchException,
      __BaseException
    >
  );
}
export declare class ImageTagAlreadyExistsException extends __BaseException {
  readonly name: "ImageTagAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ImageTagAlreadyExistsException, __BaseException>
  );
}
export interface InitiateLayerUploadRequest {
  registryId?: string;
  repositoryName: string | undefined;
}
export interface InitiateLayerUploadResponse {
  uploadId?: string;
  partSize?: number;
}
export declare class InvalidLayerPartException extends __BaseException {
  readonly name: "InvalidLayerPartException";
  readonly $fault: "client";
  registryId?: string;
  repositoryName?: string;
  uploadId?: string;
  lastValidByteReceived?: number;
  constructor(
    opts: __ExceptionOptionType<InvalidLayerPartException, __BaseException>
  );
}
export declare class LayersNotFoundException extends __BaseException {
  readonly name: "LayersNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LayersNotFoundException, __BaseException>
  );
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Tag[];
}
export interface PutImageRequest {
  registryId?: string;
  repositoryName: string | undefined;
  imageManifest: string | undefined;
  imageManifestMediaType?: string;
  imageTag?: string;
  imageDigest?: string;
}
export interface PutImageResponse {
  image?: Image;
}
export declare class ReferencedImagesNotFoundException extends __BaseException {
  readonly name: "ReferencedImagesNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReferencedImagesNotFoundException,
      __BaseException
    >
  );
}
export interface PutRegistryCatalogDataRequest {
  displayName?: string;
}
export interface PutRegistryCatalogDataResponse {
  registryCatalogData: RegistryCatalogData | undefined;
}
export interface PutRepositoryCatalogDataRequest {
  registryId?: string;
  repositoryName: string | undefined;
  catalogData: RepositoryCatalogDataInput | undefined;
}
export interface PutRepositoryCatalogDataResponse {
  catalogData?: RepositoryCatalogData;
}
export interface SetRepositoryPolicyRequest {
  registryId?: string;
  repositoryName: string | undefined;
  policyText: string | undefined;
  force?: boolean;
}
export interface SetRepositoryPolicyResponse {
  registryId?: string;
  repositoryName?: string;
  policyText?: string;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Tag[] | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export interface UploadLayerPartRequest {
  registryId?: string;
  repositoryName: string | undefined;
  uploadId: string | undefined;
  partFirstByte: number | undefined;
  partLastByte: number | undefined;
  layerPartBlob: Uint8Array | undefined;
}
export interface UploadLayerPartResponse {
  registryId?: string;
  repositoryName?: string;
  uploadId?: string;
  lastByteReceived?: number;
}

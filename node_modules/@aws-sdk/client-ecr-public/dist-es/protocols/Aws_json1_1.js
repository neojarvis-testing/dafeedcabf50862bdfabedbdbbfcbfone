import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { ECRPUBLICServiceException as __BaseException } from "../models/ECRPUBLICServiceException";
import { EmptyUploadException, ImageAlreadyExistsException, ImageDigestDoesNotMatchException, ImageNotFoundException, ImageTagAlreadyExistsException, InvalidLayerException, InvalidLayerPartException, InvalidParameterException, InvalidTagParameterException, LayerAlreadyExistsException, LayerPartTooSmallException, LayersNotFoundException, LimitExceededException, ReferencedImagesNotFoundException, RegistryNotFoundException, RepositoryAlreadyExistsException, RepositoryCatalogDataNotFoundException, RepositoryNotEmptyException, RepositoryNotFoundException, RepositoryPolicyNotFoundException, ServerException, TooManyTagsException, UnsupportedCommandException, UploadNotFoundException, } from "../models/models_0";
export const se_BatchCheckLayerAvailabilityCommand = async (input, context) => {
    const headers = sharedHeaders("BatchCheckLayerAvailability");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_BatchDeleteImageCommand = async (input, context) => {
    const headers = sharedHeaders("BatchDeleteImage");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CompleteLayerUploadCommand = async (input, context) => {
    const headers = sharedHeaders("CompleteLayerUpload");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("CreateRepository");
    let body;
    body = JSON.stringify(se_CreateRepositoryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRepositoryCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteRepository");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRepositoryPolicyCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteRepositoryPolicy");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeImagesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeImages");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeImageTagsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeImageTags");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRegistriesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeRegistries");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeRepositoriesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeRepositories");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAuthorizationTokenCommand = async (input, context) => {
    const headers = sharedHeaders("GetAuthorizationToken");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRegistryCatalogDataCommand = async (input, context) => {
    const headers = sharedHeaders("GetRegistryCatalogData");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRepositoryCatalogDataCommand = async (input, context) => {
    const headers = sharedHeaders("GetRepositoryCatalogData");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRepositoryPolicyCommand = async (input, context) => {
    const headers = sharedHeaders("GetRepositoryPolicy");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_InitiateLayerUploadCommand = async (input, context) => {
    const headers = sharedHeaders("InitiateLayerUpload");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutImageCommand = async (input, context) => {
    const headers = sharedHeaders("PutImage");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutRegistryCatalogDataCommand = async (input, context) => {
    const headers = sharedHeaders("PutRegistryCatalogData");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutRepositoryCatalogDataCommand = async (input, context) => {
    const headers = sharedHeaders("PutRepositoryCatalogData");
    let body;
    body = JSON.stringify(se_PutRepositoryCatalogDataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetRepositoryPolicyCommand = async (input, context) => {
    const headers = sharedHeaders("SetRepositoryPolicy");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UploadLayerPartCommand = async (input, context) => {
    const headers = sharedHeaders("UploadLayerPart");
    let body;
    body = JSON.stringify(se_UploadLayerPartRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_BatchCheckLayerAvailabilityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_BatchDeleteImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CompleteLayerUploadCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRepositoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRepositoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteRepositoryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteRepositoryPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeImagesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImagesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeImageTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeImageTagsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRegistriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeRepositoriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRepositoriesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetAuthorizationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAuthorizationTokenResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetRegistryCatalogDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetRepositoryCatalogDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_GetRepositoryPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_InitiateLayerUploadCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutRegistryCatalogDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PutRepositoryCatalogDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_SetRepositoryPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UploadLayerPartCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.ecrpublic#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "RegistryNotFoundException":
        case "com.amazonaws.ecrpublic#RegistryNotFoundException":
            throw await de_RegistryNotFoundExceptionRes(parsedOutput, context);
        case "RepositoryNotFoundException":
        case "com.amazonaws.ecrpublic#RepositoryNotFoundException":
            throw await de_RepositoryNotFoundExceptionRes(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecrpublic#ServerException":
            throw await de_ServerExceptionRes(parsedOutput, context);
        case "UnsupportedCommandException":
        case "com.amazonaws.ecrpublic#UnsupportedCommandException":
            throw await de_UnsupportedCommandExceptionRes(parsedOutput, context);
        case "EmptyUploadException":
        case "com.amazonaws.ecrpublic#EmptyUploadException":
            throw await de_EmptyUploadExceptionRes(parsedOutput, context);
        case "InvalidLayerException":
        case "com.amazonaws.ecrpublic#InvalidLayerException":
            throw await de_InvalidLayerExceptionRes(parsedOutput, context);
        case "LayerAlreadyExistsException":
        case "com.amazonaws.ecrpublic#LayerAlreadyExistsException":
            throw await de_LayerAlreadyExistsExceptionRes(parsedOutput, context);
        case "LayerPartTooSmallException":
        case "com.amazonaws.ecrpublic#LayerPartTooSmallException":
            throw await de_LayerPartTooSmallExceptionRes(parsedOutput, context);
        case "UploadNotFoundException":
        case "com.amazonaws.ecrpublic#UploadNotFoundException":
            throw await de_UploadNotFoundExceptionRes(parsedOutput, context);
        case "InvalidTagParameterException":
        case "com.amazonaws.ecrpublic#InvalidTagParameterException":
            throw await de_InvalidTagParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.ecrpublic#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "RepositoryAlreadyExistsException":
        case "com.amazonaws.ecrpublic#RepositoryAlreadyExistsException":
            throw await de_RepositoryAlreadyExistsExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.ecrpublic#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        case "RepositoryNotEmptyException":
        case "com.amazonaws.ecrpublic#RepositoryNotEmptyException":
            throw await de_RepositoryNotEmptyExceptionRes(parsedOutput, context);
        case "RepositoryPolicyNotFoundException":
        case "com.amazonaws.ecrpublic#RepositoryPolicyNotFoundException":
            throw await de_RepositoryPolicyNotFoundExceptionRes(parsedOutput, context);
        case "ImageNotFoundException":
        case "com.amazonaws.ecrpublic#ImageNotFoundException":
            throw await de_ImageNotFoundExceptionRes(parsedOutput, context);
        case "RepositoryCatalogDataNotFoundException":
        case "com.amazonaws.ecrpublic#RepositoryCatalogDataNotFoundException":
            throw await de_RepositoryCatalogDataNotFoundExceptionRes(parsedOutput, context);
        case "ImageAlreadyExistsException":
        case "com.amazonaws.ecrpublic#ImageAlreadyExistsException":
            throw await de_ImageAlreadyExistsExceptionRes(parsedOutput, context);
        case "ImageDigestDoesNotMatchException":
        case "com.amazonaws.ecrpublic#ImageDigestDoesNotMatchException":
            throw await de_ImageDigestDoesNotMatchExceptionRes(parsedOutput, context);
        case "ImageTagAlreadyExistsException":
        case "com.amazonaws.ecrpublic#ImageTagAlreadyExistsException":
            throw await de_ImageTagAlreadyExistsExceptionRes(parsedOutput, context);
        case "LayersNotFoundException":
        case "com.amazonaws.ecrpublic#LayersNotFoundException":
            throw await de_LayersNotFoundExceptionRes(parsedOutput, context);
        case "ReferencedImagesNotFoundException":
        case "com.amazonaws.ecrpublic#ReferencedImagesNotFoundException":
            throw await de_ReferencedImagesNotFoundExceptionRes(parsedOutput, context);
        case "InvalidLayerPartException":
        case "com.amazonaws.ecrpublic#InvalidLayerPartException":
            throw await de_InvalidLayerPartExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EmptyUploadExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new EmptyUploadException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ImageAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ImageAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ImageDigestDoesNotMatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ImageDigestDoesNotMatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ImageNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ImageNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ImageTagAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ImageTagAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidLayerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidLayerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidLayerPartExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidLayerPartException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTagParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidTagParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LayerAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new LayerAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LayerPartTooSmallExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new LayerPartTooSmallException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LayersNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new LayersNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReferencedImagesNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ReferencedImagesNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RegistryNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new RegistryNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RepositoryAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new RepositoryAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RepositoryCatalogDataNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new RepositoryCatalogDataNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RepositoryNotEmptyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new RepositoryNotEmptyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RepositoryNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new RepositoryNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_RepositoryPolicyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new RepositoryPolicyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedCommandExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UnsupportedCommandException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UploadNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UploadNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_CreateRepositoryRequest = (input, context) => {
    return take(input, {
        catalogData: (_) => se_RepositoryCatalogDataInput(_, context),
        repositoryName: [],
        tags: _json,
    });
};
const se_PutRepositoryCatalogDataRequest = (input, context) => {
    return take(input, {
        catalogData: (_) => se_RepositoryCatalogDataInput(_, context),
        registryId: [],
        repositoryName: [],
    });
};
const se_RepositoryCatalogDataInput = (input, context) => {
    return take(input, {
        aboutText: [],
        architectures: _json,
        description: [],
        logoImageBlob: context.base64Encoder,
        operatingSystems: _json,
        usageText: [],
    });
};
const se_UploadLayerPartRequest = (input, context) => {
    return take(input, {
        layerPartBlob: context.base64Encoder,
        partFirstByte: [],
        partLastByte: [],
        registryId: [],
        repositoryName: [],
        uploadId: [],
    });
};
const de_AuthorizationData = (output, context) => {
    return take(output, {
        authorizationToken: __expectString,
        expiresAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_CreateRepositoryResponse = (output, context) => {
    return take(output, {
        catalogData: _json,
        repository: (_) => de_Repository(_, context),
    });
};
const de_DeleteRepositoryResponse = (output, context) => {
    return take(output, {
        repository: (_) => de_Repository(_, context),
    });
};
const de_DescribeImagesResponse = (output, context) => {
    return take(output, {
        imageDetails: (_) => de_ImageDetailList(_, context),
        nextToken: __expectString,
    });
};
const de_DescribeImageTagsResponse = (output, context) => {
    return take(output, {
        imageTagDetails: (_) => de_ImageTagDetailList(_, context),
        nextToken: __expectString,
    });
};
const de_DescribeRepositoriesResponse = (output, context) => {
    return take(output, {
        nextToken: __expectString,
        repositories: (_) => de_RepositoryList(_, context),
    });
};
const de_GetAuthorizationTokenResponse = (output, context) => {
    return take(output, {
        authorizationData: (_) => de_AuthorizationData(_, context),
    });
};
const de_ImageDetail = (output, context) => {
    return take(output, {
        artifactMediaType: __expectString,
        imageDigest: __expectString,
        imageManifestMediaType: __expectString,
        imagePushedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        imageSizeInBytes: __expectLong,
        imageTags: _json,
        registryId: __expectString,
        repositoryName: __expectString,
    });
};
const de_ImageDetailList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImageDetail(entry, context);
    });
    return retVal;
};
const de_ImageTagDetail = (output, context) => {
    return take(output, {
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        imageDetail: (_) => de_ReferencedImageDetail(_, context),
        imageTag: __expectString,
    });
};
const de_ImageTagDetailList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImageTagDetail(entry, context);
    });
    return retVal;
};
const de_ReferencedImageDetail = (output, context) => {
    return take(output, {
        artifactMediaType: __expectString,
        imageDigest: __expectString,
        imageManifestMediaType: __expectString,
        imagePushedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        imageSizeInBytes: __expectLong,
    });
};
const de_Repository = (output, context) => {
    return take(output, {
        createdAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        registryId: __expectString,
        repositoryArn: __expectString,
        repositoryName: __expectString,
        repositoryUri: __expectString,
    });
};
const de_RepositoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Repository(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `SpencerFrontendService.${operation}`,
    };
}
